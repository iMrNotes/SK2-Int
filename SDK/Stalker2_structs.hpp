#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Stalker2

#include "Basic.hpp"

#include "SlateCore_structs.hpp"
#include "UMG_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "PhysicsControl_structs.hpp"
#include "Engine_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "PoseSearch_structs.hpp"
#include "InputCore_structs.hpp"
#include "EnhancedInput_structs.hpp"
#include "Slate_structs.hpp"


namespace SDK
{

// Enum Stalker2.EDamageSource
// NumValues: 0x0033
enum class EDamageSource : uint8
{
	None                                     = 0,
	AnomalyStrike                            = 1,
	Bullet                                   = 2,
	ShockWave                                = 3,
	Explosion                                = 4,
	BiteSmall                                = 5,
	BiteLarge                                = 6,
	CutSmall                                 = 7,
	CutLarge                                 = 8,
	RamSmall                                 = 9,
	RamLarge                                 = 10,
	Knife                                    = 11,
	WeaponButt                               = 12,
	Fire                                     = 13,
	Electricity                              = 14,
	ElectricityPermanent                     = 15,
	Acid                                     = 16,
	Radiation                                = 17,
	PSY                                      = 18,
	Bleeding                                 = 19,
	Emission                                 = 20,
	Physics                                  = 21,
	Hunger                                   = 22,
	BulletHeavy                              = 23,
	Buckshot                                 = 24,
	Chemical                                 = 25,
	Expulsion                                = 26,
	ClassicFire                              = 27,
	SoapBubble                               = 28,
	Diamond                                  = 29,
	IronWind                                 = 30,
	Carousel                                 = 31,
	LightningBall                            = 32,
	LavaLamp                                 = 33,
	ToxicCloud                               = 34,
	Clicker                                  = 35,
	Bulb                                     = 36,
	FireBreath                               = 37,
	WanderingLights                          = 38,
	PoppyField                               = 39,
	PoltergeistCommonCollisionAttack         = 40,
	PoltergeistFireCollisionAttack           = 41,
	PoltergeistElectroCollisionAttack        = 42,
	PoltergeistChemicalCollisionAttack       = 43,
	Water                                    = 44,
	Fall                                     = 45,
	StealthKill                              = 46,
	CommonPermanent                          = 47,
	BiteRat                                  = 48,
	GetCount                                 = 49,
	EDamageSource_MAX                        = 50,
};

// Enum Stalker2.EDamageType
// NumValues: 0x000E
enum class EDamageType : uint8
{
	None                                     = 0,
	Burn                                     = 1,
	Shock                                    = 2,
	ChemicalBurn                             = 3,
	Radiation                                = 4,
	PSY                                      = 5,
	Strike                                   = 6,
	Fall                                     = 7,
	Physics                                  = 8,
	Emission                                 = 9,
	Bleeding                                 = 10,
	Hunger                                   = 11,
	GetCount                                 = 12,
	EDamageType_MAX                          = 13,
};

// Enum Stalker2.EAmmoCaliber
// NumValues: 0x0011
enum class EAmmoCaliber : uint8
{
	None                                     = 0,
	A918                                     = 1,
	A919                                     = 2,
	A045                                     = 3,
	A545                                     = 4,
	A556                                     = 5,
	A762                                     = 6,
	A762Sniper                               = 7,
	A762NATO                                 = 8,
	A939                                     = 9,
	A012                                     = 10,
	AVOG                                     = 11,
	AGA                                      = 12,
	APG7V                                    = 13,
	AHEDP                                    = 14,
	GetCount                                 = 15,
	EAmmoCaliber_MAX                         = 16,
};

// Enum Stalker2.EAmmoType
// NumValues: 0x0008
enum class EAmmoType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	ArmorPiercing                            = 2,
	Supersonic                               = 3,
	Expanding                                = 4,
	Incendiary                               = 5,
	GetCount                                 = 6,
	EAmmoType_MAX                            = 7,
};

// Enum Stalker2.ECoilsState
// NumValues: 0x0004
enum class ECoilsState : uint8
{
	Broken                                   = 0,
	Restoring                                = 1,
	Cooled                                   = 2,
	ECoilsState_MAX                          = 3,
};

// Enum Stalker2.EDetailsElementType
// NumValues: 0x0005
enum class EDetailsElementType : uint8
{
	Default                                  = 0,
	StageSlots                               = 1,
	Description                              = 2,
	Count_Max                                = 3,
	EDetailsElementType_MAX                  = 4,
};

// Enum Stalker2.ESlotDirection
// NumValues: 0x0006
enum class ESlotDirection : uint8
{
	Up                                       = 0,
	Right                                    = 1,
	Down                                     = 2,
	Left                                     = 3,
	None                                     = 4,
	ESlotDirection_MAX                       = 5,
};

// Enum Stalker2.EShieldState
// NumValues: 0x0003
enum class EShieldState : uint8
{
	Enabled                                  = 0,
	Disabled                                 = 1,
	EShieldState_MAX                         = 2,
};

// Enum Stalker2.ETopazScannerState
// NumValues: 0x0008
enum class ETopazScannerState : uint8
{
	None                                     = 0,
	Inactive                                 = 1,
	Placing                                  = 2,
	Active                                   = 3,
	Done                                     = 4,
	Collected                                = 5,
	GetCount                                 = 6,
	ETopazScannerState_MAX                   = 7,
};

// Enum Stalker2.EMarkerType
// NumValues: 0x0021
enum class EMarkerType : uint8
{
	None                                     = 0,
	QuestMain                                = 1,
	QuestSecondary                           = 2,
	QuestGiverMain                           = 3,
	QuestGiverSecondary                      = 4,
	FollowLandmark                           = 5,
	PlayerLandmarkDanger                     = 6,
	PlayerLandmarkRadiation                  = 7,
	PlayerLandmarkLoot                       = 8,
	PlayerLandmarkAnomaly                    = 9,
	Enemy                                    = 10,
	QuestMainTargetEnemy                     = 11,
	QuestSecondaryTargetEnemy                = 12,
	Hub                                      = 13,
	DeadBody                                 = 14,
	Cache                                    = 15,
	CacheOpened                              = 16,
	Trader                                   = 17,
	Technician                               = 18,
	Guide                                    = 19,
	Bed                                      = 20,
	PlayerStorage                            = 21,
	AnomalyArea                              = 22,
	SearchPoint                              = 23,
	ArchAnomaly                              = 24,
	Location                                 = 25,
	RegionMarker                             = 26,
	QuestEnemy                               = 27,
	Medic                                    = 28,
	PartyLeader                              = 29,
	HubLeader                                = 30,
	GetCount                                 = 31,
	EMarkerType_MAX                          = 32,
};

// Enum Stalker2.EQuestTaskAnimationType
// NumValues: 0x0006
enum class EQuestTaskAnimationType : uint8
{
	None                                     = 0,
	TaskStart                                = 1,
	TaskFinish                               = 2,
	TaskFail                                 = 3,
	TaskCancel                               = 4,
	EQuestTaskAnimationType_MAX              = 5,
};

// Enum Stalker2.ESplitStackTypeDirection
// NumValues: 0x0005
enum class ESplitStackTypeDirection : uint8
{
	None                                     = 0,
	Take                                     = 1,
	PutDown                                  = 2,
	Drop                                     = 3,
	ESplitStackTypeDirection_MAX             = 4,
};

// Enum Stalker2.ELineDirection
// NumValues: 0x0004
enum class ELineDirection : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	ELineDirection_MAX                       = 3,
};

// Enum Stalker2.EUpgradeTargetPartType
// NumValues: 0x0008
enum class EUpgradeTargetPartType : uint8
{
	None                                     = 0,
	Stock                                    = 1,
	Body                                     = 2,
	Handguard                                = 3,
	Barrel                                   = 4,
	PistolGrip                               = 5,
	GetCount                                 = 6,
	EUpgradeTargetPartType_MAX               = 7,
};

// Enum Stalker2.EAbility
// NumValues: 0x0019
enum class EAbility : uint8
{
	None                                     = 0,
	Empty                                    = 1,
	ActivateAnomaly                          = 2,
	Attack                                   = 3,
	AoEAttack                                = 4,
	Roar                                     = 5,
	Berserk                                  = 6,
	PSYStrike                                = 7,
	Zombification                            = 8,
	AuraEffect                               = 9,
	Charge                                   = 10,
	Throw                                    = 11,
	ThrowGrenade                             = 12,
	Shield                                   = 13,
	AOEAttackPassive                         = 14,
	LongJump                                 = 15,
	WeaponDrag                               = 16,
	WeaponRiseAndShoot                       = 17,
	TrickSound                               = 18,
	Summon                                   = 19,
	HumanMeleeAttack                         = 20,
	StrelokSpecial                           = 21,
	BlinkTeleport                            = 22,
	Count                                    = 23,
	EAbility_MAX                             = 24,
};

// Enum Stalker2.EAbilityStatePhase
// NumValues: 0x0005
enum class EAbilityStatePhase : uint8
{
	Anticipation                             = 0,
	Execution                                = 1,
	Recovery                                 = 2,
	Complete                                 = 3,
	EAbilityStatePhase_MAX                   = 4,
};

// Enum Stalker2.EActionType
// NumValues: 0x0037
enum class EActionType : uint8
{
	HideMainItem                             = 0,
	EquipMainItem                            = 1,
	HideSupportItem                          = 2,
	EquipSupportItem                         = 3,
	Interact                                 = 4,
	UseMainItem                              = 5,
	ReloadWeapon                             = 6,
	ChangeFireType                           = 7,
	HandleAimInput                           = 8,
	MeleeAttack                              = 9,
	ThrowItem                                = 10,
	ChangeAmmoType                           = 11,
	UnjamWeapon                              = 12,
	Fall                                     = 13,
	Lean                                     = 14,
	Crouch                                   = 15,
	Walk                                     = 16,
	Sprint                                   = 17,
	Run                                      = 18,
	Climb                                    = 19,
	PickUpItem                               = 20,
	UseConsumableItem                        = 21,
	UseBackpack                              = 22,
	UsePDA                                   = 23,
	DragDeadBody                             = 24,
	AutoCover                                = 25,
	RemoveLeftHandFromMainItem               = 26,
	ReturnLeftHandOnMainItem                 = 27,
	KnockDown                                = 28,
	InstallAttach                            = 29,
	ThrowWithoutEquip                        = 30,
	EquipBothHands                           = 31,
	HandleAimInputUnfocusable                = 32,
	UseMainItemUnfocusable                   = 33,
	MeleeAttackUnfocusable                   = 34,
	Vault                                    = 35,
	EnableShootingAttach                     = 36,
	DisableShootingAttach                    = 37,
	ToggleFlashlight                         = 38,
	Limp                                     = 39,
	SwapWeapon                               = 40,
	ItemSelector                             = 41,
	AttachSelector                           = 42,
	InteractWithAnim                         = 43,
	InteractInstant                          = 44,
	PickUpItemWithAnim                       = 45,
	EquipTwoHandItem                         = 46,
	HideTwoHandItem                          = 47,
	InspectArtifact                          = 48,
	UnloadWeapon                             = 49,
	ToggleFlashlightWithAnim                 = 50,
	PlayGuitar                               = 51,
	Dodge                                    = 52,
	GetCount                                 = 53,
	EActionType_MAX                          = 54,
};

// Enum Stalker2.EAdvanceActionType
// NumValues: 0x0006
enum class EAdvanceActionType : uint8
{
	None                                     = 0,
	Approach                                 = 1,
	ReadyForAction                           = 2,
	MontageMovement                          = 3,
	Action                                   = 4,
	EAdvanceActionType_MAX                   = 5,
};

// Enum Stalker2.EAgentArchetype
// NumValues: 0x0004
enum class EAgentArchetype : uint8
{
	Human                                    = 0,
	Mutant                                   = 1,
	GetCount                                 = 2,
	EAgentArchetype_MAX                      = 3,
};

// Enum Stalker2.EAgentType
// NumValues: 0x0013
enum class EAgentType : uint32
{
	Human                                    = 0,
	MutantGeneric                            = 1,
	Bloodsucker                              = 2,
	BlindDog                                 = 3,
	Flesh                                    = 4,
	Boar                                     = 5,
	Controller                               = 6,
	Poltergeist                              = 7,
	Pseudogiant                              = 8,
	Snork                                    = 9,
	Burer                                    = 10,
	Chimera                                  = 11,
	Cat                                      = 12,
	Tushkan                                  = 13,
	RatSwarm                                 = 14,
	PseudoDog                                = 15,
	Deer                                     = 16,
	GetCount                                 = 17,
	EAgentType_MAX                           = 18,
};

// Enum Stalker2.EAgentTypeMask
// NumValues: 0x001C
enum class EAgentTypeMask : uint32
{
	None                                     = 0,
	Human                                    = 1,
	MutantGeneric                            = 2,
	Bloodsucker                              = 4,
	BlindDog                                 = 8,
	Flesh                                    = 16,
	Boar                                     = 32,
	Controller                               = 64,
	Poltergeist                              = 128,
	Pseudogiant                              = 256,
	Snork                                    = 512,
	Burer                                    = 1024,
	Chimera                                  = 2048,
	Cat                                      = 4096,
	Tushkan                                  = 8192,
	RatSwarm                                 = 16384,
	PseudoDog                                = 32768,
	Deer                                     = 65536,
	Mutants                                  = 131070,
	CloseCombatAgent                         = 96574,
	DeffensiveCombatAgent                    = 1216,
	SmallNavAgent                            = 24576,
	DefaultNavAgent                          = 38607,
	LargeNavAgent                            = 67888,
	AgentsCrushingStaticDestructs            = 106495,
	AgentsAvoidingStaticDestructs            = 8192,
	Default                                  = 4294967295,
	EAgentTypeMask_MAX                       = 4294967296,
};

// Enum Stalker2.EAgentBehaviourModifier
// NumValues: 0x0005
enum class EAgentBehaviourModifier : uint8
{
	Default                                  = 0,
	Zombie                                   = 1,
	Phantom                                  = 2,
	GetCount                                 = 3,
	EAgentBehaviourModifier_MAX              = 4,
};

// Enum Stalker2.EAggressiveMutantCombatPlannerActions
// NumValues: 0x0008
enum class EAggressiveMutantCombatPlannerActions : uint8
{
	ContainerActions                         = 0,
	SimpleActions                            = 1,
	RotateToEnemyAction                      = 2,
	MoveToEnemyAction                        = 3,
	MutantEscapeAction                       = 4,
	PrepareForAttackAction                   = 5,
	RetreatAction                            = 6,
	EAggressiveMutantCombatPlannerActions_MAX = 7,
};

// Enum Stalker2.EAIFeature
// NumValues: 0x0018
enum class EAIFeature : uint32
{
	None                                     = 0,
	Tick                                     = 1,
	UpdateDecision                           = 2,
	Threat                                   = 4,
	Combat                                   = 8,
	UpdateSensors                            = 16,
	Vision                                   = 32,
	Hearing                                  = 64,
	Hit                                      = 128,
	Flair                                    = 256,
	EmissionThreatAndCombat                  = 512,
	Sanity                                   = 1024,
	MovementDetection                        = 2048,
	ALifeDirector                            = 4096,
	LeaveRestrictedArea                      = 8192,
	WoundedWeapon                            = 16384,
	MotionWarpingNPC                         = 32768,
	ALifePopulationManager                   = 65536,
	SeePlayer                                = 131072,
	LuminanceManager                         = 262144,
	FlashlightUseManager                     = 524288,
	ProcessCorpse                            = 1048576,
	All                                      = 2097151,
	EAIFeature_MAX                           = 2097152,
};

// Enum Stalker2.ESwarmInstanceStates
// NumValues: 0x0007
enum class ESwarmInstanceStates : uint8
{
	NavMoving                                = 0,
	Flocking                                 = 1,
	Attacking                                = 2,
	Idle                                     = 3,
	Dying                                    = 4,
	Count                                    = 5,
	ESwarmInstanceStates_MAX                 = 6,
};

// Enum Stalker2.EDamageAffectorType
// NumValues: 0x0007
enum class EDamageAffectorType : uint8
{
	None                                     = 0,
	Projectile                               = 1,
	HeavyProjectile                          = 2,
	Explosion                                = 3,
	Melee                                    = 4,
	Count                                    = 5,
	EDamageAffectorType_MAX                  = 6,
};

// Enum Stalker2.EALifeFactionGoalType
// NumValues: 0x0005
enum class EALifeFactionGoalType : uint8
{
	Aggressive                               = 0,
	Normal                                   = 1,
	Defensive                                = 2,
	GetCount                                 = 3,
	EALifeFactionGoalType_MAX                = 4,
};

// Enum Stalker2.EFireTypeSlotType
// NumValues: 0x0004
enum class EFireTypeSlotType : uint8
{
	Default                                  = 0,
	First                                    = 1,
	Last                                     = 2,
	EFireTypeSlotType_MAX                    = 3,
};

// Enum Stalker2.EAnalyticsCategory
// NumValues: 0x0005
enum class EAnalyticsCategory : uint8
{
	None                                     = 0,
	Kills                                    = 1,
	Deaths                                   = 2,
	Count                                    = 3,
	EAnalyticsCategory_MAX                   = 4,
};

// Enum Stalker2.EAnalyticsLogType
// NumValues: 0x0004
enum class EAnalyticsLogType : uint8
{
	LocalOnly                                = 0,
	GlobalOnly                               = 1,
	LocalAndGlobal                           = 2,
	EAnalyticsLogType_MAX                    = 3,
};

// Enum Stalker2.ECalculateSignificance
// NumValues: 0x0004
enum class ECalculateSignificance : uint8
{
	Default                                  = 0,
	ScreenSize                               = 1,
	ScreenSizeAndDistance                    = 2,
	ECalculateSignificance_MAX               = 3,
};

// Enum Stalker2.EAnimationTargetType
// NumValues: 0x0008
enum class EAnimationTargetType : uint8
{
	None                                     = 0,
	Stay                                     = 1,
	Sleep                                    = 2,
	Rest                                     = 3,
	Heal                                     = 4,
	InteractWithPDA                          = 5,
	ReactionOnEmission                       = 6,
	EAnimationTargetType_MAX                 = 7,
};

// Enum Stalker2.EPlayerAnimDamageSource
// NumValues: 0x0010
enum class EPlayerAnimDamageSource : uint8
{
	None                                     = 0,
	BleedingRadiationHunger                  = 1,
	EmmisionPSY                              = 2,
	Water                                    = 3,
	Fall                                     = 4,
	Bullet                                   = 5,
	Explosion                                = 6,
	Chemical                                 = 7,
	Fire                                     = 8,
	Electro                                  = 9,
	PoppyField                               = 10,
	BulbCarouselExpulsion                    = 11,
	DiamondIronWind                          = 12,
	Mutant                                   = 13,
	GetCount                                 = 14,
	EPlayerAnimDamageSource_MAX              = 15,
};

// Enum Stalker2.EHumanAnimDamageSource
// NumValues: 0x0010
enum class EHumanAnimDamageSource : uint8
{
	None                                     = 0,
	Emmision                                 = 1,
	Bullet                                   = 2,
	Explosion                                = 3,
	Chemical                                 = 4,
	Fire                                     = 5,
	Electro                                  = 6,
	Expulsion                                = 7,
	Diamond                                  = 8,
	IronWind                                 = 9,
	Physics                                  = 10,
	Zombification                            = 11,
	Carousel                                 = 12,
	RatSwarm                                 = 13,
	GetCount                                 = 14,
	EHumanAnimDamageSource_MAX               = 15,
};

// Enum Stalker2.EAnimDialogContextualState
// NumValues: 0x0006
enum class EAnimDialogContextualState : uint8
{
	Stand                                    = 0,
	SitChair                                 = 1,
	SitBarrel                                = 2,
	SitEdge                                  = 3,
	SitGround                                = 4,
	EAnimDialogContextualState_MAX           = 5,
};

// Enum Stalker2.EDirections
// NumValues: 0x000A
enum class EDirections : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Backward                                 = 4,
	Left                                     = 8,
	Right                                    = 16,
	ForwardLeft                              = 9,
	ForwardRight                             = 17,
	BackwardLeft                             = 12,
	BackwardRight                            = 20,
	EDirections_MAX                          = 21,
};

// Enum Stalker2.EAnimDirections
// NumValues: 0x000A
enum class EAnimDirections : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Backward                                 = 2,
	Left                                     = 3,
	Right                                    = 4,
	ForwardLeft                              = 5,
	ForwardRight                             = 6,
	BackwardLeft                             = 7,
	BackwardRight                            = 8,
	EAnimDirections_MAX                      = 9,
};

// Enum Stalker2.EAnimFacialSource
// NumValues: 0x0005
enum class EAnimFacialSource : uint8
{
	Dialog                                   = 0,
	Contextual                               = 1,
	ActorDuplicating                         = 2,
	HitReaction                              = 3,
	EAnimFacialSource_MAX                    = 4,
};

// Enum Stalker2.EAnomalyAnimInteraction
// NumValues: 0x0002
enum class EAnomalyAnimInteraction : uint8
{
	GravityInteractIn                        = 0,
	EAnomalyAnimInteraction_MAX              = 1,
};

// Enum Stalker2.EAnimObjState
// NumValues: 0x0015
enum class EAnimObjState : uint32
{
	None                                     = 0,
	Alive                                    = 1,
	Moving                                   = 2,
	Walking                                  = 4,
	Running                                  = 8,
	Sprinting                                = 16,
	Crouching                                = 32,
	LowCrouching                             = 64,
	Climbing                                 = 128,
	Falling                                  = 256,
	Limping                                  = 512,
	Zombie                                   = 1024,
	BusyLeftHand                             = 2048,
	Sitting                                  = 4096,
	Inspecting                               = 8192,
	Combat                                   = 16384,
	Rotating                                 = 32768,
	RenderRelevant                           = 65536,
	ActionSlot                               = 131072,
	FullBodySlot                             = 262144,
	EAnimObjState_MAX                        = 262145,
};

// Enum Stalker2.EAnimUpdateCondition
// NumValues: 0x0009
enum class EAnimUpdateCondition : uint8
{
	None                                     = 0,
	SwappedFirstAndThirdPerson               = 1,
	MainHandChanged                          = 2,
	SecondaryHandChanged                     = 3,
	Aimed                                    = 4,
	MainUnEquipped                           = 5,
	AttachInstalled                          = 6,
	WeaponStateChanged                       = 7,
	EAnimUpdateCondition_MAX                 = 8,
};

// Enum Stalker2.EAnimationShootingTypes
// NumValues: 0x0007
enum class EAnimationShootingTypes : uint8
{
	Default                                  = 0,
	Aim                                      = 1,
	DefaultLastShoot                         = 2,
	AimLastShoot                             = 3,
	LooseShoot                               = 4,
	LooseShootInAim                          = 5,
	EAnimationShootingTypes_MAX              = 6,
};

// Enum Stalker2.EAnimGuitarRightHandState
// NumValues: 0x0007
enum class EAnimGuitarRightHandState : uint8
{
	StrumDown                                = 0,
	StrumUp                                  = 1,
	StrumDownWithoutUp                       = 2,
	StrumUpWithoutDown                       = 3,
	StrumDownWithoutUpTwice                  = 4,
	StrumUpWithoutDownTwice                  = 5,
	EAnimGuitarRightHandState_MAX            = 6,
};

// Enum Stalker2.EAnimGuitarState
// NumValues: 0x0010
enum class EAnimGuitarState : uint8
{
	Enter                                    = 0,
	Exit                                     = 1,
	Chord1                                   = 2,
	Chord1m                                  = 3,
	Chord2                                   = 4,
	Chord2m                                  = 5,
	Chord3                                   = 6,
	Chord3m                                  = 7,
	Chord4                                   = 8,
	Chord4m                                  = 9,
	Chord5                                   = 10,
	Chord5m                                  = 11,
	Chord6                                   = 12,
	Chord6m                                  = 13,
	WithoutGuitar                            = 14,
	EAnimGuitarState_MAX                     = 15,
};

// Enum Stalker2.EAnimationHeadTypes
// NumValues: 0x0030
enum class EAnimationHeadTypes : uint8
{
	SK_fac_20_00                             = 0,
	SK_fac_20_01                             = 1,
	SK_fac_20_02                             = 2,
	SK_fac_20_03                             = 3,
	SK_fac_20_04                             = 4,
	SK_fac_30_01                             = 5,
	SK_fac_30_02                             = 6,
	SK_fac_30_03                             = 7,
	SK_fac_30_04                             = 8,
	SK_fac_30_05                             = 9,
	SK_fac_30_07                             = 10,
	SK_fac_30_08                             = 11,
	SK_fac_30_09                             = 12,
	SK_fac_30_10                             = 13,
	SK_fac_30_11                             = 14,
	SK_fac_30_12                             = 15,
	SK_fac_30_13                             = 16,
	SK_fac_30_14                             = 17,
	SK_fac_30_15                             = 18,
	SK_fac_30_16                             = 19,
	SK_fac_30_17                             = 20,
	SK_fac_30_18                             = 21,
	SK_fac_30_19                             = 22,
	SK_fac_40_01                             = 23,
	SK_fac_40_03                             = 24,
	SK_fac_40_04                             = 25,
	SK_fac_40_05                             = 26,
	SK_fac_40_06                             = 27,
	SK_fac_40_07                             = 28,
	SK_fac_40_08                             = 29,
	SK_fac_40_09                             = 30,
	SK_fac_50_01                             = 31,
	SK_fac_50_01_02                          = 32,
	SK_fac_50_02                             = 33,
	SK_fac_50_03                             = 34,
	SK_fac_50_04                             = 35,
	SK_fac_50_05                             = 36,
	SK_fac_50_06                             = 37,
	SK_fac_50_07                             = 38,
	SK_fac_20_00_v2                          = 39,
	SK_fac_20_02_v2                          = 40,
	SK_fac_30_02_v2                          = 41,
	SK_fac_30_03_v2                          = 42,
	SK_fac_30_04_v2                          = 43,
	SK_fac_30_07_v2                          = 44,
	SK_fac_30_08_v2                          = 45,
	SK_fac_40_01_v2                          = 46,
	SK_fac_MAX                               = 47,
};

// Enum Stalker2.EAnimHitBodyPart
// NumValues: 0x0005
enum class EAnimHitBodyPart : uint8
{
	Head                                     = 0,
	LeftShoulder                             = 1,
	RightShoulder                            = 2,
	LowerBody                                = 3,
	EAnimHitBodyPart_MAX                     = 4,
};

// Enum Stalker2.EAnimHitBodyPartType
// NumValues: 0x0006
enum class EAnimHitBodyPartType : uint8
{
	Head                                     = 0,
	UpperBody                                = 1,
	LowerBody                                = 2,
	LeftLeg                                  = 3,
	RightLeg                                 = 4,
	EAnimHitBodyPartType_MAX                 = 5,
};

// Enum Stalker2.EAnimHitSourceType
// NumValues: 0x0003
enum class EAnimHitSourceType : uint8
{
	Default                                  = 0,
	Shotgun                                  = 1,
	EAnimHitSourceType_MAX                   = 2,
};

// Enum Stalker2.EAnimHumanBodyState
// NumValues: 0x0003
enum class EAnimHumanBodyState : uint8
{
	Stand                                    = 0,
	Sit                                      = 1,
	EAnimHumanBodyState_MAX                  = 2,
};

// Enum Stalker2.EAnimDialogIdleState
// NumValues: 0x0005
enum class EAnimDialogIdleState : uint8
{
	None                                     = 0,
	Listening                                = 1,
	Waiting                                  = 2,
	Talking                                  = 3,
	EAnimDialogIdleState_MAX                 = 4,
};

// Enum Stalker2.EAnimInteractAction
// NumValues: 0x0006
enum class EAnimInteractAction : uint8
{
	None                                     = 0,
	OpenLootMenu                             = 1,
	CloseLootMenu                            = 2,
	StartPlayerContextualAction              = 3,
	TriggerNotifyEvent                       = 4,
	EAnimInteractAction_MAX                  = 5,
};

// Enum Stalker2.ELongIdleType
// NumValues: 0x0003
enum class ELongIdleType : uint8
{
	Default                                  = 0,
	Inaction                                 = 1,
	ELongIdleType_MAX                        = 2,
};

// Enum Stalker2.ENotifyTriggerType
// NumValues: 0x0004
enum class ENotifyTriggerType : uint8
{
	Default                                  = 0,
	DefaultOnInterrupted                     = 1,
	ReverseOnInterrupted                     = 2,
	ENotifyTriggerType_MAX                   = 3,
};

// Enum Stalker2.EAttachItemType
// NumValues: 0x0006
enum class EAttachItemType : uint8
{
	None                                     = 0,
	Required                                 = 1,
	Injector                                 = 2,
	Artifact                                 = 3,
	Mesh                                     = 4,
	EAttachItemType_MAX                      = 5,
};

// Enum Stalker2.EPreciseRootMotionDeltaTimeModifier
// NumValues: 0x0003
enum class EPreciseRootMotionDeltaTimeModifier : uint8
{
	None                                     = 0,
	ClimbingSpeed                            = 1,
	EPreciseRootMotionDeltaTimeModifier_MAX  = 2,
};

// Enum Stalker2.EAttachAction
// NumValues: 0x000C
enum class EAttachAction : uint8
{
	None                                     = 0,
	JoinAttachToHand                         = 1,
	RemoveAttachFromHandAndAttachToWeapon    = 2,
	PickingUpItem                            = 3,
	RemoveItemFromHand                       = 4,
	FinishRequestedInstallAttach             = 5,
	AttachMeshToSocket                       = 6,
	ForceBindedHandsLookVertical             = 7,
	UpdateCameraRotation                     = 8,
	UpdatePlayerPosition                     = 9,
	DissolvePickedFakeArtifact               = 10,
	EAttachAction_MAX                        = 11,
};

// Enum Stalker2.EParticleAction
// NumValues: 0x0003
enum class EParticleAction : uint8
{
	AttachParticle                           = 0,
	RemoveParticle                           = 1,
	EParticleAction_MAX                      = 2,
};

// Enum Stalker2.EWeaponIdleState
// NumValues: 0x0006
enum class EWeaponIdleState : uint8
{
	ShutterState                             = 0,
	JamState                                 = 1,
	UnderbarrelState                         = 2,
	AimState                                 = 3,
	CustomAdditionalState                    = 4,
	EWeaponIdleState_MAX                     = 5,
};

// Enum Stalker2.EAnimationType
// NumValues: 0x0005
enum class EAnimationType : uint8
{
	ClimbAnimationEnded                      = 0,
	ExitLadder                               = 1,
	FocusCameraCenter                        = 2,
	StartJumpFall                            = 3,
	EAnimationType_MAX                       = 4,
};

// Enum Stalker2.ENotifyDialogAction
// NumValues: 0x0002
enum class ENotifyDialogAction : uint8
{
	EndDialogIdle                            = 0,
	ENotifyDialogAction_MAX                  = 1,
};

// Enum Stalker2.EDragDeadBodyState
// NumValues: 0x0009
enum class EDragDeadBodyState : uint8
{
	StartDragDeadBody                        = 0,
	EndDragDeadBody                          = 1,
	StartPutDeadBody                         = 2,
	EndPutDeadBody                           = 3,
	StartCorpseDragIn                        = 4,
	EndCorpseDragIn                          = 5,
	StartCorpseDragOut                       = 6,
	EndCorpseDragOut                         = 7,
	EDragDeadBodyState_MAX                   = 8,
};

// Enum Stalker2.ENotifyGuitarAction
// NumValues: 0x0007
enum class ENotifyGuitarAction : uint8
{
	StrumUp                                  = 0,
	StrumDown                                = 1,
	ExitCompleted                            = 2,
	EnterCompleted                           = 3,
	ShowGuitarMesh                           = 4,
	OnStrumComplete                          = 5,
	ENotifyGuitarAction_MAX                  = 6,
};

// Enum Stalker2.EBoneInteractionType
// NumValues: 0x0004
enum class EBoneInteractionType : uint8
{
	HideBone                                 = 0,
	ShowBone                                 = 1,
	HideBoneOnAmmoCount                      = 2,
	EBoneInteractionType_MAX                 = 3,
};

// Enum Stalker2.EJumpState
// NumValues: 0x0003
enum class EJumpState : uint8
{
	StartJump                                = 0,
	EndJump                                  = 1,
	EJumpState_MAX                           = 2,
};

// Enum Stalker2.ELookAtAction
// NumValues: 0x0004
enum class ELookAtAction : uint8
{
	Start                                    = 0,
	Restrict                                 = 1,
	ChangeOwnerState                         = 2,
	ELookAtAction_MAX                        = 3,
};

// Enum Stalker2.EPlayerActionResult
// NumValues: 0x0003
enum class EPlayerActionResult : uint8
{
	End                                      = 0,
	Interrupt                                = 1,
	EPlayerActionResult_MAX                  = 2,
};

// Enum Stalker2.EPlayerActionTriggerState
// NumValues: 0x0003
enum class EPlayerActionTriggerState : uint8
{
	Activate                                 = 0,
	Deactivate                               = 1,
	EPlayerActionTriggerState_MAX            = 2,
};

// Enum Stalker2.EPlayerUIEvent
// NumValues: 0x0002
enum class EPlayerUIEvent : uint8
{
	PlayerDied                               = 0,
	EPlayerUIEvent_MAX                       = 1,
};

// Enum Stalker2.ERagdollAction
// NumValues: 0x0004
enum class ERagdollAction : uint8
{
	StartWoundedRagdoll                      = 0,
	StartRagdollLying                        = 1,
	EndWoundedWakeUp                         = 2,
	ERagdollAction_MAX                       = 3,
};

// Enum Stalker2.EStashActionType
// NumValues: 0x0003
enum class EStashActionType : uint8
{
	Open                                     = 0,
	Close                                    = 1,
	EStashActionType_MAX                     = 2,
};

// Enum Stalker2.EUpdateSource
// NumValues: 0x0005
enum class EUpdateSource : uint8
{
	Reload                                   = 0,
	Shift                                    = 1,
	Upgrade                                  = 2,
	Spawn                                    = 3,
	EUpdateSource_MAX                        = 4,
};

// Enum Stalker2.EHandItem
// NumValues: 0x0004
enum class EHandItem : uint8
{
	None                                     = 0,
	Backpack                                 = 1,
	PDA                                      = 2,
	EHandItem_MAX                            = 3,
};

// Enum Stalker2.EWeaponAction
// NumValues: 0x000F
enum class EWeaponAction : uint8
{
	ToggleTwinMagazineShift                  = 0,
	JamRepaired                              = 1,
	TryForceJam                              = 2,
	ChangeFireType                           = 3,
	AddAmmo                                  = 4,
	FinishReload                             = 5,
	PerBulletReloading                       = 6,
	PerBulletAmmoCountSection                = 7,
	Unloading                                = 8,
	SwitchAttachMode                         = 9,
	OnPullCotter                             = 10,
	ForceShutterState                        = 11,
	BulletMeshesVisibility                   = 12,
	UnlockLeftHandIdle                       = 13,
	EWeaponAction_MAX                        = 14,
};

// Enum Stalker2.EAnimConstraintProfile
// NumValues: 0x0005
enum class EAnimConstraintProfile : uint8
{
	None                                     = 0,
	HingesOnly                               = 1,
	NoLimits                                 = 2,
	RagdollNoDrivers                         = 3,
	EAnimConstraintProfile_MAX               = 4,
};

// Enum Stalker2.EVaultState
// NumValues: 0x0004
enum class EVaultState : uint8
{
	None                                     = 0,
	VaultingOver                             = 1,
	VaultingOnTop                            = 2,
	EVaultState_MAX                          = 3,
};

// Enum Stalker2.EAnimPushbackState
// NumValues: 0x0005
enum class EAnimPushbackState : uint8
{
	Inactive                                 = 0,
	Active                                   = 1,
	Delayed                                  = 2,
	BlendingOut                              = 3,
	EAnimPushbackState_MAX                   = 4,
};

// Enum Stalker2.EAnimPoseSearchMoveType
// NumValues: 0x0006
enum class EAnimPoseSearchMoveType : uint8
{
	Idle                                     = 0,
	Move                                     = 1,
	Start                                    = 2,
	Stop                                     = 3,
	DirectionChange                          = 4,
	EAnimPoseSearchMoveType_MAX              = 5,
};

// Enum Stalker2.EAnimStateCurveType
// NumValues: 0x0004
enum class EAnimStateCurveType : uint8
{
	Standing                                 = 0,
	Sitting                                  = 1,
	Lying                                    = 2,
	EAnimStateCurveType_MAX                  = 3,
};

// Enum Stalker2.EAnimationStates
// NumValues: 0x0008
enum class EAnimationStates : uint8
{
	None                                     = 0,
	Stand                                    = 1,
	Walking                                  = 2,
	Running                                  = 3,
	Sprinting                                = 4,
	Crouching                                = 5,
	LowCrouching                             = 6,
	EAnimationStates_MAX                     = 7,
};

// Enum Stalker2.EAnimSwitchFireTypeMode
// NumValues: 0x0003
enum class EAnimSwitchFireTypeMode : uint8
{
	Hip                                      = 0,
	Aim                                      = 1,
	EAnimSwitchFireTypeMode_MAX              = 2,
};

// Enum Stalker2.EAnimTopazAction
// NumValues: 0x0006
enum class EAnimTopazAction : uint8
{
	None                                     = 0,
	SetVisible                               = 1,
	SetInvisible                             = 2,
	EnableDisplay                            = 3,
	DisableDisplay                           = 4,
	EAnimTopazAction_MAX                     = 5,
};

// Enum Stalker2.EAnimWeaponAdditivePoseMode
// NumValues: 0x0003
enum class EAnimWeaponAdditivePoseMode : uint8
{
	Identity                                 = 0,
	AdditivityEnabled                        = 1,
	EAnimWeaponAdditivePoseMode_MAX          = 2,
};

// Enum Stalker2.EAnomalyOverlappedActorState
// NumValues: 0x0009
enum class EAnomalyOverlappedActorState : uint8
{
	None                                     = 0,
	CanTriggerAnomaly                        = 1,
	ReachableByAnomaly                       = 2,
	HasInteractionEffects                    = 4,
	HasPreInteractionEffects                 = 8,
	HasPostInteractionEffects                = 16,
	HasImmuneToAnomaly                       = 32,
	ReachableAndCanTriggerAnomaly            = 3,
	EAnomalyOverlappedActorState_MAX         = 33,
};

// Enum Stalker2.ELineNavigation
// NumValues: 0x0006
enum class ELineNavigation : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Left                                     = 2,
	Down                                     = 3,
	Right                                    = 4,
	ELineNavigation_MAX                      = 5,
};

// Enum Stalker2.EAttachSlotState
// NumValues: 0x0010
enum class EAttachSlotState : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Detach                                   = 2,
	Selected                                 = 4,
	Highlighted                              = 8,
	Empty                                    = 16,
	Filled                                   = 32,
	Disabled                                 = 64,
	SelectedHighlighted                      = 12,
	HighlightedFilled                        = 40,
	HighlightedEmpty                         = 24,
	SelectedFilled                           = 36,
	SelectedEmpty                            = 20,
	SelectedHighlightedFilled                = 44,
	SelectedHighlightedEmpty                 = 28,
	EAttachSlotState_MAX                     = 65,
};

// Enum Stalker2.EAttractionPointType
// NumValues: 0x0005
enum class EAttractionPointType : uint8
{
	StaticLocation                           = 0,
	FollowObject                             = 1,
	FollowCharacterBone                      = 2,
	ExitLookAt                               = 3,
	EAttractionPointType_MAX                 = 4,
};

// Enum Stalker2.EAutoCoverState
// NumValues: 0x000F
enum class EAutoCoverState : uint8
{
	StandInCover                             = 0,
	CanLeanRight                             = 1,
	CanLeanLeft                              = 2,
	ApproachCover                            = 3,
	ApproachCoverLeft                        = 4,
	ApproachCoverRight                       = 5,
	AimLeft                                  = 6,
	AimRight                                 = 7,
	AimUp                                    = 8,
	AimlessShootLeft                         = 9,
	AimlessShootRight                        = 10,
	AimlessShootUp                           = 11,
	ExitCover                                = 12,
	InCoverWithoutCoverAffect                = 13,
	EAutoCoverState_MAX                      = 14,
};

// Enum Stalker2.EAvoidanceAgentType
// NumValues: 0x0006
enum class EAvoidanceAgentType : uint8
{
	None                                     = 0,
	AvoidanceAgent                           = 1,
	ObstacleAgent                            = 2,
	MoveThroughUnits                         = 4,
	Default                                  = 3,
	EAvoidanceAgentType_MAX                  = 5,
};

// Enum Stalker2.EBehaviorType
// NumValues: 0x0014
enum class EBehaviorType : uint8
{
	Kill                                     = 0,
	Follow                                   = 1,
	Panic                                    = 2,
	Rest                                     = 3,
	Flee                                     = 4,
	Sleep                                    = 5,
	Stay                                     = 6,
	Berserk                                  = 7,
	Pacifist                                 = 8,
	Confused                                 = 9,
	Guard                                    = 10,
	MoveTo                                   = 11,
	Escort                                   = 12,
	Patrol                                   = 13,
	ShootTarget                              = 14,
	AttackLair                               = 15,
	UseAbility                               = 16,
	BaseSquad                                = 17,
	GetCount                                 = 18,
	EBehaviorType_MAX                        = 19,
};

// Enum Stalker2.EBlockSlot
// NumValues: 0x0008
enum class EBlockSlot : uint8
{
	None                                     = 0,
	MainHandsSlot                            = 1,
	MainHandsSlotSecond                      = 2,
	PistolSlot                               = 3,
	KnifeSlot                                = 4,
	BoltSlot                                 = 5,
	GrenadeSlot                              = 6,
	EBlockSlot_MAX                           = 7,
};

// Enum Stalker2.EBodyMeshType
// NumValues: 0x0008
enum class EBodyMeshType : uint8
{
	BodyArmor                                = 0,
	Face                                     = 1,
	Hands                                    = 2,
	Head                                     = 3,
	Attach                                   = 4,
	Cloth                                    = 5,
	BodyArmorPart                            = 6,
	EBodyMeshType_MAX                        = 7,
};

// Enum Stalker2.EPageOpenMethod
// NumValues: 0x0005
enum class EPageOpenMethod : uint8
{
	Unknown                                  = 0,
	FromDialog                               = 1,
	ByHotkey                                 = 2,
	BySwitchingTabs                          = 3,
	EPageOpenMethod_MAX                      = 4,
};

// Enum Stalker2.EKeyCategory
// NumValues: 0x0007
enum class EKeyCategory : uint8
{
	Movement                                 = 0,
	Weapon                                   = 1,
	PDA                                      = 2,
	General                                  = 3,
	Developer                                = 4,
	GetCount                                 = 5,
	EKeyCategory_MAX                         = 6,
};

// Enum Stalker2.EButtonState
// NumValues: 0x0004
enum class EButtonState : uint8
{
	Active                                   = 0,
	Blocked                                  = 1,
	Hidden                                   = 2,
	EButtonState_MAX                         = 3,
};

// Enum Stalker2.EGenerationType
// NumValues: 0x0005
enum class EGenerationType : uint8
{
	None                                     = 0,
	Point                                    = 1,
	Cover                                    = 2,
	All                                      = 3,
	EGenerationType_MAX                      = 4,
};

// Enum Stalker2.ECompassState
// NumValues: 0x0005
enum class ECompassState : uint8
{
	Default                                  = 0,
	Battle                                   = 1,
	SecondaryQuestZone                       = 2,
	MainQuestZone                            = 3,
	ECompassState_MAX                        = 4,
};

// Enum Stalker2.EAIConstraintType
// NumValues: 0x0003
enum class EAIConstraintType : uint8
{
	PrepareForEmission                       = 0,
	Count                                    = 1,
	EAIConstraintType_MAX                    = 2,
};

// Enum Stalker2.EContextualActionBodyPart
// NumValues: 0x0005
enum class EContextualActionBodyPart : uint8
{
	None                                     = 0,
	Head                                     = 1,
	Back                                     = 2,
	Skirt                                    = 4,
	EContextualActionBodyPart_MAX            = 5,
};

// Enum Stalker2.EContextualActionEffectType
// NumValues: 0x0005
enum class EContextualActionEffectType : uint8
{
	None                                     = 0,
	ChangeNeedValue                          = 1,
	AddCurrentNeed                           = 2,
	RemoveCurrentNeed                        = 3,
	EContextualActionEffectType_MAX          = 4,
};

// Enum Stalker2.EContextualAgentType
// NumValues: 0x0014
enum class EContextualAgentType : uint8
{
	Human                                    = 0,
	MutantGeneric                            = 1,
	Bloodsucker                              = 2,
	BlindDog                                 = 3,
	Flesh                                    = 4,
	Boar                                     = 5,
	Controller                               = 6,
	Poltergeist                              = 7,
	Pseudogiant                              = 8,
	Snork                                    = 9,
	Burer                                    = 10,
	Chimera                                  = 11,
	Cat                                      = 12,
	Tushkan                                  = 13,
	RatSwarm                                 = 14,
	PseudoDog                                = 15,
	Deer                                     = 16,
	Zombie                                   = 17,
	GetCount                                 = 18,
	EContextualAgentType_MAX                 = 19,
};

// Enum Stalker2.EContextualActionNeeds
// NumValues: 0x0018
enum class EContextualActionNeeds : uint32
{
	None                                     = 1,
	Idle                                     = 2,
	Rest                                     = 4,
	Sleep                                    = 8,
	Smoke                                    = 16,
	Drink                                    = 32,
	Eat                                      = 64,
	Guitar                                   = 128,
	Work                                     = 256,
	PDA                                      = 512,
	Detector                                 = 1024,
	Guard                                    = 2048,
	WeaponCleaning                           = 4096,
	Patrolling                               = 8192,
	Fight                                    = 16384,
	Quest                                    = 32768,
	Emission                                 = 65536,
	Monolog                                  = 131072,
	Dialog                                   = 262144,
	FallbackIdle                             = 524288,
	Anecdote                                 = 1048576,
	RunOnTalking                             = 2097152,
	Count                                    = 22,
	EContextualActionNeeds_MAX               = 2097153,
};

// Enum Stalker2.EContextualActionComparisonOperator
// NumValues: 0x0003
enum class EContextualActionComparisonOperator : uint8
{
	Greater                                  = 0,
	Less                                     = 1,
	EContextualActionComparisonOperator_MAX  = 2,
};

// Enum Stalker2.ERepetitions
// NumValues: 0x0004
enum class ERepetitions : uint8
{
	Infinity                                 = 0,
	TimeInSeconds                            = 1,
	PlayCount                                = 2,
	ERepetitions_MAX                         = 3,
};

// Enum Stalker2.EItemPreconditionType
// NumValues: 0x0003
enum class EItemPreconditionType : uint8
{
	InventoryItem                            = 0,
	MeshGenerator                            = 1,
	EItemPreconditionType_MAX                = 2,
};

// Enum Stalker2.EDistanceSelectorCondition
// NumValues: 0x0003
enum class EDistanceSelectorCondition : uint8
{
	MinIn                                    = 0,
	MinOut                                   = 1,
	EDistanceSelectorCondition_MAX           = 2,
};

// Enum Stalker2.EInterruptionState
// NumValues: 0x0004
enum class EInterruptionState : uint8
{
	ShouldInterrupt                          = 0,
	Interrupting                             = 1,
	Interrupted                              = 2,
	EInterruptionState_MAX                   = 3,
};

// Enum Stalker2.EContextualActionAllowedAgentType
// NumValues: 0x0003
enum class EContextualActionAllowedAgentType : uint8
{
	AlifeAgent                               = 0,
	QuestAgent                               = 1,
	EContextualActionAllowedAgentType_MAX    = 2,
};

// Enum Stalker2.EZombifiedPreconditionType
// NumValues: 0x0003
enum class EZombifiedPreconditionType : uint8
{
	ZombieOnly                               = 0,
	AliveOnly                                = 1,
	EZombifiedPreconditionType_MAX           = 2,
};

// Enum Stalker2.EContextualActionPreconditionType
// NumValues: 0x000C
enum class EContextualActionPreconditionType : uint8
{
	None                                     = 0,
	Need                                     = 1,
	EquippedItem                             = 2,
	NPCPrototype                             = 3,
	AllowedAgentType                         = 4,
	ItemInInventory                          = 5,
	GlobalVariable                           = 6,
	AvailableBodyPart                        = 7,
	Weather                                  = 8,
	Rank                                     = 9,
	Faction                                  = 10,
	EContextualActionPreconditionType_MAX    = 11,
};

// Enum Stalker2.EContextualItemAttachType
// NumValues: 0x0005
enum class EContextualItemAttachType : uint32
{
	AttachNewStaticMesh                      = 0,
	AttachNewSkeletalMesh                    = 1,
	AttachItemFromScene                      = 2,
	AttachParticleSystem                     = 3,
	EContextualItemAttachType_MAX            = 4,
};

// Enum Stalker2.ESpawnNiagaraAtLocation
// NumValues: 0x0004
enum class ESpawnNiagaraAtLocation : uint32
{
	BlahBlah                                 = 0,
	CigaretteAshLocation                     = 1,
	SmokingMouth                             = 2,
	ESpawnNiagaraAtLocation_MAX              = 3,
};

// Enum Stalker2.EContextualActionDialogType
// NumValues: 0x0005
enum class EContextualActionDialogType : uint8
{
	None                                     = 0,
	Dialog                                   = 1,
	BusyComment                              = 2,
	Comment                                  = 3,
	EContextualActionDialogType_MAX          = 4,
};

// Enum Stalker2.ESmartCoverType
// NumValues: 0x0008
enum class ESmartCoverType : uint8
{
	NoCover                                  = 0,
	NoShootingPosition                       = 1,
	Generic                                  = 2,
	BehindTreeCover                          = 3,
	Low                                      = 4,
	High                                     = 5,
	Count                                    = 6,
	ESmartCoverType_MAX                      = 7,
};

// Enum Stalker2.EAvailableCoverActionsSide
// NumValues: 0x0005
enum class EAvailableCoverActionsSide : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Center                                   = 4,
	EAvailableCoverActionsSide_MAX           = 5,
};

// Enum Stalker2.EAvailableCoverEnterTypes
// NumValues: 0x0004
enum class EAvailableCoverEnterTypes : uint8
{
	None                                     = 0,
	Short                                    = 1,
	Long                                     = 2,
	EAvailableCoverEnterTypes_MAX            = 3,
};

// Enum Stalker2.EAvailableCoverExitTypes
// NumValues: 0x0005
enum class EAvailableCoverExitTypes : uint8
{
	None                                     = 0,
	Front                                    = 1,
	Aside                                    = 2,
	Back                                     = 4,
	EAvailableCoverExitTypes_MAX             = 5,
};

// Enum Stalker2.ESmartCoverActionType
// NumValues: 0x0004
enum class ESmartCoverActionType : uint8
{
	Blind                                    = 0,
	LookOut                                  = 1,
	ThrowGrenade                             = 2,
	ESmartCoverActionType_MAX                = 3,
};

// Enum Stalker2.ESmartCoverAnimationActionType
// NumValues: 0x000A
enum class ESmartCoverAnimationActionType : uint8
{
	EnterCover                               = 0,
	LeaveCover                               = 1,
	StayBehindCover                          = 2,
	PoseTransition                           = 3,
	LookFromCover                            = 4,
	HideBehindCover                          = 5,
	Shoot                                    = 6,
	ThrowGrenade                             = 7,
	Count                                    = 8,
	ESmartCoverAnimationActionType_MAX       = 9,
};

// Enum Stalker2.ECoverFocusType
// NumValues: 0x0003
enum class ECoverFocusType : uint8
{
	Path                                     = 0,
	Target                                   = 1,
	ECoverFocusType_MAX                      = 2,
};

// Enum Stalker2.ECrosshairAnimationType
// NumValues: 0x0004
enum class ECrosshairAnimationType : uint8
{
	None                                     = 0,
	Show                                     = 1,
	Hidden                                   = 2,
	ECrosshairAnimationType_MAX              = 3,
};

// Enum Stalker2.ECutsceneBlinkProfile
// NumValues: 0x0004
enum class ECutsceneBlinkProfile : uint8
{
	Default                                  = 0,
	NoBlink                                  = 1,
	Frequent                                 = 2,
	ECutsceneBlinkProfile_MAX                = 3,
};

// Enum Stalker2.ECutsceneEyesIdleProfile
// NumValues: 0x0005
enum class ECutsceneEyesIdleProfile : uint8
{
	NoIdle                                   = 0,
	Default                                  = 1,
	Dialog                                   = 2,
	KeepEyesOff                              = 3,
	ECutsceneEyesIdleProfile_MAX             = 4,
};

// Enum Stalker2.EDebugElements
// NumValues: 0x0005
enum class EDebugElements : uint8
{
	MiniMap                                  = 0,
	DataAndTime                              = 1,
	PlayerStats                              = 2,
	Count                                    = 3,
	EDebugElements_MAX                       = 4,
};

// Enum Stalker2.UIWorningType
// NumValues: 0x0003
enum class EUIWorningType : uint8
{
	TextLenght                               = 0,
	TextRow                                  = 1,
	UIWorningType_MAX                        = 2,
};

// Enum Stalker2.EDestructionActionType
// NumValues: 0x000A
enum class EDestructionActionType : uint8
{
	NoActionSelected                         = 0,
	SetNewMesh                               = 1,
	PlayVisualEffect                         = 2,
	PlaySound                                = 3,
	Destroy                                  = 4,
	DisablePhysics                           = 5,
	EnablePhysics                            = 6,
	Explode                                  = 7,
	SpawnItems                               = 8,
	EDestructionActionType_MAX               = 9,
};

// Enum Stalker2.EDialogAnimationCategory
// NumValues: 0x000F
enum class EDialogAnimationCategory : uint8
{
	All                                      = 0,
	Unique                                   = 1,
	WalkieTalkie                             = 2,
	Woman                                    = 3,
	Oldman                                   = 4,
	Idle                                     = 5,
	Wounded                                  = 6,
	Agatha                                   = 7,
	AgathaSmoke                              = 8,
	Harpia                                   = 9,
	Doroznuk                                 = 10,
	Bereza                                   = 11,
	Kalina                                   = 12,
	Drunk                                    = 13,
	EDialogAnimationCategory_MAX             = 14,
};

// Enum Stalker2.EProgressDialogType
// NumValues: 0x0005
enum class EProgressDialogType : uint8
{
	empty                                    = 0,
	Answer                                   = 1,
	Sequence                                 = 4,
	Speech                                   = 8,
	EProgressDialogType_MAX                  = 9,
};

// Enum Stalker2.EDialogEventCategory
// NumValues: 0x0008
enum class EDialogEventCategory : uint8
{
	HitReaction                              = 0,
	NPCInteraction                           = 1,
	Emission                                 = 2,
	Combat                                   = 3,
	PeacefulReaction                         = 4,
	ContextualAction                         = 5,
	GetCount                                 = 6,
	EDialogEventCategory_MAX                 = 7,
};

// Enum Stalker2.EDialogEventType
// NumValues: 0x0042
enum class EDialogEventType : uint8
{
	None                                     = 0,
	HitReaction_InstaDeath                   = 1,
	HitReaction_AgonyDeath                   = 2,
	HitReaction_WheezingDeath                = 3,
	HitReaction_AverageDeath                 = 4,
	HitReaction_CarouselDeath                = 5,
	HitReaction_Bullet                       = 6,
	HitReaction_Explosion                    = 7,
	HitReaction_Mutant                       = 8,
	HitReaction_Anomaly                      = 9,
	HitReaction_Transformation               = 10,
	Emission_LeaderStart                     = 11,
	Emission_LeaderEnd                       = 12,
	DefeatComment                            = 13,
	Combat_Wounded_Knocked                   = 14,
	Combat_Wounded_GoingToHeal               = 15,
	Combat_Wounded_HealingGratitude          = 16,
	Combat_Wounded_Grunt_HealReceive         = 17,
	Combat_EnemySearch                       = 18,
	Combat_EnemyFound                        = 19,
	Combat_SearchEnd                         = 20,
	Combat_Threats_EnemySearch               = 21,
	Combat_Threats_AlertedSearch             = 22,
	Combat_Threats_AlertedSearchEnd          = 23,
	Combat_Threats_ThreatDetected            = 24,
	Combat_Start                             = 25,
	Combat_Over                              = 26,
	Combat_EnemyRetreat                      = 27,
	Combat_SelfRetreat                       = 28,
	Combat_Action_Cover                      = 29,
	Combat_Action_Move                       = 30,
	Combat_Action_Flank                      = 31,
	Combat_Action_Detour                     = 32,
	Combat_Action_EnemyHit                   = 33,
	Combat_Action_FriendlyHit                = 34,
	Combat_Action_FriendlyFire               = 35,
	Combat_Action_Reload                     = 36,
	Combat_Action_FireSupression             = 37,
	Combat_Action_FriendlyGrenade            = 38,
	Combat_Action_EnemyGrenade               = 39,
	Combat_Action_FriendlyDead               = 40,
	Combat_Action_EnemyDead                  = 41,
	Combat_Zombie_Attack                     = 42,
	Combat_Zombie_Moan                       = 43,
	Peaceful_CorpseHubComment                = 44,
	Peaceful_DropCorpse                      = 45,
	Peaceful_LootingEnemyCorpse              = 46,
	Peaceful_LootingFriendlyCorpse           = 47,
	CallPlayer                               = 48,
	Interact_Busy                            = 49,
	Interact_Friendly                        = 50,
	Interact_Neutral                         = 51,
	Interact_NonFriendly                     = 52,
	Interact_Bump                            = 53,
	Interact_HideWeapon                      = 54,
	Interact_SpeakToLeader                   = 55,
	Chatter                                  = 56,
	Relax_EmissionFirstMessage               = 57,
	Relax_EmissionSecondMessage              = 58,
	Relax_EmissionThirdMessage               = 59,
	DialogAction_Laugh                       = 60,
	Joke                                     = 61,
	HitReaction_Melee                        = 62,
	RunOn                                    = 63,
	Count                                    = 64,
	EDialogEventType_MAX                     = 65,
};

// Enum Stalker2.StartSelectFolderType
// NumValues: 0x0003
enum class EStartSelectFolderType : uint8
{
	ToTop                                    = 0,
	ToBottom                                 = 1,
	StartSelectFolderType_MAX                = 2,
};

// Enum Stalker2.EStartDialogType
// NumValues: 0x0004
enum class EStartDialogType : uint8
{
	CanStart                                 = 0,
	CanStartWaitingForContextualAction       = 1,
	CanNotStart                              = 2,
	EStartDialogType_MAX                     = 3,
};

// Enum Stalker2.AnsverSlotPaddingType
// NumValues: 0x0005
enum class EAnsverSlotPaddingType : uint8
{
	None                                     = 0,
	Top                                      = 1,
	Bottom                                   = 2,
	TopAndBottom                             = 3,
	AnsverSlotPaddingType_MAX                = 4,
};

// Enum Stalker2.EDoorState
// NumValues: 0x0006
enum class EDoorState : uint8
{
	Idle                                     = 0,
	Locked                                   = 1,
	Opening                                  = 2,
	StealthOpening                           = 3,
	RestoreInitialState                      = 4,
	EDoorState_MAX                           = 5,
};

// Enum Stalker2.EDoorMoveDirection
// NumValues: 0x0005
enum class EDoorMoveDirection : uint8
{
	CounterClockwise                         = 0,
	None                                     = 1,
	Clockwise                                = 2,
	Stop                                     = 3,
	EDoorMoveDirection_MAX                   = 4,
};

// Enum Stalker2.EDPadClickType
// NumValues: 0x0005
enum class EDPadClickType : uint8
{
	Up                                       = 0,
	Down                                     = 1,
	Right                                    = 2,
	Left                                     = 3,
	EDPadClickType_MAX                       = 4,
};

// Enum Stalker2.EAvoidanceAgentCollisionState
// NumValues: 0x0005
enum class EAvoidanceAgentCollisionState : uint8
{
	None                                     = 0,
	IgnoreUnits                              = 1,
	IgnorePlayer                             = 2,
	IgnoreAll                                = 3,
	EAvoidanceAgentCollisionState_MAX        = 4,
};

// Enum Stalker2.EZeroBoundsFilter
// NumValues: 0x0005
enum class EZeroBoundsFilter : uint8
{
	None                                     = 0,
	OnlyGroupActors                          = 1,
	OnlyPrefabActors                         = 2,
	OnlyStaticMeshActors                     = 3,
	EZeroBoundsFilter_MAX                    = 4,
};

// Enum Stalker2.EPlayerActionInputTypeCustom
// NumValues: 0x0004
enum class EPlayerActionInputTypeCustom : uint8
{
	ToggleOrHold                             = 0,
	HoldOnly                                 = 1,
	ToggleOnly                               = 2,
	EPlayerActionInputTypeCustom_MAX         = 3,
};

// Enum Stalker2.EPlayerActionInputTrigger
// NumValues: 0x000E
enum class EPlayerActionInputTrigger : uint8
{
	None                                     = 0,
	Down                                     = 1,
	Pressed                                  = 2,
	Released                                 = 3,
	Tap                                      = 4,
	Hold                                     = 5,
	HoldAndRelease                           = 6,
	Pulse                                    = 7,
	ChordAction                              = 8,
	ChordBlocker                             = 9,
	TriggerCombo                             = 10,
	HoldWithActivationDelay                  = 11,
	GetCount                                 = 12,
	EPlayerActionInputTrigger_MAX            = 13,
};

// Enum Stalker2.EPlayerActionInputModifier
// NumValues: 0x000A
enum class EPlayerActionInputModifier : uint8
{
	None                                     = 0,
	DeadZone                                 = 1,
	Scalar                                   = 2,
	ScaleByDeltaTime                         = 3,
	SwizzleAxis                              = 4,
	Negate                                   = 5,
	Smooth                                   = 6,
	ResponseCurveExponential                 = 7,
	GetCount                                 = 8,
	EPlayerActionInputModifier_MAX           = 9,
};

// Enum Stalker2.EMusicState
// NumValues: 0x0006
enum class EMusicState : uint8
{
	Region                                   = 0,
	Location                                 = 1,
	NoMusic                                  = 2,
	Combat                                   = 3,
	CombatEnd                                = 4,
	EMusicState_MAX                          = 5,
};

// Enum Stalker2.EGoalPriorityLevel
// NumValues: 0x0004
enum class EGoalPriorityLevel : uint8
{
	ContextDependent                         = 0,
	High                                     = 1,
	Critical                                 = 2,
	EGoalPriorityLevel_MAX                   = 3,
};

// Enum Stalker2.EGameState
// NumValues: 0x000B
enum class EGameState : uint8
{
	Init                                     = 0,
	LoadingInEditor                          = 1,
	Loading                                  = 2,
	Idle                                     = 3,
	EULA                                     = 4,
	FirstTimeSettings                        = 5,
	MainMenu                                 = 6,
	IntroTrailer                             = 7,
	GameplayCutScene                         = 8,
	Game                                     = 9,
	EGameState_MAX                           = 10,
};

// Enum Stalker2.ETriggerShape
// NumValues: 0x0005
enum class ETriggerShape : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
	Cylinder                                 = 2,
	Freeform                                 = 3,
	ETriggerShape_MAX                        = 4,
};

// Enum Stalker2.ECodelockKeyType
// NumValues: 0x0004
enum class ECodelockKeyType : uint32
{
	Digit                                    = 0,
	Enter                                    = 1,
	Cancel                                   = 2,
	ECodelockKeyType_MAX                     = 3,
};

// Enum Stalker2.ECodelockKeyDirectionType
// NumValues: 0x0006
enum class ECodelockKeyDirectionType : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	ECodelockKeyDirectionType_MAX            = 5,
};

// Enum Stalker2.EAllowedValues
// NumValues: 0x0004
enum class EAllowedValues : uint8
{
	Any                                      = 0,
	NonZero                                  = 1,
	PositiveOnly                             = 2,
	EAllowedValues_MAX                       = 3,
};

// Enum Stalker2.EProficiencyLevel
// NumValues: 0x0006
enum class EProficiencyLevel : uint8
{
	Novice                                   = 0,
	Regular                                  = 1,
	Veteran                                  = 2,
	Elite                                    = 3,
	GetCount                                 = 4,
	EProficiencyLevel_MAX                    = 5,
};

// Enum Stalker2.EItemContainerType
// NumValues: 0x000B
enum class EItemContainerType : uint8
{
	None                                     = 0,
	Inventory                                = 1,
	Trader                                   = 2,
	Stash                                    = 3,
	PlayerBuyCart                            = 4,
	PlayerSellCart                           = 5,
	SingleItem                               = 6,
	PackOfItems                              = 7,
	Dummy                                    = 8,
	GetCount                                 = 9,
	EItemContainerType_MAX                   = 10,
};

// Enum Stalker2.EInventoryEquipmentSlot
// NumValues: 0x0011
enum class EInventoryEquipmentSlot : uint8
{
	None                                     = 0,
	PrimaryWeapon                            = 1,
	SecondaryWeapon                          = 2,
	Pistol                                   = 3,
	Detector                                 = 4,
	Head                                     = 5,
	Body                                     = 6,
	Artifact1                                = 7,
	Artifact2                                = 8,
	Artifact3                                = 9,
	Artifact4                                = 10,
	Artifact5                                = 11,
	Knife                                    = 12,
	Bolt                                     = 13,
	Grenade                                  = 14,
	GetCount                                 = 15,
	EInventoryEquipmentSlot_MAX              = 16,
};

// Enum Stalker2.EItemType
// NumValues: 0x000C
enum class EItemType : uint64
{
	None                                     = 18446744073709551615,
	Weapon                                   = 0,
	Armor                                    = 1,
	Artifact                                 = 2,
	Attach                                   = 3,
	Consumable                               = 4,
	Ammo                                     = 5,
	Detector                                 = 6,
	Grenade                                  = 7,
	Other                                    = 8,
	GetCount                                 = 9,
	EItemType_MAX                            = 10,
};

// Enum Stalker2.EEffectDisplayType
// NumValues: 0x0006
enum class EEffectDisplayType : uint8
{
	None                                     = 0,
	Value                                    = 1,
	ValueAndTime                             = 2,
	EffectLevel                              = 3,
	GetCount                                 = 4,
	EEffectDisplayType_MAX                   = 5,
};

// Enum Stalker2.EArchiartifactType
// NumValues: 0x0009
enum class EArchiartifactType : uint8
{
	None                                     = 0,
	Ball                                     = 1,
	Water                                    = 2,
	Flower                                   = 3,
	Bolt                                     = 4,
	Nut                                      = 5,
	Kettle                                   = 6,
	GetCount                                 = 7,
	EArchiartifactType_MAX                   = 8,
};

// Enum Stalker2.EConsumableType
// NumValues: 0x0005
enum class EConsumableType : uint8
{
	None                                     = 0,
	Food                                     = 1,
	Medicine                                 = 2,
	Guitar                                   = 3,
	EConsumableType_MAX                      = 4,
};

// Enum Stalker2.EFlashlightAction
// NumValues: 0x0004
enum class EFlashlightAction : uint8
{
	Disable                                  = 0,
	TurnOff                                  = 1,
	TurnOn                                   = 2,
	EFlashlightAction_MAX                    = 3,
};

// Enum Stalker2.ERightClickMenu
// NumValues: 0x001D
enum class ERightClickMenu : uint8
{
	Use                                      = 0,
	Take                                     = 1,
	TakeAll                                  = 2,
	EquipToArtifactSlot                      = 3,
	Equip                                    = 4,
	Unequip                                  = 5,
	Sell                                     = 6,
	SellAll                                  = 7,
	Buy                                      = 8,
	BuyAll                                   = 9,
	Return                                   = 10,
	UnloadAmmo                               = 11,
	InspectArtifact                          = 12,
	EquipToQuickSlot                         = 13,
	AttachToWeapon                           = 14,
	Remove                                   = 15,
	ReturnAll                                = 16,
	Put                                      = 17,
	PutAll                                   = 18,
	Drop                                     = 19,
	DropAll                                  = 20,
	DetachAttach                             = 21,
	DetachAllAttaches                        = 22,
	Repair                                   = 23,
	RepairAll                                = 24,
	Compare                                  = 25,
	ChangeWeaponAmmo                         = 26,
	GetCount                                 = 27,
	ERightClickMenu_MAX                      = 28,
};

// Enum Stalker2.EAttachedMagazineType
// NumValues: 0x0003
enum class EAttachedMagazineType : uint8
{
	Eject                                    = 0,
	Insert                                   = 1,
	EAttachedMagazineType_MAX                = 2,
};

// Enum Stalker2.EAttachType
// NumValues: 0x000E
enum class EAttachType : uint8
{
	Silencer                                 = 0,
	Muzzle                                   = 1,
	FlashSuppressor                          = 2,
	Scope                                    = 3,
	Grip                                     = 4,
	GrenadeLauncher                          = 5,
	Shotgun                                  = 6,
	WeaponFlashlight                         = 7,
	LaserSight                               = 8,
	Magazine                                 = 9,
	IronSight                                = 10,
	PlankScope                               = 11,
	GetCount                                 = 12,
	EAttachType_MAX                          = 13,
};

// Enum Stalker2.EMagazineMeshType
// NumValues: 0x0005
enum class EMagazineMeshType : uint8
{
	Full                                     = 0,
	Empty                                    = 1,
	RightEmpty                               = 2,
	LeftEmpty                                = 3,
	EMagazineMeshType_MAX                    = 4,
};

// Enum Stalker2.EAttachSlot
// NumValues: 0x000A
enum class EAttachSlot : uint8
{
	None                                     = 0,
	Barrel                                   = 1,
	Scope                                    = 2,
	Handguard                                = 3,
	Magazine                                 = 4,
	PlankScope                               = 5,
	Flashlight                               = 6,
	Lasersight                               = 7,
	GetCount                                 = 8,
	EAttachSlot_MAX                          = 9,
};

// Enum Stalker2.EUpgradeScheme
// NumValues: 0x0003
enum class EUpgradeScheme : uint8
{
	None                                     = 0,
	GetCount                                 = 1,
	EUpgradeScheme_MAX                       = 2,
};

// Enum Stalker2.EFaction
// NumValues: 0x001B
enum class EFaction : uint8
{
	None                                     = 0,
	Bloodsucker                              = 1,
	Boar                                     = 2,
	Beaver                                   = 3,
	Burer                                    = 4,
	Chimera                                  = 5,
	Controller                               = 6,
	Dog                                      = 7,
	Flesh                                    = 8,
	Poltergeist                              = 9,
	Pseudodog                                = 10,
	Pseudogiant                              = 11,
	Snork                                    = 12,
	Tushkan                                  = 13,
	Zombie                                   = 14,
	Bandits                                  = 15,
	Duty                                     = 16,
	Freedom                                  = 17,
	Mercenaries                              = 18,
	Militaries                               = 19,
	Monolith                                 = 20,
	Neutrals                                 = 21,
	Scientists                               = 22,
	Varta                                    = 23,
	Player                                   = 24,
	GetCount                                 = 25,
	EFaction_MAX                             = 26,
};

// Enum Stalker2.EDisplayPriority
// NumValues: 0x0006
enum class EDisplayPriority : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	GetCount                                 = 4,
	EDisplayPriority_MAX                     = 5,
};

// Enum Stalker2.EFactionRelationType
// NumValues: 0x0004
enum class EFactionRelationType : uint8
{
	Neutral                                  = 0,
	Friend                                   = 1,
	Enemy                                    = 2,
	EFactionRelationType_MAX                 = 3,
};

// Enum Stalker2.EUseAbsoluteOrDelta
// NumValues: 0x0004
enum class EUseAbsoluteOrDelta : uint8
{
	Absolute                                 = 0,
	Delta                                    = 1,
	Count                                    = 2,
	EUseAbsoluteOrDelta_MAX                  = 3,
};

// Enum Stalker2.EAffectMembers
// NumValues: 0x0004
enum class EAffectMembers : uint8
{
	NoAffectMembers                          = 0,
	AffectMembers                            = 1,
	Count                                    = 2,
	EAffectMembers_MAX                       = 3,
};

// Enum Stalker2.ESetRelationType
// NumValues: 0x0004
enum class ESetRelationType : uint8
{
	Default                                  = 0,
	Force                                    = 1,
	Count                                    = 2,
	ESetRelationType_MAX                     = 3,
};

// Enum Stalker2.EEffectSource
// NumValues: 0x000A
enum class EEffectSource : uint8
{
	None                                     = 0,
	Obj                                      = 1,
	Armor                                    = 2,
	Weapon                                   = 3,
	Artifact                                 = 4,
	Consumable                               = 5,
	Other                                    = 6,
	Debug                                    = 7,
	GetCount                                 = 8,
	EEffectSource_MAX                        = 9,
};

// Enum Stalker2.EEffectType
// NumValues: 0x0090
enum class EEffectType : uint8
{
	None                                     = 0,
	Accuracy                                 = 1,
	AdditionalInventoryWeight                = 2,
	AddAttachment                            = 3,
	AimingTime                               = 4,
	AimingFOV                                = 5,
	AimingMovementSpeed                      = 6,
	AimingSensitivity                        = 7,
	AmmoCapacity                             = 8,
	AmmoPerShot                              = 9,
	ArmorPiercing                            = 10,
	ArtifactSlots                            = 11,
	ArtifactSlotBlock                        = 12,
	BaseBleeding                             = 13,
	Bleeding                                 = 14,
	BleedingChancePerShot                    = 15,
	CameraShake                              = 16,
	ChangeAmmoTypes                          = 17,
	ChangeCaliber                            = 18,
	ChangeFireTypes                          = 19,
	ChangeFireIntervals                      = 20,
	ChangeWeaponPattern                      = 21,
	Comfort                                  = 22,
	Composite                                = 23,
	Corrosion                                = 24,
	VelocityBleeding                         = 25,
	VelocityCorrosion                        = 26,
	VelocityChange                           = 27,
	VelocityChangeNoCap                      = 28,
	TurnRateChangeYaw                        = 29,
	TurnRateChangePitch                      = 30,
	Damage                                   = 31,
	BaseDamage                               = 32,
	VelocityDamage                           = 33,
	DegenBleeding                            = 34,
	DegenDrunkness                           = 35,
	DegenRadiation                           = 36,
	DegenPsyPoints                           = 37,
	DegenSuppressionPoints                   = 38,
	Dispersion                               = 39,
	Drunkness                                = 40,
	EffectiveFireDistance                    = 41,
	FireInterval                             = 42,
	RecoilInterval                           = 43,
	FireLoudness                             = 44,
	Health                                   = 45,
	WoundedHPOverTime                        = 46,
	InstantHeal                              = 47,
	HungerPoints                             = 48,
	Invulnerability                          = 49,
	WeaponItemWeight                         = 50,
	KnockDown                                = 51,
	KnockDownPlayer                          = 52,
	KnockDownAI                              = 53,
	DragWeapon                               = 54,
	Limp                                     = 55,
	MaxBleeding                              = 56,
	MaxDurability                            = 57,
	MaxHungerPoints                          = 58,
	MaxHealth                                = 59,
	MaxRadiation                             = 60,
	MaxStamina                               = 61,
	MaxThirstPoints                          = 62,
	MaxSleepinessPoints                      = 63,
	MaxDrunkness                             = 64,
	MaxSuppressionPoints                     = 65,
	MovementSpeed                            = 66,
	OpenSlotForAttachments                   = 67,
	PenaltyLessWeight                        = 68,
	PercentDamage                            = 69,
	ProtectionStrike                         = 70,
	ProtectionBurn                           = 71,
	ProtectionShock                          = 72,
	ProtectionChemical                       = 73,
	ProtectionRadiation                      = 74,
	ProtectionPSY                            = 75,
	ProtectionFall                           = 76,
	PsyPoints                                = 77,
	Radiation                                = 78,
	Recoil                                   = 79,
	RegenHealth                              = 80,
	RegenHungerPoints                        = 81,
	RegenSleepinessPoints                    = 82,
	RegenStamina                             = 83,
	RegenThirstPoints                        = 84,
	ReloadingTime                            = 85,
	SleepinessPoints                         = 86,
	SoundEffect                              = 87,
	Stamina                                  = 88,
	StealthReveal                            = 89,
	ThirstPoints                             = 90,
	SuppressionPoints                        = 91,
	BlockAnimationActionType                 = 92,
	BulletSpeedSlowdown                      = 93,
	SpawnPsyPhantoms                         = 94,
	PsyZombification                         = 95,
	Concussion                               = 96,
	PostProcessing                           = 97,
	InputDelay                               = 98,
	InputAxisMultiplier                      = 99,
	InputInertia2DAxis                       = 100,
	PoppyFieldSleepiness                     = 101,
	PoppyFieldRegenSleepiness                = 102,
	AutoDepletionEffect                      = 103,
	MechanicsEffect                          = 104,
	FlagEffect                               = 105,
	AI_Confusion                             = 106,
	ShowEquipmentTime                        = 107,
	HideEquipmentTime                        = 108,
	FractionCount                            = 109,
	IdleSwayXModifier                        = 110,
	IdleSwayYModifier                        = 111,
	IdleSwayTimeModifier                     = 112,
	SPDrain                                  = 113,
	HoldBreathDrain                          = 114,
	FireDistanceRecoil                       = 115,
	FireDistanceDispersion                   = 116,
	ForceFlashlightState                     = 117,
	InstantDeath                             = 118,
	Teleport                                 = 119,
	BlockInput                               = 120,
	BlockingSwap                             = 121,
	OverDrunkness                            = 122,
	MaxOverDrunkness                         = 123,
	HideCurrentItem                          = 124,
	EquipLastItem                            = 125,
	DurabilityDamagePerShot                  = 126,
	DispersionAimModifier                    = 127,
	BulletDropLength                         = 128,
	DistanceDropOffLength                    = 129,
	MinBulletDistanceDamage                  = 130,
	MinBulletDistanceArmorPiercing           = 131,
	DispersionMaxRadiusExtension             = 132,
	DispersionPerIterationRadiusExtension    = 133,
	RecoilRadiusNormalizationInterval        = 134,
	FlairDistanceModifier                    = 135,
	RegenHealthModifier                      = 136,
	ForceFeedback                            = 137,
	Conditional                              = 138,
	ShowPDATime                              = 139,
	ArmorItemWeight                          = 140,
	CoverPiercing                            = 141,
	GetCount                                 = 142,
	EEffectType_MAX                          = 143,
};

// Enum Stalker2.EGSCTeleportType
// NumValues: 0x0007
enum class EGSCTeleportType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Classic                                  = 2,
	Immersive                                = 3,
	Instant                                  = 4,
	Quest                                    = 5,
	EGSCTeleportType_MAX                     = 6,
};

// Enum Stalker2.EShootingRadiusType
// NumValues: 0x0005
enum class EShootingRadiusType : uint8
{
	None                                     = 0,
	RecoilRadius                             = 1,
	DispersionRadius                         = 2,
	DispersionRadiusAI                       = 4,
	EShootingRadiusType_MAX                  = 5,
};

// Enum Stalker2.ELoadingDestination
// NumValues: 0x000C
enum class ELoadingDestination : uint8
{
	None                                     = 0,
	MainMenu                                 = 1,
	NewGame                                  = 2,
	LoadGame                                 = 3,
	FastTravel                               = 4,
	BridgeBetweenCutscenes                   = 5,
	Teleport                                 = 6,
	QuestTeleport                            = 7,
	IntroductionLogo                         = 8,
	DefaultTeleport                          = 9,
	WhiteBridgeBetweenCutscenes              = 10,
	ELoadingDestination_MAX                  = 11,
};

// Enum Stalker2.EObjType
// NumValues: 0x001D
enum class EObjType : uint8
{
	NPC                                      = 0,
	Anomaly                                  = 1,
	AnomalySpawner                           = 2,
	ArtifactSpawner                          = 3,
	Marker                                   = 4,
	Squad                                    = 5,
	Item                                     = 6,
	ItemContainer                            = 7,
	Grenade                                  = 8,
	Lair                                     = 9,
	ContextualAction                         = 10,
	Zone                                     = 11,
	DestructibleObject                       = 12,
	Patrol                                   = 13,
	Searchpoint                              = 14,
	Door                                     = 15,
	InteractableObject                       = 16,
	Bed                                      = 17,
	ALifeScenarioModel                       = 18,
	WanderingLights                          = 19,
	VortexArchAnomaly                        = 20,
	VolumeForEffects                         = 21,
	MistArchianomaly                         = 22,
	PoppyFieldArchanomaly                    = 23,
	FireBreathArchAnomaly                    = 24,
	BulbArchAnomaly                          = 25,
	Invalid                                  = 26,
	GetCount                                 = 26,
	EObjType_MAX                             = 27,
};

// Enum Stalker2.EValveState
// NumValues: 0x0004
enum class EValveState : uint8
{
	OpenInFirst                              = 0,
	OpenIn                                   = 1,
	CloseIn                                  = 2,
	EValveState_MAX                          = 3,
};

// Enum Stalker2.EVoiceCommand
// NumValues: 0x0017
enum class EVoiceCommand : uint8
{
	None                                     = 0,
	AttackLaunch                             = 1,
	AttackLaunchAgainstPlayer                = 2,
	BattleRoar                               = 3,
	BattleRoarAgainstPlayer                  = 4,
	RequestCoverFire                         = 5,
	RequestFlank                             = 6,
	Wounded                                  = 7,
	DeathRattle                              = 8,
	EnemyKilled                              = 9,
	EnemyCriticalHit                         = 10,
	EnemyLost                                = 11,
	EnemySearching                           = 12,
	EnemyDetected                            = 13,
	EnemyNearby                              = 14,
	EnemyFarAway                             = 15,
	FriendDeath                              = 16,
	FriendCriticalHit                        = 17,
	FriendlyFire                             = 18,
	GrenadeNearby                            = 19,
	GrenadeThrowRequest                      = 20,
	Reloading                                = 21,
	EVoiceCommand_MAX                        = 22,
};

// Enum Stalker2.ESpeechRequestMode
// NumValues: 0x0005
enum class ESpeechRequestMode : uint8
{
	Flexible                                 = 0,
	Forced                                   = 1,
	Queued                                   = 2,
	GetCount                                 = 3,
	ESpeechRequestMode_MAX                   = 4,
};

// Enum Stalker2.EBeneficial
// NumValues: 0x0005
enum class EBeneficial : uint8
{
	None                                     = 0,
	Positive                                 = 1,
	Negative                                 = 2,
	GetCount                                 = 3,
	EBeneficial_MAX                          = 4,
};

// Enum Stalker2.EEffectLevel
// NumValues: 0x0007
enum class EEffectLevel : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Medium                                   = 2,
	Strong                                   = 3,
	Max                                      = 4,
	VeryLow                                  = 5,
	Count                                    = 6,
};

// Enum Stalker2.EWeaponType
// NumValues: 0x0006
enum class EWeaponType : uint8
{
	None                                     = 0,
	Pistol                                   = 1,
	Rifle                                    = 2,
	Shotgun                                  = 3,
	GetCount                                 = 4,
	EWeaponType_MAX                          = 5,
};

// Enum Stalker2.EAnomalyElementType
// NumValues: 0x0008
enum class EAnomalyElementType : uint8
{
	None                                     = 0,
	Gravity                                  = 1,
	Electro                                  = 2,
	Fire                                     = 3,
	Chemical                                 = 4,
	PSY                                      = 5,
	GetCount                                 = 6,
	EAnomalyElementType_MAX                  = 7,
};

// Enum Stalker2.EAnomalyType
// NumValues: 0x0014
enum class EAnomalyType : uint8
{
	None                                     = 0,
	CarouselAnomaly                          = 1,
	ChemicalAnomaly                          = 2,
	ClassicFireAnomaly                       = 3,
	ClickerAnomaly                           = 4,
	DiamondAnomaly                           = 5,
	ElectroAnomaly                           = 6,
	ExpulsionAnomaly                         = 7,
	FlycatcherAnomaly                        = 8,
	RazorAnomaly                             = 9,
	LavaLampAnomaly                          = 10,
	LightningBallAnomaly                     = 11,
	PillowAnomaly                            = 12,
	PSYAnomaly                               = 13,
	PSYEmitterAnomaly                        = 14,
	PSYControllerAnomaly                     = 15,
	SoapBubbleAnomaly                        = 16,
	ToxicCloudAnomaly                        = 17,
	GetCount                                 = 18,
	EAnomalyType_MAX                         = 19,
};

// Enum Stalker2.EAnomalyActiveState
// NumValues: 0x0003
enum class EAnomalyActiveState : uint8
{
	Active                                   = 0,
	Idle                                     = 1,
	EAnomalyActiveState_MAX                  = 2,
};

// Enum Stalker2.EAnomalyVisualization
// NumValues: 0x0003
enum class EAnomalyVisualization : uint8
{
	Shape                                    = 0,
	VFX                                      = 1,
	EAnomalyVisualization_MAX                = 2,
};

// Enum Stalker2.EPillowAnomalyBiomeType
// NumValues: 0x0008
enum class EPillowAnomalyBiomeType : uint8
{
	None                                     = 0,
	Rock                                     = 1,
	Forest                                   = 2,
	Urban                                    = 3,
	RedForest                                = 4,
	Industrial                               = 5,
	Paper                                    = 6,
	EPillowAnomalyBiomeType_MAX              = 7,
};

// Enum Stalker2.ECauseOfDeath
// NumValues: 0x0017
enum class ECauseOfDeath : uint8
{
	None                                     = 0,
	Range                                    = 1,
	Puncture                                 = 2,
	Bite                                     = 3,
	Explosive                                = 4,
	Burn                                     = 5,
	ChemicalBurn                             = 6,
	Shock                                    = 7,
	Gravity                                  = 8,
	CarouselAnomaly                          = 9,
	Emission                                 = 10,
	Zombification                            = 11,
	PsyPhantomDeath                          = 12,
	HeadShot                                 = 13,
	KnifeCritical                            = 14,
	DeadOnSpawn                              = 15,
	Killed                                   = 16,
	Drowned                                  = 17,
	SpawnedCorpseNoNPCCollision              = 18,
	Quest                                    = 19,
	PSY                                      = 20,
	Radiation                                = 21,
	ECauseOfDeath_MAX                        = 22,
};

// Enum Stalker2.ETooltipItemCategory
// NumValues: 0x0006
enum class ETooltipItemCategory : uint8
{
	Armor                                    = 0,
	Weapon                                   = 1,
	Consumable                               = 2,
	Artifact                                 = 3,
	GetCount                                 = 4,
	ETooltipItemCategory_MAX                 = 5,
};

// Enum Stalker2.EProjectilePropagation
// NumValues: 0x0009
enum class EProjectilePropagation : uint8
{
	None                                     = 0,
	FlyFixedAngle                            = 1,
	FlyFixedSpeed                            = 2,
	FlyFixedPoint                            = 3,
	FlyFixedDirection                        = 4,
	FollowTarget                             = 5,
	FlyRandomDirection                       = 6,
	GetCount                                 = 7,
	EProjectilePropagation_MAX               = 8,
};

// Enum Stalker2.EDetectorType
// NumValues: 0x0008
enum class EDetectorType : uint8
{
	None                                     = 0,
	Standard                                 = 1,
	Echo                                     = 2,
	Bear                                     = 3,
	Gilka                                    = 4,
	Veles                                    = 5,
	GetCount                                 = 6,
	EDetectorType_MAX                        = 7,
};

// Enum Stalker2.EAttackActionType
// NumValues: 0x000B
enum class EAttackActionType : uint8
{
	None                                     = 0,
	Shoot                                    = 1,
	Melee                                    = 2,
	Throw                                    = 3,
	Reload                                   = 4,
	Jam                                      = 5,
	Idle                                     = 6,
	Attach                                   = 7,
	ChargeGrenade                            = 8,
	GetCount                                 = 9,
	EAttackActionType_MAX                    = 10,
};

// Enum Stalker2.EJamType
// NumValues: 0x0004
enum class EJamType : uint8
{
	Jam                                      = 0,
	Misfire                                  = 1,
	FirstShotMisfire                         = 2,
	EJamType_MAX                             = 3,
};

// Enum Stalker2.EJamStateTag
// NumValues: 0x0007
enum class EJamStateTag : uint8
{
	None                                     = 0,
	WeaponJammed                             = 1,
	WasJammed                                = 2,
	WasReloaded                              = 4,
	JamNextShot                              = 8,
	GetCount                                 = 9,
	EJamStateTag_MAX                         = 10,
};

// Enum Stalker2.EProjectileMesh
// NumValues: 0x0005
enum class EProjectileMesh : uint8
{
	None                                     = 0,
	Building                                 = 1,
	Barrel                                   = 2,
	GetCount                                 = 3,
	EProjectileMesh_MAX                      = 4,
};

// Enum Stalker2.EItemContainerMesh
// NumValues: 0x0004
enum class EItemContainerMesh : uint8
{
	None                                     = 0,
	Box                                      = 1,
	GetCount                                 = 2,
	EItemContainerMesh_MAX                   = 3,
};

// Enum Stalker2.EProjectileBlueprint
// NumValues: 0x0005
enum class EProjectileBlueprint : uint8
{
	None                                     = 0,
	MM768                                    = 1,
	MM556                                    = 2,
	GetCount                                 = 3,
	EProjectileBlueprint_MAX                 = 4,
};

// Enum Stalker2.ECurrentActiveWeapon
// NumValues: 0x0005
enum class ECurrentActiveWeapon : uint8
{
	None                                     = 0,
	Primary                                  = 1,
	Secondary                                = 2,
	GetCount                                 = 3,
	ECurrentActiveWeapon_MAX                 = 4,
};

// Enum Stalker2.EFireType
// NumValues: 0x0007
enum class EFireType : uint8
{
	None                                     = 0,
	SemiAutomatic                            = 1,
	Queue                                    = 2,
	Automatic                                = 3,
	Dualshot                                 = 4,
	GetCount                                 = 5,
	EFireType_MAX                            = 6,
};

// Enum Stalker2.EObjMesh
// NumValues: 0x0004
enum class EObjMesh : uint8
{
	None                                     = 0,
	Actor                                    = 1,
	GetCount                                 = 2,
	EObjMesh_MAX                             = 3,
};

// Enum Stalker2.EObjAnim
// NumValues: 0x0004
enum class EObjAnim : uint8
{
	None                                     = 0,
	Actor                                    = 1,
	GetCount                                 = 2,
	EObjAnim_MAX                             = 3,
};

// Enum Stalker2.EItemGenerationCategory
// NumValues: 0x0010
enum class EItemGenerationCategory : uint32
{
	None                                     = 0,
	Ammo                                     = 1,
	Artifact                                 = 2,
	Attach                                   = 3,
	BodyArmor                                = 4,
	Consumable                               = 5,
	Detector                                 = 6,
	Head                                     = 7,
	Junk                                     = 8,
	Mask                                     = 9,
	SubItemGenerator                         = 10,
	WeaponPistol                             = 11,
	WeaponPrimary                            = 12,
	WeaponSecondary                          = 13,
	GetCount                                 = 14,
	EItemGenerationCategory_MAX              = 15,
};

// Enum Stalker2.EUpdateGeneration
// NumValues: 0x0007
enum class EUpdateGeneration : uint8
{
	None                                     = 0,
	Reputation                               = 1,
	Time                                     = 2,
	TimeDays                                 = 4,
	Rank                                     = 8,
	Difficulty                               = 16,
	EUpdateGeneration_MAX                    = 17,
};

// Enum Stalker2.EWeaponGenerationFlags
// NumValues: 0x000A
enum class EWeaponGenerationFlags : uint8
{
	None                                     = 0,
	RequireMagazineAmmo                      = 1,
	RequireAdditionalAmmo                    = 2,
	RequireWeapon                            = 4,
	WithoutLoadedAmmo                        = 8,
	RequireAllAmmo                           = 3,
	RequireAll                               = 7,
	RequireWeaponWithMagazine                = 5,
	RequireWeaponWithAdditionalAmmo          = 6,
	EWeaponGenerationFlags_MAX               = 9,
};

// Enum Stalker2.EJournalQuestRewardCategory
// NumValues: 0x000E
enum class EJournalQuestRewardCategory : uint8
{
	None                                     = 0,
	Ammunition                               = 1,
	Artifact                                 = 2,
	Attach                                   = 3,
	BodyArmor                                = 4,
	Medicine                                 = 5,
	Detector                                 = 6,
	Food                                     = 7,
	Helmet                                   = 8,
	Money                                    = 9,
	Weapon                                   = 10,
	Other                                    = 11,
	GetCount                                 = 12,
	EJournalQuestRewardCategory_MAX          = 13,
};

// Enum Stalker2.ESignificanceFlags
// NumValues: 0x0006
enum class ESignificanceFlags : uint8
{
	None                                     = 0,
	Distance                                 = 1,
	LastRender                               = 2,
	ScreenSize                               = 4,
	GetCount                                 = 5,
	ESignificanceFlags_MAX                   = 6,
};

// Enum Stalker2.EMainHandEquipmentType
// NumValues: 0x000A
enum class EMainHandEquipmentType : uint8
{
	None                                     = 0,
	Pistol                                   = 1,
	PrimaryWeapon                            = 2,
	SecondaryWeapon                          = 3,
	Knife                                    = 4,
	Grenade                                  = 5,
	Bolt                                     = 6,
	Item                                     = 7,
	GetCount                                 = 8,
	EMainHandEquipmentType_MAX               = 9,
};

// Enum Stalker2.EItemInHandType
// NumValues: 0x0006
enum class EItemInHandType : uint8
{
	None                                     = 0,
	Guitar                                   = 1,
	Consumable                               = 2,
	Grenade                                  = 3,
	AdditionalItem                           = 4,
	EItemInHandType_MAX                      = 5,
};

// Enum Stalker2.EGrenadeType
// NumValues: 0x0007
enum class EGrenadeType : uint64
{
	None                                     = 18446744073709551615,
	RGD5                                     = 0,
	F1                                       = 1,
	Molotov                                  = 2,
	Dynamite                                 = 3,
	GetCount                                 = 4,
	EGrenadeType_MAX                         = 5,
};

// Enum Stalker2.EWeaponFireResult
// NumValues: 0x0007
enum class EWeaponFireResult : uint8
{
	None                                     = 0,
	Fired                                    = 1,
	NotEnoughAmmo                            = 2,
	Jammed                                   = 3,
	Interrupted                              = 4,
	GetCount                                 = 5,
	EWeaponFireResult_MAX                    = 6,
};

// Enum Stalker2.EShootingAvailability
// NumValues: 0x000B
enum class EShootingAvailability : uint8
{
	None                                     = 0,
	Available                                = 1,
	Blocked                                  = 2,
	NoAmmoLoaded                             = 3,
	NoAmmo                                   = 4,
	Jammed                                   = 5,
	NoWeapon                                 = 6,
	NoInventory                              = 7,
	ShootingCooldown                         = 8,
	GetCount                                 = 9,
	EShootingAvailability_MAX                = 10,
};

// Enum Stalker2.EReloadingCases
// NumValues: 0x0004
enum class EReloadingCases : uint8
{
	None                                     = 0,
	PerBullet                                = 1,
	Unload                                   = 2,
	EReloadingCases_MAX                      = 3,
};

// Enum Stalker2.EBoltActionWeaponState
// NumValues: 0x0004
enum class EBoltActionWeaponState : uint8
{
	NotBolted                                = 0,
	ReadyToShoot                             = 1,
	NoBoltAction                             = 2,
	EBoltActionWeaponState_MAX               = 3,
};

// Enum Stalker2.EAssetType
// NumValues: 0x0030
enum class EAssetType : uint8
{
	None                                     = 0,
	DynamicReloadAsset                       = 1,
	Blueprint                                = 2,
	AnomalyBlueprint                         = 3,
	ArtifactBlueprint                        = 4,
	BoltBlueprint                            = 5,
	CharacterBlueprint                       = 6,
	ProjectileBlueprint                      = 7,
	InteractableBlueprint                    = 8,
	UIWidgetBlueprint                        = 9,
	GrenadeBlueprint                         = 10,
	StaticMesh                               = 11,
	SkeletalMesh                             = 12,
	BaseWeaponAnimationBlueprints            = 13,
	AnimSequence                             = 14,
	AnimMontage                              = 15,
	Material                                 = 16,
	MaterialInstanceConstant                 = 17,
	ItemIcons                                = 18,
	UIIcons                                  = 19,
	Markers                                  = 20,
	UpgradeIcons                             = 21,
	Texture2D                                = 22,
	CurveFloat                               = 23,
	CurveLinearColor                         = 24,
	CameraShake                              = 25,
	WeaponCameraShake                        = 26,
	WeaponParticles                          = 27,
	ProjectileParticles                      = 28,
	ProjectileDecals                         = 29,
	WeaponMaterials                          = 30,
	CurveLinearColorAtlas                    = 31,
	MaterialParameterCollection              = 32,
	ParticleSystems                          = 33,
	NiagaraParticleSystem                    = 34,
	TrueSkySequenceAsset                     = 35,
	GroomAsset                               = 36,
	GroomBindingAsset                        = 37,
	GroomMaterials                           = 38,
	AkAudioEvent                             = 39,
	AkAudioParameter                         = 40,
	AkAudioSwitchValue                       = 41,
	AkAudioStateValue                        = 42,
	AkAudioAuxBus                            = 43,
	InputAction                              = 44,
	InputMappingContext                      = 45,
	GetCount                                 = 46,
	EAssetType_MAX                           = 47,
};

// Enum Stalker2.EAsyncLoadPriority
// NumValues: 0x0004
enum class EAsyncLoadPriority : uint8
{
	Default                                  = 0,
	High                                     = 50,
	Maximum                                  = 100,
	EAsyncLoadPriority_MAX                   = 101,
};

// Enum Stalker2.EUpgradeAvailability
// NumValues: 0x000A
enum class EUpgradeAvailability : uint8
{
	Unavailable                              = 0,
	Available                                = 1,
	Purchased                                = 2,
	Blocked                                  = 3,
	BlockedHidden                            = 4,
	PurchasedModuleOn                        = 5,
	PurchasedModuleOff                       = 6,
	LastUpdate                               = 7,
	GetCount                                 = 8,
	EUpgradeAvailability_MAX                 = 9,
};

// Enum Stalker2.EOverweightLock
// NumValues: 0x0004
enum class EOverweightLock : uint8
{
	NoLock                                   = 0,
	Partial                                  = 1,
	Full                                     = 2,
	EOverweightLock_MAX                      = 3,
};

// Enum Stalker2.EDialogAction
// NumValues: 0x0020
enum class EDialogAction : uint32
{
	None                                     = 0,
	TerminateDialog                          = 1,
	TimedAnswer                              = 2,
	FastTravel                               = 4,
	OpenTradeMenu                            = 8,
	OpenUpgradeMenu                          = 16,
	Heal                                     = 32,
	Bribe                                    = 64,
	GetMoney                                 = 128,
	ShowMoney                                = 256,
	Attack                                   = 512,
	Hit                                      = 1024,
	GiveMedkit                               = 2048,
	Bye                                      = 4096,
	ShowItem                                 = 8192,
	RankCheck                                = 16384,
	FactionRelationshipCheck                 = 32768,
	GiveItem                                 = 65536,
	GetItem                                  = 131072,
	Guide                                    = 262144,
	GuideUI                                  = 524288,
	GuideSelection                           = 1048576,
	Threat                                   = 2097152,
	Eat                                      = 4194304,
	Drink                                    = 8388608,
	SideQuest                                = 16777216,
	Reward                                   = 33554432,
	SetGlobalVariable                        = 67108864,
	Laugh                                    = 134217728,
	VisibleAsUILabel                         = 66844668,
	LastPhraseAction                         = 147062784,
	EDialogAction_MAX                        = 147062785,
};

// Enum Stalker2.EDialogEndType
// NumValues: 0x0005
enum class EDialogEndType : uint8
{
	None                                     = 0,
	CloseUI                                  = 1,
	ReturnToTopicSelection                   = 2,
	GetCount                                 = 3,
	EDialogEndType_MAX                       = 4,
};

// Enum Stalker2.EDialogAnswerColor
// NumValues: 0x000A
enum class EDialogAnswerColor : uint8
{
	MainRead                                 = 0,
	MainUnread                               = 1,
	MainHover                                = 2,
	CommonRead                               = 3,
	CommonUnread                             = 4,
	CommonUnavailable                        = 5,
	MainUnavailable                          = 6,
	CommonHover                              = 7,
	DangerUnread                             = 8,
	EDialogAnswerColor_MAX                   = 9,
};

// Enum Stalker2.EEmotionalDialogState
// NumValues: 0x0004
enum class EEmotionalDialogState : uint8
{
	Talking                                  = 0,
	ListeningWaiting                         = 1,
	Unique                                   = 2,
	EEmotionalDialogState_MAX                = 3,
};

// Enum Stalker2.EDialogAnimationType
// NumValues: 0x0102
enum class EDialogAnimationType : uint64
{
	Idle                                     = 0,
	NPCApprovalTalkingUsual                  = 1,
	NPCApprovalTalkingExpressive             = 2,
	NPCApprovalListeningStiff                = 3,
	NPCApprovalListeningUsual                = 4,
	NPCCallTalkingUsual                      = 5,
	NPCCallTalkingExpressive                 = 6,
	NPCGreetingTalkingUsual1                 = 7,
	NPCGreetingTalkingUsual2                 = 8,
	NPCGreetingTalkingStiff                  = 9,
	NPCGreetingTalkingExpressive             = 10,
	NPCFarewellTalkingStiff                  = 11,
	NPCFarewellTalkingUsual                  = 12,
	NPCFarewellTalkingExpressive             = 13,
	NPCDisapprovalTalkingStiff1              = 14,
	NPCDisapprovalTalkingStiff2              = 15,
	NPCDisapprovalTalkingUsual               = 16,
	NPCDisapprovalTalkingUsual2              = 17,
	NPCDisapprovalTalkingExpressive          = 18,
	NPCDisapprovalListeningUsual1            = 19,
	NPCDisapprovalListeningUsual2            = 20,
	NPCDisapprovalListeningUsual3            = 21,
	NPCDisapprovalListeningExpressive        = 22,
	NPCReconcillationTalkingUsual            = 23,
	NPCReconcillationTalkingExpressive       = 24,
	NPCSalute                                = 25,
	NPCUsePDA                                = 26,
	NPCHandToForehead                        = 27,
	NPCAllInPosition                         = 28,
	NPCQuietly                               = 29,
	NPCFacepalm                              = 30,
	NPCPointPlayer                           = 31,
	NPCPointHimself                          = 32,
	NPCPointBack                             = 33,
	NPCGive                                  = 34,
	NPCPsyVoices                             = 35,
	NPCFeelingSick                           = 36,
	SidorovichNotebook                       = 37,
	TalkWalkieTalkie_E07_MQ01                = 38,
	TalkWalkieTalkie_E07_MQ02                = 39,
	TalkWalkieTalkie_SQ13                    = 40,
	TalkWalkieTalkie_E05_MQ01                = 41,
	TalkWalkieTalkie_E05_MQ04                = 42,
	TalkWalkieTalkie_E05_MQ05                = 43,
	TalkWalkieTalkie_E02_SQ01                = 44,
	TalkWalkieTalkie_E08_MQ03                = 45,
	TalkWalkieTalkie_E08_MQ04                = 46,
	TalkWalkieTalkie_E06_MQ02                = 47,
	TalkWalkieTalkie_E14_MQ01                = 48,
	TalkWalkieTalkie_E03_MQ01                = 49,
	TalkWalkieTalkie_E03_MQ06                = 50,
	TalkWalkieTalkie_E05_SQ01_1              = 51,
	TalkWalkieTalkie_E05_SQ01_2              = 52,
	TalkWalkieTalkie_E11_MQ01                = 53,
	TalkWalkieTalkie_SQ18                    = 54,
	TalkWalkieTalkie_E14_MQ02                = 55,
	TalkWalkieTalkie_E08_MQ05                = 56,
	TalkWalkieTalkie_E07_MQ01_2              = 57,
	TalkWalkieTalkie_E06_MQ01_1              = 58,
	TalkWalkieTalkie_E06_MQ01_2              = 59,
	TalkWalkieTalkie_E06_MQ01_3              = 60,
	NPCDisapprovalTalkingStiff3              = 61,
	NPCAngerTalkingUsual_NEW                 = 62,
	NPCArquingTreatExpressiveLong_NEW        = 63,
	NPCDisapprovalListeningBusyUsual_NEW     = 64,
	NPCApprovalListeningStiff1_NEW           = 65,
	NPCApprovalTalkingExpressive1_NEW        = 66,
	NPCCallTalkingUsual2_NEW                 = 67,
	NPCPointdown_NEW                         = 68,
	NPCArguingArmsExpressive                 = 69,
	NPCArguingQuestionExpressive             = 70,
	NPCAngerTalkingExpressive                = 71,
	NPCDisapprovalThreatExpressive1          = 72,
	NPCDisapprovalThreatExpressive2          = 73,
	NPCDisapprovalDoubtStiff                 = 74,
	NPCDisapprovalDoubtExpressive            = 75,
	NPCScaredTalkingStiff1                   = 76,
	NPCScaredTalkingStiff2                   = 77,
	NPCScaredTalkingUsual                    = 78,
	NPCThinkingStiff                         = 79,
	NPCDisappointmentWaveStiff               = 80,
	NPCDisappointmentTalkingExpressive       = 81,
	NPCReconciliationTalkingStiff            = 82,
	NPCReconciliationTalkingUsual            = 83,
	NPCIdleTalkingExpressive                 = 84,
	NPCIdleTalkingStiff1                     = 85,
	NPCIdleTalkingStiff2                     = 86,
	NPCIdleTalkingStiff3                     = 87,
	NPCIdleTalkingUsual1                     = 88,
	NPCIdleTalkingUsual2                     = 89,
	NPCIdleTalkingUsual3                     = 90,
	NPCIdleTalkingUsual4                     = 91,
	NPCIdleTalkingUsual5                     = 92,
	NPCIdleTalkingUsual6                     = 93,
	NPCIdleTalkingHeadswayStiff              = 94,
	NPCIdleTalkingExpressive2                = 95,
	NPCIdleTalkingExpressive1                = 96,
	NPCIdleTalkingArmsUsual                  = 97,
	NPCIdleWaitingUsual1                     = 98,
	NPCIdleWaitingUsual2                     = 99,
	NPCIdleWaitingExpressive2                = 100,
	NPCIdleListeningUsual3                   = 101,
	NPCIdleListeningUsual4                   = 102,
	TalkWalkieTalkie_E03_MQ1_2               = 103,
	TalkWalkieTalkie_E03_MQ1_3               = 104,
	TalkWalkieTalkie_E11_MQ1_1               = 105,
	TalkWalkieTalkie_E11_MQ1_2               = 106,
	TalkWalkieTalkie_E14_MQ1_2               = 107,
	TalkWalkieTalkie_E14_MQ1_3               = 108,
	TalkWalkieTalkie_E03_MQ03_1              = 109,
	TalkWalkieTalkie_E03_MQ03_2              = 110,
	NPCIdleListeningUsual1                   = 111,
	NPCIdleListeningUsual2                   = 112,
	NPCGive2                                 = 113,
	NPCTake1                                 = 114,
	NPCIdleWaitingCrossedArms                = 115,
	NPCIdleWaitingHand                       = 116,
	NPCPSYListeningVoicesExpressive1         = 117,
	NPCPSYListeningVoicesExpressive2         = 118,
	NPCDrinkToast                            = 119,
	NPCDrinkPills                            = 120,
	DalinReaction                            = 121,
	StriderTouchneck                         = 122,
	NPCIdleWaitingStomachHands               = 123,
	NPCIdleTalkingCrossedArmRight            = 124,
	NPCIdleTalkingSpreadHands                = 125,
	NPCWoundedArmLeft                        = 126,
	NPCWoundedArmRight                       = 127,
	NPCWoundedDisappointment                 = 128,
	NPCWoundedGratitude                      = 129,
	NPCWoundedSorry                          = 130,
	AgathaWaitingHeadtiltUsual               = 131,
	AgathaNodUsual                           = 132,
	AgathaIdleListeningStiff1                = 133,
	AgathaIdleListeningStiff2                = 134,
	AgathaIdleListeningStiff3                = 135,
	AgathaIdleTalkingStiff1                  = 136,
	AgathaIdleTalkingStiff2                  = 137,
	AgathaIdleTalkingStiff3                  = 138,
	AgathaSmokeIdleListeningStiff2           = 139,
	AgathaSmokeIdleListeningStiff3           = 140,
	AgathaSmokeIdleListeningStiff4           = 141,
	AgathaSmokeIdleListeningStiff5           = 142,
	AgathaSmokeIdleTalkingStiff1             = 143,
	AgathaSmokeIdleTalkingStiff2             = 144,
	AgathaSmokeIdleTalkingStiff3             = 145,
	AgathaSmokeIdleTalkingStiff4             = 146,
	AgathaSmokeIdleTalkingStiff5             = 147,
	AgathaSmokeUniqueSmoking1                = 148,
	AgathaSmokeUniqueSmoking2                = 149,
	AgathaSmokeNodUsual1                     = 150,
	AgathaSmokeNodUsual2                     = 151,
	AgathaSmokeWaitingHeadtiltUsual          = 152,
	HarpiaIdleTalkingUsual1                  = 153,
	HarpiaIdleTalkingUsual2                  = 154,
	HarpiaIdleListeningUsual                 = 155,
	HarpiaIdleListeningStiff1                = 156,
	HarpiaIdleListeningStiff2                = 157,
	HarpiaIdleTalkingArmOnGunUsual           = 158,
	HarpiaNodExpressive                      = 159,
	HarpiaArguaingArmOnGunExpressive         = 160,
	HarpiaTalkingLongUsual                   = 161,
	HarpiaAruingBadReputationExpressive      = 162,
	HarpiaIdleWaiting1                       = 163,
	HarpiaIdleWaiting2                       = 164,
	DoroznukIdleTalkingUsual                 = 165,
	DoroznukIdleListeningUsual1              = 166,
	DoroznukIdleListeningUsual2              = 167,
	DoroznukTalkingPointdown                 = 168,
	DoroznukTalkingFingerExpressive          = 169,
	DoroznukTalkingUsual1                    = 170,
	DoroznukTalkingUsual2                    = 171,
	DoroznukTalkingDoubt                     = 172,
	DoroznukTalkingAgree                     = 173,
	DoroznukTalkingExpressive                = 174,
	DoroznukTalkingHandWave                  = 175,
	DoroznukTalkingNegative                  = 176,
	DoroznukTalkingHead                      = 177,
	DoroznukIdleWaitingHand                  = 178,
	DoroznukIdleWaiting1                     = 179,
	DoroznukIdleWaiting2                     = 180,
	BerezaIdleTalkingUsual                   = 181,
	BerezaIdleTalkingHandUsual               = 182,
	BerezaTalkingLongUsual                   = 183,
	BerezaIdleListeningUsual                 = 184,
	BerezaIdleTalkingArmUsual                = 185,
	BerezaHippieUsual                        = 186,
	BerezaTalkingAgree                       = 187,
	BerezaTalkingNegative                    = 188,
	BerezaTalkingHead                        = 189,
	BerezaTalkingHandWave                    = 190,
	BerezaIdleWaitingHand                    = 191,
	BerezaIdleWaiting1                       = 192,
	BerezaIdleWaiting2                       = 193,
	KalinaIdleTalkingUsual                   = 194,
	KalinaIdleListeningStiff                 = 195,
	KalinaIdleListeningUsual                 = 196,
	KalinaTalkingArmsUsual1                  = 197,
	KalinaTalkingArmsUsual2                  = 198,
	KalinaTalkingLongUsual                   = 199,
	KalinaTalkingFingerExpressive            = 200,
	KalinaTalkingGoAwayExpressive            = 201,
	KalinaIdleWaiting1                       = 202,
	KalinaIdleWaiting2                       = 203,
	KalinaIdleWaiting3                       = 204,
	KalinaIdleWaiting4                       = 205,
	KalinaIdleWaitingDust                    = 206,
	KalinaIdleWaitingTable                   = 207,
	DrunkTalkingFingerExpressive             = 208,
	DrunkTalkingFingerExpressive2            = 209,
	DrunkTalkingForwardUsual                 = 210,
	DrunkTalkingLong                         = 211,
	DrunkIdleListening                       = 212,
	DrunkIdleListening2                      = 213,
	DrunkIdleListening3                      = 214,
	DrunkTalkingLong1                        = 215,
	DrunkTalkingLong2                        = 216,
	DrunkTalkingLong3                        = 217,
	TalkWalkieTalkie_E07_MQ01_3              = 218,
	TalkWalkieTalkie_E05_SQ04                = 219,
	PlayerHello                              = 220,
	PlayerArmSwingLeft                       = 221,
	PlayerArmSwingRight                      = 222,
	PlayerMoney                              = 223,
	PlayerPointForward                       = 224,
	PlayerWhatever                           = 225,
	PlayerShowItem                           = 226,
	PlayerDrinkVodka                         = 227,
	PlayerPeace                              = 228,
	PlayerRefuse                             = 229,
	PlayerWavingHands                        = 230,
	PlayerApproval                           = 231,
	PlayerDisapproval                        = 232,
	PlayerFingerCrunching                    = 233,
	PlayerPointUp                            = 234,
	PlayerFku                                = 235,
	PlayerFku2                               = 236,
	PlayerPlayerSalute                       = 237,
	PlayerApplause                           = 238,
	PlayerHeadshakeRefuse                    = 239,
	PlayerAgree                              = 240,
	PlayerBackOn                             = 241,
	PlayerGiveItem                           = 242,
	PlayerNod                                = 243,
	PlayerShowBadge                          = 244,
	PlayerTakeItem                           = 245,
	PlayerWavingHandExpressive               = 246,
	PlayerOpenHandsExpressive                = 247,
	PlayerFingerpointOpenpalm                = 248,
	PlayerBothhandsStatement                 = 249,
	PlayerDisapprovalRight                   = 250,
	PlayerOpenpalmRight                      = 251,
	PlayerPointNPCLeft                       = 252,
	PlayerConvince                           = 253,
	PlayerPoindownLeft                       = 254,
	PlayerPoindownRight                      = 255,
	None                                     = 256,
	EDialogAnimationType_MAX                 = 257,
};

// Enum Stalker2.EQuestRewardType
// NumValues: 0x000C
enum class EQuestRewardType : uint8
{
	Random                                   = 0,
	Money                                    = 1,
	Helmet                                   = 2,
	Armor                                    = 3,
	Weapon                                   = 4,
	Detector                                 = 5,
	Artifact                                 = 6,
	Ammo                                     = 7,
	Attach                                   = 8,
	Medkit                                   = 9,
	Food                                     = 10,
	EQuestRewardType_MAX                     = 11,
};

// Enum Stalker2.ENPCType
// NumValues: 0x0007
enum class ENPCType : uint8
{
	None                                     = 0,
	Trader                                   = 1,
	Technician                               = 2,
	Repairman                                = 3,
	Guide                                    = 4,
	GetCount                                 = 5,
	ENPCType_MAX                             = 6,
};

// Enum Stalker2.ERecalcFieldsFlag
// NumValues: 0x000D
enum class ERecalcFieldsFlag : uint16
{
	None                                     = 0,
	BuffData                                 = 1,
	MaxInventoryMass                         = 2,
	MovementParams                           = 4,
	Significance                             = 8,
	Vitals                                   = 16,
	WeaponData                               = 32,
	BlockedAnimationActionTypes              = 64,
	BulletSpeedSlowdown                      = 128,
	StaminaActionTypes                       = 256,
	Everything                               = 511,
	GetCount                                 = 512,
	ERecalcFieldsFlag_MAX                    = 513,
};

// Enum Stalker2.EInteractableType
// NumValues: 0x000E
enum class EInteractableType : uint8
{
	None                                     = 0,
	Body                                     = 1,
	CodeLock                                 = 2,
	Door                                     = 3,
	ItemContainer                            = 4,
	Lever                                    = 5,
	Look                                     = 6,
	Sleep                                    = 7,
	Artifact                                 = 8,
	NPC                                      = 9,
	ToggleButton                             = 10,
	Ladder                                   = 11,
	Custom                                   = 12,
	EInteractableType_MAX                    = 13,
};

// Enum Stalker2.EArtifactRarity
// NumValues: 0x0006
enum class EArtifactRarity : uint8
{
	Common                                   = 0,
	Uncommon                                 = 1,
	Rare                                     = 2,
	Epic                                     = 3,
	GetCount                                 = 4,
	EArtifactRarity_MAX                      = 5,
};

// Enum Stalker2.EArtifactType
// NumValues: 0x0009
enum class EArtifactType : uint8
{
	Fire                                     = 0,
	Electro                                  = 1,
	Gravity                                  = 2,
	Chemical                                 = 3,
	PSY                                      = 4,
	GetCount                                 = 5,
	Fake                                     = 6,
	None                                     = 7,
	EArtifactType_MAX                        = 8,
};

// Enum Stalker2.EGameMode
// NumValues: 0x0007
enum class EGameMode : uint8
{
	ReleaseGame                              = 0,
	DebugGame                                = 1,
	Benchmark                                = 2,
	DeveloperSpectator                       = 3,
	Death                                    = 4,
	GetCount                                 = 5,
	EGameMode_MAX                            = 6,
};

// Enum Stalker2.EMeshSubType
// NumValues: 0x0005
enum class EMeshSubType : uint32
{
	None                                     = 0,
	Static                                   = 1,
	Skeletal                                 = 2,
	GetCount                                 = 3,
	EMeshSubType_MAX                         = 4,
};

// Enum Stalker2.EGodModType
// NumValues: 0x0008
enum class EGodModType : uint8
{
	None                                     = 0,
	Invulnerable                             = 1,
	Unkillable                               = 2,
	InfiniteMagazine                         = 4,
	InfiniteAmmo                             = 8,
	UnbreakableWeapon                        = 16,
	All                                      = 29,
	EGodModType_MAX                          = 30,
};

// Enum Stalker2.EPlayerMovementType
// NumValues: 0x0006
enum class EPlayerMovementType : uint8
{
	None                                     = 0,
	Walk                                     = 1,
	Jump                                     = 2,
	Crouch                                   = 4,
	All                                      = 7,
	EPlayerMovementType_MAX                  = 8,
};

// Enum Stalker2.EStateTag
// NumValues: 0x0056
enum class EStateTag : uint32
{
	None                                     = 0,
	ShouldWalk                               = 1,
	ShouldRun                                = 2,
	ShouldSprint                             = 4,
	ShouldAim                                = 8,
	Sprint                                   = 16,
	Walk                                     = 32,
	Run                                      = 64,
	MoveForward                              = 128,
	MoveBack                                 = 256,
	Strafe                                   = 512,
	Crouch                                   = 1024,
	Climb                                    = 2048,
	Jump                                     = 4096,
	Aim                                      = 8192,
	Drunk                                    = 16384,
	Sleep                                    = 32768,
	Sit                                      = 65536,
	Interact                                 = 131072,
	LeanLeft                                 = 262144,
	LeanRight                                = 524288,
	LayDown                                  = 1048576,
	HoldBreath                               = 2097152,
	Psycho                                   = 8388608,
	Vault                                    = 16777216,
	Limp                                     = 33554432,
	ZombieReadyToEquipWeapon                 = 67108864,
	ZombieIsStandingUp                       = 134217728,
	EquipItem                                = 268435456,
	AimingActive                             = 536870912,
	SlowRun                                  = 1073741824,
	MovementTypes                            = 112,
	IsMovingXAxis                            = 384,
	IsMoving                                 = 896,
	WalkInPlaceAim                           = 8224,
	WalkMove                                 = 160,
	WalkMoveAim                              = 8352,
	WalkStrafe                               = 544,
	WalkStrafeAim                            = 8736,
	WalkBack                                 = 288,
	WalkBackAim                              = 8480,
	RunMove                                  = 192,
	RunAim                                   = 8384,
	RunStrafeAim                             = 8768,
	RunBack                                  = 320,
	RunBackAim                               = 8512,
	SprintMove                               = 144,
	SprintStrafe                             = 528,
	SprintBack                               = 272,
	JumpWalkInPlace                          = 4128,
	JumpWalkInPlaceAim                       = 12320,
	JumpWalkMove                             = 4256,
	JumpWalkMoveAim                          = 12448,
	JumpWalkStrafe                           = 4640,
	JumpWalkStrafeAim                        = 12832,
	JumpWalkBack                             = 4384,
	JumpWalkBackAim                          = 12576,
	JumpRunInPlaceAim                        = 12288,
	JumpRunMove                              = 4224,
	JumpRunMoveAim                           = 12416,
	JumpRunStrafe                            = 4608,
	JumpRunStrafeAim                         = 12800,
	JumpRunBack                              = 4352,
	JumpRunBackAim                           = 12544,
	JumpSprintInPlace                        = 4112,
	JumpSprintMove                           = 4240,
	JumpSprintStrafe                         = 4624,
	JumpSprintBack                           = 4368,
	LowCrouchInPlace                         = 1056,
	LowCrouchInPlaceAim                      = 9248,
	LowCrouchMove                            = 1184,
	LowCrouchMoveAim                         = 9376,
	LowCrouchStrafe                          = 1568,
	LowCrouchStrafeAim                       = 9760,
	LowCrouchBack                            = 1312,
	LowCrouchBackAim                         = 9504,
	CrouchInPlaceAim                         = 9216,
	CrouchMove                               = 1152,
	CrouchMoveAim                            = 9344,
	CrouchStrafe                             = 1536,
	CrouchStrafeAim                          = 9728,
	CrouchBack                               = 1280,
	CrouchBackAim                            = 9472,
	FastDescend                              = 2320,
	GetCount                                 = 65535,
	EStateTag_MAX                            = 1073741825,
};

// Enum Stalker2.EPlayerTriggerState
// NumValues: 0x0036
enum class EPlayerTriggerState : uint64
{
	None                                     = 0,
	MainTrigger                              = 1,
	AimTrigger                               = 2,
	MeleeTrigger                             = 4,
	ChangeAmmoTypeTrigger                    = 8,
	ChangeFireTypeTrigger                    = 16,
	ReloadTrigger                            = 32,
	UnjamTrigger                             = 64,
	JumpTrigger                              = 128,
	LeanLeftTrigger                          = 256,
	LeanRightTrigger                         = 512,
	CrouchTrigger                            = 1024,
	WalkTrigger                              = 2048,
	SprintTrigger                            = 4096,
	DropItemTrigger                          = 8192,
	PickUpLeftHandTrigger                    = 16384,
	PickUpRightHandTrigger                   = 32768,
	InteractRightHandTrigger                 = 65536,
	InteractLeftHandTrigger                  = 131072,
	UseItemLeftHandTrigger                   = 262144,
	UseItemRightHandTrigger                  = 524288,
	RemoveLeftHandFromMainItemTrigger        = 1048576,
	ReturnLeftHandOnMainItemTrigger          = 2097152,
	AutoCoverTrigger                         = 4194304,
	PrepareMainItemUseTrigger                = 8388608,
	KnockDownTrigger                         = 16777216,
	InstallAttachTrigger                     = 33554432,
	ThrowWithoutEquipTrigger                 = 67108864,
	VaultTrigger                             = 134217728,
	EquipBothHandsTrigger                    = 268435456,
	ToggleFlashlightTrigger                  = 536870912,
	UseBackpackTrigger                       = 1073741824,
	LimpTrigger                              = 2147483648,
	ToggleShootingAttach                     = 4294967296,
	ItemSelectorTrigger                      = 8589934592,
	ThrowStrongTrigger                       = 17179869184,
	ThrowWeakTrigger                         = 34359738368,
	SwapWeaponTrigger                        = 68719476736,
	AttachSelectorTrigger                    = 137438953472,
	InteractTrigger                          = 274877906944,
	PickUpTrigger                            = 549755813888,
	HoldBreathTrigger                        = 1099511627776,
	UsePDATrigger                            = 2199023255552,
	UnloadTrigger                            = 4398046511104,
	InspectArtifactTrigger                   = 8796093022208,
	InspectArtifactWithBackpackTrigger       = 17592186044416,
	RestoreCrouchTrigger                     = 35184372088832,
	PlayGuitarTrigger                        = 70368744177664,
	SprintStartedTrigger                     = 140737488355328,
	LadderSprintTrigger                      = 281474976710656,
	DodgeTrigger                             = 562949953421312,
	PrepareAmmoTypeChangeTrigger             = 1125899906842624,
	TakeNextItemTrigger                      = 2251799813685248,
	EPlayerTriggerState_MAX                  = 2251799813685249,
};

// Enum Stalker2.EInputContextAdditionalFlags
// NumValues: 0x0019
enum class EInputContextAdditionalFlags : uint32
{
	None                                     = 0,
	Falling                                  = 1,
	CanBeStanding                            = 2,
	HasMovementInput                         = 4,
	CanWalk                                  = 8,
	CanRun                                   = 16,
	CanSprint                                = 32,
	HasClimbTarget                           = 64,
	HasInteractTarget                        = 128,
	CanJump                                  = 256,
	HasCorpse                                = 512,
	VaultingInProgress                       = 1024,
	Immobilized                              = 2048,
	CanCrouch                                = 4096,
	CanHarmUnfocusable                       = 8192,
	UnderbarrelAttachMode                    = 16384,
	InteractWithCorpse                       = 32768,
	HasInstantInteract                       = 65536,
	HasInteractWithAnim                      = 131072,
	HasFlashlightAnimation                   = 262144,
	HasFireSwitchAnimation                   = 524288,
	HasDragWeaponAnimation                   = 1048576,
	HasForwardMovementInput                  = 2097152,
	HasMeleeAttackAnimation                  = 4194304,
	EInputContextAdditionalFlags_MAX         = 4194305,
};

// Enum Stalker2.EIgnoreDamageType
// NumValues: 0x000C
enum class EIgnoreDamageType : uint16
{
	None                                     = 1,
	Unkillable                               = 2,
	Unfocusable                              = 4,
	IgnorePSY                                = 8,
	IgnoreFallDamage                         = 16,
	ImmuneToEmission                         = 32,
	UnkillableByALife                        = 64,
	IgnoreMeleeDamage                        = 128,
	InvulnerableInteract                     = 256,
	IgnoreExplosionDamage                    = 512,
	Invulnerable                             = 6,
	EIgnoreDamageType_MAX                    = 513,
};

// Enum Stalker2.EStaminaAction
// NumValues: 0x000E
enum class EStaminaAction : uint8
{
	None                                     = 0,
	Walk                                     = 1,
	Run                                      = 2,
	Sprint                                   = 3,
	Crouch                                   = 4,
	LowCrouch                                = 5,
	Climb                                    = 6,
	Jump                                     = 7,
	MeleeNormal                              = 8,
	MeleeStrong                              = 9,
	MeleeButstock                            = 10,
	Vault                                    = 11,
	GetCount                                 = 12,
	EStaminaAction_MAX                       = 13,
};

// Enum Stalker2.EWeightStatus
// NumValues: 0x0005
enum class EWeightStatus : uint8
{
	Normal                                   = 0,
	Heavy                                    = 1,
	Overweight                               = 2,
	GetCount                                 = 3,
	EWeightStatus_MAX                        = 4,
};

// Enum Stalker2.EScriptVariableType
// NumValues: 0x0009
enum class EScriptVariableType : uint8
{
	None                                     = 0,
	BoolVar                                  = 1,
	Int32Var                                 = 2,
	Int64Var                                 = 3,
	FloatVar                                 = 4,
	DoubleVar                                = 5,
	FStringVar                               = 6,
	GetCount                                 = 7,
	EScriptVariableType_MAX                  = 8,
};

// Enum Stalker2.ESpawnType
// NumValues: 0x0026
enum class ESpawnType : uint8
{
	None                                     = 0,
	ALifeGroup                               = 1,
	Anomaly                                  = 2,
	AnomalySpawner                           = 3,
	ArtifactSpawner                          = 4,
	DeadBody                                 = 5,
	ElectroAnomaly                           = 6,
	FlashlightOnZone                         = 7,
	DailyScheduleZone                        = 8,
	GuardZone                                = 9,
	Item                                     = 10,
	ItemContainer                            = 11,
	FogVolume                                = 12,
	LairSpawner                              = 13,
	LightningBallAnomaly                     = 14,
	MoveToPath                               = 15,
	Marker                                   = 16,
	Obj                                      = 17,
	PackOfItems                              = 18,
	PillowAnomaly                            = 19,
	PsyAnomaly                               = 20,
	PSYControllerAnomaly                     = 21,
	Patrol                                   = 22,
	ContextualAction                         = 23,
	Radiation                                = 24,
	SafeZone                                 = 25,
	Searchpoint                              = 26,
	Shelter                                  = 27,
	SoapBubbleAnomaly                        = 28,
	Hub                                      = 29,
	Squad                                    = 30,
	Trigger                                  = 31,
	DestructibleObject                       = 32,
	WeatherSelection                         = 33,
	TeleportPoint                            = 34,
	ClickerAnomaly                           = 35,
	OnlineModifierZone                       = 36,
	ESpawnType_MAX                           = 37,
};

// Enum Stalker2.EHideViewType
// NumValues: 0x0004
enum class EHideViewType : uint8
{
	ForceHide                                = 0,
	Hide                                     = 1,
	Unhide                                   = 2,
	EHideViewType_MAX                        = 3,
};

// Enum Stalker2.ERegion
// NumValues: 0x001A
enum class ERegion : uint8
{
	Zone                                     = 0,
	MalayaZona                               = 1,
	Svalka                                   = 2,
	ChemZavod                                = 3,
	DickyOstrov                              = 4,
	Zaton                                    = 5,
	Bolota                                   = 6,
	NIICHAZ                                  = 7,
	Gradirni                                 = 8,
	Malahit                                  = 9,
	Duga                                     = 10,
	Rostock                                  = 11,
	Yantar                                   = 12,
	GoreliyLes                               = 13,
	Kordon                                   = 14,
	RizhyLes                                 = 15,
	Yanov                                    = 16,
	Jupiter                                  = 17,
	Pripyat                                  = 18,
	ZheleznyLes                              = 19,
	CHAES                                    = 20,
	Generatory                               = 21,
	ZementniyZavod                           = 22,
	GetCount                                 = 23,
	None                                     = 24,
	ERegion_MAX                              = 25,
};

// Enum Stalker2.EPrototypeClass
// NumValues: 0x0070
enum class EPrototypeClass : uint8
{
	Ability                                  = 0,
	ALifeDirectorScenario                    = 1,
	ALifePopulationManagerFaction            = 2,
	Anomaly                                  = 3,
	PassiveDetector                          = 4,
	AnomalyOverlap                           = 5,
	ArtifactSpawner                          = 6,
	AudioRoom                                = 7,
	AudioScatterer                           = 8,
	BarbedWire                               = 9,
	BodyMesh                                 = 10,
	BodyMeshSimulatePhysics                  = 11,
	Bolt                                     = 12,
	Corpse                                   = 13,
	ContextualActionBlueprint                = 14,
	ContextualActionNode                     = 15,
	ContextualActionDialogSettings           = 16,
	ContextualActionBodyParts                = 17,
	CoverEvaluator                           = 18,
	DamageSource                             = 19,
	DailySchedule                            = 20,
	DestructibleObject                       = 21,
	DialogChain                              = 22,
	Dialog                                   = 23,
	DialogPool                               = 24,
	Difficulty                               = 25,
	Door                                     = 26,
	Effect                                   = 27,
	EffectSourcePriority                     = 28,
	Emission                                 = 29,
	Explosion                                = 30,
	FastTravel                               = 31,
	FastTravelLocation                       = 32,
	Flashlight                               = 33,
	GlobalVariable                           = 34,
	GroomGenerator                           = 35,
	HearingSensor                            = 36,
	ImpactPhysicalMaterial                   = 37,
	Infotopic                                = 38,
	InputMappingContext                      = 39,
	Item                                     = 40,
	ItemContainer                            = 41,
	ItemGenerator                            = 42,
	JournalQuest                             = 43,
	Lair                                     = 44,
	LevelStreaming                           = 45,
	Marker                                   = 46,
	Mesh                                     = 47,
	MeshGenerator                            = 48,
	MusicManager                             = 49,
	MovementFX                               = 50,
	MeleeWeapon                              = 51,
	PhysicsInteraction                       = 52,
	Note                                     = 53,
	NPC                                      = 54,
	NPCNeedsPreset                           = 55,
	Obj                                      = 56,
	PackOfItemsGroup                         = 57,
	Projectile                               = 58,
	Relation                                 = 59,
	Quest                                    = 60,
	QuestNode                                = 61,
	SmartCover                               = 62,
	SpawnActor                               = 63,
	Stash                                    = 64,
	Threat                                   = 65,
	Upgrade                                  = 66,
	VisionScanner                            = 67,
	WeatherSelection                         = 68,
	WeatherChain                             = 69,
	WeaponAttributes                         = 70,
	WeaponGeneralSetup                       = 71,
	CharacterWeaponSettings                  = 72,
	PostEffectProcessor                      = 73,
	RegionMusic                              = 74,
	ObjSleepParams                           = 75,
	ObjHoldBreathParams                      = 76,
	ObjWeightParams                          = 77,
	ObjEffectMaxParams                       = 78,
	HappyHours                               = 79,
	CameraShake                              = 80,
	CameraShakeGroup                         = 81,
	MovementSensor                           = 82,
	FlairSensor                              = 83,
	VisionTick                               = 84,
	Constraint                               = 85,
	GroomBlockingMapping                     = 86,
	FaceBlockingBlendMask                    = 87,
	PostProcessMaterial                      = 88,
	PostProcessParam                         = 89,
	FloatProvider                            = 90,
	BoolProvider                             = 91,
	ObjWeatherParams                         = 92,
	ObjCrouchParams                          = 93,
	ObjOnHitParams                           = 94,
	ObjCustomAbilityDialog                   = 95,
	EnemyEvaluator                           = 96,
	AimAssistCone                            = 97,
	AimAssistPreset                          = 98,
	AimAssistWeights                         = 99,
	VoiceModulator                           = 100,
	CorpseClueStash                          = 101,
	TeleportGroup                            = 102,
	AnimationBudget                          = 103,
	Teleport                                 = 104,
	Trade                                    = 105,
	PDATutorial                              = 106,
	Backpack                                 = 107,
	GreetingsPopup                           = 108,
	ObjAimAssistParams                       = 109,
	GetCount                                 = 110,
	EPrototypeClass_MAX                      = 111,
};

// Enum Stalker2.EPhysicalMaterialType
// NumValues: 0x0030
enum class EPhysicalMaterialType : uint32
{
	Default                                  = 0,
	Dirt                                     = 1,
	Grass                                    = 2,
	Brick                                    = 3,
	Glass                                    = 4,
	Sand                                     = 5,
	Rock                                     = 6,
	Asphalt                                  = 7,
	Cloth                                    = 8,
	Leather                                  = 9,
	Rubber                                   = 10,
	Paper                                    = 11,
	Plastic                                  = 12,
	Flesh                                    = 13,
	FleshCloth                               = 14,
	FleshMetal                               = 15,
	FleshRubber                              = 16,
	WoodThin                                 = 17,
	WoodSolid                                = 18,
	MetalThin                                = 19,
	MetalSolid                               = 20,
	MetalGrid                                = 21,
	Slate                                    = 22,
	Water                                    = 23,
	Chemical                                 = 24,
	Bread                                    = 25,
	Meat                                     = 26,
	Vegetable                                = 27,
	Tree                                     = 28,
	ForestGrass                              = 29,
	Puddle                                   = 30,
	Gravel                                   = 31,
	BrokenGlass                              = 32,
	Ground                                   = 33,
	ForestPine                               = 34,
	Artifact                                 = 35,
	Leaves                                   = 36,
	Ceramic                                  = 37,
	TreeNoParticles                          = 38,
	GlassNoParticles                         = 39,
	Bone                                     = 40,
	ClothCorpses                             = 41,
	FleshCorpses                             = 42,
	ArmoredGlass                             = 43,
	AirPoltergeist                           = 44,
	FaustInvulnerable                        = 45,
	GetCount                                 = 46,
	EPhysicalMaterialType_MAX                = 47,
};

// Enum Stalker2.EBiomeCurveAtlas
// NumValues: 0x000B
enum class EBiomeCurveAtlas : uint8
{
	Default                                  = 0,
	RedForest                                = 1,
	Urban                                    = 2,
	OrdinaryForest                           = 3,
	Water                                    = 4,
	Swamp                                    = 5,
	Road                                     = 6,
	DeadForest                               = 7,
	PineForest                               = 8,
	GetCount                                 = 9,
	EBiomeCurveAtlas_MAX                     = 10,
};

// Enum Stalker2.EWeatherCurveAtlas
// NumValues: 0x0005
enum class EWeatherCurveAtlas : uint8
{
	Default                                  = 0,
	Sunny                                    = 1,
	Cloud                                    = 2,
	GetCount                                 = 3,
	EWeatherCurveAtlas_MAX                   = 4,
};

// Enum Stalker2.ECurveAtlasParameter
// NumValues: 0x000D
enum class ECurveAtlasParameter : uint8
{
	SkySphere_CloudColor                     = 0,
	SkySphere_HorizonColor                   = 4,
	SkySphere_ZenithColor                    = 8,
	AtmosphericFogParametersPack1_SunMultiplier = 12,
	AtmosphericFog_FogMultiplier             = 13,
	AtmosphericFog_DensityMultiplier         = 14,
	AtmosphericFog_DensityOffset             = 15,
	ExponentialFogParameters                 = 16,
	SkyLightColor                            = 20,
	Intensity                                = 24,
	Contrast                                 = 28,
	GetCount                                 = 29,
	ECurveAtlasParameter_MAX                 = 30,
};

// Enum Stalker2.EInputKey
// NumValues: 0x004E
enum class EInputKey : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Backward                                 = 2,
	Right                                    = 3,
	Left                                     = 4,
	UpArrow                                  = 5,
	DownArrow                                = 6,
	LeftArrow                                = 7,
	RightArrow                               = 8,
	Turn                                     = 9,
	LookUp                                   = 10,
	Fire                                     = 11,
	Aim                                      = 12,
	Reload                                   = 13,
	ChangeAmmoType                           = 14,
	Jump                                     = 15,
	Walk                                     = 16,
	Sprint                                   = 17,
	Crouch                                   = 18,
	MainHandEquipKnife                       = 19,
	MainHandEquipPistol                      = 20,
	MainHandEquipPrimaryWeapon               = 21,
	MainHandEquipSecondaryWeapon             = 22,
	MainHandEquipGrenade                     = 23,
	MainHandEquipBolt                        = 24,
	MainHandEquipDetector                    = 25,
	MainHandEquipBinoculars                  = 26,
	DPadOpenUp                               = 27,
	DPadOpenDown                             = 28,
	DPadRight                                = 29,
	DPadLeft                                 = 30,
	ChangeFireType                           = 31,
	ToggleAttachMode                         = 32,
	Interact                                 = 33,
	Inventory                                = 34,
	WorldMap                                 = 35,
	Journal                                  = 36,
	Notes                                    = 37,
	Bestiary                                 = 38,
	Statistics                               = 39,
	MouseWheelUp                             = 40,
	MouseWheelDown                           = 41,
	DropItemInHands                          = 42,
	Ctrl                                     = 43,
	PersonViewSwitcher                       = 44,
	DeveloperSpectatorSwitcher               = 45,
	TeleportToSpectator                      = 46,
	Esc                                      = 47,
	QuickSlot1                               = 48,
	QuickSlot2                               = 49,
	QuickSlot3                               = 50,
	QuickSlot4                               = 51,
	QuickSave                                = 52,
	QuickLoad                                = 53,
	LeanLeft                                 = 54,
	LeanRight                                = 55,
	MeleeAttack                              = 56,
	Flashlight                               = 57,
	TacticalFlashlight                       = 58,
	SwitchWeapon                             = 59,
	AutoWalk                                 = 60,
	Square                                   = 61,
	Cross                                    = 62,
	Circle                                   = 63,
	Triangle                                 = 64,
	LeftShoulder                             = 65,
	LeftTrigger                              = 66,
	LeftThumbstickButton                     = 67,
	RightShoulder                            = 68,
	RightTrigger                             = 69,
	RightThumbstickButton                    = 70,
	Select                                   = 71,
	Start                                    = 72,
	TouchpadButton                           = 73,
	DPadXYAxis                               = 74,
	ItemSelector                             = 75,
	GetCount                                 = 76,
	EInputKey_MAX                            = 77,
};

// Enum Stalker2.EKeyState
// NumValues: 0x0007
enum class EKeyState : uint8
{
	InitialHoldInProgress                    = 0,
	PressedEvent                             = 1,
	HoldEventStarted                         = 2,
	Holding                                  = 3,
	Released                                 = 4,
	Processed                                = 5,
	EKeyState_MAX                            = 6,
};

// Enum Stalker2.EDamageBone
// NumValues: 0x0005
enum class EDamageBone : uint8
{
	Head                                     = 0,
	Body                                     = 1,
	Limbs                                    = 2,
	GetCount                                 = 3,
	EDamageBone_MAX                          = 4,
};

// Enum Stalker2.EVitalType
// NumValues: 0x0010
enum class EVitalType : uint8
{
	None                                     = 0,
	HP                                       = 1,
	SP                                       = 2,
	HungerPoints                             = 3,
	ThirstPoints                             = 4,
	SleepinessPoints                         = 5,
	Bleeding                                 = 6,
	Radiation                                = 7,
	PoppyFieldSleepiness                     = 8,
	SuppressionPoints                        = 9,
	PsyPoints                                = 10,
	Drunkness                                = 11,
	OverDrunkness                            = 12,
	FallHeight                               = 13,
	GetCount                                 = 14,
	EVitalType_MAX                           = 15,
};

// Enum Stalker2.ESoundEventType
// NumValues: 0x0013
enum class ESoundEventType : uint32
{
	None                                     = 0,
	Shot                                     = 1,
	Reload                                   = 2,
	Steps                                    = 4,
	Jump                                     = 8,
	Voice                                    = 16,
	AnomalyActivated                         = 32,
	Explosion                                = 64,
	BulletFlyby                              = 128,
	PhysObjectImpact                         = 256,
	Interactable                             = 512,
	DoorKnockedOut                           = 1024,
	Bolt                                     = 2048,
	StealthKill                              = 4096,
	BulletHit                                = 8192,
	GrenadeHit                               = 16384,
	Guitar                                   = 32768,
	Count                                    = 16,
	ESoundEventType_MAX                      = 32769,
};

// Enum Stalker2.EEmissionAIEvent
// NumValues: 0x0006
enum class EEmissionAIEvent : uint8
{
	EmissionStart                            = 0,
	EmissionDanger                           = 1,
	EmissionActive                           = 2,
	EmissionEnd                              = 3,
	Count                                    = 4,
	EEmissionAIEvent_MAX                     = 5,
};

// Enum Stalker2.EThreatAwareness
// NumValues: 0x0008
enum class EThreatAwareness : uint8
{
	None                                     = 0,
	Calm                                     = 1,
	TurnHead                                 = 2,
	SearchEnemy                              = 3,
	MoveToLocation                           = 4,
	CallAllies                               = 5,
	Battle                                   = 6,
	EThreatAwareness_MAX                     = 7,
};

// Enum Stalker2.EAwareness
// NumValues: 0x0005
enum class EAwareness : uint8
{
	None                                     = 0,
	Calm                                     = 1,
	Suspicious                               = 2,
	Battle                                   = 3,
	EAwareness_MAX                           = 4,
};

// Enum Stalker2.EAIMovementPose
// NumValues: 0x0003
enum class EAIMovementPose : uint8
{
	Stand                                    = 0,
	Crouch                                   = 1,
	EAIMovementPose_MAX                      = 2,
};

// Enum Stalker2.EMovementBehaviour
// NumValues: 0x0007
enum class EMovementBehaviour : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Walk                                     = 2,
	Run                                      = 3,
	Sprint                                   = 4,
	GetCount                                 = 5,
	EMovementBehaviour_MAX                   = 6,
};

// Enum Stalker2.EMovementTarget
// NumValues: 0x0004
enum class EMovementTarget : uint8
{
	Path_Legacy                              = 0,
	Path                                     = 1,
	DynamicObject                            = 2,
	EMovementTarget_MAX                      = 3,
};

// Enum Stalker2.EQuestNodeType
// NumValues: 0x008A
enum class EQuestNodeType : uint8
{
	AchievementUnlock                        = 0,
	ActivateAnomaly                          = 1,
	ActivateInteractableObject               = 2,
	ActivateRestrictor                       = 3,
	AddNote                                  = 4,
	AddOrRemoveFromSquad                     = 5,
	AddTechnicianSkillOrUpgrade              = 6,
	ALifeDirectorZoneSwitch                  = 7,
	BridgeCleanUp                            = 8,
	CancelAllSideQuests                      = 9,
	ChangeRelationships                      = 10,
	ChangeFaction                            = 11,
	Condition                                = 12,
	Container                                = 13,
	DeactivateZone                           = 14,
	Despawn                                  = 15,
	DisableNPCBark                           = 16,
	DisableNPCInteraction                    = 17,
	EmissionScheduleControl                  = 18,
	EmissionStart                            = 19,
	End                                      = 20,
	Event                                    = 21,
	GiveCache                                = 22,
	If                                       = 23,
	ItemAdd                                  = 24,
	ItemRemove                               = 25,
	EnableDataLayer                          = 26,
	FlashlightOnOff                          = 27,
	ForceInteract                            = 28,
	HideTutorial                             = 29,
	LookAt                                   = 30,
	MoveInventory                            = 31,
	NPCBark                                  = 32,
	PlayEffect                               = 33,
	PlayPostProcess                          = 34,
	PlaySound                                = 35,
	ReputationLocker                         = 36,
	ResetAI                                  = 37,
	RestrictionArea                          = 38,
	Random                                   = 39,
	ScheduledContainer                       = 40,
	SearchPoint                              = 41,
	SendSignal                               = 42,
	SetAIBehavior                            = 43,
	SetCharacterEffect                       = 44,
	SetCharacterParam                        = 45,
	SetDialog                                = 46,
	SetDurabilityParam                       = 47,
	SetEmotionalState                        = 48,
	SetFactionRestriction                    = 49,
	SetGlobalVariable                        = 50,
	SetHubOwner                              = 51,
	SetItemGenerator                         = 52,
	SetJournal                               = 53,
	SetLocationName                          = 54,
	SetMeshGenerator                         = 55,
	SetName                                  = 56,
	SetNPCSequentialAbility                  = 57,
	SetPersonalRestriction                   = 58,
	SetQuestGiver                            = 59,
	SetSpaceRestrictor                       = 60,
	SetTime                                  = 61,
	SetTimer                                 = 62,
	SetWeather                               = 63,
	SetWounded                               = 64,
	ShowFadeScreen                           = 65,
	ShowMarker                               = 66,
	ShowTutorialWidget                       = 67,
	Spawn                                    = 68,
	SequenceStart                            = 69,
	SwitchQuestItemState                     = 70,
	Technical                                = 71,
	TeleportCharacter                        = 72,
	TimeLock                                 = 73,
	ToggleNPCHidden                          = 74,
	ToggleLairActivity                       = 75,
	EquipItemInHands                         = 76,
	Trigger                                  = 77,
	SaveGame                                 = 78,
	RestrictSave                             = 79,
	StartQuestStage                          = 80,
	ProtectLairNPCSquadItem                  = 81,
	SpawnAnomaly                             = 82,
	SpawnAnomalySpawner                      = 83,
	SpawnArtifactSpawner                     = 84,
	SpawnContextualAction                    = 85,
	SpawnDeadBody                            = 86,
	SpawnGuardZone                           = 87,
	SpawnHub                                 = 88,
	SpawnItemContainer                       = 89,
	SpawnLair                                = 90,
	SpawnSafeZone                            = 91,
	SpawnSingleObj                           = 92,
	SpawnShelter                             = 93,
	SpawnSquad                               = 94,
	SpawnTrigger                             = 95,
	BridgeEvent                              = 96,
	OnAbilityUsedEvent                       = 97,
	OnEmissionStageActivated                 = 98,
	OnEmissionStageFinished                  = 99,
	OnEmissionStartEvent                     = 100,
	OnEmissionFinishEvent                    = 101,
	OnFactionBecomeFriendEvent               = 102,
	OnFactionBecomeEnemyEvent                = 103,
	OnGetCompatibleAttachEvent               = 104,
	OnHitEvent                               = 105,
	OnInteractEvent                          = 106,
	OnJournalQuestEvent                      = 107,
	OnKillerCheckEvent                       = 108,
	OnMoneyAmountReachedEvent                = 109,
	OnNPCBecomeEnemyEvent                    = 110,
	OnNPCBecomeFriendEvent                   = 111,
	OnNPCCreateEvent                         = 112,
	OnNPCDeathEvent                          = 113,
	OnNPCDefeatEvent                         = 114,
	OnPlayerGetItemEvent                     = 115,
	OnPlayerLostItemEvent                    = 116,
	OnPlayerNoticedEvent                     = 117,
	OnPlayerRankReachedEvent                 = 118,
	OnSignalReceived                         = 119,
	OnTickEvent                              = 120,
	OnTriggerEnterEvent                      = 121,
	OnTriggerExitEvent                       = 122,
	OnInfotopicFinishEvent                   = 123,
	TrackShelter                             = 124,
	TrackJournal                             = 125,
	StartBenchmark                           = 126,
	ConsoleCommand                           = 127,
	PlayVideo                                = 128,
	ShowLoadingScreen                        = 129,
	LoadAsset                                = 130,
	HideLoadingScreen                        = 131,
	OnAbilityEndedEvent                      = 132,
	OnUpgradeInstallEvent                    = 133,
	SpawnMarker                              = 134,
	OnDialogStartEvent                       = 135,
	GetCount                                 = 136,
	EQuestNodeType_MAX                       = 137,
};

// Enum Stalker2.EModifiedCharacterParam
// NumValues: 0x000F
enum class EModifiedCharacterParam : uint8
{
	HP                                       = 0,
	HPPercent                                = 1,
	SP                                       = 2,
	Bleeding                                 = 3,
	HungerPoints                             = 4,
	Sleepiness                               = 5,
	Radiation                                = 6,
	Money                                    = 7,
	RewardMainLineMoney                      = 8,
	RewardSideLineMoney                      = 9,
	Rank                                     = 10,
	InventoryWeight                          = 11,
	IgnoreDamageType                         = 12,
	Zombie                                   = 13,
	EModifiedCharacterParam_MAX              = 14,
};

// Enum Stalker2.EQuestRewardSource
// NumValues: 0x0005
enum class EQuestRewardSource : uint8
{
	None                                     = 0,
	MainLine                                 = 1,
	SideLine                                 = 2,
	GetCount                                 = 3,
	EQuestRewardSource_MAX                   = 4,
};

// Enum Stalker2.EQuestEventType
// NumValues: 0x004F
enum class EQuestEventType : uint8
{
	None                                     = 0,
	OnAbilityUsed                            = 1,
	OnBecomeEnemy                            = 2,
	OnBecomeFriend                           = 3,
	OnCacheOpened                            = 4,
	OnCombatStarted                          = 5,
	OnCombatFinished                         = 6,
	OnRelationshipChanged                    = 7,
	OnDialogFinished                         = 8,
	OnEmissionFinished                       = 9,
	OnEmissionStarted                        = 10,
	OnEmissionStageFinished                  = 11,
	OnEmissionStageStarted                   = 12,
	OnFactionBecomeEnemy                     = 13,
	OnFactionBecomeFriend                    = 14,
	OnFactionRelationshipChanged             = 15,
	OnGlobalVariableChanged                  = 16,
	OnItemContainerLoot                      = 17,
	OnItemContainerLootFinished              = 18,
	OnQuestInteractionFinish                 = 19,
	OnInteract                               = 20,
	OnHit                                    = 21,
	OnInteractEnabled                        = 22,
	OnJournalQuestStart                      = 23,
	OnJournalQuestFinish                     = 24,
	OnJournalQuestFail                       = 25,
	OnJournalQuestCancel                     = 26,
	OnJournalQuestStageStart                 = 27,
	OnJournalQuestStageFinish                = 28,
	OnJournalQuestStageFail                  = 29,
	OnJournalQuestStageCancel                = 30,
	OnLocationDiscovered                     = 31,
	OnLookAtEnded                            = 32,
	OnMoneyAmountReached                     = 33,
	OnNotesChanged                           = 34,
	OnModelCreate                            = 35,
	OnModelUnhide                            = 36,
	OnObjCreate                              = 37,
	OnObjDeath                               = 38,
	OnObjDefeat                              = 39,
	OnObjViewCreate                          = 40,
	OnObjViewDestroy                         = 41,
	OnPlayerSetupFinished                    = 42,
	OnPlayerGetItem                          = 43,
	OnPlayerLostItem                         = 44,
	OnPlayerNoticed                          = 45,
	OnPlayerRankReached                      = 46,
	OnResetAI                                = 47,
	OnSaveLockRemoved                        = 48,
	OnScenarioManagerTickStarted             = 49,
	OnSetupALifeQuestScenarioGroup           = 50,
	OnSetEmotionalStatePerformed             = 51,
	OnSetEmotionalStateFinished              = 52,
	OnSignalReceiverBeginPlay                = 53,
	OnSignalReceived                         = 54,
	OnQuestFinish                            = 55,
	OnQuestNodeChangeState                   = 56,
	OnTick                                   = 57,
	OnTriggerEnter                           = 58,
	OnTriggerExit                            = 59,
	OnItemContainerEmpty                     = 60,
	OnDayStarted                             = 61,
	OnNightStarted                           = 62,
	OnDialogExit                             = 63,
	OnDialogEntered                          = 64,
	OnPlayerEnterShelter                     = 65,
	OnPlayerExitShelter                      = 66,
	OnUpdateALifeQuestZoneData               = 67,
	OnWeatherChanged                         = 68,
	OnPDATutorialChanged                     = 69,
	OnGetCompatibleAttachment                = 70,
	OnAbilityEnded                           = 71,
	OnInteractionCommentFinished             = 72,
	OnUpgradeInstall                         = 73,
	OnObjHeal                                = 74,
	OnRankScalingApplied                     = 75,
	OnItemContainerCreate                    = 76,
	GetCount                                 = 77,
	EQuestEventType_MAX                      = 78,
};

// Enum Stalker2.EQuestNodeState
// NumValues: 0x0005
enum class EQuestNodeState : uint8
{
	None                                     = 0,
	Activated                                = 1,
	Excluded                                 = 2,
	Finished                                 = 3,
	EQuestNodeState_MAX                      = 4,
};

// Enum Stalker2.EConditionCheckType
// NumValues: 0x0004
enum class EConditionCheckType : uint8
{
	None                                     = 0,
	And                                      = 1,
	Or                                       = 2,
	EConditionCheckType_MAX                  = 3,
};

// Enum Stalker2.EQuestConditionType
// NumValues: 0x002E
enum class EQuestConditionType : uint8
{
	HP                                       = 0,
	HPPercent                                = 1,
	Stamina                                  = 2,
	Radiation                                = 3,
	Bleeding                                 = 4,
	Psy                                      = 5,
	HungerPoints                             = 6,
	Money                                    = 7,
	InventoryWeight                          = 8,
	IsAlive                                  = 9,
	IsOnline                                 = 10,
	FactionRelationship                      = 11,
	PersonalRelationship                     = 12,
	Rank                                     = 13,
	Effect                                   = 14,
	Awareness                                = 15,
	Note                                     = 16,
	ItemInInventory                          = 17,
	AITarget                                 = 18,
	GlobalVariable                           = 19,
	Trigger                                  = 20,
	DistanceToNPC                            = 21,
	DistanceToPoint                          = 22,
	LookAtAngle                              = 23,
	Bridge                                   = 24,
	ItemInContainer                          = 25,
	EquipmentInHands                         = 26,
	IsAiming                                 = 27,
	CorpseCarry                              = 28,
	JournalState                             = 29,
	IsCreated                                = 30,
	Emission                                 = 31,
	PlayerOverload                           = 32,
	IsWounded                                = 33,
	ContextualAction                         = 34,
	IsDialogMemberValid                      = 35,
	Weather                                  = 36,
	IsEnoughAmmo                             = 37,
	IsWeaponJammed                           = 38,
	HasItemInQuickSlot                       = 39,
	ArmorState                               = 40,
	Random                                   = 41,
	FastTravelMoney                          = 42,
	NodeState                                = 43,
	Last                                     = 255,
	EQuestConditionType_MAX                  = 256,
};

// Enum Stalker2.EConditionComparance
// NumValues: 0x0007
enum class EConditionComparance : uint8
{
	Less                                     = 0,
	LessOrEqual                              = 1,
	Equal                                    = 2,
	NotEqual                                 = 3,
	GreaterOrEqual                           = 4,
	Greater                                  = 5,
	EConditionComparance_MAX                 = 6,
};

// Enum Stalker2.EJournalEntity
// NumValues: 0x0003
enum class EJournalEntity : uint8
{
	Quest                                    = 0,
	QuestStage                               = 1,
	EJournalEntity_MAX                       = 2,
};

// Enum Stalker2.EJournalAction
// NumValues: 0x0006
enum class EJournalAction : uint8
{
	Start                                    = 0,
	Finish                                   = 1,
	Fail                                     = 2,
	Cancel                                   = 3,
	ChangeStageDescription                   = 4,
	EJournalAction_MAX                       = 5,
};

// Enum Stalker2.EJournalState
// NumValues: 0x0006
enum class EJournalState : uint8
{
	Pending                                  = 0,
	Active                                   = 1,
	Finished                                 = 2,
	Failed                                   = 3,
	Cancelled                                = 4,
	EJournalState_MAX                        = 5,
};

// Enum Stalker2.EContextualActionNodeType
// NumValues: 0x000A
enum class EContextualActionNodeType : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Animation                                = 2,
	SoundDependentAnimation                  = 3,
	RandomSelector                           = 4,
	SequentialSelector                       = 5,
	DistanceSelector                         = 6,
	Interrupt                                = 7,
	ConditionalSelector                      = 8,
	EContextualActionNodeType_MAX            = 9,
};

// Enum Stalker2.EChangeValueMode
// NumValues: 0x0006
enum class EChangeValueMode : uint8
{
	Set                                      = 0,
	Add                                      = 1,
	Subtract                                 = 2,
	Multiply                                 = 3,
	Divide                                   = 4,
	EChangeValueMode_MAX                     = 5,
};

// Enum Stalker2.ERequiredSquadMembers
// NumValues: 0x0003
enum class ERequiredSquadMembers : uint8
{
	AllMembers                               = 0,
	AnyMember                                = 1,
	ERequiredSquadMembers_MAX                = 2,
};

// Enum Stalker2.EAnimationMovingStates
// NumValues: 0x0004
enum class EAnimationMovingStates : uint8
{
	Idle                                     = 0,
	Moving                                   = 1,
	ShootingMoving                           = 2,
	EAnimationMovingStates_MAX               = 3,
};

// Enum Stalker2.EAnimationIdleStates
// NumValues: 0x0004
enum class EAnimationIdleStates : uint8
{
	Idle                                     = 0,
	RelaxedIdle                              = 1,
	ShootingIdle                             = 2,
	EAnimationIdleStates_MAX                 = 3,
};

// Enum Stalker2.EAnimClimbState
// NumValues: 0x0014
enum class EAnimClimbState : uint8
{
	None                                     = 0,
	RightUp                                  = 1,
	LeftUp                                   = 2,
	RightDown                                = 3,
	LeftDown                                 = 4,
	ExitUpLadder                             = 5,
	EnterUpLadder                            = 6,
	EnterDownLadder                          = 7,
	FastDescentStartRight                    = 8,
	FastDescentStartLeft                     = 9,
	FastDescentStartBoth                     = 10,
	FastDescentLoop                          = 11,
	FastDescentExit                          = 12,
	FastDescentExitOnTop                     = 13,
	EnterLastStepUpRight                     = 14,
	EnterLastStepUpLeft                      = 15,
	EnterPreLastStepUpRight                  = 16,
	EnterPreLastStepUpLeft                   = 17,
	ExitLastStep                             = 18,
	EAnimClimbState_MAX                      = 19,
};

// Enum Stalker2.EWeaponIdleType
// NumValues: 0x0007
enum class EWeaponIdleType : uint8
{
	Default                                  = 0,
	GrenLauncher                             = 1,
	GrenLauncherAction                       = 2,
	BuckLauncher                             = 3,
	BuckLauncherAction                       = 4,
	Grip                                     = 5,
	EWeaponIdleType_MAX                      = 6,
};

// Enum Stalker2.EShutterState
// NumValues: 0x0005
enum class EShutterState : uint8
{
	None                                     = 0,
	ReadyToShoot                             = 1,
	FirstBarrelShot                          = 2,
	LastShot                                 = 3,
	EShutterState_MAX                        = 4,
};

// Enum Stalker2.EHealingType
// NumValues: 0x0004
enum class EHealingType : uint8
{
	Quest                                    = 0,
	HoldComponent                            = 1,
	Dialog                                   = 2,
	EHealingType_MAX                         = 3,
};

// Enum Stalker2.EWoundedAnimState
// NumValues: 0x0007
enum class EWoundedAnimState : uint8
{
	NotWounded                               = 0,
	Falling                                  = 1,
	RagdollLying                             = 2,
	RagdollWaking                            = 3,
	ReceiveHeal                              = 4,
	WakingUp                                 = 5,
	EWoundedAnimState_MAX                    = 6,
};

// Enum Stalker2.EWeaponCustomAdditionalIdle
// NumValues: 0x0002
enum class EWeaponCustomAdditionalIdle : uint8
{
	None                                     = 0,
	EWeaponCustomAdditionalIdle_MAX          = 1,
};

// Enum Stalker2.EWoundedType
// NumValues: 0x0004
enum class EWoundedType : uint8
{
	NotWounded                               = 0,
	GenericWounded                           = 1,
	QuestWounded                             = 2,
	EWoundedType_MAX                         = 3,
};

// Enum Stalker2.EWoundedState
// NumValues: 0x0005
enum class EWoundedState : uint8
{
	None                                     = 0,
	Falling                                  = 1,
	Fallen                                   = 2,
	Reviving                                 = 3,
	EWoundedState_MAX                        = 4,
};

// Enum Stalker2.EKnockedDownState
// NumValues: 0x0003
enum class EKnockedDownState : uint8
{
	NotKnockedDown                           = 0,
	KnockedDown                              = 1,
	EKnockedDownState_MAX                    = 2,
};

// Enum Stalker2.ECriticalHitState
// NumValues: 0x0003
enum class ECriticalHitState : uint8
{
	NotCriticalHit                           = 0,
	CriticalHit                              = 1,
	ECriticalHitState_MAX                    = 2,
};

// Enum Stalker2.EAnimationRequestType
// NumValues: 0x0007
enum class EAnimationRequestType : uint8
{
	None                                     = 0,
	WhenAvailableSlot                        = 1,
	WhenChangeState                          = 2,
	WhenAnimMontageBlendingOut               = 3,
	WhenAnimMontageEnded                     = 4,
	WhenAnimationStarted                     = 5,
	EAnimationRequestType_MAX                = 6,
};

// Enum Stalker2.EAnimationSlots
// NumValues: 0x0003
enum class EAnimationSlots : uint8
{
	DefaultSlot                              = 0,
	MainActionSlot                           = 1,
	EAnimationSlots_MAX                      = 2,
};

// Enum Stalker2.EAnimationLeanState
// NumValues: 0x0008
enum class EAnimationLeanState : uint8
{
	None                                     = 0,
	LeftIn                                   = 1,
	LeftIdle                                 = 2,
	LeftOut                                  = 3,
	RightIn                                  = 4,
	RightIdle                                = 5,
	RightOut                                 = 6,
	EAnimationLeanState_MAX                  = 7,
};

// Enum Stalker2.EAnimationAimState
// NumValues: 0x0005
enum class EAnimationAimState : uint8
{
	None                                     = 0,
	HipToAimActive                           = 1,
	AimToHipActive                           = 2,
	AimingActive                             = 3,
	EAnimationAimState_MAX                   = 4,
};

// Enum Stalker2.EAnimationStealthState
// NumValues: 0x0005
enum class EAnimationStealthState : uint8
{
	None                                     = 0,
	RelaxToStealthActive                     = 1,
	StealthToRelaxActive                     = 2,
	StealthActive                            = 3,
	EAnimationStealthState_MAX               = 4,
};

// Enum Stalker2.EAnimationReloadTypes
// NumValues: 0x000A
enum class EAnimationReloadTypes : uint8
{
	None                                     = 0,
	Full                                     = 1,
	Tactical                                 = 2,
	Unload                                   = 4,
	SingleBullet                             = 8,
	TwinFull                                 = 16,
	TwinTactical                             = 32,
	TwinFullAux                              = 64,
	TwinTacticalAux                          = 128,
	EAnimationReloadTypes_MAX                = 129,
};

// Enum Stalker2.EAnimationHands
// NumValues: 0x0005
enum class EAnimationHands : uint8
{
	None                                     = 0,
	LeftHand                                 = 1,
	RightHand                                = 2,
	BothHand                                 = 3,
	EAnimationHands_MAX                      = 4,
};

// Enum Stalker2.EEmotionalFaceMasks
// NumValues: 0x0007
enum class EEmotionalFaceMasks : uint8
{
	None                                     = 0,
	Surprised                                = 1,
	Angry                                    = 2,
	Scared                                   = 3,
	Sad                                      = 4,
	Happy                                    = 5,
	EEmotionalFaceMasks_MAX                  = 6,
};

// Enum Stalker2.EFaceBlockingBlendMasks
// NumValues: 0x0011
enum class EFaceBlockingBlendMasks : uint8
{
	Chin                                     = 0,
	LeftCheek                                = 1,
	RightCheek                               = 2,
	Mouth                                    = 3,
	OralCavity                               = 4,
	Nose                                     = 5,
	LeftEye                                  = 6,
	RightEye                                 = 7,
	LeftTemple                               = 8,
	RightTemple                              = 9,
	Forehead                                 = 10,
	Throat                                   = 11,
	GetCount                                 = 12,
	Cheeks                                   = 13,
	Eyes                                     = 14,
	Temples                                  = 15,
	EFaceBlockingBlendMasks_MAX              = 16,
};

// Enum Stalker2.EUpdateBulletSource
// NumValues: 0x0003
enum class EUpdateBulletSource : uint8
{
	Shoot                                    = 0,
	Reload                                   = 1,
	EUpdateBulletSource_MAX                  = 2,
};

// Enum Stalker2.EAIAnimationAction
// NumValues: 0x0009
enum class EAIAnimationAction : uint8
{
	None                                     = 0,
	HitBlendOut                              = 1,
	HitEnded                                 = 2,
	DeathRagdoll                             = 3,
	KnockDownIn                              = 4,
	KnockDownOut                             = 5,
	ZombieResurrect                          = 6,
	ResurectionComplete                      = 7,
	EAIAnimationAction_MAX                   = 8,
};

// Enum Stalker2.EDeathAnimationType
// NumValues: 0x000E
enum class EDeathAnimationType : uint8
{
	Default                                  = 0,
	Explosion                                = 1,
	Burn                                     = 2,
	ChemicalBurn                             = 3,
	Emission                                 = 4,
	Zombification                            = 5,
	HeadShot                                 = 6,
	DeadOnSpawn                              = 7,
	Killed                                   = 8,
	Drowned                                  = 9,
	Carousel                                 = 10,
	Shock                                    = 11,
	Physic                                   = 12,
	EDeathAnimationType_MAX                  = 13,
};

// Enum Stalker2.EAnimationThrowingType
// NumValues: 0x0007
enum class EAnimationThrowingType : uint8
{
	None                                     = 0,
	Weak                                     = 1,
	Strong                                   = 2,
	WeakOneHanded                            = 3,
	StrongOneHanded                          = 4,
	WithoutEquip                             = 5,
	EAnimationThrowingType_MAX               = 6,
};

// Enum Stalker2.EFootType
// NumValues: 0x0006
enum class EFootType : uint8
{
	None                                     = 0,
	FrontRightFoot                           = 1,
	FrontLeftFoot                            = 2,
	BackRightFoot                            = 3,
	BackLeftFoot                             = 4,
	EFootType_MAX                            = 5,
};

// Enum Stalker2.EBleedingStatusLog
// NumValues: 0x0003
enum class EBleedingStatusLog : uint8
{
	None                                     = 0,
	BleedingDamage                           = 1,
	EBleedingStatusLog_MAX                   = 2,
};

// Enum Stalker2.EDebugBulletLog
// NumValues: 0x0014
enum class EDebugBulletLog : uint16
{
	None                                     = 0,
	BaseDamage                               = 1,
	LastBulletDamage                         = 2,
	DistanceScalingDamage                    = 4,
	ArmorScalingDamage                       = 8,
	BoneScalingDamage                        = 16,
	BotsBaseDamage                           = 32,
	BotsLastBulletDamage                     = 64,
	BotsDistanceScalingDamage                = 128,
	BotsArmorScalingDamage                   = 256,
	BotsBoneScalingDamage                    = 512,
	OnlyBaseDamage                           = 33,
	OnlyLastBulletDamage                     = 66,
	OnlyDistanceScalingDamage                = 132,
	OnlyArmorScalingDamage                   = 264,
	OnlyBoneScalingDamage                    = 528,
	PlayerDamage                             = 31,
	BotsDamage                               = 992,
	Everything                               = 1023,
	EDebugBulletLog_MAX                      = 1024,
};

// Enum Stalker2.EInteractFXType
// NumValues: 0x000D
enum class EInteractFXType : uint32
{
	None                                     = 0,
	LadderIdle                               = 2,
	LadderMovementHand                       = 4,
	LadderMovementFoot                       = 8,
	LadderMovementJump                       = 16,
	LadderMovementFast                       = 32,
	LadderStartInteractBottom                = 64,
	LadderEndInteractTop                     = 128,
	LadderStartInteractTop                   = 256,
	LadderEndInteractBot                     = 512,
	LadderMevementFastEnd                    = 1024,
	Ladder                                   = 2046,
	EInteractFXType_MAX                      = 2047,
};

// Enum Stalker2.ELadderType
// NumValues: 0x0006
enum class ELadderType : uint8
{
	Blockout                                 = 0,
	Wood                                     = 1,
	MetalCorner                              = 2,
	MetalPipe                                = 3,
	MetalClip                                = 4,
	ELadderType_MAX                          = 5,
};

// Enum Stalker2.EPathFollowingMode
// NumValues: 0x0006
enum class EPathFollowingMode : uint8
{
	None                                     = 0,
	PreferAnimElseProcedural                 = 1,
	PreferProceduralElseAnim                 = 2,
	PreferProceduralElseStop                 = 3,
	GetCount                                 = 4,
	EPathFollowingMode_MAX                   = 5,
};

// Enum Stalker2.EPostProcessParam
// NumValues: 0x001A
enum class EPostProcessParam : uint8
{
	Anomaly                                  = 0,
	RadiationNoise                           = 1,
	RadiationSepia                           = 2,
	PoppyField                               = 3,
	SleepinessVignette                       = 4,
	DamageBloodIntensity                     = 5,
	BloodTopMaskIntensity                    = 6,
	BloodRightMaskIntensity                  = 7,
	BloodBottomMaskIntensity                 = 8,
	BloodLeftMaskIntensity                   = 9,
	PulsationIntensityMin                    = 10,
	PulsationIntensityMax                    = 11,
	LeakingBloodIntensity                    = 12,
	LeakingBloodPulsationIntensityMin        = 13,
	LeakingBloodPulsationIntensityMax        = 14,
	RainIntensity                            = 15,
	GaussianBlur                             = 16,
	PsyFieldSepia                            = 17,
	ChemicalIntensity                        = 18,
	ExpulsionCompletion                      = 19,
	CarouselIntensity                        = 20,
	BurnIntensity                            = 21,
	DrunknessIntensity                       = 22,
	SuppressionGaussianBlur                  = 23,
	GetCount                                 = 24,
	EPostProcessParam_MAX                    = 25,
};

// Enum Stalker2.ESettingCategoryType
// NumValues: 0x000E
enum class ESettingCategoryType : uint8
{
	None                                     = 0,
	Gameplay                                 = 1,
	Input                                    = 2,
	InputMappings                            = 3,
	UI                                       = 4,
	Audio                                    = 5,
	Graphics                                 = 6,
	Display                                  = 7,
	Accessibility                            = 8,
	FirstTime                                = 9,
	Debug                                    = 10,
	All                                      = 11,
	GetCount                                 = 12,
	ESettingCategoryType_MAX                 = 13,
};

// Enum Stalker2.EScalabilitySetting
// NumValues: 0x0015
enum class EScalabilitySetting : uint8
{
	ResolutionQuality                        = 0,
	ViewDistanceQuality                      = 1,
	AntiAliasingQuality                      = 2,
	ShadowQuality                            = 3,
	GlobalIlluminationQuality                = 4,
	ReflectionQuality                        = 5,
	PostProcessQuality                       = 6,
	TextureQuality                           = 7,
	EffectsQuality                           = 8,
	FoliageQuality                           = 9,
	ShadingQuality                           = 10,
	HairQuality                              = 11,
	ObjectDetailQuality                      = 12,
	VolumetricFogQuality                     = 13,
	VolumetricCloudsQuality                  = 14,
	SkyQuality                               = 15,
	MaterialQuality                          = 16,
	MotionBlurQuality                        = 17,
	DOFQuality                               = 18,
	GetCount                                 = 19,
	EScalabilitySetting_MAX                  = 20,
};

// Enum Stalker2.EScalabilityQuality
// NumValues: 0x0011
enum class EScalabilityQuality : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Epic                                     = 3,
	Cinematic                                = 4,
	XSX_Quality                              = 5,
	XSX_Performance                          = 6,
	XSS_Quality                              = 7,
	XSS_Performance                          = 8,
	GCin                                     = 9,
	GNar                                     = 10,
	GLev                                     = 11,
	GEC                                      = 12,
	GTemp                                    = 13,
	GDefault                                 = 14,
	GetCount                                 = 15,
	EScalabilityQuality_MAX                  = 16,
};

// Enum Stalker2.ESubtitlesSize
// NumValues: 0x0005
enum class ESubtitlesSize : uint8
{
	Small                                    = 0,
	Standart                                 = 1,
	Big                                      = 2,
	GetCount                                 = 3,
	ESubtitlesSize_MAX                       = 4,
};

// Enum Stalker2.ECrosshairTypeSetting
// NumValues: 0x0004
enum class ECrosshairTypeSetting : uint8
{
	Regular                                  = 0,
	Dot                                      = 1,
	GetCount                                 = 2,
	ECrosshairTypeSetting_MAX                = 3,
};

// Enum Stalker2.ECameraShakeEffectSubtype
// NumValues: 0x0005
enum class ECameraShakeEffectSubtype : uint8
{
	None                                     = 0,
	AddEffect                                = 1,
	RemoveEffect                             = 2,
	GetCount                                 = 3,
	ECameraShakeEffectSubtype_MAX            = 4,
};

// Enum Stalker2.ESoundEffectSubtype
// NumValues: 0x0009
enum class ESoundEffectSubtype : uint8
{
	None                                     = 0,
	SetState                                 = 1,
	SetSwitch                                = 2,
	SetParameter                             = 3,
	SetGlobalParameter                       = 4,
	PlaySoundAttached                        = 5,
	StopInfiniteSound                        = 6,
	GetCount                                 = 7,
	ESoundEffectSubtype_MAX                  = 8,
};

// Enum Stalker2.EArmorScale
// NumValues: 0x0006
enum class EArmorScale : uint8
{
	LightArmor                               = 0,
	MediumArmor                              = 1,
	HeavyArmor                               = 2,
	SuperHeavyArmor                          = 3,
	GetCount                                 = 4,
	EArmorScale_MAX                          = 5,
};

// Enum Stalker2.ERadiationPreset
// NumValues: 0x000A
enum class ERadiationPreset : uint8
{
	None                                     = 0,
	Light                                    = 1,
	Medium                                   = 2,
	Strong                                   = 3,
	Deadly                                   = 4,
	RadBlock                                 = 5,
	Custom                                   = 6,
	Topaz                                    = 7,
	GetCount                                 = 8,
	ERadiationPreset_MAX                     = 9,
};

// Enum Stalker2.ERadiationInnerOffsetPreset
// NumValues: 0x0006
enum class ERadiationInnerOffsetPreset : uint8
{
	None                                     = 0,
	Half                                     = 1,
	Full                                     = 2,
	Custom                                   = 3,
	GetCount                                 = 4,
	ERadiationInnerOffsetPreset_MAX          = 5,
};

// Enum Stalker2.EInteractionSystemNotificationsType
// NumValues: 0x0009
enum class EInteractionSystemNotificationsType : uint8
{
	None                                     = 0,
	Cache                                    = 1,
	Note                                     = 2,
	Audio                                    = 3,
	Encyclopedia                             = 4,
	Region                                   = 5,
	Inspect                                  = 6,
	Blueprint                                = 7,
	EInteractionSystemNotificationsType_MAX  = 8,
};

// Enum Stalker2.EColorBlindMode
// NumValues: 0x0006
enum class EColorBlindMode : uint8
{
	None                                     = 0,
	Protanopia                               = 1,
	Deuteranopia                             = 2,
	Tritanopia                               = 3,
	GetCount                                 = 4,
	EColorBlindMode_MAX                      = 5,
};

// Enum Stalker2.EStageUI
// NumValues: 0x0012
enum class EStageUI : uint8
{
	None                                     = 0,
	Show                                     = 1,
	Update                                   = 2,
	Hide                                     = 4,
	PermanentHide                            = 8,
	ShowUpdate                               = 3,
	ShowHide                                 = 5,
	ShowPermanentHide                        = 9,
	UpdateHide                               = 6,
	UpdatePermanentHide                      = 10,
	HidePermanentHide                        = 12,
	ShowUpdateHide                           = 7,
	ShowUpdatePermanentHide                  = 11,
	ShowHidePermanentHide                    = 13,
	UpdateHidePermanentHide                  = 14,
	ShowUpdateHidePermanentHide              = 15,
	GetCount                                 = 16,
	EStageUI_MAX                             = 17,
};

// Enum Stalker2.EElementUI
// NumValues: 0x002F
enum class EElementUI : uint8
{
	None                                     = 0,
	All                                      = 1,
	AllWindows                               = 2,
	Ammo                                     = 3,
	Clock                                    = 4,
	CombinationLock                          = 5,
	Compass                                  = 6,
	CrossHair                                = 7,
	DeathScreen                              = 8,
	Dialog                                   = 9,
	EquipmentSlots                           = 10,
	FadeoutScreen                            = 11,
	GrenadeCounter                           = 12,
	HP                                       = 13,
	Inventory                                = 14,
	InteractionProgressBar                   = 15,
	InteractionPrompt                        = 16,
	InteractionPromptParameters              = 17,
	ItemsInInventoryContainer                = 18,
	ItemSelector                             = 19,
	Menu                                     = 20,
	Minimap                                  = 21,
	MoneyInBag                               = 22,
	MoneyInTrader                            = 23,
	Quests                                   = 24,
	PickedItem                               = 25,
	Radiation                                = 26,
	RadiationBar                             = 27,
	SleepMenu                                = 28,
	SlotsInInventoryContainer                = 29,
	SlotsInStorageContainer                  = 30,
	SlotsInTraderContainer                   = 31,
	StackSplittingWindow                     = 32,
	Stamina                                  = 33,
	Stats                                    = 34,
	StatsIconBar                             = 35,
	Stealth                                  = 36,
	Storage                                  = 37,
	Subtitles                                = 38,
	Teleport                                 = 39,
	Trader                                   = 40,
	Upgrade                                  = 41,
	WeaponSelector                           = 42,
	WeightInBag                              = 43,
	WorldMap                                 = 44,
	GetCount                                 = 45,
	EElementUI_MAX                           = 46,
};

// Enum Stalker2.EHUDElements
// NumValues: 0x000E
enum class EHUDElements : uint32
{
	None                                     = 0,
	HP                                       = 1,
	Stamina                                  = 2,
	Stealth                                  = 4,
	Minimap                                  = 8,
	Radiation                                = 16,
	PDA                                      = 32,
	AmmoBar                                  = 64,
	Crosshair                                = 128,
	StatsIcons                               = 256,
	BasicHUD                                 = 479,
	Everything                               = 511,
	GetCount                                 = 512,
	EHUDElements_MAX                         = 513,
};

// Enum Stalker2.EReflectionUpdatePriority
// NumValues: 0x0006
enum class EReflectionUpdatePriority : uint8
{
	High                                     = 0,
	Medium                                   = 1,
	Low                                      = 2,
	Minimal                                  = 3,
	GetCount                                 = 4,
	EReflectionUpdatePriority_MAX            = 5,
};

// Enum Stalker2.ESpeechState
// NumValues: 0x0006
enum class ESpeechState : uint8
{
	None                                     = 0,
	Load                                     = 1,
	Play                                     = 2,
	Pause                                    = 3,
	Finish                                   = 4,
	ESpeechState_MAX                         = 5,
};

// Enum Stalker2.ELocalizationLanguage
// NumValues: 0x0015
enum class ELocalizationLanguage : uint8
{
	Ukrainian                                = 0,
	English                                  = 1,
	German                                   = 2,
	French                                   = 3,
	SpanishEuropean                          = 4,
	Italian                                  = 5,
	Polish                                   = 6,
	Czech                                    = 7,
	Turkish                                  = 8,
	Serbian                                  = 9,
	PortugalBrazilian                        = 10,
	SpanishLatinoAmerican                    = 11,
	Arabic                                   = 12,
	ChineseSimplified                        = 13,
	ChineseTraditional                       = 14,
	Japanese                                 = 15,
	Korean                                   = 16,
	Russian                                  = 17,
	GetCount                                 = 18,
	GetAudioCount                            = 2,
	ELocalizationLanguage_MAX                = 19,
};

// Enum Stalker2.EPathControlPointType
// NumValues: 0x0004
enum class EPathControlPointType : uint8
{
	Regular                                  = 0,
	Avoidance                                = 1,
	GetCount                                 = 2,
	EPathControlPointType_MAX                = 3,
};

// Enum Stalker2.EMainSoundClass
// NumValues: 0x000A
enum class EMainSoundClass : uint8
{
	All                                      = 0,
	Music                                    = 1,
	SFX                                      = 2,
	Ambient                                  = 3,
	Player                                   = 4,
	Weapon                                   = 5,
	UI                                       = 6,
	NPC                                      = 7,
	GetCount                                 = 8,
	EMainSoundClass_MAX                      = 9,
};

// Enum Stalker2.ESecondarySoundClass
// NumValues: 0x0023
enum class ESecondarySoundClass : uint8
{
	HitMark                                  = 0,
	FTS                                      = 1,
	Equip                                    = 2,
	ImpactFrom                               = 3,
	Breath                                   = 4,
	P_Gun                                    = 5,
	P_Fire                                   = 6,
	P_Tail                                   = 7,
	Frag                                     = 8,
	Impact                                   = 9,
	Handling                                 = 10,
	Gun                                      = 11,
	Fire                                     = 12,
	Tail                                     = 13,
	Human                                    = 14,
	Creature                                 = 15,
	Polter                                   = 16,
	Menu                                     = 17,
	Inventory                                = 18,
	Calm                                     = 19,
	Fight                                    = 20,
	Suspicious                               = 21,
	Anomaly                                  = 22,
	Drone                                    = 23,
	Destruct                                 = 24,
	Int_Props                                = 25,
	Unassign                                 = 26,
	WeatherBioms                             = 27,
	InternalsScatter                         = 28,
	Transition                               = 29,
	Props                                    = 30,
	DayScatter                               = 31,
	NightScatter                             = 32,
	GetCount                                 = 33,
	ESecondarySoundClass_MAX                 = 34,
};

// Enum Stalker2.EGlobalVariableType
// NumValues: 0x0005
enum class EGlobalVariableType : uint8
{
	Int                                      = 0,
	String                                   = 1,
	Bool                                     = 2,
	GetCount                                 = 3,
	EGlobalVariableType_MAX                  = 4,
};

// Enum Stalker2.EDayOfWeekFlag
// NumValues: 0x0008
enum class EDayOfWeekFlag : uint8
{
	Monday                                   = 1,
	Tuesday                                  = 2,
	Wednesday                                = 4,
	Thursday                                 = 8,
	Friday                                   = 16,
	Saturday                                 = 32,
	Sunday                                   = 64,
	EDayOfWeekFlag_MAX                       = 65,
};

// Enum Stalker2.EInputController
// NumValues: 0x0004
enum class EInputController : uint8
{
	KeyboardAndMouse                         = 0,
	Dualshock4                               = 1,
	XboxSeriesXPad                           = 2,
	EInputController_MAX                     = 3,
};

// Enum Stalker2.EOverrideDialogTopic
// NumValues: 0x000F
enum class EOverrideDialogTopic : uint8
{
	None                                     = 0,
	Hello                                    = 1,
	Bye                                      = 2,
	Info                                     = 3,
	Defeat                                   = 4,
	DefeatComment                            = 5,
	CallPlayerComment                        = 6,
	Resume                                   = 7,
	Busy                                     = 8,
	Trade                                    = 9,
	Upgrade                                  = 10,
	Travel                                   = 11,
	Forced                                   = 12,
	GetCount                                 = 13,
	EOverrideDialogTopic_MAX                 = 14,
};

// Enum Stalker2.ECollisionFormType
// NumValues: 0x0006
enum class ECollisionFormType : uint8
{
	None                                     = 0,
	Box                                      = 1,
	Sphere                                   = 2,
	Cylinder                                 = 3,
	Custom                                   = 4,
	ECollisionFormType_MAX                   = 5,
};

// Enum Stalker2.EPDASignalStrength
// NumValues: 0x0006
enum class EPDASignalStrength : uint8
{
	Minimal                                  = 0,
	Low                                      = 1,
	Normal                                   = 2,
	Full                                     = 3,
	None                                     = 4,
	EPDASignalStrength_MAX                   = 5,
};

// Enum Stalker2.EEmissionState
// NumValues: 0x0006
enum class EEmissionState : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Active                                   = 2,
	Paused                                   = 3,
	GetCount                                 = 4,
	EEmissionState_MAX                       = 5,
};

// Enum Stalker2.EEmissionStage
// NumValues: 0x0008
enum class EEmissionStage : uint8
{
	None                                     = 0,
	BeforeTheStorm                           = 1,
	ActivateQuest                            = 2,
	ShockWave                                = 3,
	Active                                   = 4,
	AfterTheStorm                            = 5,
	GetCount                                 = 6,
	EEmissionStage_MAX                       = 7,
};

// Enum Stalker2.EWeather
// NumValues: 0x000B
enum class EWeather : uint8
{
	Clearly                                  = 0,
	Cloudy                                   = 1,
	Fogy                                     = 2,
	Stormy                                   = 3,
	LightRainy                               = 4,
	Rainy                                    = 5,
	Thundery                                 = 6,
	Emission                                 = 7,
	CalmBeforeEmission                       = 8,
	Count                                    = 9,
	EWeather_MAX                             = 10,
};

// Enum Stalker2.EFlashlightPriority
// NumValues: 0x0005
enum class EFlashlightPriority : uint8
{
	FlashlightWeaponAttachment               = 0,
	AdditionalAttachment                     = 1,
	Head                                     = 2,
	Chest                                    = 3,
	EFlashlightPriority_MAX                  = 4,
};

// Enum Stalker2.EDetectorMode
// NumValues: 0x0003
enum class EDetectorMode : uint8
{
	Inactive                                 = 0,
	Active                                   = 1,
	EDetectorMode_MAX                        = 2,
};

// Enum Stalker2.EItemCacheVisibilityType
// NumValues: 0x0003
enum class EItemCacheVisibilityType : uint8
{
	ClueRequired                             = 0,
	AlwaysAvailable                          = 1,
	EItemCacheVisibilityType_MAX             = 2,
};

// Enum Stalker2.EItemCacheType
// NumValues: 0x0004
enum class EItemCacheType : uint8
{
	Stash                                    = 0,
	PackOfItems                              = 1,
	Destructible                             = 2,
	EItemCacheType_MAX                       = 3,
};

// Enum Stalker2.EItemCacheGenerationType
// NumValues: 0x0005
enum class EItemCacheGenerationType : uint8
{
	Random                                   = 0,
	PlayerBasedStats                         = 1,
	Preset                                   = 2,
	Mixed                                    = 3,
	EItemCacheGenerationType_MAX             = 4,
};

// Enum Stalker2.EItemCacheRarity
// NumValues: 0x0005
enum class EItemCacheRarity : uint8
{
	Common                                   = 0,
	Uncommon                                 = 1,
	Rare                                     = 2,
	Epic                                     = 3,
	EItemCacheRarity_MAX                     = 4,
};

// Enum Stalker2.EPlayerConditionType
// NumValues: 0x0005
enum class EPlayerConditionType : uint8
{
	None                                     = 0,
	CurrentHealth                            = 1,
	CurrentAmmo                              = 2,
	ItemCount                                = 3,
	EPlayerConditionType_MAX                 = 4,
};

// Enum Stalker2.ERank
// NumValues: 0x0006
enum class ERank : uint8
{
	Newbie                                   = 0,
	Experienced                              = 1,
	Veteran                                  = 2,
	Master                                   = 3,
	GetCount                                 = 4,
	ERank_MAX                                = 5,
};

// Enum Stalker2.EShotDistanceType
// NumValues: 0x0005
enum class EShotDistanceType : uint8
{
	Short                                    = 0,
	Medium                                   = 1,
	Long                                     = 2,
	GetCount                                 = 3,
	EShotDistanceType_MAX                    = 4,
};

// Enum Stalker2.ESpawnSource
// NumValues: 0x0006
enum class ESpawnSource : uint8
{
	Quest                                    = 0,
	ALife                                    = 1,
	ALifeDirector                            = 2,
	SummonAbility                            = 3,
	Debug                                    = 4,
	ESpawnSource_MAX                         = 5,
};

// Enum Stalker2.ESpawnNodeExcludeType
// NumValues: 0x0004
enum class ESpawnNodeExcludeType : uint8
{
	SeamlessDespawn                          = 0,
	ForceDespawn                             = 1,
	KillSpawnedObj                           = 2,
	ESpawnNodeExcludeType_MAX                = 3,
};

// Enum Stalker2.EGSCInputDeviceType
// NumValues: 0x0004
enum class EGSCInputDeviceType : uint8
{
	MouseKeyboard                            = 0,
	DefaultGamepad                           = 1,
	Undefined                                = 2,
	EGSCInputDeviceType_MAX                  = 3,
};

// Enum Stalker2.EGSCPlatformType
// NumValues: 0x0005
enum class EGSCPlatformType : uint8
{
	None                                     = 0,
	PC                                       = 1,
	XSX                                      = 2,
	PS5                                      = 4,
	EGSCPlatformType_MAX                     = 5,
};

// Enum Stalker2.EVitalState
// NumValues: 0x0004
enum class EVitalState : uint8
{
	Alive                                    = 0,
	Dead                                     = 1,
	Zombie                                   = 2,
	EVitalState_MAX                          = 3,
};

// Enum Stalker2.EObjSkeletalMeshTraceBone
// NumValues: 0x0012
enum class EObjSkeletalMeshTraceBone : uint16
{
	None                                     = 0,
	Head                                     = 1,
	Chest                                    = 2,
	RArm                                     = 4,
	LArm                                     = 8,
	Pelvis                                   = 16,
	RKnee                                    = 32,
	LKnee                                    = 64,
	RLeg                                     = 128,
	LLeg                                     = 256,
	Arms                                     = 12,
	Knees                                    = 96,
	Legs                                     = 384,
	UpperBody                                = 15,
	LowerBody                                = 496,
	EveryBone                                = 511,
	GetCount                                 = 512,
	EObjSkeletalMeshTraceBone_MAX            = 513,
};

// Enum Stalker2.EGrenadeDebugFlag
// NumValues: 0x0008
enum class EGrenadeDebugFlag : uint32
{
	None                                     = 0,
	DrawFragments                            = 1,
	DrawInnerRadius                          = 2,
	DrawOuterRadius                          = 4,
	DrawTraces                               = 8,
	DrawRadii                                = 6,
	Everything                               = 15,
	EGrenadeDebugFlag_MAX                    = 16,
};

// Enum Stalker2.EInputAxisType
// NumValues: 0x0006
enum class EInputAxisType : uint8
{
	None                                     = 0,
	XY                                       = 1,
	Rotate2D                                 = 2,
	Rotate2DInertia                          = 3,
	Jump                                     = 4,
	EInputAxisType_MAX                       = 5,
};

// Enum Stalker2.ETriggerReact
// NumValues: 0x0004
enum class ETriggerReact : uint8
{
	ReactOnAlive                             = 0,
	ReactOnDead                              = 1,
	ReactBoth                                = 2,
	ETriggerReact_MAX                        = 3,
};

// Enum Stalker2.ESortGroup
// NumValues: 0x000D
enum class ESortGroup : uint8
{
	None                                     = 18446744073709551615,
	Up                                       = 0,
	Down                                     = 1,
	Left                                     = 2,
	Right                                    = 3,
	HP                                       = 4,
	Bleeding                                 = 5,
	Radiations                               = 6,
	Stamina                                  = 7,
	Buff                                     = 8,
	Hunger                                   = 9,
	GetCount                                 = 10,
	ESortGroup_MAX                           = 11,
};

// Enum Stalker2.ENoteType
// NumValues: 0x0006
enum class ENoteType : uint32
{
	Flash                                    = 0,
	Data                                     = 1,
	Notes                                    = 2,
	Audio                                    = 3,
	GetCount                                 = 4,
	ENoteType_MAX                            = 5,
};

// Enum Stalker2.EPDATutorialCategory
// NumValues: 0x0006
enum class EPDATutorialCategory : uint32
{
	Navigation                               = 0,
	Fight                                    = 1,
	Survival                                 = 2,
	Earning                                  = 3,
	GetCount                                 = 4,
	EPDATutorialCategory_MAX                 = 5,
};

// Enum Stalker2.EGaussWeaponDisplayState
// NumValues: 0x0004
enum class EGaussWeaponDisplayState : uint8
{
	Default                                  = 0,
	Discharge                                = 1,
	Charge                                   = 2,
	EGaussWeaponDisplayState_MAX             = 3,
};

// Enum Stalker2.EMappingContext
// NumValues: 0x0033
enum class EMappingContext : uint32
{
	None                                     = 0,
	Exploration                              = 1,
	Inventory                                = 2,
	Trade                                    = 3,
	ItemSelector                             = 4,
	AttachSelector                           = 5,
	Dialogue                                 = 6,
	DialogueOnTheGo                          = 7,
	ImportantChoice                          = 8,
	Debug                                    = 9,
	PDA                                      = 10,
	Map                                      = 11,
	Journal                                  = 12,
	Note                                     = 13,
	Sleep                                    = 14,
	Ladder                                   = 15,
	NoInput                                  = 16,
	Upgrades                                 = 17,
	UpgradesPopup                            = 18,
	UpgradesNavigation                       = 19,
	Codelock                                 = 20,
	Menu                                     = 21,
	Aiming                                   = 22,
	Bolt                                     = 23,
	Grenade                                  = 24,
	Knife                                    = 25,
	PDA_Encyclopedia                         = 26,
	PDA_Stats                                = 27,
	DeathScreen                              = 28,
	Cutscene                                 = 29,
	QuestNotification                        = 30,
	SystemNotifications                      = 31,
	StealthKill                              = 32,
	Interactivity                            = 33,
	Popup                                    = 34,
	PDATutorial                              = 35,
	MenuSettings                             = 36,
	PlayMovie                                = 37,
	Subtitle                                 = 38,
	Presentation                             = 39,
	EULA                                     = 40,
	PlayerContextualAction                   = 41,
	InspectArtifact                          = 42,
	ModBrowser                               = 43,
	StackSplitMenu                           = 44,
	RightClickContextualMenu                 = 45,
	Guitar                                   = 46,
	EditSafeZone                             = 47,
	LoadingScreen                            = 48,
	GetCount                                 = 49,
	EMappingContext_MAX                      = 50,
};

// Enum Stalker2.EInputMappingContextPriority
// NumValues: 0x0006
enum class EInputMappingContextPriority : uint8
{
	Lowest                                   = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	Exclusive                                = 4,
	EInputMappingContextPriority_MAX         = 5,
};

// Enum Stalker2.ECharacterType
// NumValues: 0x0003
enum class ECharacterType : uint8
{
	Player                                   = 0,
	NPC                                      = 1,
	ECharacterType_MAX                       = 2,
};

// Enum Stalker2.ECinematicParameter
// NumValues: 0x0008
enum class ECinematicParameter : uint8
{
	None                                     = 0,
	MovementSpeedMultiplier                  = 1,
	HudVisibility                            = 2,
	AnimationCameraYawLimit                  = 3,
	AnimationCameraPitchLimit                = 4,
	AnimationCameraMultiplier                = 5,
	GetCount                                 = 6,
	ECinematicParameter_MAX                  = 7,
};

// Enum Stalker2.EBrokenGameDataFilter
// NumValues: 0x0006
enum class EBrokenGameDataFilter : uint8
{
	None                                     = 0,
	QuestPart                                = 1,
	UnderDraftComment                        = 2,
	IsInWhiteList                            = 3,
	GetCount                                 = 4,
	EBrokenGameDataFilter_MAX                = 5,
};

// Enum Stalker2.EPostEffectProcessorType
// NumValues: 0x0008
enum class EPostEffectProcessorType : uint8
{
	None                                     = 0,
	Constant                                 = 1,
	Lerp                                     = 2,
	FloatProvider                            = 3,
	Raw                                      = 4,
	Cyclical                                 = 5,
	GetCount                                 = 6,
	EPostEffectProcessorType_MAX             = 7,
};

// Enum Stalker2.EDuplicateResolveType
// NumValues: 0x0004
enum class EDuplicateResolveType : uint8
{
	KeepNew                                  = 0,
	KeepOld                                  = 1,
	KeepAll                                  = 2,
	EDuplicateResolveType_MAX                = 3,
};

// Enum Stalker2.ESaveType
// NumValues: 0x0006
enum class ESaveType : uint8
{
	Manual                                   = 0,
	Auto                                     = 1,
	Quick                                    = 2,
	Quest                                    = 3,
	GetCount                                 = 4,
	ESaveType_MAX                            = 5,
};

// Enum Stalker2.ECrosshairType
// NumValues: 0x0007
enum class ECrosshairType : uint8
{
	Cross                                    = 0,
	Circle                                   = 1,
	Point                                    = 2,
	Arc                                      = 3,
	Empty                                    = 4,
	GetCount                                 = 5,
	ECrosshairType_MAX                       = 6,
};

// Enum Stalker2.ESaveLoadResult
// NumValues: 0x0014
enum class ESaveLoadResult : uint8
{
	Success                                  = 0,
	InvalidCampaign                          = 1,
	NoFreeSaveSlots                          = 2,
	CantOverwriteSave                        = 3,
	DataSaveFailed                           = 4,
	LoadFileDoesNotExist                     = 5,
	LoadFileReadingFailed                    = 6,
	CampaignsSaveFailed                      = 7,
	CampaignsFileReadingFailed               = 8,
	SaveDoesNotExist                         = 9,
	SaveDeleteFailed                         = 10,
	ThumbnailDeleteFailed                    = 11,
	NoFreeCampaignSlots                      = 12,
	NoSavesToLoad                            = 13,
	CantAutosave                             = 14,
	SavingRestricted                         = 15,
	GenericError                             = 16,
	SaveInProgress                           = 17,
	GetCount                                 = 18,
	ESaveLoadResult_MAX                      = 19,
};

// Enum Stalker2.ELoadingStep
// NumValues: 0x000E
enum class ELoadingStep : uint8
{
	InitializingManagers                     = 0,
	InitializingNewGame                      = 1,
	StartingScripts                          = 2,
	SpawningPlaceholders                     = 3,
	InitializingWeather                      = 4,
	LoadingNecessaryModels                   = 5,
	LoadingNecessaryActors                   = 6,
	LoadingStart                             = 7,
	LoadingModelsData                        = 8,
	LoadingManagersData                      = 9,
	FinishingUp                              = 10,
	Complete                                 = 11,
	GetCount                                 = 12,
	ELoadingStep_MAX                         = 13,
};

// Enum Stalker2.EObjSpawnStage
// NumValues: 0x0007
enum class EObjSpawnStage : uint8
{
	HasModel                                 = 0,
	HasBlueprintActor                        = 1,
	MeshGenerationStarted                    = 2,
	ProcessedFlashlight                      = 3,
	CheckingPlayerVisiblity                  = 4,
	FinishedSpawn                            = 5,
	EObjSpawnStage_MAX                       = 6,
};

// Enum Stalker2.EPsyNPCType
// NumValues: 0x0004
enum class EPsyNPCType : uint8
{
	None                                     = 0,
	PsyNPC                                   = 1,
	PsyPhantom                               = 2,
	EPsyNPCType_MAX                          = 3,
};

// Enum Stalker2.ECrashStoredType
// NumValues: 0x000A
enum class ECrashStoredType : uint8
{
	None                                     = 0,
	ActiveNodes                              = 1,
	ActiveQuests                             = 2,
	Inventory                                = 3,
	Health                                   = 4,
	Stamina                                  = 5,
	DrinkLevel                               = 6,
	RadiationLevel                           = 7,
	GetCount                                 = 8,
	ECrashStoredType_MAX                     = 9,
};

// Enum Stalker2.ESleepAvailability
// NumValues: 0x0006
enum class ESleepAvailability : uint8
{
	Available                                = 0,
	NotTired                                 = 1,
	Emission                                 = 2,
	NegativeEffect                           = 3,
	InBattle                                 = 4,
	ESleepAvailability_MAX                   = 5,
};

// Enum Stalker2.ECameraShakeType
// NumValues: 0x0006
enum class ECameraShakeType : uint8
{
	None                                     = 0,
	Constant                                 = 1,
	Vital                                    = 2,
	FloatProvider                            = 3,
	GetCount                                 = 4,
	ECameraShakeType_MAX                     = 5,
};

// Enum Stalker2.ECameraShakeGroupType
// NumValues: 0x0005
enum class ECameraShakeGroupType : uint8
{
	None                                     = 0,
	Priority                                 = 1,
	MaxCount                                 = 2,
	GetCount                                 = 3,
	ECameraShakeGroupType_MAX                = 4,
};

// Enum Stalker2.EModifyAbilitySequenceQuestNodeMode
// NumValues: 0x0003
enum class EModifyAbilitySequenceQuestNodeMode : uint8
{
	AddAbility                               = 0,
	RemoveAbility                            = 1,
	EModifyAbilitySequenceQuestNodeMode_MAX  = 2,
};

// Enum Stalker2.EAudioRoomPresetBandwidth
// NumValues: 0x0009
enum class EAudioRoomPresetBandwidth : uint8
{
	None                                     = 0,
	Custom                                   = 1,
	Close                                    = 2,
	HalfOpen                                 = 3,
	Open                                     = 4,
	Isolated                                 = 5,
	PsyDome                                  = 6,
	GetCount                                 = 7,
	EAudioRoomPresetBandwidth_MAX            = 8,
};

// Enum Stalker2.EFloatProviderType
// NumValues: 0x000E
enum class EFloatProviderType : uint8
{
	None                                     = 0,
	Constant                                 = 1,
	Conditional                              = 2,
	PlayerVital                              = 3,
	Weather                                  = 4,
	PostEffect                               = 5,
	Blink                                    = 6,
	ObjParam                                 = 7,
	Add                                      = 8,
	Subtract                                 = 9,
	Multiply                                 = 10,
	Divide                                   = 11,
	GetCount                                 = 12,
	EFloatProviderType_MAX                   = 13,
};

// Enum Stalker2.EBoolProviderType
// NumValues: 0x0010
enum class EBoolProviderType : uint8
{
	None                                     = 0,
	Constant                                 = 1,
	And                                      = 2,
	Or                                       = 3,
	Not                                      = 4,
	PlayerUnderRoof                          = 5,
	PlayerRank                               = 6,
	TargetRank                               = 7,
	FactionRelation                          = 8,
	TargetRelation                           = 9,
	TraderRegenerationHours                  = 10,
	TraderRegenerationDays                   = 11,
	TargetHasEffectBoolProvider              = 12,
	TargetInShelter                          = 13,
	GetCount                                 = 14,
	EBoolProviderType_MAX                    = 15,
};

// Enum Stalker2.EWeatherParam
// NumValues: 0x0004
enum class EWeatherParam : uint8
{
	None                                     = 0,
	RainIntensity                            = 1,
	GetCount                                 = 2,
	EWeatherParam_MAX                        = 3,
};

// Enum Stalker2.EAimAssistWeightType
// NumValues: 0x0008
enum class EAimAssistWeightType : uint8
{
	None                                     = 0,
	DistanceFromApex                         = 1,
	DistanceFromCenter                       = 2,
	Angle                                    = 3,
	Intensity                                = 4,
	IsTargetHostile                          = 5,
	GetCount                                 = 6,
	EAimAssistWeightType_MAX                 = 7,
};

// Enum Stalker2.EALifeDirectorScenarioTarget
// NumValues: 0x0008
enum class EALifeDirectorScenarioTarget : uint8
{
	None                                     = 0,
	Player                                   = 1,
	EnemyLair                                = 2,
	AllyLair                                 = 4,
	AttackEnemyLair                          = 8,
	ContextualAction                         = 16,
	TargetEachOther                          = 32,
	EALifeDirectorScenarioTarget_MAX         = 33,
};

// Enum Stalker2.EScenarioCategory
// NumValues: 0x0003
enum class EScenarioCategory : uint8
{
	Combat                                   = 0,
	Peaceful                                 = 1,
	EScenarioCategory_MAX                    = 2,
};

// Enum Stalker2.ELairPreferredSpawnType
// NumValues: 0x0003
enum class ELairPreferredSpawnType : uint8
{
	TerritoryVolume                          = 0,
	CoreVolume                               = 1,
	ELairPreferredSpawnType_MAX              = 2,
};

// Enum Stalker2.EScenarioBranch
// NumValues: 0x0008
enum class EScenarioBranch : uint8
{
	None                                     = 0,
	Spark                                    = 1,
	Varta                                    = 2,
	Strelok                                  = 3,
	Skif                                     = 4,
	Stalker                                  = 5,
	Noon                                     = 6,
	EScenarioBranch_MAX                      = 7,
};

// Enum Stalker2.EAnimStealthKillPose
// NumValues: 0x0005
enum class EAnimStealthKillPose : uint8
{
	None                                     = 0,
	Standing                                 = 1,
	Sitting                                  = 2,
	SittingOnGround                          = 3,
	EAnimStealthKillPose_MAX                 = 4,
};

// Enum Stalker2.EPassiveDetectorType
// NumValues: 0x0004
enum class EPassiveDetectorType : uint8
{
	None                                     = 0,
	Anomaly                                  = 1,
	Searchpoint                              = 2,
	EPassiveDetectorType_MAX                 = 3,
};

// Enum Stalker2.ESummonSpawnOrientation
// NumValues: 0x0006
enum class ESummonSpawnOrientation : uint8
{
	Identity                                 = 0,
	MatchOwner                               = 1,
	LookAtOwner                              = 2,
	LookAtEnemy                              = 3,
	LookFromOwner                            = 4,
	ESummonSpawnOrientation_MAX              = 5,
};

// Enum Stalker2.EWaterImmersionLevel
// NumValues: 0x0007
enum class EWaterImmersionLevel : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	Deadly                                   = 4,
	GetCount                                 = 5,
	EWaterImmersionLevel_MAX                 = 6,
};

// Enum Stalker2.EUpgradeVerticalPosition
// NumValues: 0x0005
enum class EUpgradeVerticalPosition : uint8
{
	None                                     = 0,
	Top                                      = 1,
	Down                                     = 2,
	GetCount                                 = 3,
	EUpgradeVerticalPosition_MAX             = 4,
};

// Enum Stalker2.EALifeGroupPriorityType
// NumValues: 0x0008
enum class EALifeGroupPriorityType : uint8
{
	Default                                  = 0,
	Global                                   = 1,
	Local                                    = 2,
	Emission                                 = 3,
	Quest                                    = 4,
	Directed                                 = 5,
	Count                                    = 6,
	EALifeGroupPriorityType_MAX              = 7,
};

// Enum Stalker2.EGameDifficulty
// NumValues: 0x0006
enum class EGameDifficulty : uint8
{
	Easy                                     = 0,
	Medium                                   = 1,
	Hard                                     = 2,
	Stalker                                  = 3,
	GetCount                                 = 4,
	EGameDifficulty_MAX                      = 5,
};

// Enum Stalker2.EAimAssistType
// NumValues: 0x0007
enum class EAimAssistType : uint8
{
	None                                     = 0,
	Stickiness                               = 1,
	Magnetism                                = 2,
	Snapping                                 = 3,
	TargetTracking                           = 4,
	GetCount                                 = 5,
	EAimAssistType_MAX                       = 6,
};

// Enum Stalker2.EAimAssistPresetType
// NumValues: 0x0007
enum class EAimAssistPresetType : uint8
{
	Disable                                  = 0,
	Default                                  = 1,
	Focusing                                 = 2,
	Full                                     = 3,
	Custom                                   = 4,
	GetCount                                 = 5,
	EAimAssistPresetType_MAX                 = 6,
};

// Enum Stalker2.ETutorialWidgetType
// NumValues: 0x0005
enum class ETutorialWidgetType : uint8
{
	Autonomic                                = 0,
	Reference                                = 1,
	ReferenceLeft                            = 2,
	PointOfNoreturn                          = 3,
	ETutorialWidgetType_MAX                  = 4,
};

// Enum Stalker2.EQuestState
// NumValues: 0x0007
enum class EQuestState : uint8
{
	None                                     = 0,
	New                                      = 1,
	Active                                   = 2,
	Finished                                 = 3,
	Cancelled                                = 4,
	Failed                                   = 5,
	EQuestState_MAX                          = 6,
};

// Enum Stalker2.EDialogElementType
// NumValues: 0x0004
enum class EDialogElementType : uint8
{
	Audiolog                                 = 0,
	Comment                                  = 1,
	Dialog                                   = 2,
	EDialogElementType_MAX                   = 3,
};

// Enum Stalker2.EAspectRatio
// NumValues: 0x0008
enum class EAspectRatio : uint8
{
	Auto                                     = 0,
	X16Y9                                    = 1,
	X16Y10                                   = 2,
	X21Y9                                    = 3,
	X32Y9                                    = 4,
	X4Y3                                     = 5,
	GetCount                                 = 6,
	EAspectRatio_MAX                         = 7,
};

// Enum Stalker2.EArtifactSpawnerExcludeRule
// NumValues: 0x0005
enum class EArtifactSpawnerExcludeRule : uint8
{
	None                                     = 0,
	ExcludeQuestArtifacts                    = 1,
	ExcludeArchiArtifacts                    = 2,
	All                                      = 3,
	EArtifactSpawnerExcludeRule_MAX          = 4,
};

// Enum Stalker2.EInteractLengthType
// NumValues: 0x0005
enum class EInteractLengthType : uint8
{
	None                                     = 0,
	Regular                                  = 1,
	WithAnim                                 = 2,
	Instant                                  = 3,
	EInteractLengthType_MAX                  = 4,
};

// Enum Stalker2.EObjFloatParams
// NumValues: 0x0005
enum class EObjFloatParams : uint8
{
	None                                     = 0,
	Wetness                                  = 1,
	AimAlpha                                 = 2,
	GetCount                                 = 3,
	EObjFloatParams_MAX                      = 4,
};

// Enum Stalker2.EStashClueSource
// NumValues: 0x0005
enum class EStashClueSource : uint8
{
	None                                     = 0,
	QuestReward                              = 1,
	Loot                                     = 2,
	GetCount                                 = 3,
	EStashClueSource_MAX                     = 4,
};

// Enum Stalker2.EDodgeSide
// NumValues: 0x0005
enum class EDodgeSide : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	GetCount                                 = 3,
	EDodgeSide_MAX                           = 4,
};

// Enum Stalker2.EUISound
// NumValues: 0x0063
enum class EUISound : uint32
{
	None                                     = 18446744073709551615,
	OnShowReferenceTutorial                  = 0,
	OnShowSplashTutorial                     = 1,
	CloseInventory                           = 2,
	UnloadAmmoInventory                      = 3,
	WearEquipment                            = 4,
	TakeOffEquipment                         = 5,
	UseConsumableSausage                     = 6,
	UseConsumableBread                       = 7,
	UseConsumableVodka                       = 8,
	UseConsumableEnergetic                   = 9,
	UseConsumableWater                       = 10,
	UseConsumableBeer                        = 11,
	UseConsumableMilk                        = 12,
	UseConsumableCannedFood                  = 13,
	UseConsumableMedkit                      = 14,
	UseConsumableArmyMedkit                  = 15,
	UseConsumableEcoMedkit                   = 16,
	UseConsumableBandage                     = 17,
	UseConsumableAntiRad                     = 18,
	UseConsumableHercules                    = 19,
	UseConsumableBarvinok                    = 20,
	UseConsumablePsyBlocker                  = 21,
	UseConsumableCinnamon                    = 22,
	UpgradeItem                              = 23,
	RepairArmor                              = 24,
	RepairWeapon                             = 25,
	UpgradeItemCancel                        = 26,
	UpgradeItemModification                  = 27,
	UpgradeItemSelect                        = 28,
	DisassembleItem                          = 29,
	Click                                    = 30,
	SectionSwitch                            = 31,
	JournalTabSwitch                         = 32,
	ScrollQuest                              = 33,
	SystemNotificationObjective              = 34,
	SystemNotificationNews                   = 35,
	SystemNotificationTip                    = 36,
	SystemNotificationNewArea                = 37,
	SystemNotificationNewAudio               = 38,
	ItemSelectorGrenade                      = 39,
	ItemSelectorFireMode                     = 40,
	ItemSelectorClose                        = 41,
	ItemSelectorHover                        = 42,
	ItemSelectorOpen                         = 43,
	AcceptTrade                              = 44,
	CancelTrade                              = 45,
	OpenTrade                                = 46,
	CloseTrade                               = 47,
	JournalTrackQuest                        = 48,
	JournalUntrackQuest                      = 49,
	MainQuestAdded                           = 50,
	MainQuestCompleted                       = 51,
	SecondaryQuestAdded                      = 52,
	SecondaryQuestCompleted                  = 53,
	QuestFailed                              = 54,
	QuestCancelled                           = 55,
	QuestStageUpdated                        = 56,
	QuestStageFailed                         = 57,
	SettingsApply                            = 58,
	SettingsBack                             = 59,
	SettingsSlotHover                        = 60,
	SettingsSlotState                        = 61,
	SettingsTabSwitch                        = 62,
	PDATutorialTabSwitch                     = 63,
	PDATutorialScrol                         = 64,
	NoteStartPlayAudiologSound               = 65,
	NoteStopPlayAudiologSound                = 66,
	IdleScreen                               = 67,
	MainMenuMusicStart                       = 68,
	MainMenuMusicEnd                         = 69,
	MainMenuHover                            = 70,
	MainMenuSelect                           = 71,
	MainMenuNewGame                          = 72,
	PauseMenuOn                              = 73,
	PauseMenuOff                             = 74,
	AttachSelectorActivateAttach             = 75,
	AttachSelectorDeactivateAttach           = 76,
	AttachSelectorOpened                     = 77,
	AttachSelectorClosed                     = 78,
	AttachSelectorSlotSwitched               = 79,
	AttachSelectorSlotHovered                = 80,
	AttachSelectorDeactivateAllAttaches      = 81,
	MapZoomIn                                = 82,
	MapZoomOut                               = 83,
	MapMarkerTrack                           = 84,
	MapMarkerUntrack                         = 85,
	MapUserMarkerSet                         = 86,
	MapUserMarkerRemove                      = 87,
	MapMarkerMenuOpen                        = 88,
	MapMarkerMenuClose                       = 89,
	MapMarkerMenuSwitch                      = 90,
	MapMarkerMenuDenied                      = 91,
	SpecificReward                           = 92,
	PickItem                                 = 93,
	PlaceItem                                = 94,
	TakeAllLoot                              = 95,
	Count                                    = 96,
	EUISound_MAX                             = 97,
};

// Enum Stalker2.EStaticParticleType
// NumValues: 0x001B
enum class EStaticParticleType : uint8
{
	None                                     = 0,
	Dust                                     = 1,
	FallingDust                              = 2,
	Embers                                   = 3,
	FlyingGarbage                            = 4,
	FireBarrel                               = 5,
	Bonfire                                  = 6,
	OvenFire                                 = 7,
	PipeSmoke                                = 8,
	Smoke                                    = 9,
	Fog                                      = 10,
	WaterFog                                 = 11,
	LowLandFog                               = 12,
	WaterLeaks                               = 13,
	Sparks                                   = 14,
	Water                                    = 15,
	Insects                                  = 16,
	Flies                                    = 17,
	Fireflies                                = 18,
	ElectricField                            = 19,
	RustyGeyser                              = 20,
	DugaElectricField                        = 21,
	Steam                                    = 22,
	Wildlife                                 = 23,
	FlyingCrows                              = 24,
	CreepyCrawlyCoalition                    = 25,
	EStaticParticleType_MAX                  = 26,
};

// Enum Stalker2.EDynamicParticleType
// NumValues: 0x0008
enum class EDynamicParticleType : uint8
{
	None                                     = 0,
	Leaves                                   = 1,
	TumbleweedFlies                          = 2,
	FlyingCrowsAndBats                       = 3,
	BogFlies                                 = 4,
	DynamicDust                              = 5,
	LightningStrike                          = 6,
	EDynamicParticleType_MAX                 = 7,
};

// Enum Stalker2.EEvadeActionType
// NumValues: 0x0006
enum class EEvadeActionType : uint8
{
	None                                     = 0,
	Back                                     = 2,
	Left                                     = 4,
	Right                                    = 8,
	Side                                     = 12,
	EEvadeActionType_MAX                     = 13,
};

// Enum Stalker2.EFleeType
// NumValues: 0x0005
enum class EFleeType : uint8
{
	FleeFromCurrentLocation                  = 0,
	FleeFromCustomLocation                   = 1,
	FleeFromPlayer                           = 2,
	FleeFromNPC                              = 3,
	EFleeType_MAX                            = 4,
};

// Enum Stalker2.EFocusType
// NumValues: 0x0004
enum class EFocusType : uint8
{
	NoFocus                                  = 0,
	Location                                 = 1,
	Direction                                = 2,
	EFocusType_MAX                           = 3,
};

// Enum Stalker2.EAgentFollowingFlags
// NumValues: 0x0004
enum class EAgentFollowingFlags : uint8
{
	None                                     = 0,
	ForceLookAtTargetLocation                = 1,
	GetCount                                 = 2,
	EAgentFollowingFlags_MAX                 = 3,
};

// Enum Stalker2.ERumbleType
// NumValues: 0x0011
enum class ERumbleType : uint8
{
	None                                     = 0,
	LeftTrigger                              = 1,
	RightTrigger                             = 2,
	Triggers                                 = 3,
	LeftGrip                                 = 4,
	RightGrip                                = 8,
	Grips                                    = 12,
	LeftSide                                 = 5,
	RightSide                                = 10,
	RightTop                                 = 11,
	RightBottom                              = 14,
	LeftTop                                  = 7,
	LeftBottop                               = 13,
	PartiallyLeft                            = 6,
	PartiallyRight                           = 9,
	All                                      = 15,
	ERumbleType_MAX                          = 16,
};

// Enum Stalker2.EPerformanceBoostDLSSFGMode
// NumValues: 0x0005
enum class EPerformanceBoostDLSSFGMode : uint8
{
	Off                                      = 0,
	On                                       = 1,
	Auto                                     = 2,
	Pause                                    = 3,
	EPerformanceBoostDLSSFGMode_MAX          = 4,
};

// Enum Stalker2.EPerformanceBoostFFXFIMode
// NumValues: 0x0003
enum class EPerformanceBoostFFXFIMode : uint8
{
	Off                                      = 0,
	On                                       = 1,
	EPerformanceBoostFFXFIMode_MAX           = 2,
};

// Enum Stalker2.EPerformanceBoostFeatureSupport
// NumValues: 0x000A
enum class EPerformanceBoostFeatureSupport : uint8
{
	Supported                                = 0,
	NotSupported                             = 1,
	NotSupported_IncompatibleHardware        = 2,
	NotSupported_DriverOutOfDate             = 3,
	NotSupported_OperatingSystemOutOfDate    = 4,
	NotSupported_HardwareSchedulingDisabled  = 5,
	NotSupported_ByRHI                       = 6,
	NotSupported_ByPlatformAtBuildTime       = 7,
	NotSupported_IncompatibleAPICaptureToolActive = 8,
	EPerformanceBoostFeatureSupport_MAX      = 9,
};

// Enum Stalker2.EGameGraphGenerationDebugType
// NumValues: 0x0005
enum class EGameGraphGenerationDebugType : uint8
{
	None                                     = 0,
	Samples                                  = 1,
	SamplesLinks                             = 2,
	All                                      = 255,
	EGameGraphGenerationDebugType_MAX        = 256,
};

// Enum Stalker2.EGASessionState
// NumValues: 0x0003
enum class EGASessionState : uint8
{
	Start                                    = 0,
	Finish                                   = 1,
	EGASessionState_MAX                      = 2,
};

// Enum Stalker2.EGAQuickSlotUseState
// NumValues: 0x0004
enum class EGAQuickSlotUseState : uint8
{
	Started                                  = 0,
	Interrupted                              = 1,
	Finished                                 = 2,
	EGAQuickSlotUseState_MAX                 = 3,
};

// Enum Stalker2.EGoalPriority
// NumValues: 0x001B
enum class EGoalPriority : uint8
{
	ALife                                    = 0,
	ContextualAction                         = 1,
	PatrolContextualAction                   = 2,
	Patrol                                   = 3,
	ReuniteWithLair                          = 4,
	Idle                                     = 5,
	QuestPatrolContextualAction              = 6,
	EmissionContextualAction                 = 7,
	MoveToHigherThanALife                    = 8,
	HigherThanALife                          = 9,
	LowerThanHealAlly                        = 10,
	HealAlly                                 = 11,
	Threat                                   = 12,
	HigherThanThreat                         = 13,
	HideWeaponWarning                        = 14,
	Combat                                   = 15,
	HigherThanCombat                         = 16,
	LeaveRestrictedArea                      = 17,
	SafeFromEmission                         = 18,
	HigherThanEmission                       = 19,
	RadiationFields                          = 20,
	HigherThanRadiationFields                = 21,
	Anomaly                                  = 22,
	HigherThanAnomaly                        = 23,
	RecoverFromKnockdown                     = 24,
	AskMedkit                                = 25,
	EGoalPriority_MAX                        = 26,
};

// Enum Stalker2.EGoalType
// NumValues: 0x0027
enum class EGoalType : uint8
{
	None                                     = 0,
	ALife                                    = 1,
	AskMedkit                                = 2,
	Berserk                                  = 3,
	Combat                                   = 4,
	Threat                                   = 5,
	Escort                                   = 6,
	Flee                                     = 7,
	Follow                                   = 8,
	GuardTarget                              = 9,
	GuardZone                                = 10,
	HealAlly                                 = 11,
	HideFromThreats                          = 12,
	Emission                                 = 13,
	ReturnFromShelter                        = 14,
	Idle                                     = 15,
	Kill                                     = 16,
	LairPatrolling                           = 17,
	MoveTo                                   = 18,
	Pacifist                                 = 19,
	Panic                                    = 20,
	RecoverFromKnockdown                     = 21,
	SeekPlayer                               = 22,
	AnimationStay                            = 23,
	IdleStay                                 = 24,
	WaitingPlayer                            = 25,
	WarnThreat                               = 26,
	ContextualAction                         = 27,
	Patrol                                   = 28,
	ShootTarget                              = 29,
	Sane                                     = 30,
	LeaveRestrictedArea                      = 31,
	HideWeaponWarning                        = 32,
	AttackLairGoal                           = 33,
	ReuniteWithLair                          = 34,
	UseAbility                               = 35,
	PathFailed                               = 36,
	ProcessCorpse                            = 37,
	EGoalType_MAX                            = 38,
};

// Enum Stalker2.EAudioRoomPresetBase
// NumValues: 0x0030
enum class EAudioRoomPresetBase : uint8
{
	None                                     = 0,
	Custom                                   = 1,
	GlobalExterior                           = 2,
	RoomWoodSmall                            = 3,
	RoomWoodMedium                           = 4,
	RoomWoodLarge                            = 5,
	RoomConcreteSmall                        = 6,
	RoomConcreteMedium                       = 7,
	RoomConcreteLarge                        = 8,
	CaveGroundSmall                          = 9,
	CaveGroundMedium                         = 10,
	CaveGroundLarge                          = 11,
	CaveRockSmall                            = 12,
	CaveRockMedium                           = 13,
	CaveRockLarge                            = 14,
	HangarMedium                             = 15,
	HangarLarge                              = 16,
	LabSmall                                 = 17,
	LabMedium                                = 18,
	LabLarge                                 = 19,
	SewerSmall                               = 20,
	SewerMedium                              = 21,
	SewerLarge                               = 22,
	TunnelSmall                              = 23,
	TunnelMedium                             = 24,
	TunnelLarge                              = 25,
	BasementSmall                            = 26,
	BasementMedium                           = 27,
	BasementLarge                            = 28,
	IsolatedSmall                            = 29,
	IsolatedMedium                           = 30,
	IsolatedLarge                            = 31,
	MetalSmall                               = 32,
	SIRCAAMedium                             = 33,
	SIRCAALarge                              = 34,
	SIRCAAMediumNoDetails                    = 35,
	SIRCAALargeNoDetails                     = 36,
	SIRCAAGallery                            = 37,
	Generators_Large                         = 38,
	Elevator_Tunnel                          = 39,
	Strelok_Arena                            = 40,
	Lab_X7                                   = 41,
	XlabSmall                                = 42,
	XlabMedium                               = 43,
	XlabLarge                                = 44,
	PsyDome                                  = 45,
	GetCount                                 = 46,
	EAudioRoomPresetBase_MAX                 = 47,
};

// Enum Stalker2.EAudioVolumeAxisOptionType
// NumValues: 0x0008
enum class EAudioVolumeAxisOptionType : uint8
{
	None                                     = 0,
	X                                        = 1,
	Y                                        = 2,
	Z                                        = 3,
	X_Neg                                    = 4,
	Y_Neg                                    = 5,
	Z_Neg                                    = 6,
	EAudioVolumeAxisOptionType_MAX           = 7,
};

// Enum Stalker2.EGuardType
// NumValues: 0x0004
enum class EGuardType : uint8
{
	GuardTarget                              = 0,
	GuardPlayer                              = 1,
	GuardZone                                = 2,
	EGuardType_MAX                           = 3,
};

// Enum Stalker2.EHintHoverActionType
// NumValues: 0x0004
enum class EHintHoverActionType : uint8
{
	None                                     = 0,
	ChangeVisibility                         = 1,
	ChangeColor                              = 2,
	EHintHoverActionType_MAX                 = 3,
};

// Enum Stalker2.EHintDescriptionSettings
// NumValues: 0x0004
enum class EHintDescriptionSettings : uint8
{
	Hide                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	EHintDescriptionSettings_MAX             = 3,
};

// Enum Stalker2.EHintProgressType
// NumValues: 0x0004
enum class EHintProgressType : uint8
{
	NoProgress                               = 0,
	MultiClickProgress                       = 1,
	HoldProgress                             = 2,
	EHintProgressType_MAX                    = 3,
};

// Enum Stalker2.EHumanCombatPlannerAction
// NumValues: 0x0018
enum class EHumanCombatPlannerAction : uint8
{
	MoveToLocationWalkPrepareWeapon          = 0,
	MoveToLocationWalkFire                   = 1,
	MoveToLocationSprint                     = 2,
	CoverPrepareWeapon                       = 3,
	CoverFire                                = 4,
	CoverLookOut                             = 5,
	CoverHide                                = 6,
	CoverLeave                               = 7,
	PrepareWeapon                            = 8,
	Fire                                     = 9,
	WaitForLocations                         = 10,
	LookOut                                  = 11,
	SearchEnemy                              = 12,
	ForgetEnemy                              = 13,
	UseSequentialAbility                     = 14,
	Flank                                    = 15,
	Evade                                    = 16,
	Advance                                  = 17,
	ThrowGrenade                             = 18,
	SuppressiveFire                          = 19,
	Escape                                   = 20,
	Ambush                                   = 21,
	Count                                    = 22,
	EHumanCombatPlannerAction_MAX            = 23,
};

// Enum Stalker2.EHumanThreatAction
// NumValues: 0x000A
enum class EHumanThreatAction : uint8
{
	TurnHead                                 = 0,
	MoveToThreatLocation                     = 1,
	MoveToLocationSprintNoWeapon             = 2,
	Flee                                     = 3,
	SearchEnemy                              = 4,
	Idle                                     = 5,
	PrepareWeapon                            = 6,
	ForgetThreat                             = 7,
	Count                                    = 8,
	EHumanThreatAction_MAX                   = 9,
};

// Enum Stalker2.EZombieCombatAction
// NumValues: 0x0007
enum class EZombieCombatAction : uint8
{
	MoveToTarget                             = 0,
	ShootInTarget                            = 1,
	ValidateLostEnemy                        = 2,
	Reload                                   = 3,
	PerformAbility                           = 4,
	Count                                    = 5,
	EZombieCombatAction_MAX                  = 6,
};

// Enum Stalker2.StyleManagerActionType
// NumValues: 0x0004
enum class EStyleManagerActionType : uint8
{
	ChangeOnlyColour                         = 0,
	ChangeIcon                               = 1,
	ChangeIconAndColour                      = 2,
	StyleManagerActionType_MAX               = 3,
};

// Enum Stalker2.EPerformanceBoostInputLatencyReflex
// NumValues: 0x0004
enum class EPerformanceBoostInputLatencyReflex : uint8
{
	Off                                      = 0,
	On                                       = 1,
	OnPlusBoost                              = 2,
	EPerformanceBoostInputLatencyReflex_MAX  = 3,
};

// Enum Stalker2.EInputDeviceType
// NumValues: 0x0005
enum class EInputDeviceType : uint8
{
	None                                     = 0,
	Keyboard                                 = 1,
	Mouse                                    = 2,
	Gamepad                                  = 3,
	EInputDeviceType_MAX                     = 4,
};

// Enum Stalker2.EInteractionTypeIcon
// NumValues: 0x0005
enum class EInteractionTypeIcon : uint8
{
	None                                     = 0,
	Lock                                     = 1,
	Key                                      = 2,
	LowHealth                                = 3,
	Max                                      = 4,
};

// Enum Stalker2.EInteractHintType
// NumValues: 0x0003
enum class EInteractHintType : uint8
{
	Main                                     = 0,
	Optional                                 = 1,
	EInteractHintType_MAX                    = 2,
};

// Enum Stalker2.EHintsState
// NumValues: 0x0007
enum class EHintsState : uint8
{
	None                                     = 0,
	HoveredItem                              = 1,
	Drag                                     = 2,
	ContextualMenu                           = 3,
	Split                                    = 4,
	QuickPanel                               = 5,
	EHintsState_MAX                          = 6,
};

// Enum Stalker2.EItemAnimationOnExit
// NumValues: 0x0005
enum class EItemAnimationOnExit : uint8
{
	None                                     = 0,
	Consumable                               = 1,
	InstallAttach                            = 2,
	RemoveAttach                             = 3,
	EItemAnimationOnExit_MAX                 = 4,
};

// Enum Stalker2.EDpadNavigation
// NumValues: 0x0005
enum class EDpadNavigation : uint8
{
	Left                                     = 0,
	Up                                       = 1,
	Right                                    = 2,
	Down                                     = 3,
	EDpadNavigation_MAX                      = 4,
};

// Enum Stalker2.EMidleDisplayType
// NumValues: 0x0005
enum class EMidleDisplayType : uint8
{
	None                                     = 0,
	OnlyText                                 = 1,
	Weapons                                  = 2,
	Grenade                                  = 3,
	EMidleDisplayType_MAX                    = 4,
};

// Enum Stalker2.EItemSelectorSlotStateType
// NumValues: 0x0004
enum class EItemSelectorSlotStateType : uint8
{
	None                                     = 0,
	Hovered                                  = 1,
	Selected                                 = 2,
	EItemSelectorSlotStateType_MAX           = 3,
};

// Enum Stalker2.ELayerSlotType
// NumValues: 0x0004
enum class ELayerSlotType : uint8
{
	Defoult                                  = 0,
	Grenade                                  = 1,
	Weapon                                   = 2,
	ELayerSlotType_MAX                       = 3,
};

// Enum Stalker2.EKillTargetType
// NumValues: 0x0004
enum class EKillTargetType : uint8
{
	NPCTarget                                = 0,
	PlayerTarget                             = 1,
	AreaTarget                               = 2,
	EKillTargetType_MAX                      = 3,
};

// Enum Stalker2.ELairType
// NumValues: 0x0004
enum class ELairType : uint8
{
	ALifeLair                                = 0,
	RestingLair                              = 1,
	GetCount                                 = 2,
	ELairType_MAX                            = 3,
};

// Enum Stalker2.ELookAtOwnerState
// NumValues: 0x004A
enum class ELookAtOwnerState : uint8
{
	Empty                                    = 0,
	RelaxStand                               = 1,
	RelaxARStand                             = 2,
	CombatStand                              = 3,
	CombatCrouch                             = 4,
	CombatLowCrouch                          = 5,
	CoverIdleStand                           = 6,
	CoverIdleCrouch                          = 7,
	CoverIdleLowCrouch                       = 8,
	CoverStandBlindLeft                      = 9,
	CoverCrouchBlindLeft                     = 10,
	CoverCrouchBlindTop                      = 11,
	ZeroRotations                            = 12,
	EnterContextualAction                    = 13,
	LockOnlyFullBody                         = 14,
	CAWomanSitChair                          = 15,
	CAWomanSitChairItemManipulation          = 16,
	CAWomanStandBartable                     = 17,
	CAWomanStandBartableItemManipulation     = 18,
	CADefault                                = 19,
	CASitGround                              = 20,
	CASitBartable                            = 21,
	CASitChair                               = 22,
	CASitLegsDandling                        = 23,
	CASitTable                               = 24,
	CAStand                                  = 25,
	CAStandAgainstWall                       = 26,
	CAStandAgainstWallRight                  = 27,
	CAStandAgainstWallLeft                   = 28,
	CAStandBartable                          = 29,
	CASitGroundEatDrinkSmoke                 = 30,
	CASitGroundItemManipulation              = 31,
	CASitGroundSurroundingInteract           = 32,
	CASitGroundWounded                       = 33,
	CASitBartableEatDrinkSmoke               = 34,
	CASitBartableSurroundingInteract         = 35,
	CASitChairEatDrinkSmoke                  = 36,
	CASitChairItemManipulation               = 37,
	CASitChairSurroundingInteract            = 38,
	CASitLegsDandlingEatDrinkSmoke           = 39,
	CASitLegsDandlingItemManipulation        = 40,
	CASitLegsDandlingSurroundingInteract     = 41,
	CASitTableEatDrinkSmoke                  = 42,
	CASitTableItemManipulation               = 43,
	CASitTableSurroundingInteract            = 44,
	CAStandEatDrinkSmoke                     = 45,
	CAStandItemManipulation                  = 46,
	CAStandSurroundingInteract               = 47,
	CAStandAgainstWallEatDrinkSmoke          = 48,
	CAStandAgainstWallItemManipulation       = 49,
	CAStandAgainstWallSurroundingInteract    = 50,
	CAStandBartableEatDrinkSmoke             = 51,
	CAStandBartableItemManipulation          = 52,
	CAStandBartableSurroundingInteract       = 53,
	CAQuestBatyaSidorovych                   = 54,
	CAQuestBatyaSitChair                     = 55,
	CAQuestAgatha                            = 56,
	CAQuestAgathaSmoke                       = 57,
	CAQuestHarpia                            = 58,
	CAQuestDoroznuk                          = 59,
	CAQuestBereza                            = 60,
	CAQuestKalina                            = 61,
	CAQuestSolomia                           = 62,
	CAQuestKorshunov                         = 63,
	CAQuestBartender                         = 64,
	SitGround                                = 63,
	SitBartable                              = 55,
	SitChair                                 = 63,
	SitLegsDandling                          = 63,
	SitTable                                 = 63,
	Stand                                    = 63,
	StandAgainstWall                         = 59,
	StandBartable                            = 63,
	ELookAtOwnerState_MAX                    = 65,
};

// Enum Stalker2.EApplyRestrictionType
// NumValues: 0x0004
enum class EApplyRestrictionType : uint8
{
	Custom                                   = 0,
	LeaveSame                                = 1,
	Reset                                    = 2,
	EApplyRestrictionType_MAX                = 3,
};

// Enum Stalker2.ECompassPosition
// NumValues: 0x0003
enum class ECompassPosition : uint8
{
	Bottom                                   = 0,
	Top                                      = 1,
	ECompassPosition_MAX                     = 2,
};

// Enum Stalker2.ECustomDataDistribution
// NumValues: 0x0003
enum class ECustomDataDistribution : uint8
{
	Uniform                                  = 0,
	Custom                                   = 1,
	ECustomDataDistribution_MAX              = 2,
};

// Enum Stalker2.EBorderType
// NumValues: 0x0003
enum class EBorderType : uint8
{
	HorizontalBorder                         = 0,
	VerticalBorder                           = 1,
	EBorderType_MAX                          = 2,
};

// Enum Stalker2.ETracePhase
// NumValues: 0x0005
enum class ETracePhase : uint8
{
	HorizontalTracePhase                     = 0,
	VerticalUpTracePhase                     = 1,
	VerticalDownTracePhase                   = 2,
	VerticalTraces                           = 3,
	ETracePhase_MAX                          = 4,
};

// Enum Stalker2.EMarkerState
// NumValues: 0x0005
enum class EMarkerState : uint8
{
	Hidden                                   = 0,
	Default                                  = 1,
	Discovered                               = 2,
	Explored                                 = 3,
	EMarkerState_MAX                         = 4,
};

// Enum Stalker2.ETextListType
// NumValues: 0x0004
enum class ETextListType : uint8
{
	None                                     = 0,
	Point                                    = 1,
	Numeric                                  = 2,
	ETextListType_MAX                        = 3,
};

// Enum Stalker2.EModioFirstFilter
// NumValues: 0x0005
enum class EModioFirstFilter : uint8
{
	None                                     = 0,
	Browse                                   = 1,
	Subscribed                               = 2,
	Count                                    = 3,
	EModioFirstFilter_MAX                    = 4,
};

// Enum Stalker2.EModioSecondFilter
// NumValues: 0x0006
enum class EModioSecondFilter : uint8
{
	None                                     = 0,
	MostPopular                              = 1,
	HighestRated                             = 2,
	RecentlyAdded                            = 3,
	Count                                    = 4,
	EModioSecondFilter_MAX                   = 5,
};

// Enum Stalker2.EBreathState
// NumValues: 0x0004
enum class EBreathState : uint8
{
	Inhale                                   = 0,
	Exhale                                   = 1,
	Hold                                     = 2,
	EBreathState_MAX                         = 3,
};

// Enum Stalker2.EPathBuilderPathType
// NumValues: 0x0006
enum class EPathBuilderPathType : uint32
{
	FewCircles                               = 0,
	Circle                                   = 1,
	ExpensiveActor                           = 2,
	ShortPath                                = 3,
	GameGraph                                = 4,
	EPathBuilderPathType_MAX                 = 5,
};

// Enum Stalker2.EMutantAttackType
// NumValues: 0x0005
enum class EMutantAttackType : uint8
{
	None                                     = 0,
	ClawAttack                               = 1,
	RunAttack                                = 2,
	JumpAttack                               = 3,
	EMutantAttackType_MAX                    = 4,
};

// Enum Stalker2.EAttackDirection
// NumValues: 0x0004
enum class EAttackDirection : uint8
{
	Any                                      = 0,
	Left                                     = 1,
	Right                                    = 2,
	EAttackDirection_MAX                     = 3,
};

// Enum Stalker2.ENiagaraProviderType
// NumValues: 0x0008
enum class ENiagaraProviderType : uint8
{
	None                                     = 0,
	WindProvider                             = 1,
	TimeOfDayProvider                        = 2,
	PlayerLocationProvider                   = 3,
	EyeAdaptationProvider                    = 4,
	TerrainOffsetProvider                    = 5,
	GetCount                                 = 6,
	ENiagaraProviderType_MAX                 = 7,
};

// Enum Stalker2.ENotificationQuestWidgetType
// NumValues: 0x0005
enum class ENotificationQuestWidgetType : uint8
{
	QuestStart                               = 0,
	QuestFinish                              = 1,
	QuestFail                                = 2,
	QuestCancel                              = 3,
	ENotificationQuestWidgetType_MAX         = 4,
};

// Enum Stalker2.EPDAPageType
// NumValues: 0x0009
enum class EPDAPageType : uint8
{
	Map                                      = 0,
	Journal                                  = 1,
	Notes                                    = 2,
	Upgrades                                 = 3,
	Statistic                                = 4,
	Bestiary                                 = 5,
	Tutorial                                 = 6,
	GetCount                                 = 7,
	EPDAPageType_MAX                         = 8,
};

// Enum Stalker2.ESpawnDataState
// NumValues: 0x0007
enum class ESpawnDataState : uint8
{
	None                                     = 0,
	ProbabilityAccumulation                  = 1,
	SpawnPointPick                           = 2,
	ActivateParticle                         = 3,
	ActiveParticle                           = 4,
	InactiveParticle                         = 5,
	ESpawnDataState_MAX                      = 6,
};

// Enum Stalker2.ESingleLaunchTaskType
// NumValues: 0x0003
enum class ESingleLaunchTaskType : uint8
{
	Default                                  = 0,
	MainHandEquipChange                      = 1,
	ESingleLaunchTaskType_MAX                = 2,
};

// Enum Stalker2.EImpactResourceType
// NumValues: 0x0004
enum class EImpactResourceType : uint8
{
	Sound                                    = 0,
	VFX                                      = 1,
	Decal                                    = 2,
	EImpactResourceType_MAX                  = 3,
};

// Enum Stalker2.EQuestAnimationType
// NumValues: 0x0005
enum class EQuestAnimationType : uint8
{
	None                                     = 0,
	AfterPDA                                 = 1,
	Show                                     = 2,
	Hidden                                   = 3,
	EQuestAnimationType_MAX                  = 4,
};

// Enum Stalker2.EQuestHintState
// NumValues: 0x0005
enum class EQuestHintState : uint8
{
	None                                     = 0,
	OpenJournal                              = 1,
	Track                                    = 2,
	Untrack                                  = 3,
	EQuestHintState_MAX                      = 4,
};

// Enum Stalker2.EThreatSensor
// NumValues: 0x0006
enum class EThreatSensor : uint8
{
	None                                     = 0,
	Vision                                   = 1,
	Hearing                                  = 2,
	Smell                                    = 4,
	MovementDetection                        = 8,
	EThreatSensor_MAX                        = 9,
};

// Enum Stalker2.EAIThreatState
// NumValues: 0x0005
enum class EAIThreatState : uint8
{
	None                                     = 0,
	Peaceful                                 = 1,
	SearchForThreat                          = 2,
	Combat                                   = 4,
	EAIThreatState_MAX                       = 5,
};

// Enum Stalker2.ERelationLevel
// NumValues: 0x0007
enum class ERelationLevel : uint8
{
	Enemy                                    = 0,
	Disaffection                             = 1,
	Neutral                                  = 2,
	Friend                                   = 3,
	Self                                     = 4,
	Count                                    = 5,
	ERelationLevel_MAX                       = 6,
};

// Enum Stalker2.ERelationChangingEvent
// NumValues: 0x000A
enum class ERelationChangingEvent : uint8
{
	Damage                                   = 0,
	Wounded                                  = 1,
	KillWounded                              = 2,
	Kill                                     = 3,
	Heal                                     = 4,
	Grenade                                  = 5,
	FractionDamage                           = 6,
	Melee                                    = 7,
	Count                                    = 8,
	ERelationChangingEvent_MAX               = 9,
};

// Enum Stalker2.EReloadState
// NumValues: 0x0004
enum class EReloadState : uint8
{
	Started                                  = 0,
	Finished                                 = 1,
	Interrupted                              = 2,
	EReloadState_MAX                         = 3,
};

// Enum Stalker2.ERotationPartType
// NumValues: 0x0005
enum class ERotationPartType : uint8
{
	Eyes                                     = 0,
	Head                                     = 1,
	UpperBody                                = 2,
	FullBody                                 = 3,
	ERotationPartType_MAX                    = 4,
};

// Enum Stalker2.EFilterMode
// NumValues: 0x0004
enum class EFilterMode : uint8
{
	Disabled                                 = 0,
	Blacklist                                = 1,
	Whitelist                                = 2,
	EFilterMode_MAX                          = 3,
};

// Enum Stalker2.EInputTypeForButtons
// NumValues: 0x0004
enum class EInputTypeForButtons : uint8
{
	Both                                     = 0,
	Gamepad                                  = 1,
	Keyboard                                 = 2,
	EInputTypeForButtons_MAX                 = 3,
};

// Enum Stalker2.ENestingIndex
// NumValues: 0x0004
enum class ENestingIndex : uint8
{
	Settings                                 = 0,
	PCMapping                                = 1,
	GamepadMapping                           = 2,
	ENestingIndex_MAX                        = 3,
};

// Enum Stalker2.EOutputDeviceEffect
// NumValues: 0x0005
enum class EOutputDeviceEffect : uint8
{
	Full                                     = 0,
	Medium                                   = 1,
	Narrow                                   = 2,
	Count                                    = 3,
	EOutputDeviceEffect_MAX                  = 4,
};

// Enum Stalker2.EAgentDomain
// NumValues: 0x0004
enum class EAgentDomain : uint8
{
	ALife                                    = 0,
	Quest                                    = 1,
	Count                                    = 2,
	EAgentDomain_MAX                         = 3,
};

// Enum Stalker2.ESpaceRestrictionType
// NumValues: 0x0004
enum class ESpaceRestrictionType : uint8
{
	None                                     = 0,
	In                                       = 1,
	Out                                      = 2,
	ESpaceRestrictionType_MAX                = 3,
};

// Enum Stalker2.EAnomalyStateType
// NumValues: 0x0006
enum class EAnomalyStateType : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Activation                               = 2,
	Active                                   = 3,
	Recharge                                 = 4,
	EAnomalyStateType_MAX                    = 5,
};

// Enum Stalker2.EStatSlotStates
// NumValues: 0x0005
enum class EStatSlotStates : uint32
{
	None                                     = 0,
	Weak                                     = 1,
	Medium                                   = 2,
	Strong                                   = 3,
	EStatSlotStates_MAX                      = 4,
};

// Enum Stalker2.EStayBehaviorType
// NumValues: 0x0004
enum class EStayBehaviorType : uint8
{
	Animation                                = 0,
	ContextualAction                         = 1,
	Idle                                     = 2,
	EStayBehaviorType_MAX                    = 3,
};

// Enum Stalker2.EOverrideLifeGridVisionRadius
// NumValues: 0x0005
enum class EOverrideLifeGridVisionRadius : uint8
{
	None                                     = 0,
	Low                                      = 40,
	Default                                  = 75,
	High                                     = 120,
	EOverrideLifeGridVisionRadius_MAX        = 121,
};

// Enum Stalker2.ESubgraphBlendTypes
// NumValues: 0x000A
enum class ESubgraphBlendTypes : uint8
{
	None                                     = 0,
	WeaponHide                               = 1,
	WeaponShow                               = 2,
	DetectorHide                             = 3,
	DetectorShow                             = 4,
	OneHandedConsumableShow                  = 5,
	OneHandedConsumableHide                  = 6,
	TwoHandedConsumableHide                  = 7,
	TwoHandedConsumableShow                  = 8,
	ESubgraphBlendTypes_MAX                  = 9,
};

// Enum Stalker2.EHintType
// NumValues: 0x0005
enum class EHintType : uint8
{
	None                                     = 0,
	General                                  = 1,
	Audiolog                                 = 2,
	InspectArtifact                          = 3,
	EHintType_MAX                            = 4,
};

// Enum Stalker2.ESystemNotificationIconType
// NumValues: 0x0008
enum class ESystemNotificationIconType : uint8
{
	Item                                     = 0,
	Blueprint                                = 1,
	Money                                    = 2,
	Note                                     = 3,
	Cache                                    = 4,
	AudioNote                                = 5,
	Region                                   = 6,
	ESystemNotificationIconType_MAX          = 7,
};

// Enum Stalker2.EImageFormats
// NumValues: 0x0007
enum class EImageFormats : uint8
{
	JPG                                      = 0,
	PNG                                      = 1,
	BMP                                      = 2,
	ICO                                      = 3,
	EXR                                      = 4,
	ICNS                                     = 5,
	EImageFormats_MAX                        = 6,
};

// Enum Stalker2.EThreatActionType
// NumValues: 0x0007
enum class EThreatActionType : uint8
{
	None                                     = 0,
	TurnHead                                 = 1,
	MoveToLocation                           = 2,
	CallAllies                               = 4,
	SearchEnemy                              = 8,
	Count                                    = 4,
	EThreatActionType_MAX                    = 9,
};

// Enum Stalker2.EThreatType
// NumValues: 0x000B
enum class EThreatType : uint8
{
	None                                     = 0,
	Corpse                                   = 1,
	Sound                                    = 2,
	PhysicsTouch                             = 3,
	Hit                                      = 4,
	Flashlight                               = 5,
	CharacterTouch                           = 6,
	UnidentifiedEnemy                        = 7,
	IdentifiedEnemy                          = 8,
	Explosive                                = 9,
	EThreatType_MAX                          = 10,
};

// Enum Stalker2.ETickSlicingGroup
// NumValues: 0x0007
enum class ETickSlicingGroup : uint8
{
	SkipTick                                 = 0,
	HighestPriority                          = 1,
	HighPriority                             = 2,
	MediumPriority                           = 3,
	LowPriority                              = 4,
	GetCount                                 = 5,
	ETickSlicingGroup_MAX                    = 6,
};

// Enum Stalker2.EToggleType
// NumValues: 0x0004
enum class EToggleType : uint8
{
	Open                                     = 0,
	DotOpen                                  = 1,
	Close                                    = 2,
	EToggleType_MAX                          = 3,
};

// Enum Stalker2.EWidgetNameEx
// NumValues: 0x0021
enum class EWidgetNameEx : uint32
{
	None                                     = 18446744073709551615,
	MainMenu                                 = 0,
	Inventory                                = 1,
	Interact                                 = 2,
	InteractDots                             = 3,
	DebugHUD                                 = 4,
	ItemSelector                             = 5,
	AttachSelector                           = 6,
	FastDialog                               = 7,
	ImportantDialogue                        = 8,
	Dialog                                   = 9,
	Subtitle                                 = 10,
	PDA                                      = 11,
	FadeView                                 = 12,
	GamePauseMenu                            = 13,
	SleepView                                = 14,
	Trade                                    = 15,
	Upgrade                                  = 16,
	DeathScreen                              = 17,
	HUD                                      = 18,
	AutonomicTutorial                        = 19,
	ReferenceTutorial                        = 20,
	ReferenceTutorialLeft                    = 21,
	SplashTutorial                           = 22,
	IdleScreen                               = 23,
	FirstTimeSettings                        = 24,
	EULA                                     = 25,
	InspectArtifactView                      = 26,
	NewDLCPopup                              = 27,
	GuitarPlayView                           = 28,
	SkipHint                                 = 29,
	Count                                    = 30,
	EWidgetNameEx_MAX                        = 31,
};

// Enum Stalker2.EInputIconsType
// NumValues: 0x0003
enum class EInputIconsType : uint8
{
	WindowsDefault                           = 0,
	WindowsDisabled                          = 1,
	EInputIconsType_MAX                      = 2,
};

// Enum Stalker2.EConnectionLineState
// NumValues: 0x0005
enum class EConnectionLineState : uint8
{
	None                                     = 0,
	Top                                      = 1,
	Middle                                   = 2,
	Down                                     = 3,
	EConnectionLineState_MAX                 = 4,
};

// Enum Stalker2.EPerformanceBoostUpscalingMethod
// NumValues: 0x0008
enum class EPerformanceBoostUpscalingMethod : uint8
{
	Unknown                                  = 0,
	None                                     = 1,
	TAA                                      = 2,
	TSR                                      = 3,
	FSR                                      = 4,
	DLSS                                     = 5,
	XeSS                                     = 6,
	Max                                      = 6,
};

// Enum Stalker2.EPerformanceBoostUpscalingQuality
// NumValues: 0x0002
enum class EPerformanceBoostUpscalingQuality : uint8
{
	Unknown                                  = 0,
	EPerformanceBoostUpscalingQuality_MAX    = 1,
};

// Enum Stalker2.EMarkerPosition
// NumValues: 0x0005
enum class EMarkerPosition : uint8
{
	Top                                      = 0,
	Right                                    = 1,
	Left                                     = 2,
	Bottom                                   = 3,
	EMarkerPosition_MAX                      = 4,
};

// Enum Stalker2.ECloseType
// NumValues: 0x0004
enum class ECloseType : uint8
{
	OnlyPriority                             = 0,
	IgnoreClose                              = 1,
	PriorityAndIgnoreCloseByName             = 2,
	ECloseType_MAX                           = 3,
};

// Enum Stalker2.EWanderingLightsSimulationState
// NumValues: 0x0007
enum class EWanderingLightsSimulationState : uint8
{
	Disabled                                 = 0,
	WakingUp                                 = 1,
	Idle                                     = 2,
	HasTarget                                = 3,
	Active                                   = 4,
	ShuttingDown                             = 5,
	EWanderingLightsSimulationState_MAX      = 6,
};

// Enum Stalker2.EWeaponState
// NumValues: 0x0004
enum class EWeaponState : uint8
{
	NoWeapon                                 = 0,
	Relax                                    = 1,
	Combat                                   = 2,
	EWeaponState_MAX                         = 3,
};

// Enum Stalker2.ETrackGroup
// NumValues: 0x0005
enum class ETrackGroup : uint8
{
	MainQuest                                = 0,
	SideQuest                                = 1,
	PlayerLandmark                           = 2,
	Other                                    = 3,
	ETrackGroup_MAX                          = 4,
};

// Enum Stalker2.EZombificationType
// NumValues: 0x0003
enum class EZombificationType : uint8
{
	AliveHuman                               = 0,
	CorpseHuman                              = 1,
	EZombificationType_MAX                   = 2,
};

// ScriptStruct Stalker2.HintStyleSettings
// 0x0030 (0x0030 - 0x0000)
struct FHintStyleSettings final
{
public:
	EHintDescriptionSettings                      DescriptionSettings;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HintDescriptionFontStyleSID;                       // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HintDescriptionSID;                                // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HintAndDescriptionGap;                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HintHeight;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBlockedState;                                 // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHintStyleSettings) == 0x000008, "Wrong alignment on FHintStyleSettings");
static_assert(sizeof(FHintStyleSettings) == 0x000030, "Wrong size on FHintStyleSettings");
static_assert(offsetof(FHintStyleSettings, DescriptionSettings) == 0x000000, "Member 'FHintStyleSettings::DescriptionSettings' has a wrong offset!");
static_assert(offsetof(FHintStyleSettings, HintDescriptionFontStyleSID) == 0x000004, "Member 'FHintStyleSettings::HintDescriptionFontStyleSID' has a wrong offset!");
static_assert(offsetof(FHintStyleSettings, HintDescriptionSID) == 0x000010, "Member 'FHintStyleSettings::HintDescriptionSID' has a wrong offset!");
static_assert(offsetof(FHintStyleSettings, HintAndDescriptionGap) == 0x000020, "Member 'FHintStyleSettings::HintAndDescriptionGap' has a wrong offset!");
static_assert(offsetof(FHintStyleSettings, HintHeight) == 0x000024, "Member 'FHintStyleSettings::HintHeight' has a wrong offset!");
static_assert(offsetof(FHintStyleSettings, bShowBlockedState) == 0x000028, "Member 'FHintStyleSettings::bShowBlockedState' has a wrong offset!");

// ScriptStruct Stalker2.MenuHintSettings
// 0x0010 (0x0010 - 0x0000)
struct FMenuHintSettings final
{
public:
	EMappingContext                               MappingContext;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeyboardAndMouseMappingIndex;                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GamepadMappingIndex;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerIndex;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuHintSettings) == 0x000004, "Wrong alignment on FMenuHintSettings");
static_assert(sizeof(FMenuHintSettings) == 0x000010, "Wrong size on FMenuHintSettings");
static_assert(offsetof(FMenuHintSettings, MappingContext) == 0x000000, "Member 'FMenuHintSettings::MappingContext' has a wrong offset!");
static_assert(offsetof(FMenuHintSettings, KeyboardAndMouseMappingIndex) == 0x000004, "Member 'FMenuHintSettings::KeyboardAndMouseMappingIndex' has a wrong offset!");
static_assert(offsetof(FMenuHintSettings, GamepadMappingIndex) == 0x000008, "Member 'FMenuHintSettings::GamepadMappingIndex' has a wrong offset!");
static_assert(offsetof(FMenuHintSettings, TriggerIndex) == 0x00000C, "Member 'FMenuHintSettings::TriggerIndex' has a wrong offset!");

// ScriptStruct Stalker2.ShortcutData
// 0x0068 (0x0068 - 0x0000)
struct FShortcutData final
{
public:
	bool                                          bShowLegend;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHintStyleSettings                     LegendButtonStyle;                                 // 0x0008(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMenuHintSettings                      MenuHintSettings;                                  // 0x0038(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 InputAction;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMenuButtonActionBase*                  ExecuteAction;                                     // 0x0058(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETriggerEvent                                 InputEventType;                                    // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShortcutData) == 0x000008, "Wrong alignment on FShortcutData");
static_assert(sizeof(FShortcutData) == 0x000068, "Wrong size on FShortcutData");
static_assert(offsetof(FShortcutData, bShowLegend) == 0x000000, "Member 'FShortcutData::bShowLegend' has a wrong offset!");
static_assert(offsetof(FShortcutData, LegendButtonStyle) == 0x000008, "Member 'FShortcutData::LegendButtonStyle' has a wrong offset!");
static_assert(offsetof(FShortcutData, MenuHintSettings) == 0x000038, "Member 'FShortcutData::MenuHintSettings' has a wrong offset!");
static_assert(offsetof(FShortcutData, InputAction) == 0x000048, "Member 'FShortcutData::InputAction' has a wrong offset!");
static_assert(offsetof(FShortcutData, ExecuteAction) == 0x000058, "Member 'FShortcutData::ExecuteAction' has a wrong offset!");
static_assert(offsetof(FShortcutData, InputEventType) == 0x000060, "Member 'FShortcutData::InputEventType' has a wrong offset!");

// ScriptStruct Stalker2.MenuButtonData
// 0x0068 (0x0068 - 0x0000)
struct FMenuButtonData final
{
public:
	TSoftClassPtr<class UClass>                   ButtonStyleClass;                                  // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ButtonNameSID;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMenuButtonActionBase*                  ButtonAction;                                      // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FShortcutData>                  ButtonShortcuts;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMenuButtonStateDefiner*>        ButtonDefiners;                                    // 0x0058(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuButtonData) == 0x000008, "Wrong alignment on FMenuButtonData");
static_assert(sizeof(FMenuButtonData) == 0x000068, "Wrong size on FMenuButtonData");
static_assert(offsetof(FMenuButtonData, ButtonStyleClass) == 0x000000, "Member 'FMenuButtonData::ButtonStyleClass' has a wrong offset!");
static_assert(offsetof(FMenuButtonData, ButtonNameSID) == 0x000030, "Member 'FMenuButtonData::ButtonNameSID' has a wrong offset!");
static_assert(offsetof(FMenuButtonData, ButtonAction) == 0x000040, "Member 'FMenuButtonData::ButtonAction' has a wrong offset!");
static_assert(offsetof(FMenuButtonData, ButtonShortcuts) == 0x000048, "Member 'FMenuButtonData::ButtonShortcuts' has a wrong offset!");
static_assert(offsetof(FMenuButtonData, ButtonDefiners) == 0x000058, "Member 'FMenuButtonData::ButtonDefiners' has a wrong offset!");

// ScriptStruct Stalker2.FeedbackSettings
// 0x0001 (0x0001 - 0x0000)
struct FFeedbackSettings final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFeedbackSettings) == 0x000001, "Wrong alignment on FFeedbackSettings");
static_assert(sizeof(FFeedbackSettings) == 0x000001, "Wrong size on FFeedbackSettings");

// ScriptStruct Stalker2.UID
// 0x0004 (0x0004 - 0x0000)
struct FUID
{
public:
	int32                                         UID;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FUID) == 0x000004, "Wrong alignment on FUID");
static_assert(sizeof(FUID) == 0x000004, "Wrong size on FUID");
static_assert(offsetof(FUID, UID) == 0x000000, "Member 'FUID::UID' has a wrong offset!");

// ScriptStruct Stalker2.AnimHandIKData
// 0x0038 (0x0038 - 0x0000)
struct FAnimHandIKData final
{
public:
	float                                         Alpha;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlend                            BlendArgs;                                         // 0x0008(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHandIKData) == 0x000008, "Wrong alignment on FAnimHandIKData");
static_assert(sizeof(FAnimHandIKData) == 0x000038, "Wrong size on FAnimHandIKData");
static_assert(offsetof(FAnimHandIKData, Alpha) == 0x000000, "Member 'FAnimHandIKData::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimHandIKData, BlendArgs) == 0x000008, "Member 'FAnimHandIKData::BlendArgs' has a wrong offset!");

// ScriptStruct Stalker2.RecoilKeys
// 0x0008 (0x0008 - 0x0000)
struct FRecoilKeys final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecoilKeys) == 0x000004, "Wrong alignment on FRecoilKeys");
static_assert(sizeof(FRecoilKeys) == 0x000008, "Wrong size on FRecoilKeys");
static_assert(offsetof(FRecoilKeys, X) == 0x000000, "Member 'FRecoilKeys::X' has a wrong offset!");
static_assert(offsetof(FRecoilKeys, Y) == 0x000004, "Member 'FRecoilKeys::Y' has a wrong offset!");

// ScriptStruct Stalker2.RebuildData
// 0x0020 (0x0020 - 0x0000)
struct FRebuildData final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentSocketName;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlipped;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Mesh;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRebuildData) == 0x000008, "Wrong alignment on FRebuildData");
static_assert(sizeof(FRebuildData) == 0x000020, "Wrong size on FRebuildData");
static_assert(offsetof(FRebuildData, SocketName) == 0x000000, "Member 'FRebuildData::SocketName' has a wrong offset!");
static_assert(offsetof(FRebuildData, ParentSocketName) == 0x000008, "Member 'FRebuildData::ParentSocketName' has a wrong offset!");
static_assert(offsetof(FRebuildData, bIsFlipped) == 0x000010, "Member 'FRebuildData::bIsFlipped' has a wrong offset!");
static_assert(offsetof(FRebuildData, Mesh) == 0x000018, "Member 'FRebuildData::Mesh' has a wrong offset!");

// ScriptStruct Stalker2.BaseTickAggregationCollection
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FBaseTickAggregationCollection
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseTickAggregationCollection) == 0x000008, "Wrong alignment on FBaseTickAggregationCollection");
static_assert(sizeof(FBaseTickAggregationCollection) == 0x000068, "Wrong size on FBaseTickAggregationCollection");

// ScriptStruct Stalker2.HitBlocker
// 0x0010 (0x0010 - 0x0000)
struct FHitBlocker final
{
public:
	class FName                                   JointName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ElementIndex;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPiercing;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitBlocker) == 0x000004, "Wrong alignment on FHitBlocker");
static_assert(sizeof(FHitBlocker) == 0x000010, "Wrong size on FHitBlocker");
static_assert(offsetof(FHitBlocker, JointName) == 0x000000, "Member 'FHitBlocker::JointName' has a wrong offset!");
static_assert(offsetof(FHitBlocker, ElementIndex) == 0x000008, "Member 'FHitBlocker::ElementIndex' has a wrong offset!");
static_assert(offsetof(FHitBlocker, MaxPiercing) == 0x00000C, "Member 'FHitBlocker::MaxPiercing' has a wrong offset!");

// ScriptStruct Stalker2.PlayerGuitarAnimations
// 0x0108 (0x0108 - 0x0000)
struct FPlayerGuitarAnimations final
{
public:
	class UAnimMontage*                           ChordTransition;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          GuitarItemEnterAnimation;                          // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          GuitarItemExitAnimation;                           // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EAnimGuitarState, class UAkAudioEvent*>  StrumUpSounds;                                     // 0x0018(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EAnimGuitarState, class UAkAudioEvent*>  StrumDownSounds;                                   // 0x0068(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EAnimGuitarState, class UAkAudioEvent*>  GlissSounds;                                       // 0x00B8(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerGuitarAnimations) == 0x000008, "Wrong alignment on FPlayerGuitarAnimations");
static_assert(sizeof(FPlayerGuitarAnimations) == 0x000108, "Wrong size on FPlayerGuitarAnimations");
static_assert(offsetof(FPlayerGuitarAnimations, ChordTransition) == 0x000000, "Member 'FPlayerGuitarAnimations::ChordTransition' has a wrong offset!");
static_assert(offsetof(FPlayerGuitarAnimations, GuitarItemEnterAnimation) == 0x000008, "Member 'FPlayerGuitarAnimations::GuitarItemEnterAnimation' has a wrong offset!");
static_assert(offsetof(FPlayerGuitarAnimations, GuitarItemExitAnimation) == 0x000010, "Member 'FPlayerGuitarAnimations::GuitarItemExitAnimation' has a wrong offset!");
static_assert(offsetof(FPlayerGuitarAnimations, StrumUpSounds) == 0x000018, "Member 'FPlayerGuitarAnimations::StrumUpSounds' has a wrong offset!");
static_assert(offsetof(FPlayerGuitarAnimations, StrumDownSounds) == 0x000068, "Member 'FPlayerGuitarAnimations::StrumDownSounds' has a wrong offset!");
static_assert(offsetof(FPlayerGuitarAnimations, GlissSounds) == 0x0000B8, "Member 'FPlayerGuitarAnimations::GlissSounds' has a wrong offset!");

// ScriptStruct Stalker2.GroomCategory
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FGroomCategory final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGroomCategory) == 0x000008, "Wrong alignment on FGroomCategory");
static_assert(sizeof(FGroomCategory) == 0x000078, "Wrong size on FGroomCategory");

// ScriptStruct Stalker2.ItemUID
// 0x0000 (0x0004 - 0x0004)
struct FItemUID final : public FUID
{
};
static_assert(alignof(FItemUID) == 0x000004, "Wrong alignment on FItemUID");
static_assert(sizeof(FItemUID) == 0x000004, "Wrong size on FItemUID");

// ScriptStruct Stalker2.ContextualItemDetachment
// 0x0008 (0x0008 - 0x0000)
struct FContextualItemDetachment final
{
public:
	class FName                                   AttachmentName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContextualItemDetachment) == 0x000004, "Wrong alignment on FContextualItemDetachment");
static_assert(sizeof(FContextualItemDetachment) == 0x000008, "Wrong size on FContextualItemDetachment");
static_assert(offsetof(FContextualItemDetachment, AttachmentName) == 0x000000, "Member 'FContextualItemDetachment::AttachmentName' has a wrong offset!");

// ScriptStruct Stalker2.BulletProjectileHitArgs
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FBulletProjectileHitArgs final
{
public:
	EAmmoType                                     Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAmmoCaliber                                  Caliber;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0xA];                                        // 0x0002(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletProjectileHitArgs) == 0x000004, "Wrong alignment on FBulletProjectileHitArgs");
static_assert(sizeof(FBulletProjectileHitArgs) == 0x00000C, "Wrong size on FBulletProjectileHitArgs");
static_assert(offsetof(FBulletProjectileHitArgs, Type) == 0x000000, "Member 'FBulletProjectileHitArgs::Type' has a wrong offset!");
static_assert(offsetof(FBulletProjectileHitArgs, Caliber) == 0x000001, "Member 'FBulletProjectileHitArgs::Caliber' has a wrong offset!");

// ScriptStruct Stalker2.AnimCutsceneData
// 0x0008 (0x0008 - 0x0000)
struct FAnimCutsceneData final
{
public:
	float                                         BlendTime;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CacheToggleFlag;                                   // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimCutsceneData) == 0x000004, "Wrong alignment on FAnimCutsceneData");
static_assert(sizeof(FAnimCutsceneData) == 0x000008, "Wrong size on FAnimCutsceneData");
static_assert(offsetof(FAnimCutsceneData, BlendTime) == 0x000000, "Member 'FAnimCutsceneData::BlendTime' has a wrong offset!");
static_assert(offsetof(FAnimCutsceneData, CacheToggleFlag) == 0x000004, "Member 'FAnimCutsceneData::CacheToggleFlag' has a wrong offset!");

// ScriptStruct Stalker2.AnomalyHitArgs
// 0x0001 (0x0001 - 0x0000)
struct FAnomalyHitArgs final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnomalyHitArgs) == 0x000001, "Wrong alignment on FAnomalyHitArgs");
static_assert(sizeof(FAnomalyHitArgs) == 0x000001, "Wrong size on FAnomalyHitArgs");

// ScriptStruct Stalker2.ModifyVFXValue
// 0x0014 (0x0014 - 0x0000)
struct FModifyVFXValue final
{
public:
	class FName                                   AttachmentName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ValueToBeModified;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueModifierPerSec;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModifyVFXValue) == 0x000004, "Wrong alignment on FModifyVFXValue");
static_assert(sizeof(FModifyVFXValue) == 0x000014, "Wrong size on FModifyVFXValue");
static_assert(offsetof(FModifyVFXValue, AttachmentName) == 0x000000, "Member 'FModifyVFXValue::AttachmentName' has a wrong offset!");
static_assert(offsetof(FModifyVFXValue, ValueToBeModified) == 0x000008, "Member 'FModifyVFXValue::ValueToBeModified' has a wrong offset!");
static_assert(offsetof(FModifyVFXValue, ValueModifierPerSec) == 0x000010, "Member 'FModifyVFXValue::ValueModifierPerSec' has a wrong offset!");

// ScriptStruct Stalker2.EffectValueOverridePair
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FEffectValueOverridePair final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEffectValueOverridePair) == 0x000004, "Wrong alignment on FEffectValueOverridePair");
static_assert(sizeof(FEffectValueOverridePair) == 0x00000C, "Wrong size on FEffectValueOverridePair");

// ScriptStruct Stalker2.Weapon
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FWeapon final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeapon) == 0x000004, "Wrong alignment on FWeapon");
static_assert(sizeof(FWeapon) == 0x000008, "Wrong size on FWeapon");

// ScriptStruct Stalker2.CommonHitArgs
// 0x0150 (0x0150 - 0x0000)
struct FCommonHitArgs final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseStr;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorDamage;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorPiercing;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bleeding;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BleedingChanceIncrement;                           // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpulseDir;                                        // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUID                                   DamageDealerUID;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0038(0x00E8)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EDamageType                                   DamageType;                                        // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDirectDamageSkipCalculations;                     // 0x0121(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldIgnoreArmor;                                // 0x0122(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_123[0x5];                                      // 0x0123(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEffectValueOverridePair>       ApplicableEffects;                                 // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	EDamageSource                                 DamageSource;                                      // 0x0138(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeapon                                Weapon;                                            // 0x013C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	bool                                          bFlownThroughObject;                               // 0x0144(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LaunchTimestamp;                                   // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFractionDamage;                                 // 0x014C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommonHitArgs) == 0x000008, "Wrong alignment on FCommonHitArgs");
static_assert(sizeof(FCommonHitArgs) == 0x000150, "Wrong size on FCommonHitArgs");
static_assert(offsetof(FCommonHitArgs, Damage) == 0x000000, "Member 'FCommonHitArgs::Damage' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, ImpulseStr) == 0x000004, "Member 'FCommonHitArgs::ImpulseStr' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, ArmorDamage) == 0x000008, "Member 'FCommonHitArgs::ArmorDamage' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, ArmorPiercing) == 0x00000C, "Member 'FCommonHitArgs::ArmorPiercing' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, Bleeding) == 0x000010, "Member 'FCommonHitArgs::Bleeding' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, BleedingChanceIncrement) == 0x000014, "Member 'FCommonHitArgs::BleedingChanceIncrement' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, ImpulseDir) == 0x000018, "Member 'FCommonHitArgs::ImpulseDir' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, DamageDealerUID) == 0x000030, "Member 'FCommonHitArgs::DamageDealerUID' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, HitResult) == 0x000038, "Member 'FCommonHitArgs::HitResult' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, DamageType) == 0x000120, "Member 'FCommonHitArgs::DamageType' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, bDirectDamageSkipCalculations) == 0x000121, "Member 'FCommonHitArgs::bDirectDamageSkipCalculations' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, bShouldIgnoreArmor) == 0x000122, "Member 'FCommonHitArgs::bShouldIgnoreArmor' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, ApplicableEffects) == 0x000128, "Member 'FCommonHitArgs::ApplicableEffects' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, DamageSource) == 0x000138, "Member 'FCommonHitArgs::DamageSource' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, Weapon) == 0x00013C, "Member 'FCommonHitArgs::Weapon' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, bFlownThroughObject) == 0x000144, "Member 'FCommonHitArgs::bFlownThroughObject' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, LaunchTimestamp) == 0x000148, "Member 'FCommonHitArgs::LaunchTimestamp' has a wrong offset!");
static_assert(offsetof(FCommonHitArgs, bIsFractionDamage) == 0x00014C, "Member 'FCommonHitArgs::bIsFractionDamage' has a wrong offset!");

// ScriptStruct Stalker2.CutsceneBlinkConfig
// 0x0008 (0x0008 - 0x0000)
struct FCutsceneBlinkConfig final
{
public:
	float                                         MinTimeInterval;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeInterval;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCutsceneBlinkConfig) == 0x000004, "Wrong alignment on FCutsceneBlinkConfig");
static_assert(sizeof(FCutsceneBlinkConfig) == 0x000008, "Wrong size on FCutsceneBlinkConfig");
static_assert(offsetof(FCutsceneBlinkConfig, MinTimeInterval) == 0x000000, "Member 'FCutsceneBlinkConfig::MinTimeInterval' has a wrong offset!");
static_assert(offsetof(FCutsceneBlinkConfig, MaxTimeInterval) == 0x000004, "Member 'FCutsceneBlinkConfig::MaxTimeInterval' has a wrong offset!");

// ScriptStruct Stalker2.EyesLookAtData
// 0x00C0 (0x00C0 - 0x0000)
struct FEyesLookAtData final
{
public:
	TMap<ECutsceneBlinkProfile, struct FCutsceneBlinkConfig> CutsceneBlinkConfigs;                   // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BlinkAnimation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlinkOnEyeMoveThreshold;                           // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlinkOnEyeMoveInterval;                            // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlRigEnableInterpSpeed;                       // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlRigDisableInterpSpeed;                      // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CutsceneProceduralEyesWeight;                      // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CutsceneProceduralEyesAmplitude;                   // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CutsceneProceduralEyesIntensity;                   // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBeEnabled;                                  // 0x0074(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ControlRigAlpha;                                   // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CutsceneEyesLookAtWeight;                          // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtLocation;                                    // 0x0080(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LookAtActor;                                       // 0x0098(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 LookAtSkeletalMesh;                                // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECutsceneBlinkProfile                         CutsceneBlinkProfile;                              // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECutsceneEyesIdleProfile                      CutsceneEyesIdleProfile;                           // 0x00A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToNextBlink;                                   // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlinkOnEyeMoveCooldown;                            // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CutsceneHeadControlRigAlpha;                       // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CutsceneHeadLookAtWeight;                          // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldOffOnEdges;                                 // 0x00BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEyesLookAtData) == 0x000008, "Wrong alignment on FEyesLookAtData");
static_assert(sizeof(FEyesLookAtData) == 0x0000C0, "Wrong size on FEyesLookAtData");
static_assert(offsetof(FEyesLookAtData, CutsceneBlinkConfigs) == 0x000000, "Member 'FEyesLookAtData::CutsceneBlinkConfigs' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, BlinkAnimation) == 0x000050, "Member 'FEyesLookAtData::BlinkAnimation' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, BlinkOnEyeMoveThreshold) == 0x000058, "Member 'FEyesLookAtData::BlinkOnEyeMoveThreshold' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, BlinkOnEyeMoveInterval) == 0x00005C, "Member 'FEyesLookAtData::BlinkOnEyeMoveInterval' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, ControlRigEnableInterpSpeed) == 0x000060, "Member 'FEyesLookAtData::ControlRigEnableInterpSpeed' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, ControlRigDisableInterpSpeed) == 0x000064, "Member 'FEyesLookAtData::ControlRigDisableInterpSpeed' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, CutsceneProceduralEyesWeight) == 0x000068, "Member 'FEyesLookAtData::CutsceneProceduralEyesWeight' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, CutsceneProceduralEyesAmplitude) == 0x00006C, "Member 'FEyesLookAtData::CutsceneProceduralEyesAmplitude' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, CutsceneProceduralEyesIntensity) == 0x000070, "Member 'FEyesLookAtData::CutsceneProceduralEyesIntensity' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, bShouldBeEnabled) == 0x000074, "Member 'FEyesLookAtData::bShouldBeEnabled' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, ControlRigAlpha) == 0x000078, "Member 'FEyesLookAtData::ControlRigAlpha' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, CutsceneEyesLookAtWeight) == 0x00007C, "Member 'FEyesLookAtData::CutsceneEyesLookAtWeight' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, LookAtLocation) == 0x000080, "Member 'FEyesLookAtData::LookAtLocation' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, LookAtActor) == 0x000098, "Member 'FEyesLookAtData::LookAtActor' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, LookAtSkeletalMesh) == 0x0000A0, "Member 'FEyesLookAtData::LookAtSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, CutsceneBlinkProfile) == 0x0000A8, "Member 'FEyesLookAtData::CutsceneBlinkProfile' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, CutsceneEyesIdleProfile) == 0x0000A9, "Member 'FEyesLookAtData::CutsceneEyesIdleProfile' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, TimeToNextBlink) == 0x0000AC, "Member 'FEyesLookAtData::TimeToNextBlink' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, BlinkOnEyeMoveCooldown) == 0x0000B0, "Member 'FEyesLookAtData::BlinkOnEyeMoveCooldown' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, CutsceneHeadControlRigAlpha) == 0x0000B4, "Member 'FEyesLookAtData::CutsceneHeadControlRigAlpha' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, CutsceneHeadLookAtWeight) == 0x0000B8, "Member 'FEyesLookAtData::CutsceneHeadLookAtWeight' has a wrong offset!");
static_assert(offsetof(FEyesLookAtData, bShouldOffOnEdges) == 0x0000BC, "Member 'FEyesLookAtData::bShouldOffOnEdges' has a wrong offset!");

// ScriptStruct Stalker2.AnimFaceBlendConfig
// 0x0038 (0x0038 - 0x0000)
struct FAnimFaceBlendConfig final
{
public:
	struct FAlphaBlend                            BlendIn;                                           // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FaceBlendOutTime;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FaceBlendOutTriggerTime;                           // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimFaceBlendConfig) == 0x000008, "Wrong alignment on FAnimFaceBlendConfig");
static_assert(sizeof(FAnimFaceBlendConfig) == 0x000038, "Wrong size on FAnimFaceBlendConfig");
static_assert(offsetof(FAnimFaceBlendConfig, BlendIn) == 0x000000, "Member 'FAnimFaceBlendConfig::BlendIn' has a wrong offset!");
static_assert(offsetof(FAnimFaceBlendConfig, FaceBlendOutTime) == 0x000030, "Member 'FAnimFaceBlendConfig::FaceBlendOutTime' has a wrong offset!");
static_assert(offsetof(FAnimFaceBlendConfig, FaceBlendOutTriggerTime) == 0x000034, "Member 'FAnimFaceBlendConfig::FaceBlendOutTriggerTime' has a wrong offset!");

// ScriptStruct Stalker2.AnimHumanFaceData
// 0x01F8 (0x01F8 - 0x0000)
struct FAnimHumanFaceData final
{
public:
	TArray<class UAnimSequence*>                  DeathAnimations;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CurrentDeathAnimation;                             // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  HitAnimations;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LastHitAnimation;                                  // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  WoundedAnimations;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CurrentWoundedAnimation;                           // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LastWoundedAnimation;                              // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      BlendShapeCurves;                                  // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EEmotionalFaceMasks                           CurrentFaceMask;                                   // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 FaceMeshComponent;                                 // 0x00A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 CharacterSkeletalMeshComponent;                    // 0x00B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEyesLookAtData                        EyesLookAtData;                                    // 0x00B8(0x00C0)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAnimFaceBlendConfig                   FaceBlendConfig;                                   // 0x0178(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EAnimationHeadTypes                           HeadType;                                          // 0x01B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 BlockingMasks;                                     // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           FastFaceBlendCurves;                               // 0x01C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SlowFaceBlendCurves;                               // 0x01D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAlive;                                            // 0x01E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEnableAdamAppleAnimations;                  // 0x01E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsThroatAnimationPlaying;                         // 0x01EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayingDummyDialogAnimation;                      // 0x01EB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFaceAnimBlendingOut;                            // 0x01EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFaceAnimPlaying;                                // 0x01ED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFaceTongueAnimPlaying;                          // 0x01EE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EF[0x1];                                      // 0x01EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisableIdleTongueCurveValue;                       // 0x01F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimHumanFaceData) == 0x000008, "Wrong alignment on FAnimHumanFaceData");
static_assert(sizeof(FAnimHumanFaceData) == 0x0001F8, "Wrong size on FAnimHumanFaceData");
static_assert(offsetof(FAnimHumanFaceData, DeathAnimations) == 0x000000, "Member 'FAnimHumanFaceData::DeathAnimations' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, CurrentDeathAnimation) == 0x000010, "Member 'FAnimHumanFaceData::CurrentDeathAnimation' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, HitAnimations) == 0x000018, "Member 'FAnimHumanFaceData::HitAnimations' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, LastHitAnimation) == 0x000028, "Member 'FAnimHumanFaceData::LastHitAnimation' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, WoundedAnimations) == 0x000030, "Member 'FAnimHumanFaceData::WoundedAnimations' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, CurrentWoundedAnimation) == 0x000040, "Member 'FAnimHumanFaceData::CurrentWoundedAnimation' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, LastWoundedAnimation) == 0x000048, "Member 'FAnimHumanFaceData::LastWoundedAnimation' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, BlendShapeCurves) == 0x000050, "Member 'FAnimHumanFaceData::BlendShapeCurves' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, CurrentFaceMask) == 0x0000A0, "Member 'FAnimHumanFaceData::CurrentFaceMask' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, FaceMeshComponent) == 0x0000A8, "Member 'FAnimHumanFaceData::FaceMeshComponent' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, CharacterSkeletalMeshComponent) == 0x0000B0, "Member 'FAnimHumanFaceData::CharacterSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, EyesLookAtData) == 0x0000B8, "Member 'FAnimHumanFaceData::EyesLookAtData' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, FaceBlendConfig) == 0x000178, "Member 'FAnimHumanFaceData::FaceBlendConfig' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, HeadType) == 0x0001B0, "Member 'FAnimHumanFaceData::HeadType' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, BlockingMasks) == 0x0001B8, "Member 'FAnimHumanFaceData::BlockingMasks' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, FastFaceBlendCurves) == 0x0001C8, "Member 'FAnimHumanFaceData::FastFaceBlendCurves' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, SlowFaceBlendCurves) == 0x0001D8, "Member 'FAnimHumanFaceData::SlowFaceBlendCurves' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, bAlive) == 0x0001E8, "Member 'FAnimHumanFaceData::bAlive' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, bShouldEnableAdamAppleAnimations) == 0x0001E9, "Member 'FAnimHumanFaceData::bShouldEnableAdamAppleAnimations' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, bIsThroatAnimationPlaying) == 0x0001EA, "Member 'FAnimHumanFaceData::bIsThroatAnimationPlaying' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, bPlayingDummyDialogAnimation) == 0x0001EB, "Member 'FAnimHumanFaceData::bPlayingDummyDialogAnimation' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, bIsFaceAnimBlendingOut) == 0x0001EC, "Member 'FAnimHumanFaceData::bIsFaceAnimBlendingOut' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, bIsFaceAnimPlaying) == 0x0001ED, "Member 'FAnimHumanFaceData::bIsFaceAnimPlaying' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, bIsFaceTongueAnimPlaying) == 0x0001EE, "Member 'FAnimHumanFaceData::bIsFaceTongueAnimPlaying' has a wrong offset!");
static_assert(offsetof(FAnimHumanFaceData, DisableIdleTongueCurveValue) == 0x0001F0, "Member 'FAnimHumanFaceData::DisableIdleTongueCurveValue' has a wrong offset!");

// ScriptStruct Stalker2.AnimWoundedData
// 0x0048 (0x0048 - 0x0000)
struct FAnimWoundedData final
{
public:
	bool                                          bWounded;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWoundedAnimState                             WoundedState;                                      // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SlopeCorrectionDelta;                              // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EnterRagdollTime;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeTestSweepUpOffset;                            // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeTestSweepDownOffset;                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeTestSweepSphereRadius;                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             SlopeTestCollisionChannel;                         // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x17];                                      // 0x0031(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimWoundedData) == 0x000008, "Wrong alignment on FAnimWoundedData");
static_assert(sizeof(FAnimWoundedData) == 0x000048, "Wrong size on FAnimWoundedData");
static_assert(offsetof(FAnimWoundedData, bWounded) == 0x000000, "Member 'FAnimWoundedData::bWounded' has a wrong offset!");
static_assert(offsetof(FAnimWoundedData, WoundedState) == 0x000001, "Member 'FAnimWoundedData::WoundedState' has a wrong offset!");
static_assert(offsetof(FAnimWoundedData, SlopeCorrectionDelta) == 0x000008, "Member 'FAnimWoundedData::SlopeCorrectionDelta' has a wrong offset!");
static_assert(offsetof(FAnimWoundedData, EnterRagdollTime) == 0x000020, "Member 'FAnimWoundedData::EnterRagdollTime' has a wrong offset!");
static_assert(offsetof(FAnimWoundedData, SlopeTestSweepUpOffset) == 0x000024, "Member 'FAnimWoundedData::SlopeTestSweepUpOffset' has a wrong offset!");
static_assert(offsetof(FAnimWoundedData, SlopeTestSweepDownOffset) == 0x000028, "Member 'FAnimWoundedData::SlopeTestSweepDownOffset' has a wrong offset!");
static_assert(offsetof(FAnimWoundedData, SlopeTestSweepSphereRadius) == 0x00002C, "Member 'FAnimWoundedData::SlopeTestSweepSphereRadius' has a wrong offset!");
static_assert(offsetof(FAnimWoundedData, SlopeTestCollisionChannel) == 0x000030, "Member 'FAnimWoundedData::SlopeTestCollisionChannel' has a wrong offset!");

// ScriptStruct Stalker2.AkLateReverbCollection
// 0x0010 (0x0078 - 0x0068)
struct FAkLateReverbCollection final : public FBaseTickAggregationCollection
{
public:
	TArray<class UAkLateReverbComponent*>         LateReverbComponents;                              // 0x0068(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAkLateReverbCollection) == 0x000008, "Wrong alignment on FAkLateReverbCollection");
static_assert(sizeof(FAkLateReverbCollection) == 0x000078, "Wrong size on FAkLateReverbCollection");
static_assert(offsetof(FAkLateReverbCollection, LateReverbComponents) == 0x000068, "Member 'FAkLateReverbCollection::LateReverbComponents' has a wrong offset!");

// ScriptStruct Stalker2.AnimSleepData
// 0x0001 (0x0001 - 0x0000)
struct FAnimSleepData final
{
public:
	bool                                          bSleep;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSleepData) == 0x000001, "Wrong alignment on FAnimSleepData");
static_assert(sizeof(FAnimSleepData) == 0x000001, "Wrong size on FAnimSleepData");
static_assert(offsetof(FAnimSleepData, bSleep) == 0x000000, "Member 'FAnimSleepData::bSleep' has a wrong offset!");

// ScriptStruct Stalker2.TransitionAnimations
// 0x0010 (0x0010 - 0x0000)
struct FTransitionAnimations final
{
public:
	class UAnimSequence*                          To;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          From;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransitionAnimations) == 0x000008, "Wrong alignment on FTransitionAnimations");
static_assert(sizeof(FTransitionAnimations) == 0x000010, "Wrong size on FTransitionAnimations");
static_assert(offsetof(FTransitionAnimations, To) == 0x000000, "Member 'FTransitionAnimations::To' has a wrong offset!");
static_assert(offsetof(FTransitionAnimations, From) == 0x000008, "Member 'FTransitionAnimations::From' has a wrong offset!");

// ScriptStruct Stalker2.AkSurfaceReflectorSetCollection
// 0x0010 (0x0078 - 0x0068)
struct FAkSurfaceReflectorSetCollection final : public FBaseTickAggregationCollection
{
public:
	TArray<class UAkSurfaceReflectorSetComponent*> SurfaceReflectorSetComponents;                    // 0x0068(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAkSurfaceReflectorSetCollection) == 0x000008, "Wrong alignment on FAkSurfaceReflectorSetCollection");
static_assert(sizeof(FAkSurfaceReflectorSetCollection) == 0x000078, "Wrong size on FAkSurfaceReflectorSetCollection");
static_assert(offsetof(FAkSurfaceReflectorSetCollection, SurfaceReflectorSetComponents) == 0x000068, "Member 'FAkSurfaceReflectorSetCollection::SurfaceReflectorSetComponents' has a wrong offset!");

// ScriptStruct Stalker2.ExplosionHitArgs
// 0x0040 (0x0040 - 0x0000)
struct FExplosionHitArgs final
{
public:
	struct FVector                                ExplosionLocation;                                 // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionRadius;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  ExplosiveActor;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ExplosiveActorPrototypeID;                         // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUID                                   ExplosionInstigatorUID;                            // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExplosionHitArgs) == 0x000008, "Wrong alignment on FExplosionHitArgs");
static_assert(sizeof(FExplosionHitArgs) == 0x000040, "Wrong size on FExplosionHitArgs");
static_assert(offsetof(FExplosionHitArgs, ExplosionLocation) == 0x000000, "Member 'FExplosionHitArgs::ExplosionLocation' has a wrong offset!");
static_assert(offsetof(FExplosionHitArgs, ExplosionRadius) == 0x000018, "Member 'FExplosionHitArgs::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(FExplosionHitArgs, ExplosiveActor) == 0x00001C, "Member 'FExplosionHitArgs::ExplosiveActor' has a wrong offset!");
static_assert(offsetof(FExplosionHitArgs, ExplosiveActorPrototypeID) == 0x000028, "Member 'FExplosionHitArgs::ExplosiveActorPrototypeID' has a wrong offset!");
static_assert(offsetof(FExplosionHitArgs, ExplosionInstigatorUID) == 0x000038, "Member 'FExplosionHitArgs::ExplosionInstigatorUID' has a wrong offset!");

// ScriptStruct Stalker2.GSC_WidgetProgressStyle
// 0x02F8 (0x0300 - 0x0008)
struct FGSC_WidgetProgressStyle final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProgressBarStyle                      ProgressBarStyle;                                  // 0x0010(0x02F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGSC_WidgetProgressStyle) == 0x000010, "Wrong alignment on FGSC_WidgetProgressStyle");
static_assert(sizeof(FGSC_WidgetProgressStyle) == 0x000300, "Wrong size on FGSC_WidgetProgressStyle");
static_assert(offsetof(FGSC_WidgetProgressStyle, ProgressBarStyle) == 0x000010, "Member 'FGSC_WidgetProgressStyle::ProgressBarStyle' has a wrong offset!");

// ScriptStruct Stalker2.MeleeHitArgs
// 0x0001 (0x0001 - 0x0000)
struct FMeleeHitArgs final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMeleeHitArgs) == 0x000001, "Wrong alignment on FMeleeHitArgs");
static_assert(sizeof(FMeleeHitArgs) == 0x000001, "Wrong size on FMeleeHitArgs");

// ScriptStruct Stalker2.ParameterTransition
// 0x0008 (0x0008 - 0x0000)
struct FParameterTransition final
{
public:
	float                                         StartOffset;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParameterTransition) == 0x000004, "Wrong alignment on FParameterTransition");
static_assert(sizeof(FParameterTransition) == 0x000008, "Wrong size on FParameterTransition");
static_assert(offsetof(FParameterTransition, StartOffset) == 0x000000, "Member 'FParameterTransition::StartOffset' has a wrong offset!");
static_assert(offsetof(FParameterTransition, Duration) == 0x000004, "Member 'FParameterTransition::Duration' has a wrong offset!");

// ScriptStruct Stalker2.Parameter
// 0x0058 (0x0058 - 0x0000)
struct FParameter
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EWeather, struct FParameterTransition>   TransitionOverrides;                               // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParameter) == 0x000008, "Wrong alignment on FParameter");
static_assert(sizeof(FParameter) == 0x000058, "Wrong size on FParameter");
static_assert(offsetof(FParameter, TransitionOverrides) == 0x000008, "Member 'FParameter::TransitionOverrides' has a wrong offset!");

// ScriptStruct Stalker2.LinearColorParameter
// 0x0008 (0x0060 - 0x0058)
struct FLinearColorParameter final : public FParameter
{
public:
	class UCurveLinearColor*                      Curve;                                             // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLinearColorParameter) == 0x000008, "Wrong alignment on FLinearColorParameter");
static_assert(sizeof(FLinearColorParameter) == 0x000060, "Wrong size on FLinearColorParameter");
static_assert(offsetof(FLinearColorParameter, Curve) == 0x000058, "Member 'FLinearColorParameter::Curve' has a wrong offset!");

// ScriptStruct Stalker2.LightShaftsState
// 0x0060 (0x0060 - 0x0000)
struct FLightShaftsState final
{
public:
	struct FLinearColorParameter                  BloomTint;                                         // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightShaftsState) == 0x000008, "Wrong alignment on FLightShaftsState");
static_assert(sizeof(FLightShaftsState) == 0x000060, "Wrong size on FLightShaftsState");
static_assert(offsetof(FLightShaftsState, BloomTint) == 0x000000, "Member 'FLightShaftsState::BloomTint' has a wrong offset!");

// ScriptStruct Stalker2.HumanKnockDownAnimations
// 0x0028 (0x0028 - 0x0000)
struct FHumanKnockDownAnimations final
{
public:
	class UAnimSequence*                          KnockDownInForward;                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          KnockDownInBackward;                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          KnockDownInLeft;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          KnockDownInRight;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          KnockDownOut;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHumanKnockDownAnimations) == 0x000008, "Wrong alignment on FHumanKnockDownAnimations");
static_assert(sizeof(FHumanKnockDownAnimations) == 0x000028, "Wrong size on FHumanKnockDownAnimations");
static_assert(offsetof(FHumanKnockDownAnimations, KnockDownInForward) == 0x000000, "Member 'FHumanKnockDownAnimations::KnockDownInForward' has a wrong offset!");
static_assert(offsetof(FHumanKnockDownAnimations, KnockDownInBackward) == 0x000008, "Member 'FHumanKnockDownAnimations::KnockDownInBackward' has a wrong offset!");
static_assert(offsetof(FHumanKnockDownAnimations, KnockDownInLeft) == 0x000010, "Member 'FHumanKnockDownAnimations::KnockDownInLeft' has a wrong offset!");
static_assert(offsetof(FHumanKnockDownAnimations, KnockDownInRight) == 0x000018, "Member 'FHumanKnockDownAnimations::KnockDownInRight' has a wrong offset!");
static_assert(offsetof(FHumanKnockDownAnimations, KnockDownOut) == 0x000020, "Member 'FHumanKnockDownAnimations::KnockDownOut' has a wrong offset!");

// ScriptStruct Stalker2.AkComponentRetargetRow
// 0x0008 (0x0010 - 0x0008)
struct FAkComponentRetargetRow final : public FTableRowBase
{
public:
	class FName                                   TargetSocketName;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkComponentRetargetRow) == 0x000008, "Wrong alignment on FAkComponentRetargetRow");
static_assert(sizeof(FAkComponentRetargetRow) == 0x000010, "Wrong size on FAkComponentRetargetRow");
static_assert(offsetof(FAkComponentRetargetRow, TargetSocketName) == 0x000008, "Member 'FAkComponentRetargetRow::TargetSocketName' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerAimingData
// 0x0018 (0x0018 - 0x0000)
struct FAnimPlayerAimingData final
{
public:
	bool                                          bAiming;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimInFrame;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOutFrame;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAlpha;                                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimCameraShakeAlpha;                               // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimationAimState                            AimState;                                          // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerAimingData) == 0x000004, "Wrong alignment on FAnimPlayerAimingData");
static_assert(sizeof(FAnimPlayerAimingData) == 0x000018, "Wrong size on FAnimPlayerAimingData");
static_assert(offsetof(FAnimPlayerAimingData, bAiming) == 0x000000, "Member 'FAnimPlayerAimingData::bAiming' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAimingData, AimInFrame) == 0x000004, "Member 'FAnimPlayerAimingData::AimInFrame' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAimingData, AimOutFrame) == 0x000008, "Member 'FAnimPlayerAimingData::AimOutFrame' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAimingData, AimAlpha) == 0x00000C, "Member 'FAnimPlayerAimingData::AimAlpha' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAimingData, AimCameraShakeAlpha) == 0x000010, "Member 'FAnimPlayerAimingData::AimCameraShakeAlpha' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAimingData, AimState) == 0x000014, "Member 'FAnimPlayerAimingData::AimState' has a wrong offset!");

// ScriptStruct Stalker2.RightClickMenuItemData
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FRightClickMenuItemData final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRightClickMenuItemData) == 0x000008, "Wrong alignment on FRightClickMenuItemData");
static_assert(sizeof(FRightClickMenuItemData) == 0x000040, "Wrong size on FRightClickMenuItemData");

// ScriptStruct Stalker2.PhysicsHitArgs
// 0x0008 (0x0008 - 0x0000)
struct FPhysicsHitArgs final
{
public:
	class AActor*                                 StimulusActor;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhysicsHitArgs) == 0x000008, "Wrong alignment on FPhysicsHitArgs");
static_assert(sizeof(FPhysicsHitArgs) == 0x000008, "Wrong size on FPhysicsHitArgs");
static_assert(offsetof(FPhysicsHitArgs, StimulusActor) == 0x000000, "Member 'FPhysicsHitArgs::StimulusActor' has a wrong offset!");

// ScriptStruct Stalker2.AnimationSingleHit
// 0x000C (0x000C - 0x0000)
struct FAnimationSingleHit final
{
public:
	bool                                          bPlay;                                             // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitDirection;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationSingleHit) == 0x000004, "Wrong alignment on FAnimationSingleHit");
static_assert(sizeof(FAnimationSingleHit) == 0x00000C, "Wrong size on FAnimationSingleHit");
static_assert(offsetof(FAnimationSingleHit, bPlay) == 0x000000, "Member 'FAnimationSingleHit::bPlay' has a wrong offset!");
static_assert(offsetof(FAnimationSingleHit, PlayRate) == 0x000004, "Member 'FAnimationSingleHit::PlayRate' has a wrong offset!");
static_assert(offsetof(FAnimationSingleHit, HitDirection) == 0x000008, "Member 'FAnimationSingleHit::HitDirection' has a wrong offset!");

// ScriptStruct Stalker2.AnimHitBodyPart
// 0x0058 (0x0058 - 0x0000)
struct FAnimHitBodyPart final
{
public:
	struct FAnimationSingleHit                    FirstHit;                                          // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimationSingleHit                    SecondHit;                                         // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinimalAngleBetweenHits;                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextHitAvailableCurveName;                         // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AvailiableParentBoneNames;                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ExcludedParentBoneNames;                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EAnimHitBodyPartType                          BodyType;                                          // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0xF];                                       // 0x0049(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimHitBodyPart) == 0x000008, "Wrong alignment on FAnimHitBodyPart");
static_assert(sizeof(FAnimHitBodyPart) == 0x000058, "Wrong size on FAnimHitBodyPart");
static_assert(offsetof(FAnimHitBodyPart, FirstHit) == 0x000000, "Member 'FAnimHitBodyPart::FirstHit' has a wrong offset!");
static_assert(offsetof(FAnimHitBodyPart, SecondHit) == 0x00000C, "Member 'FAnimHitBodyPart::SecondHit' has a wrong offset!");
static_assert(offsetof(FAnimHitBodyPart, MinimalAngleBetweenHits) == 0x000018, "Member 'FAnimHitBodyPart::MinimalAngleBetweenHits' has a wrong offset!");
static_assert(offsetof(FAnimHitBodyPart, NextHitAvailableCurveName) == 0x00001C, "Member 'FAnimHitBodyPart::NextHitAvailableCurveName' has a wrong offset!");
static_assert(offsetof(FAnimHitBodyPart, AvailiableParentBoneNames) == 0x000028, "Member 'FAnimHitBodyPart::AvailiableParentBoneNames' has a wrong offset!");
static_assert(offsetof(FAnimHitBodyPart, ExcludedParentBoneNames) == 0x000038, "Member 'FAnimHitBodyPart::ExcludedParentBoneNames' has a wrong offset!");
static_assert(offsetof(FAnimHitBodyPart, BodyType) == 0x000048, "Member 'FAnimHitBodyPart::BodyType' has a wrong offset!");

// ScriptStruct Stalker2.AnimBodyPartBonesConfig
// 0x0058 (0x0058 - 0x0000)
struct FAnimBodyPartBonesConfig final
{
public:
	EAnimHitBodyPart                              HitBodyPart;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             Bones;                                             // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimBodyPartBonesConfig) == 0x000008, "Wrong alignment on FAnimBodyPartBonesConfig");
static_assert(sizeof(FAnimBodyPartBonesConfig) == 0x000058, "Wrong size on FAnimBodyPartBonesConfig");
static_assert(offsetof(FAnimBodyPartBonesConfig, HitBodyPart) == 0x000000, "Member 'FAnimBodyPartBonesConfig::HitBodyPart' has a wrong offset!");
static_assert(offsetof(FAnimBodyPartBonesConfig, Bones) == 0x000008, "Member 'FAnimBodyPartBonesConfig::Bones' has a wrong offset!");

// ScriptStruct Stalker2.AnimHitData
// 0x0140 (0x0140 - 0x0000)
struct FAnimHitData final
{
public:
	bool                                          bEnableAnimationHit;                               // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimHitBodyPart>               Hits;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EAnimHitSourceType                            HitSourceType;                                     // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxCountOfSimultaneouslyPlayedHitAnimations;       // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumberOfAnimationsWhenFirstWillBeStopped;          // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x65];                                      // 0x001B(0x0065)(Fixing Size After Last Property [ Dumper-7 ])
	EAnimHitBodyPartType                          LastHittedBodyPart;                                // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitDirection;                                      // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CalculatedHitDirection;                            // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitVerticalDirection;                              // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimDirections                               HitAnimDirection;                                  // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDeathAnimationType                           DeathAnimationType;                                // 0x0091(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHumanAnimDamageSource                        DeathDamageSource;                                 // 0x0092(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93[0x5];                                       // 0x0093(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          DeadPose;                                          // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiedLyingDown;                                    // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiedFromAbove;                                    // 0x00A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZombieResurrectRate;                               // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FRotator>            ForceWarpActorRotation;                            // 0x00A8(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FAnimBodyPartBonesConfig>       BodyPartBonesConfig;                               // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x38];                                     // 0x0108(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimHitData) == 0x000008, "Wrong alignment on FAnimHitData");
static_assert(sizeof(FAnimHitData) == 0x000140, "Wrong size on FAnimHitData");
static_assert(offsetof(FAnimHitData, bEnableAnimationHit) == 0x000000, "Member 'FAnimHitData::bEnableAnimationHit' has a wrong offset!");
static_assert(offsetof(FAnimHitData, Hits) == 0x000008, "Member 'FAnimHitData::Hits' has a wrong offset!");
static_assert(offsetof(FAnimHitData, HitSourceType) == 0x000018, "Member 'FAnimHitData::HitSourceType' has a wrong offset!");
static_assert(offsetof(FAnimHitData, MaxCountOfSimultaneouslyPlayedHitAnimations) == 0x000019, "Member 'FAnimHitData::MaxCountOfSimultaneouslyPlayedHitAnimations' has a wrong offset!");
static_assert(offsetof(FAnimHitData, NumberOfAnimationsWhenFirstWillBeStopped) == 0x00001A, "Member 'FAnimHitData::NumberOfAnimationsWhenFirstWillBeStopped' has a wrong offset!");
static_assert(offsetof(FAnimHitData, LastHittedBodyPart) == 0x000080, "Member 'FAnimHitData::LastHittedBodyPart' has a wrong offset!");
static_assert(offsetof(FAnimHitData, HitDirection) == 0x000084, "Member 'FAnimHitData::HitDirection' has a wrong offset!");
static_assert(offsetof(FAnimHitData, CalculatedHitDirection) == 0x000088, "Member 'FAnimHitData::CalculatedHitDirection' has a wrong offset!");
static_assert(offsetof(FAnimHitData, HitVerticalDirection) == 0x00008C, "Member 'FAnimHitData::HitVerticalDirection' has a wrong offset!");
static_assert(offsetof(FAnimHitData, HitAnimDirection) == 0x000090, "Member 'FAnimHitData::HitAnimDirection' has a wrong offset!");
static_assert(offsetof(FAnimHitData, DeathAnimationType) == 0x000091, "Member 'FAnimHitData::DeathAnimationType' has a wrong offset!");
static_assert(offsetof(FAnimHitData, DeathDamageSource) == 0x000092, "Member 'FAnimHitData::DeathDamageSource' has a wrong offset!");
static_assert(offsetof(FAnimHitData, DeadPose) == 0x000098, "Member 'FAnimHitData::DeadPose' has a wrong offset!");
static_assert(offsetof(FAnimHitData, bDiedLyingDown) == 0x0000A0, "Member 'FAnimHitData::bDiedLyingDown' has a wrong offset!");
static_assert(offsetof(FAnimHitData, bDiedFromAbove) == 0x0000A1, "Member 'FAnimHitData::bDiedFromAbove' has a wrong offset!");
static_assert(offsetof(FAnimHitData, ZombieResurrectRate) == 0x0000A4, "Member 'FAnimHitData::ZombieResurrectRate' has a wrong offset!");
static_assert(offsetof(FAnimHitData, ForceWarpActorRotation) == 0x0000A8, "Member 'FAnimHitData::ForceWarpActorRotation' has a wrong offset!");
static_assert(offsetof(FAnimHitData, BodyPartBonesConfig) == 0x0000F8, "Member 'FAnimHitData::BodyPartBonesConfig' has a wrong offset!");

// ScriptStruct Stalker2.SpawnPhantomParams
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FSpawnPhantomParams final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnPhantomParams) == 0x000008, "Wrong alignment on FSpawnPhantomParams");
static_assert(sizeof(FSpawnPhantomParams) == 0x000058, "Wrong size on FSpawnPhantomParams");

// ScriptStruct Stalker2.EnvironmentParticlePrototype
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FEnvironmentParticlePrototype
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnvironmentParticlePrototype) == 0x000008, "Wrong alignment on FEnvironmentParticlePrototype");
static_assert(sizeof(FEnvironmentParticlePrototype) == 0x000008, "Wrong size on FEnvironmentParticlePrototype");

// ScriptStruct Stalker2.ParticlePlayerComponentSpawnPrototype
// 0x0028 (0x0030 - 0x0008)
struct FParticlePlayerComponentSpawnPrototype final : public FEnvironmentParticlePrototype
{
public:
	float                                         BaseSpawnProbability;                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnProbabilityIncrement;                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnProbabilityCheckTime;                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationCheckTime;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlayerHeadOffset;                                  // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticlePlayerComponentSpawnPrototype) == 0x000008, "Wrong alignment on FParticlePlayerComponentSpawnPrototype");
static_assert(sizeof(FParticlePlayerComponentSpawnPrototype) == 0x000030, "Wrong size on FParticlePlayerComponentSpawnPrototype");
static_assert(offsetof(FParticlePlayerComponentSpawnPrototype, BaseSpawnProbability) == 0x000008, "Member 'FParticlePlayerComponentSpawnPrototype::BaseSpawnProbability' has a wrong offset!");
static_assert(offsetof(FParticlePlayerComponentSpawnPrototype, SpawnProbabilityIncrement) == 0x00000C, "Member 'FParticlePlayerComponentSpawnPrototype::SpawnProbabilityIncrement' has a wrong offset!");
static_assert(offsetof(FParticlePlayerComponentSpawnPrototype, SpawnProbabilityCheckTime) == 0x000010, "Member 'FParticlePlayerComponentSpawnPrototype::SpawnProbabilityCheckTime' has a wrong offset!");
static_assert(offsetof(FParticlePlayerComponentSpawnPrototype, LocationCheckTime) == 0x000014, "Member 'FParticlePlayerComponentSpawnPrototype::LocationCheckTime' has a wrong offset!");
static_assert(offsetof(FParticlePlayerComponentSpawnPrototype, PlayerHeadOffset) == 0x000018, "Member 'FParticlePlayerComponentSpawnPrototype::PlayerHeadOffset' has a wrong offset!");

// ScriptStruct Stalker2.ProjectileHitArgs
// 0x0001 (0x0001 - 0x0000)
struct FProjectileHitArgs final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileHitArgs) == 0x000001, "Wrong alignment on FProjectileHitArgs");
static_assert(sizeof(FProjectileHitArgs) == 0x000001, "Wrong size on FProjectileHitArgs");

// ScriptStruct Stalker2.ComplexAttachAnimations
// 0x00B8 (0x00B8 - 0x0000)
struct FComplexAttachAnimations final
{
public:
	EWeaponIdleType                               WeaponIdleType;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AttachAttachingAnimation;                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AttachDetachingAnimation;                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterAttachModeIn;                             // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WeaponAttachModeIn;                                // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AttachAttachModeIn;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterAttachModeOut;                            // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WeaponAttachModeOut;                               // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AttachAttachModeOut;                               // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBindedToWeaponBehaviour;                        // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CharacterAttachShoot;                              // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WeaponAttachShoot;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AttachAttachShoot;                                 // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterAttachReload;                             // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WeaponAttachReload;                                // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AttachAttachReload;                                // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterAttachReloadTactical;                     // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WeaponAttachReloadTactical;                        // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AttachAttachReloadTactical;                        // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AttachAttachShootEnd;                              // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   AttachJamAnimations;                               // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UPlayerFirearmAnimCollection*           WeaponAnimCollection;                              // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComplexAttachAnimations) == 0x000008, "Wrong alignment on FComplexAttachAnimations");
static_assert(sizeof(FComplexAttachAnimations) == 0x0000B8, "Wrong size on FComplexAttachAnimations");
static_assert(offsetof(FComplexAttachAnimations, WeaponIdleType) == 0x000000, "Member 'FComplexAttachAnimations::WeaponIdleType' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, AttachAttachingAnimation) == 0x000008, "Member 'FComplexAttachAnimations::AttachAttachingAnimation' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, AttachDetachingAnimation) == 0x000010, "Member 'FComplexAttachAnimations::AttachDetachingAnimation' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, CharacterAttachModeIn) == 0x000018, "Member 'FComplexAttachAnimations::CharacterAttachModeIn' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, WeaponAttachModeIn) == 0x000020, "Member 'FComplexAttachAnimations::WeaponAttachModeIn' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, AttachAttachModeIn) == 0x000028, "Member 'FComplexAttachAnimations::AttachAttachModeIn' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, CharacterAttachModeOut) == 0x000030, "Member 'FComplexAttachAnimations::CharacterAttachModeOut' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, WeaponAttachModeOut) == 0x000038, "Member 'FComplexAttachAnimations::WeaponAttachModeOut' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, AttachAttachModeOut) == 0x000040, "Member 'FComplexAttachAnimations::AttachAttachModeOut' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, bIsBindedToWeaponBehaviour) == 0x000048, "Member 'FComplexAttachAnimations::bIsBindedToWeaponBehaviour' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, CharacterAttachShoot) == 0x000050, "Member 'FComplexAttachAnimations::CharacterAttachShoot' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, WeaponAttachShoot) == 0x000058, "Member 'FComplexAttachAnimations::WeaponAttachShoot' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, AttachAttachShoot) == 0x000060, "Member 'FComplexAttachAnimations::AttachAttachShoot' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, CharacterAttachReload) == 0x000068, "Member 'FComplexAttachAnimations::CharacterAttachReload' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, WeaponAttachReload) == 0x000070, "Member 'FComplexAttachAnimations::WeaponAttachReload' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, AttachAttachReload) == 0x000078, "Member 'FComplexAttachAnimations::AttachAttachReload' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, CharacterAttachReloadTactical) == 0x000080, "Member 'FComplexAttachAnimations::CharacterAttachReloadTactical' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, WeaponAttachReloadTactical) == 0x000088, "Member 'FComplexAttachAnimations::WeaponAttachReloadTactical' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, AttachAttachReloadTactical) == 0x000090, "Member 'FComplexAttachAnimations::AttachAttachReloadTactical' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, AttachAttachShootEnd) == 0x000098, "Member 'FComplexAttachAnimations::AttachAttachShootEnd' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, AttachJamAnimations) == 0x0000A0, "Member 'FComplexAttachAnimations::AttachJamAnimations' has a wrong offset!");
static_assert(offsetof(FComplexAttachAnimations, WeaponAnimCollection) == 0x0000B0, "Member 'FComplexAttachAnimations::WeaponAnimCollection' has a wrong offset!");

// ScriptStruct Stalker2.WaterHitArgs
// 0x0001 (0x0001 - 0x0000)
struct FWaterHitArgs final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWaterHitArgs) == 0x000001, "Wrong alignment on FWaterHitArgs");
static_assert(sizeof(FWaterHitArgs) == 0x000001, "Wrong size on FWaterHitArgs");

// ScriptStruct Stalker2.AkRoomCollection
// 0x0010 (0x0078 - 0x0068)
struct FAkRoomCollection final : public FBaseTickAggregationCollection
{
public:
	TArray<class UAkRoomComponent*>               RoomComponents;                                    // 0x0068(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAkRoomCollection) == 0x000008, "Wrong alignment on FAkRoomCollection");
static_assert(sizeof(FAkRoomCollection) == 0x000078, "Wrong size on FAkRoomCollection");
static_assert(offsetof(FAkRoomCollection, RoomComponents) == 0x000068, "Member 'FAkRoomCollection::RoomComponents' has a wrong offset!");

// ScriptStruct Stalker2.EventData
// 0x0048 (0x0048 - 0x0000)
struct FEventData final
{
public:
	TSoftObjectPtr<class UAkAudioEvent>           AkEvent;                                           // 0x0000(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeTransform;                                 // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventData) == 0x000008, "Wrong alignment on FEventData");
static_assert(sizeof(FEventData) == 0x000048, "Wrong size on FEventData");
static_assert(offsetof(FEventData, AkEvent) == 0x000000, "Member 'FEventData::AkEvent' has a wrong offset!");
static_assert(offsetof(FEventData, RelativeTransform) == 0x000030, "Member 'FEventData::RelativeTransform' has a wrong offset!");

// ScriptStruct Stalker2.MeshesData
// 0x0040 (0x0040 - 0x0000)
struct FMeshesData final
{
public:
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0000(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEventData>                     EventsData;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshesData) == 0x000008, "Wrong alignment on FMeshesData");
static_assert(sizeof(FMeshesData) == 0x000040, "Wrong size on FMeshesData");
static_assert(offsetof(FMeshesData, StaticMesh) == 0x000000, "Member 'FMeshesData::StaticMesh' has a wrong offset!");
static_assert(offsetof(FMeshesData, EventsData) == 0x000030, "Member 'FMeshesData::EventsData' has a wrong offset!");

// ScriptStruct Stalker2.UpgradeSlotData
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FUpgradeSlotData final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUpgradeSlotData) == 0x000008, "Wrong alignment on FUpgradeSlotData");
static_assert(sizeof(FUpgradeSlotData) == 0x000068, "Wrong size on FUpgradeSlotData");

// ScriptStruct Stalker2.CharacterDetectorWeaponAnimations
// 0x0008 (0x0008 - 0x0000)
struct FCharacterDetectorWeaponAnimations final
{
public:
	class UAnimMontage*                           CharacterLeftHand;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDetectorWeaponAnimations) == 0x000008, "Wrong alignment on FCharacterDetectorWeaponAnimations");
static_assert(sizeof(FCharacterDetectorWeaponAnimations) == 0x000008, "Wrong size on FCharacterDetectorWeaponAnimations");
static_assert(offsetof(FCharacterDetectorWeaponAnimations, CharacterLeftHand) == 0x000000, "Member 'FCharacterDetectorWeaponAnimations::CharacterLeftHand' has a wrong offset!");

// ScriptStruct Stalker2.DirectionBlendData
// 0x0024 (0x0024 - 0x0000)
struct FDirectionBlendData final
{
public:
	float                                         Forward;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Backward;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Left;                                              // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Right;                                             // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardLeft;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardRight;                                      // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardLeft;                                      // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardRight;                                     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInterpSpeed;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectionBlendData) == 0x000004, "Wrong alignment on FDirectionBlendData");
static_assert(sizeof(FDirectionBlendData) == 0x000024, "Wrong size on FDirectionBlendData");
static_assert(offsetof(FDirectionBlendData, Forward) == 0x000000, "Member 'FDirectionBlendData::Forward' has a wrong offset!");
static_assert(offsetof(FDirectionBlendData, Backward) == 0x000004, "Member 'FDirectionBlendData::Backward' has a wrong offset!");
static_assert(offsetof(FDirectionBlendData, Left) == 0x000008, "Member 'FDirectionBlendData::Left' has a wrong offset!");
static_assert(offsetof(FDirectionBlendData, Right) == 0x00000C, "Member 'FDirectionBlendData::Right' has a wrong offset!");
static_assert(offsetof(FDirectionBlendData, ForwardLeft) == 0x000010, "Member 'FDirectionBlendData::ForwardLeft' has a wrong offset!");
static_assert(offsetof(FDirectionBlendData, ForwardRight) == 0x000014, "Member 'FDirectionBlendData::ForwardRight' has a wrong offset!");
static_assert(offsetof(FDirectionBlendData, BackwardLeft) == 0x000018, "Member 'FDirectionBlendData::BackwardLeft' has a wrong offset!");
static_assert(offsetof(FDirectionBlendData, BackwardRight) == 0x00001C, "Member 'FDirectionBlendData::BackwardRight' has a wrong offset!");
static_assert(offsetof(FDirectionBlendData, BlendInterpSpeed) == 0x000020, "Member 'FDirectionBlendData::BlendInterpSpeed' has a wrong offset!");

// ScriptStruct Stalker2.AchievementData
// 0x0010 (0x0010 - 0x0000)
struct FAchievementData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAchievementTracker*                    Tracker;                                           // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAchievementData) == 0x000008, "Wrong alignment on FAchievementData");
static_assert(sizeof(FAchievementData) == 0x000010, "Wrong size on FAchievementData");
static_assert(offsetof(FAchievementData, Tracker) == 0x000008, "Member 'FAchievementData::Tracker' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerWeaponSwingData
// 0x0080 (0x0080 - 0x0000)
struct FAnimPlayerWeaponSwingData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ItemTotalRotation;                                 // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ItemTotalShift;                                    // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ItemSocketTotalShift;                              // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerWeaponSwingData) == 0x000008, "Wrong alignment on FAnimPlayerWeaponSwingData");
static_assert(sizeof(FAnimPlayerWeaponSwingData) == 0x000080, "Wrong size on FAnimPlayerWeaponSwingData");
static_assert(offsetof(FAnimPlayerWeaponSwingData, ItemTotalRotation) == 0x000020, "Member 'FAnimPlayerWeaponSwingData::ItemTotalRotation' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponSwingData, ItemTotalShift) == 0x000038, "Member 'FAnimPlayerWeaponSwingData::ItemTotalShift' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponSwingData, ItemSocketTotalShift) == 0x000050, "Member 'FAnimPlayerWeaponSwingData::ItemSocketTotalShift' has a wrong offset!");

// ScriptStruct Stalker2.SnapshotMapping
// 0x0010 (0x0010 - 0x0000)
struct FSnapshotMapping final
{
public:
	class FName                                   SourceNodeTag;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetNodeTag;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnapshotMapping) == 0x000004, "Wrong alignment on FSnapshotMapping");
static_assert(sizeof(FSnapshotMapping) == 0x000010, "Wrong size on FSnapshotMapping");
static_assert(offsetof(FSnapshotMapping, SourceNodeTag) == 0x000000, "Member 'FSnapshotMapping::SourceNodeTag' has a wrong offset!");
static_assert(offsetof(FSnapshotMapping, TargetNodeTag) == 0x000008, "Member 'FSnapshotMapping::TargetNodeTag' has a wrong offset!");

// ScriptStruct Stalker2.UserAchievements
// 0x0050 (0x0050 - 0x0000)
struct FUserAchievements final
{
public:
	TMap<class FString, struct FAchievementData>  Achievements;                                      // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FUserAchievements) == 0x000008, "Wrong alignment on FUserAchievements");
static_assert(sizeof(FUserAchievements) == 0x000050, "Wrong size on FUserAchievements");
static_assert(offsetof(FUserAchievements, Achievements) == 0x000000, "Member 'FUserAchievements::Achievements' has a wrong offset!");

// ScriptStruct Stalker2.ActionMimicSettings
// 0x0010 (0x0010 - 0x0000)
struct FActionMimicSettings final
{
public:
	class FName                                   InputAction;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMappingContext                               MappingContext;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerIndex;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActionMimicSettings) == 0x000004, "Wrong alignment on FActionMimicSettings");
static_assert(sizeof(FActionMimicSettings) == 0x000010, "Wrong size on FActionMimicSettings");
static_assert(offsetof(FActionMimicSettings, InputAction) == 0x000000, "Member 'FActionMimicSettings::InputAction' has a wrong offset!");
static_assert(offsetof(FActionMimicSettings, MappingContext) == 0x000008, "Member 'FActionMimicSettings::MappingContext' has a wrong offset!");
static_assert(offsetof(FActionMimicSettings, TriggerIndex) == 0x00000C, "Member 'FActionMimicSettings::TriggerIndex' has a wrong offset!");

// ScriptStruct Stalker2.PrototypeSID
// 0x0040 (0x0040 - 0x0000)
struct FPrototypeSID
{
public:
	class FString                                 Value;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x30];                                      // 0x0010(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPrototypeSID) == 0x000008, "Wrong alignment on FPrototypeSID");
static_assert(sizeof(FPrototypeSID) == 0x000040, "Wrong size on FPrototypeSID");
static_assert(offsetof(FPrototypeSID, Value) == 0x000000, "Member 'FPrototypeSID::Value' has a wrong offset!");

// ScriptStruct Stalker2.ContextualActionNotifyWeaponEquipData
// 0x0048 (0x0048 - 0x0000)
struct FContextualActionNotifyWeaponEquipData final
{
public:
	struct FPrototypeSID                          ItemSID;                                           // 0x0000(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMainHandEquipmentType                        SlotToEquip;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContextualActionNotifyWeaponEquipData) == 0x000008, "Wrong alignment on FContextualActionNotifyWeaponEquipData");
static_assert(sizeof(FContextualActionNotifyWeaponEquipData) == 0x000048, "Wrong size on FContextualActionNotifyWeaponEquipData");
static_assert(offsetof(FContextualActionNotifyWeaponEquipData, ItemSID) == 0x000000, "Member 'FContextualActionNotifyWeaponEquipData::ItemSID' has a wrong offset!");
static_assert(offsetof(FContextualActionNotifyWeaponEquipData, SlotToEquip) == 0x000040, "Member 'FContextualActionNotifyWeaponEquipData::SlotToEquip' has a wrong offset!");

// ScriptStruct Stalker2.ActorInteractionData
// 0x0018 (0x0018 - 0x0000)
struct FActorInteractionData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InteractableTextToolName;                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorInteractionData) == 0x000008, "Wrong alignment on FActorInteractionData");
static_assert(sizeof(FActorInteractionData) == 0x000018, "Wrong size on FActorInteractionData");
static_assert(offsetof(FActorInteractionData, InteractableTextToolName) == 0x000008, "Member 'FActorInteractionData::InteractableTextToolName' has a wrong offset!");

// ScriptStruct Stalker2.StashPrototypeSID
// 0x0000 (0x0040 - 0x0040)
struct FStashPrototypeSID final : public FPrototypeSID
{
};
static_assert(alignof(FStashPrototypeSID) == 0x000008, "Wrong alignment on FStashPrototypeSID");
static_assert(sizeof(FStashPrototypeSID) == 0x000040, "Wrong size on FStashPrototypeSID");

// ScriptStruct Stalker2.DamageInteractVFXData
// 0x0010 (0x0010 - 0x0000)
struct FDamageInteractVFXData final
{
public:
	class UNiagaraComponent*                      InteractDamageVFX;                                 // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageInteractVFXData) == 0x000008, "Wrong alignment on FDamageInteractVFXData");
static_assert(sizeof(FDamageInteractVFXData) == 0x000010, "Wrong size on FDamageInteractVFXData");
static_assert(offsetof(FDamageInteractVFXData, InteractDamageVFX) == 0x000000, "Member 'FDamageInteractVFXData::InteractDamageVFX' has a wrong offset!");

// ScriptStruct Stalker2.CharacterWeaponAnimations
// 0x0020 (0x0020 - 0x0000)
struct FCharacterWeaponAnimations final
{
public:
	class UAnimMontage*                           Character;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterLeftHand;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Weapon;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterWeaponAnimations) == 0x000008, "Wrong alignment on FCharacterWeaponAnimations");
static_assert(sizeof(FCharacterWeaponAnimations) == 0x000020, "Wrong size on FCharacterWeaponAnimations");
static_assert(offsetof(FCharacterWeaponAnimations, Character) == 0x000000, "Member 'FCharacterWeaponAnimations::Character' has a wrong offset!");
static_assert(offsetof(FCharacterWeaponAnimations, CharacterLeftHand) == 0x000008, "Member 'FCharacterWeaponAnimations::CharacterLeftHand' has a wrong offset!");
static_assert(offsetof(FCharacterWeaponAnimations, Weapon) == 0x000010, "Member 'FCharacterWeaponAnimations::Weapon' has a wrong offset!");
static_assert(offsetof(FCharacterWeaponAnimations, PlayRate) == 0x000018, "Member 'FCharacterWeaponAnimations::PlayRate' has a wrong offset!");

// ScriptStruct Stalker2.ChangeFireTypeAnimation
// 0x0028 (0x0028 - 0x0000)
struct FChangeFireTypeAnimation final
{
public:
	EFireType                                     FromFireType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFireType                                     ToFireType;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterWeaponAnimations             Animations;                                        // 0x0008(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChangeFireTypeAnimation) == 0x000008, "Wrong alignment on FChangeFireTypeAnimation");
static_assert(sizeof(FChangeFireTypeAnimation) == 0x000028, "Wrong size on FChangeFireTypeAnimation");
static_assert(offsetof(FChangeFireTypeAnimation, FromFireType) == 0x000000, "Member 'FChangeFireTypeAnimation::FromFireType' has a wrong offset!");
static_assert(offsetof(FChangeFireTypeAnimation, ToFireType) == 0x000001, "Member 'FChangeFireTypeAnimation::ToFireType' has a wrong offset!");
static_assert(offsetof(FChangeFireTypeAnimation, Animations) == 0x000008, "Member 'FChangeFireTypeAnimation::Animations' has a wrong offset!");

// ScriptStruct Stalker2.AgentCollection
// 0x0038 (0x00A0 - 0x0068)
struct FAgentCollection final : public FBaseTickAggregationCollection
{
public:
	uint8                                         Pad_68[0x38];                                      // 0x0068(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAgentCollection) == 0x000008, "Wrong alignment on FAgentCollection");
static_assert(sizeof(FAgentCollection) == 0x0000A0, "Wrong size on FAgentCollection");

// ScriptStruct Stalker2.AttractionPoint
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FAttractionPoint final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  LookAtActor;                                       // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  SkeletalMesh;                                      // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SID;                                               // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttractionPoint) == 0x000008, "Wrong alignment on FAttractionPoint");
static_assert(sizeof(FAttractionPoint) == 0x000068, "Wrong size on FAttractionPoint");
static_assert(offsetof(FAttractionPoint, LookAtActor) == 0x000050, "Member 'FAttractionPoint::LookAtActor' has a wrong offset!");
static_assert(offsetof(FAttractionPoint, SkeletalMesh) == 0x000058, "Member 'FAttractionPoint::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FAttractionPoint, SID) == 0x000060, "Member 'FAttractionPoint::SID' has a wrong offset!");

// ScriptStruct Stalker2.BaseModelCollection
// 0x0038 (0x00A0 - 0x0068)
struct FBaseModelCollection : public FBaseTickAggregationCollection
{
public:
	uint8                                         Pad_68[0x38];                                      // 0x0068(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseModelCollection) == 0x000008, "Wrong alignment on FBaseModelCollection");
static_assert(sizeof(FBaseModelCollection) == 0x0000A0, "Wrong size on FBaseModelCollection");

// ScriptStruct Stalker2.AgentModelCollection
// 0x0018 (0x00B8 - 0x00A0)
struct FAgentModelCollection final : public FBaseModelCollection
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAgentModelCollection) == 0x000008, "Wrong alignment on FAgentModelCollection");
static_assert(sizeof(FAgentModelCollection) == 0x0000B8, "Wrong size on FAgentModelCollection");

// ScriptStruct Stalker2.AIEntityCollection
// 0x0000 (0x0068 - 0x0068)
struct FAIEntityCollection final : public FBaseTickAggregationCollection
{
};
static_assert(alignof(FAIEntityCollection) == 0x000008, "Wrong alignment on FAIEntityCollection");
static_assert(sizeof(FAIEntityCollection) == 0x000068, "Wrong size on FAIEntityCollection");

// ScriptStruct Stalker2.TwoBlendedAnimationData
// 0x0020 (0x0020 - 0x0000)
struct FTwoBlendedAnimationData final
{
public:
	class UAnimSequence*                          FirstAnimation;                                    // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondAnimation;                                   // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstBlendIn;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondBlendIn;                                     // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFirstAnimation;                                // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTwoBlendedAnimationData) == 0x000008, "Wrong alignment on FTwoBlendedAnimationData");
static_assert(sizeof(FTwoBlendedAnimationData) == 0x000020, "Wrong size on FTwoBlendedAnimationData");
static_assert(offsetof(FTwoBlendedAnimationData, FirstAnimation) == 0x000000, "Member 'FTwoBlendedAnimationData::FirstAnimation' has a wrong offset!");
static_assert(offsetof(FTwoBlendedAnimationData, SecondAnimation) == 0x000008, "Member 'FTwoBlendedAnimationData::SecondAnimation' has a wrong offset!");
static_assert(offsetof(FTwoBlendedAnimationData, FirstBlendIn) == 0x000010, "Member 'FTwoBlendedAnimationData::FirstBlendIn' has a wrong offset!");
static_assert(offsetof(FTwoBlendedAnimationData, SecondBlendIn) == 0x000014, "Member 'FTwoBlendedAnimationData::SecondBlendIn' has a wrong offset!");
static_assert(offsetof(FTwoBlendedAnimationData, bUseFirstAnimation) == 0x000018, "Member 'FTwoBlendedAnimationData::bUseFirstAnimation' has a wrong offset!");

// ScriptStruct Stalker2.SwarmVATAnimation
// 0x0028 (0x0028 - 0x0000)
struct FSwarmVATAnimation final
{
public:
	class FName                                   StateName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameStart;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameEnd;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameRate;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaybackRate;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutDuration;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x8];                                       // 0x001C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsLooped;                                         // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSwarmVATAnimation) == 0x000004, "Wrong alignment on FSwarmVATAnimation");
static_assert(sizeof(FSwarmVATAnimation) == 0x000028, "Wrong size on FSwarmVATAnimation");
static_assert(offsetof(FSwarmVATAnimation, StateName) == 0x000000, "Member 'FSwarmVATAnimation::StateName' has a wrong offset!");
static_assert(offsetof(FSwarmVATAnimation, FrameStart) == 0x000008, "Member 'FSwarmVATAnimation::FrameStart' has a wrong offset!");
static_assert(offsetof(FSwarmVATAnimation, FrameEnd) == 0x00000C, "Member 'FSwarmVATAnimation::FrameEnd' has a wrong offset!");
static_assert(offsetof(FSwarmVATAnimation, FrameRate) == 0x000010, "Member 'FSwarmVATAnimation::FrameRate' has a wrong offset!");
static_assert(offsetof(FSwarmVATAnimation, PlaybackRate) == 0x000014, "Member 'FSwarmVATAnimation::PlaybackRate' has a wrong offset!");
static_assert(offsetof(FSwarmVATAnimation, BlendOutDuration) == 0x000018, "Member 'FSwarmVATAnimation::BlendOutDuration' has a wrong offset!");
static_assert(offsetof(FSwarmVATAnimation, bIsLooped) == 0x000024, "Member 'FSwarmVATAnimation::bIsLooped' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerWeaponInertiaData
// 0x0098 (0x0098 - 0x0000)
struct FAnimPlayerWeaponInertiaData final
{
public:
	float                                         AlphaInterpSpeed;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslationInterpSpeed;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterpSpeed;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaStartThreshold;                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x30];                                      // 0x0010(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           RotationCurve;                                     // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           TranslationCurve;                                  // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TimeScaleCurve;                                    // 0x0050(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AmplitudeScaleCurve;                               // 0x0058(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AdditionalInertiaRotation;                         // 0x0060(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AdditionalInertiaTranslation;                      // 0x0078(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaAlpha;                                      // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerWeaponInertiaData) == 0x000008, "Wrong alignment on FAnimPlayerWeaponInertiaData");
static_assert(sizeof(FAnimPlayerWeaponInertiaData) == 0x000098, "Wrong size on FAnimPlayerWeaponInertiaData");
static_assert(offsetof(FAnimPlayerWeaponInertiaData, AlphaInterpSpeed) == 0x000000, "Member 'FAnimPlayerWeaponInertiaData::AlphaInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponInertiaData, TranslationInterpSpeed) == 0x000004, "Member 'FAnimPlayerWeaponInertiaData::TranslationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponInertiaData, RotationInterpSpeed) == 0x000008, "Member 'FAnimPlayerWeaponInertiaData::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponInertiaData, InertiaStartThreshold) == 0x00000C, "Member 'FAnimPlayerWeaponInertiaData::InertiaStartThreshold' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponInertiaData, RotationCurve) == 0x000040, "Member 'FAnimPlayerWeaponInertiaData::RotationCurve' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponInertiaData, TranslationCurve) == 0x000048, "Member 'FAnimPlayerWeaponInertiaData::TranslationCurve' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponInertiaData, TimeScaleCurve) == 0x000050, "Member 'FAnimPlayerWeaponInertiaData::TimeScaleCurve' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponInertiaData, AmplitudeScaleCurve) == 0x000058, "Member 'FAnimPlayerWeaponInertiaData::AmplitudeScaleCurve' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponInertiaData, AdditionalInertiaRotation) == 0x000060, "Member 'FAnimPlayerWeaponInertiaData::AdditionalInertiaRotation' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponInertiaData, AdditionalInertiaTranslation) == 0x000078, "Member 'FAnimPlayerWeaponInertiaData::AdditionalInertiaTranslation' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponInertiaData, InertiaAlpha) == 0x000090, "Member 'FAnimPlayerWeaponInertiaData::InertiaAlpha' has a wrong offset!");

// ScriptStruct Stalker2.AnimHandItemData
// 0x0138 (0x0138 - 0x0000)
struct FAnimHandItemData final
{
public:
	bool                                          bHasItemInHands;                                   // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEmptyHands;                                    // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 ItemSkeletal;                                      // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionComponent*                  ItemInteractable;                                  // 0x0010(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsesLeftHand;                                   // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsesRightHand;                                  // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimPlayerWeaponSwingData             SwingData;                                         // 0x0020(0x0080)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimPlayerWeaponInertiaData           InertiaData;                                       // 0x00A0(0x0098)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHandItemData) == 0x000008, "Wrong alignment on FAnimHandItemData");
static_assert(sizeof(FAnimHandItemData) == 0x000138, "Wrong size on FAnimHandItemData");
static_assert(offsetof(FAnimHandItemData, bHasItemInHands) == 0x000000, "Member 'FAnimHandItemData::bHasItemInHands' has a wrong offset!");
static_assert(offsetof(FAnimHandItemData, bHasEmptyHands) == 0x000001, "Member 'FAnimHandItemData::bHasEmptyHands' has a wrong offset!");
static_assert(offsetof(FAnimHandItemData, ItemSkeletal) == 0x000008, "Member 'FAnimHandItemData::ItemSkeletal' has a wrong offset!");
static_assert(offsetof(FAnimHandItemData, ItemInteractable) == 0x000010, "Member 'FAnimHandItemData::ItemInteractable' has a wrong offset!");
static_assert(offsetof(FAnimHandItemData, bIsUsesLeftHand) == 0x000018, "Member 'FAnimHandItemData::bIsUsesLeftHand' has a wrong offset!");
static_assert(offsetof(FAnimHandItemData, bIsUsesRightHand) == 0x000019, "Member 'FAnimHandItemData::bIsUsesRightHand' has a wrong offset!");
static_assert(offsetof(FAnimHandItemData, SwingData) == 0x000020, "Member 'FAnimHandItemData::SwingData' has a wrong offset!");
static_assert(offsetof(FAnimHandItemData, InertiaData) == 0x0000A0, "Member 'FAnimHandItemData::InertiaData' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerLookAtPreset
// 0x000C (0x000C - 0x0000)
struct FAnimPlayerLookAtPreset final
{
public:
	float                                         RotationFreemoveEdge;                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationStopEdge;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldRepeatTargetMovement;                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerLookAtPreset) == 0x000004, "Wrong alignment on FAnimPlayerLookAtPreset");
static_assert(sizeof(FAnimPlayerLookAtPreset) == 0x00000C, "Wrong size on FAnimPlayerLookAtPreset");
static_assert(offsetof(FAnimPlayerLookAtPreset, RotationFreemoveEdge) == 0x000000, "Member 'FAnimPlayerLookAtPreset::RotationFreemoveEdge' has a wrong offset!");
static_assert(offsetof(FAnimPlayerLookAtPreset, RotationStopEdge) == 0x000004, "Member 'FAnimPlayerLookAtPreset::RotationStopEdge' has a wrong offset!");
static_assert(offsetof(FAnimPlayerLookAtPreset, bShouldRepeatTargetMovement) == 0x000008, "Member 'FAnimPlayerLookAtPreset::bShouldRepeatTargetMovement' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerLookAtData
// 0x00D0 (0x00D0 - 0x0000)
struct FAnimPlayerLookAtData final
{
public:
	TMap<class FName, struct FAnimPlayerLookAtPreset> Presets;                                       // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAnimPlayerLookAtPreset                ActivePreset;                                      // 0x0050(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            EnteringSpeed;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CenteringSpeed;                                    // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CursorFreemoveDistanceFactor;                      // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CursorApproachDirectionFactor;                     // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x28];                                      // 0x0080(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CenteringTime;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerLookAtTimer;                                 // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFreemoveSpeed;                                  // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinStopSpeed;                                      // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DialogEnteringTime;                                // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwitchTargertFactor;                               // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerLookAtData) == 0x000008, "Wrong alignment on FAnimPlayerLookAtData");
static_assert(sizeof(FAnimPlayerLookAtData) == 0x0000D0, "Wrong size on FAnimPlayerLookAtData");
static_assert(offsetof(FAnimPlayerLookAtData, Presets) == 0x000000, "Member 'FAnimPlayerLookAtData::Presets' has a wrong offset!");
static_assert(offsetof(FAnimPlayerLookAtData, ActivePreset) == 0x000050, "Member 'FAnimPlayerLookAtData::ActivePreset' has a wrong offset!");
static_assert(offsetof(FAnimPlayerLookAtData, EnteringSpeed) == 0x000060, "Member 'FAnimPlayerLookAtData::EnteringSpeed' has a wrong offset!");
static_assert(offsetof(FAnimPlayerLookAtData, CenteringSpeed) == 0x000068, "Member 'FAnimPlayerLookAtData::CenteringSpeed' has a wrong offset!");
static_assert(offsetof(FAnimPlayerLookAtData, CursorFreemoveDistanceFactor) == 0x000070, "Member 'FAnimPlayerLookAtData::CursorFreemoveDistanceFactor' has a wrong offset!");
static_assert(offsetof(FAnimPlayerLookAtData, CursorApproachDirectionFactor) == 0x000078, "Member 'FAnimPlayerLookAtData::CursorApproachDirectionFactor' has a wrong offset!");
static_assert(offsetof(FAnimPlayerLookAtData, CenteringTime) == 0x0000A8, "Member 'FAnimPlayerLookAtData::CenteringTime' has a wrong offset!");
static_assert(offsetof(FAnimPlayerLookAtData, PlayerLookAtTimer) == 0x0000AC, "Member 'FAnimPlayerLookAtData::PlayerLookAtTimer' has a wrong offset!");
static_assert(offsetof(FAnimPlayerLookAtData, MaxFreemoveSpeed) == 0x0000B0, "Member 'FAnimPlayerLookAtData::MaxFreemoveSpeed' has a wrong offset!");
static_assert(offsetof(FAnimPlayerLookAtData, MinStopSpeed) == 0x0000B4, "Member 'FAnimPlayerLookAtData::MinStopSpeed' has a wrong offset!");
static_assert(offsetof(FAnimPlayerLookAtData, DialogEnteringTime) == 0x0000B8, "Member 'FAnimPlayerLookAtData::DialogEnteringTime' has a wrong offset!");
static_assert(offsetof(FAnimPlayerLookAtData, SwitchTargertFactor) == 0x0000BC, "Member 'FAnimPlayerLookAtData::SwitchTargertFactor' has a wrong offset!");

// ScriptStruct Stalker2.VATAnimation
// 0x0020 (0x0020 - 0x0000)
struct FVATAnimation final
{
public:
	class FName                                   StateName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameStart;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameEnd;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameRate;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaybackRate;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutDuration;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLooped;                                         // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVATAnimation) == 0x000004, "Wrong alignment on FVATAnimation");
static_assert(sizeof(FVATAnimation) == 0x000020, "Wrong size on FVATAnimation");
static_assert(offsetof(FVATAnimation, StateName) == 0x000000, "Member 'FVATAnimation::StateName' has a wrong offset!");
static_assert(offsetof(FVATAnimation, FrameStart) == 0x000008, "Member 'FVATAnimation::FrameStart' has a wrong offset!");
static_assert(offsetof(FVATAnimation, FrameEnd) == 0x00000C, "Member 'FVATAnimation::FrameEnd' has a wrong offset!");
static_assert(offsetof(FVATAnimation, FrameRate) == 0x000010, "Member 'FVATAnimation::FrameRate' has a wrong offset!");
static_assert(offsetof(FVATAnimation, PlaybackRate) == 0x000014, "Member 'FVATAnimation::PlaybackRate' has a wrong offset!");
static_assert(offsetof(FVATAnimation, BlendOutDuration) == 0x000018, "Member 'FVATAnimation::BlendOutDuration' has a wrong offset!");
static_assert(offsetof(FVATAnimation, bIsLooped) == 0x00001C, "Member 'FVATAnimation::bIsLooped' has a wrong offset!");

// ScriptStruct Stalker2.SwarmInstanceSimulationConfig
// 0x0060 (0x0060 - 0x0000)
struct FSwarmInstanceSimulationConfig final
{
public:
	float                                         AvoidenceRadius;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlignmentRadius;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CohesionRadius;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxForce;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeparationWeight;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlignmentWeight;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CohesionWeight;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttractionPointWeight;                             // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlowWeight;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearDrag;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightDisplacementRadius;                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightDisplacementAmmount;                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeightDisplacement;                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseFriction;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VATAnimation;                                      // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x1C];                                      // 0x0044(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSwarmInstanceSimulationConfig) == 0x000004, "Wrong alignment on FSwarmInstanceSimulationConfig");
static_assert(sizeof(FSwarmInstanceSimulationConfig) == 0x000060, "Wrong size on FSwarmInstanceSimulationConfig");
static_assert(offsetof(FSwarmInstanceSimulationConfig, AvoidenceRadius) == 0x000000, "Member 'FSwarmInstanceSimulationConfig::AvoidenceRadius' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, AlignmentRadius) == 0x000004, "Member 'FSwarmInstanceSimulationConfig::AlignmentRadius' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, CohesionRadius) == 0x000008, "Member 'FSwarmInstanceSimulationConfig::CohesionRadius' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, MaxForce) == 0x00000C, "Member 'FSwarmInstanceSimulationConfig::MaxForce' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, SeparationWeight) == 0x000010, "Member 'FSwarmInstanceSimulationConfig::SeparationWeight' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, AlignmentWeight) == 0x000014, "Member 'FSwarmInstanceSimulationConfig::AlignmentWeight' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, CohesionWeight) == 0x000018, "Member 'FSwarmInstanceSimulationConfig::CohesionWeight' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, AttractionPointWeight) == 0x00001C, "Member 'FSwarmInstanceSimulationConfig::AttractionPointWeight' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, FlowWeight) == 0x000020, "Member 'FSwarmInstanceSimulationConfig::FlowWeight' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, MaxSpeed) == 0x000024, "Member 'FSwarmInstanceSimulationConfig::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, LinearDrag) == 0x000028, "Member 'FSwarmInstanceSimulationConfig::LinearDrag' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, HeightDisplacementRadius) == 0x00002C, "Member 'FSwarmInstanceSimulationConfig::HeightDisplacementRadius' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, HeightDisplacementAmmount) == 0x000030, "Member 'FSwarmInstanceSimulationConfig::HeightDisplacementAmmount' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, MaxHeightDisplacement) == 0x000034, "Member 'FSwarmInstanceSimulationConfig::MaxHeightDisplacement' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, ImpulseFriction) == 0x000038, "Member 'FSwarmInstanceSimulationConfig::ImpulseFriction' has a wrong offset!");
static_assert(offsetof(FSwarmInstanceSimulationConfig, VATAnimation) == 0x00003C, "Member 'FSwarmInstanceSimulationConfig::VATAnimation' has a wrong offset!");

// ScriptStruct Stalker2.DestructibleModelCollection
// 0x0000 (0x00A0 - 0x00A0)
struct FDestructibleModelCollection final : public FBaseModelCollection
{
};
static_assert(alignof(FDestructibleModelCollection) == 0x000008, "Wrong alignment on FDestructibleModelCollection");
static_assert(sizeof(FDestructibleModelCollection) == 0x0000A0, "Wrong size on FDestructibleModelCollection");

// ScriptStruct Stalker2.SwarmDamageHandleImpact
// 0x0028 (0x0028 - 0x0000)
struct FSwarmDamageHandleImpact final
{
public:
	bool                                          bSpawnCorpseOnDestroy;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyImpulseToCorpse;                             // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachImpactEffectToCorpse;                       // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetMaterialParametersToCorpse;                    // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseScale;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularImpulseScale;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     SpawnCorpseTemplate;                               // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ImpactEffect;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         EnvironmentEffect;                                 // 0x0020(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSwarmDamageHandleImpact) == 0x000008, "Wrong alignment on FSwarmDamageHandleImpact");
static_assert(sizeof(FSwarmDamageHandleImpact) == 0x000028, "Wrong size on FSwarmDamageHandleImpact");
static_assert(offsetof(FSwarmDamageHandleImpact, bSpawnCorpseOnDestroy) == 0x000000, "Member 'FSwarmDamageHandleImpact::bSpawnCorpseOnDestroy' has a wrong offset!");
static_assert(offsetof(FSwarmDamageHandleImpact, bApplyImpulseToCorpse) == 0x000001, "Member 'FSwarmDamageHandleImpact::bApplyImpulseToCorpse' has a wrong offset!");
static_assert(offsetof(FSwarmDamageHandleImpact, bAttachImpactEffectToCorpse) == 0x000002, "Member 'FSwarmDamageHandleImpact::bAttachImpactEffectToCorpse' has a wrong offset!");
static_assert(offsetof(FSwarmDamageHandleImpact, bSetMaterialParametersToCorpse) == 0x000003, "Member 'FSwarmDamageHandleImpact::bSetMaterialParametersToCorpse' has a wrong offset!");
static_assert(offsetof(FSwarmDamageHandleImpact, ImpulseScale) == 0x000004, "Member 'FSwarmDamageHandleImpact::ImpulseScale' has a wrong offset!");
static_assert(offsetof(FSwarmDamageHandleImpact, AngularImpulseScale) == 0x000008, "Member 'FSwarmDamageHandleImpact::AngularImpulseScale' has a wrong offset!");
static_assert(offsetof(FSwarmDamageHandleImpact, SpawnCorpseTemplate) == 0x000010, "Member 'FSwarmDamageHandleImpact::SpawnCorpseTemplate' has a wrong offset!");
static_assert(offsetof(FSwarmDamageHandleImpact, ImpactEffect) == 0x000018, "Member 'FSwarmDamageHandleImpact::ImpactEffect' has a wrong offset!");
static_assert(offsetof(FSwarmDamageHandleImpact, EnvironmentEffect) == 0x000020, "Member 'FSwarmDamageHandleImpact::EnvironmentEffect' has a wrong offset!");

// ScriptStruct Stalker2.AITickComponentCollection
// 0x0010 (0x0078 - 0x0068)
struct FAITickComponentCollection final : public FBaseTickAggregationCollection
{
public:
	TArray<class UAITickComponent*>               AITickComponents;                                  // 0x0068(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAITickComponentCollection) == 0x000008, "Wrong alignment on FAITickComponentCollection");
static_assert(sizeof(FAITickComponentCollection) == 0x000078, "Wrong size on FAITickComponentCollection");
static_assert(offsetof(FAITickComponentCollection, AITickComponents) == 0x000068, "Member 'FAITickComponentCollection::AITickComponents' has a wrong offset!");

// ScriptStruct Stalker2.ForceFeedbackArgs
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FForceFeedbackArgs
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FForceFeedbackArgs) == 0x000008, "Wrong alignment on FForceFeedbackArgs");
static_assert(sizeof(FForceFeedbackArgs) == 0x000008, "Wrong size on FForceFeedbackArgs");

// ScriptStruct Stalker2.PrototypeFeedbackArgs
// 0x0010 (0x0018 - 0x0008)
struct FPrototypeFeedbackArgs final : public FForceFeedbackArgs
{
public:
	class FString                                 PrototypeSID;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrototypeFeedbackArgs) == 0x000008, "Wrong alignment on FPrototypeFeedbackArgs");
static_assert(sizeof(FPrototypeFeedbackArgs) == 0x000018, "Wrong size on FPrototypeFeedbackArgs");
static_assert(offsetof(FPrototypeFeedbackArgs, PrototypeSID) == 0x000008, "Member 'FPrototypeFeedbackArgs::PrototypeSID' has a wrong offset!");

// ScriptStruct Stalker2.AkComponentCollection
// 0x0010 (0x0078 - 0x0068)
struct FAkComponentCollection final : public FBaseTickAggregationCollection
{
public:
	TArray<class UAkComponent*>                   AkComponents;                                      // 0x0068(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAkComponentCollection) == 0x000008, "Wrong alignment on FAkComponentCollection");
static_assert(sizeof(FAkComponentCollection) == 0x000078, "Wrong size on FAkComponentCollection");
static_assert(offsetof(FAkComponentCollection, AkComponents) == 0x000068, "Member 'FAkComponentCollection::AkComponents' has a wrong offset!");

// ScriptStruct Stalker2.AbilityParams
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FAbilityParams final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityParams) == 0x000004, "Wrong alignment on FAbilityParams");
static_assert(sizeof(FAbilityParams) == 0x00000C, "Wrong size on FAbilityParams");

// ScriptStruct Stalker2.ALifeScenarioGroupSIDSelector
// 0x0010 (0x0010 - 0x0000)
struct FALifeScenarioGroupSIDSelector final
{
public:
	class FString                                 Value;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FALifeScenarioGroupSIDSelector) == 0x000008, "Wrong alignment on FALifeScenarioGroupSIDSelector");
static_assert(sizeof(FALifeScenarioGroupSIDSelector) == 0x000010, "Wrong size on FALifeScenarioGroupSIDSelector");
static_assert(offsetof(FALifeScenarioGroupSIDSelector, Value) == 0x000000, "Member 'FALifeScenarioGroupSIDSelector::Value' has a wrong offset!");

// ScriptStruct Stalker2.AttachedMagazineStruct
// 0x0010 (0x0010 - 0x0000)
struct FAttachedMagazineStruct final
{
public:
	class UMeshComponent*                         MagazineMesh;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttachedMagazineStruct) == 0x000008, "Wrong alignment on FAttachedMagazineStruct");
static_assert(sizeof(FAttachedMagazineStruct) == 0x000010, "Wrong size on FAttachedMagazineStruct");
static_assert(offsetof(FAttachedMagazineStruct, MagazineMesh) == 0x000000, "Member 'FAttachedMagazineStruct::MagazineMesh' has a wrong offset!");

// ScriptStruct Stalker2.AnimAbilityData
// 0x0018 (0x0018 - 0x0000)
struct FAnimAbilityData final
{
public:
	float                                         BlendAlpha;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetAlphaYaw;                                 // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetAlphaPitch;                               // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            Offset;                                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimAbilityData) == 0x000008, "Wrong alignment on FAnimAbilityData");
static_assert(sizeof(FAnimAbilityData) == 0x000018, "Wrong size on FAnimAbilityData");
static_assert(offsetof(FAnimAbilityData, BlendAlpha) == 0x000000, "Member 'FAnimAbilityData::BlendAlpha' has a wrong offset!");
static_assert(offsetof(FAnimAbilityData, AimOffsetAlphaYaw) == 0x000004, "Member 'FAnimAbilityData::AimOffsetAlphaYaw' has a wrong offset!");
static_assert(offsetof(FAnimAbilityData, AimOffsetAlphaPitch) == 0x000008, "Member 'FAnimAbilityData::AimOffsetAlphaPitch' has a wrong offset!");
static_assert(offsetof(FAnimAbilityData, Offset) == 0x000010, "Member 'FAnimAbilityData::Offset' has a wrong offset!");

// ScriptStruct Stalker2.WLParticlesPropertyState
// 0x0010 (0x0010 - 0x0000)
struct FWLParticlesPropertyState final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetValue;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationSpeed;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWLParticlesPropertyState) == 0x000004, "Wrong alignment on FWLParticlesPropertyState");
static_assert(sizeof(FWLParticlesPropertyState) == 0x000010, "Wrong size on FWLParticlesPropertyState");
static_assert(offsetof(FWLParticlesPropertyState, PropertyName) == 0x000000, "Member 'FWLParticlesPropertyState::PropertyName' has a wrong offset!");
static_assert(offsetof(FWLParticlesPropertyState, TargetValue) == 0x000008, "Member 'FWLParticlesPropertyState::TargetValue' has a wrong offset!");
static_assert(offsetof(FWLParticlesPropertyState, InterpolationSpeed) == 0x00000C, "Member 'FWLParticlesPropertyState::InterpolationSpeed' has a wrong offset!");

// ScriptStruct Stalker2.AnimDamageData
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FAnimDamageData final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimDamageData) == 0x000008, "Wrong alignment on FAnimDamageData");
static_assert(sizeof(FAnimDamageData) == 0x000030, "Wrong size on FAnimDamageData");

// ScriptStruct Stalker2.InjectorAnimations
// 0x0010 (0x0010 - 0x0000)
struct FInjectorAnimations final
{
public:
	class UAnimMontage*                           PlayerHealAnimation;                               // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           HumanHealAnimation;                                // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInjectorAnimations) == 0x000008, "Wrong alignment on FInjectorAnimations");
static_assert(sizeof(FInjectorAnimations) == 0x000010, "Wrong size on FInjectorAnimations");
static_assert(offsetof(FInjectorAnimations, PlayerHealAnimation) == 0x000000, "Member 'FInjectorAnimations::PlayerHealAnimation' has a wrong offset!");
static_assert(offsetof(FInjectorAnimations, HumanHealAnimation) == 0x000008, "Member 'FInjectorAnimations::HumanHealAnimation' has a wrong offset!");

// ScriptStruct Stalker2.AnimTwoHandsIKData
// 0x0078 (0x0078 - 0x0000)
struct FAnimTwoHandsIKData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimHandIKData                        LeftHand;                                          // 0x0008(0x0038)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimHandIKData                        RightHand;                                         // 0x0040(0x0038)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimTwoHandsIKData) == 0x000008, "Wrong alignment on FAnimTwoHandsIKData");
static_assert(sizeof(FAnimTwoHandsIKData) == 0x000078, "Wrong size on FAnimTwoHandsIKData");
static_assert(offsetof(FAnimTwoHandsIKData, LeftHand) == 0x000008, "Member 'FAnimTwoHandsIKData::LeftHand' has a wrong offset!");
static_assert(offsetof(FAnimTwoHandsIKData, RightHand) == 0x000040, "Member 'FAnimTwoHandsIKData::RightHand' has a wrong offset!");

// ScriptStruct Stalker2.FloatParameter
// 0x0008 (0x0060 - 0x0058)
struct FFloatParameter final : public FParameter
{
public:
	class UCurveFloat*                            Curve;                                             // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatParameter) == 0x000008, "Wrong alignment on FFloatParameter");
static_assert(sizeof(FFloatParameter) == 0x000060, "Wrong size on FFloatParameter");
static_assert(offsetof(FFloatParameter, Curve) == 0x000058, "Member 'FFloatParameter::Curve' has a wrong offset!");

// ScriptStruct Stalker2.SkySphereState
// 0x0180 (0x0180 - 0x0000)
struct FSkySphereState final
{
public:
	struct FFloatParameter                        AtmosphereBrightness;                              // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        EmissiveBrightness;                                // 0x0060(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  ZenithColor;                                       // 0x00C0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  HorizonColor;                                      // 0x0120(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkySphereState) == 0x000008, "Wrong alignment on FSkySphereState");
static_assert(sizeof(FSkySphereState) == 0x000180, "Wrong size on FSkySphereState");
static_assert(offsetof(FSkySphereState, AtmosphereBrightness) == 0x000000, "Member 'FSkySphereState::AtmosphereBrightness' has a wrong offset!");
static_assert(offsetof(FSkySphereState, EmissiveBrightness) == 0x000060, "Member 'FSkySphereState::EmissiveBrightness' has a wrong offset!");
static_assert(offsetof(FSkySphereState, ZenithColor) == 0x0000C0, "Member 'FSkySphereState::ZenithColor' has a wrong offset!");
static_assert(offsetof(FSkySphereState, HorizonColor) == 0x000120, "Member 'FSkySphereState::HorizonColor' has a wrong offset!");

// ScriptStruct Stalker2.WeatherHistoryData
// 0x0024 (0x0024 - 0x0000)
struct FWeatherHistoryData final
{
public:
	EWeather                                      WeatherType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendWeight;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeightIncrease;                               // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cooldown;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRepeatAmount;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepeatAmount;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaused;                                           // 0x0018(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowInDialogueTransition;                        // 0x0019(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0xA];                                       // 0x001A(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeatherHistoryData) == 0x000004, "Wrong alignment on FWeatherHistoryData");
static_assert(sizeof(FWeatherHistoryData) == 0x000024, "Wrong size on FWeatherHistoryData");
static_assert(offsetof(FWeatherHistoryData, WeatherType) == 0x000000, "Member 'FWeatherHistoryData::WeatherType' has a wrong offset!");
static_assert(offsetof(FWeatherHistoryData, BlendWeight) == 0x000004, "Member 'FWeatherHistoryData::BlendWeight' has a wrong offset!");
static_assert(offsetof(FWeatherHistoryData, BlendWeightIncrease) == 0x000008, "Member 'FWeatherHistoryData::BlendWeightIncrease' has a wrong offset!");
static_assert(offsetof(FWeatherHistoryData, Cooldown) == 0x00000C, "Member 'FWeatherHistoryData::Cooldown' has a wrong offset!");
static_assert(offsetof(FWeatherHistoryData, MaxRepeatAmount) == 0x000010, "Member 'FWeatherHistoryData::MaxRepeatAmount' has a wrong offset!");
static_assert(offsetof(FWeatherHistoryData, RepeatAmount) == 0x000014, "Member 'FWeatherHistoryData::RepeatAmount' has a wrong offset!");
static_assert(offsetof(FWeatherHistoryData, bPaused) == 0x000018, "Member 'FWeatherHistoryData::bPaused' has a wrong offset!");
static_assert(offsetof(FWeatherHistoryData, bAllowInDialogueTransition) == 0x000019, "Member 'FWeatherHistoryData::bAllowInDialogueTransition' has a wrong offset!");

// ScriptStruct Stalker2.DetectorToggleFlashlightAnimations
// 0x0050 (0x0050 - 0x0000)
struct FDetectorToggleFlashlightAnimations final
{
public:
	TMap<EMainHandEquipmentType, class UAnimMontage*> ToggleFlashlight;                              // 0x0000(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectorToggleFlashlightAnimations) == 0x000008, "Wrong alignment on FDetectorToggleFlashlightAnimations");
static_assert(sizeof(FDetectorToggleFlashlightAnimations) == 0x000050, "Wrong size on FDetectorToggleFlashlightAnimations");
static_assert(offsetof(FDetectorToggleFlashlightAnimations, ToggleFlashlight) == 0x000000, "Member 'FDetectorToggleFlashlightAnimations::ToggleFlashlight' has a wrong offset!");

// ScriptStruct Stalker2.HumanHitAnimations
// 0x0028 (0x0028 - 0x0000)
struct FHumanHitAnimations final
{
public:
	class UBlendSpace1D*                          Head;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          UpperBody;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          LowerBody;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          LeftLeg;                                           // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          RightLeg;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHumanHitAnimations) == 0x000008, "Wrong alignment on FHumanHitAnimations");
static_assert(sizeof(FHumanHitAnimations) == 0x000028, "Wrong size on FHumanHitAnimations");
static_assert(offsetof(FHumanHitAnimations, Head) == 0x000000, "Member 'FHumanHitAnimations::Head' has a wrong offset!");
static_assert(offsetof(FHumanHitAnimations, UpperBody) == 0x000008, "Member 'FHumanHitAnimations::UpperBody' has a wrong offset!");
static_assert(offsetof(FHumanHitAnimations, LowerBody) == 0x000010, "Member 'FHumanHitAnimations::LowerBody' has a wrong offset!");
static_assert(offsetof(FHumanHitAnimations, LeftLeg) == 0x000018, "Member 'FHumanHitAnimations::LeftLeg' has a wrong offset!");
static_assert(offsetof(FHumanHitAnimations, RightLeg) == 0x000020, "Member 'FHumanHitAnimations::RightLeg' has a wrong offset!");

// ScriptStruct Stalker2.HumanLookAtAnimations
// 0x0018 (0x0018 - 0x0000)
struct FHumanLookAtAnimations final
{
public:
	class UBlendSpace*                            CoverStandBlindLeft;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CoverCrouchBlindLeft;                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CoverCrouchBlindTop;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHumanLookAtAnimations) == 0x000008, "Wrong alignment on FHumanLookAtAnimations");
static_assert(sizeof(FHumanLookAtAnimations) == 0x000018, "Wrong size on FHumanLookAtAnimations");
static_assert(offsetof(FHumanLookAtAnimations, CoverStandBlindLeft) == 0x000000, "Member 'FHumanLookAtAnimations::CoverStandBlindLeft' has a wrong offset!");
static_assert(offsetof(FHumanLookAtAnimations, CoverCrouchBlindLeft) == 0x000008, "Member 'FHumanLookAtAnimations::CoverCrouchBlindLeft' has a wrong offset!");
static_assert(offsetof(FHumanLookAtAnimations, CoverCrouchBlindTop) == 0x000010, "Member 'FHumanLookAtAnimations::CoverCrouchBlindTop' has a wrong offset!");

// ScriptStruct Stalker2.HumanExternalAnimations
// 0x00D0 (0x00D0 - 0x0000)
struct FHumanExternalAnimations final
{
public:
	struct FHumanHitAnimations                    DefaultHits;                                       // 0x0000(0x0028)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FHumanHitAnimations                    ShotgunHits;                                       // 0x0028(0x0028)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FHumanKnockDownAnimations              KnockdownAnimations;                               // 0x0050(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FHumanLookAtAnimations                 LookAt;                                            // 0x0078(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleStand;                                         // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleCrouch;                                        // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleRelaxed;                                       // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleRelaxedAdditive;                               // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandToCrouch;                                     // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchToStand;                                     // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandToRelax;                                      // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RelaxToStand;                                      // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHumanExternalAnimations) == 0x000008, "Wrong alignment on FHumanExternalAnimations");
static_assert(sizeof(FHumanExternalAnimations) == 0x0000D0, "Wrong size on FHumanExternalAnimations");
static_assert(offsetof(FHumanExternalAnimations, DefaultHits) == 0x000000, "Member 'FHumanExternalAnimations::DefaultHits' has a wrong offset!");
static_assert(offsetof(FHumanExternalAnimations, ShotgunHits) == 0x000028, "Member 'FHumanExternalAnimations::ShotgunHits' has a wrong offset!");
static_assert(offsetof(FHumanExternalAnimations, KnockdownAnimations) == 0x000050, "Member 'FHumanExternalAnimations::KnockdownAnimations' has a wrong offset!");
static_assert(offsetof(FHumanExternalAnimations, LookAt) == 0x000078, "Member 'FHumanExternalAnimations::LookAt' has a wrong offset!");
static_assert(offsetof(FHumanExternalAnimations, IdleStand) == 0x000090, "Member 'FHumanExternalAnimations::IdleStand' has a wrong offset!");
static_assert(offsetof(FHumanExternalAnimations, IdleCrouch) == 0x000098, "Member 'FHumanExternalAnimations::IdleCrouch' has a wrong offset!");
static_assert(offsetof(FHumanExternalAnimations, IdleRelaxed) == 0x0000A0, "Member 'FHumanExternalAnimations::IdleRelaxed' has a wrong offset!");
static_assert(offsetof(FHumanExternalAnimations, IdleRelaxedAdditive) == 0x0000A8, "Member 'FHumanExternalAnimations::IdleRelaxedAdditive' has a wrong offset!");
static_assert(offsetof(FHumanExternalAnimations, StandToCrouch) == 0x0000B0, "Member 'FHumanExternalAnimations::StandToCrouch' has a wrong offset!");
static_assert(offsetof(FHumanExternalAnimations, CrouchToStand) == 0x0000B8, "Member 'FHumanExternalAnimations::CrouchToStand' has a wrong offset!");
static_assert(offsetof(FHumanExternalAnimations, StandToRelax) == 0x0000C0, "Member 'FHumanExternalAnimations::StandToRelax' has a wrong offset!");
static_assert(offsetof(FHumanExternalAnimations, RelaxToStand) == 0x0000C8, "Member 'FHumanExternalAnimations::RelaxToStand' has a wrong offset!");

// ScriptStruct Stalker2.HumanWeaponExternalAnimations
// 0x0040 (0x0040 - 0x0000)
struct FHumanWeaponExternalAnimations final
{
public:
	class UAnimSequence*                          IdleCommon;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleCrouchCommon;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Idle;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleRelaxed;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleAdd;                                           // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleRelaxedAdd;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LowCoverIdleAdditive;                              // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HighCoverIdleAdditive;                             // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHumanWeaponExternalAnimations) == 0x000008, "Wrong alignment on FHumanWeaponExternalAnimations");
static_assert(sizeof(FHumanWeaponExternalAnimations) == 0x000040, "Wrong size on FHumanWeaponExternalAnimations");
static_assert(offsetof(FHumanWeaponExternalAnimations, IdleCommon) == 0x000000, "Member 'FHumanWeaponExternalAnimations::IdleCommon' has a wrong offset!");
static_assert(offsetof(FHumanWeaponExternalAnimations, IdleCrouchCommon) == 0x000008, "Member 'FHumanWeaponExternalAnimations::IdleCrouchCommon' has a wrong offset!");
static_assert(offsetof(FHumanWeaponExternalAnimations, Idle) == 0x000010, "Member 'FHumanWeaponExternalAnimations::Idle' has a wrong offset!");
static_assert(offsetof(FHumanWeaponExternalAnimations, IdleRelaxed) == 0x000018, "Member 'FHumanWeaponExternalAnimations::IdleRelaxed' has a wrong offset!");
static_assert(offsetof(FHumanWeaponExternalAnimations, IdleAdd) == 0x000020, "Member 'FHumanWeaponExternalAnimations::IdleAdd' has a wrong offset!");
static_assert(offsetof(FHumanWeaponExternalAnimations, IdleRelaxedAdd) == 0x000028, "Member 'FHumanWeaponExternalAnimations::IdleRelaxedAdd' has a wrong offset!");
static_assert(offsetof(FHumanWeaponExternalAnimations, LowCoverIdleAdditive) == 0x000030, "Member 'FHumanWeaponExternalAnimations::LowCoverIdleAdditive' has a wrong offset!");
static_assert(offsetof(FHumanWeaponExternalAnimations, HighCoverIdleAdditive) == 0x000038, "Member 'FHumanWeaponExternalAnimations::HighCoverIdleAdditive' has a wrong offset!");

// ScriptStruct Stalker2.AnimHumanCollectionsData
// 0x0128 (0x0128 - 0x0000)
struct FAnimHumanCollectionsData final
{
public:
	class UHumanDefaultAnimCollection*            DefaultAnimCollection;                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHumanAnimCollection*                   AnimCollection;                                    // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHumanFirearmAnimCollection*            FirearmAnimCollection;                             // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHumanExternalAnimations               ExternalAnimations;                                // 0x0018(0x00D0)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FHumanWeaponExternalAnimations         WeaponExternalAnimations;                          // 0x00E8(0x0040)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanCollectionsData) == 0x000008, "Wrong alignment on FAnimHumanCollectionsData");
static_assert(sizeof(FAnimHumanCollectionsData) == 0x000128, "Wrong size on FAnimHumanCollectionsData");
static_assert(offsetof(FAnimHumanCollectionsData, DefaultAnimCollection) == 0x000000, "Member 'FAnimHumanCollectionsData::DefaultAnimCollection' has a wrong offset!");
static_assert(offsetof(FAnimHumanCollectionsData, AnimCollection) == 0x000008, "Member 'FAnimHumanCollectionsData::AnimCollection' has a wrong offset!");
static_assert(offsetof(FAnimHumanCollectionsData, FirearmAnimCollection) == 0x000010, "Member 'FAnimHumanCollectionsData::FirearmAnimCollection' has a wrong offset!");
static_assert(offsetof(FAnimHumanCollectionsData, ExternalAnimations) == 0x000018, "Member 'FAnimHumanCollectionsData::ExternalAnimations' has a wrong offset!");
static_assert(offsetof(FAnimHumanCollectionsData, WeaponExternalAnimations) == 0x0000E8, "Member 'FAnimHumanCollectionsData::WeaponExternalAnimations' has a wrong offset!");

// ScriptStruct Stalker2.VolumetricCloudState
// 0x0C00 (0x0C00 - 0x0000)
struct FVolumetricCloudState final
{
public:
	struct FFloatParameter                        CloudMapBias;                                      // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        CloudMapDensity;                                   // 0x0060(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        NoiseFlowMapAMultiplier;                           // 0x00C0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        NoiseFlowMapABias;                                 // 0x0120(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        NoiseFlowMapADetail;                               // 0x0180(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        NoiseFlowMapABottomNoise;                          // 0x01E0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        NoiseFlowMapBBias;                                 // 0x0240(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        NoiseFlowMapBDetail;                               // 0x02A0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        NoiseFlowMapBScale;                                // 0x0300(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        BillowyStormyCloudsHeight;                         // 0x0360(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        DensityVariationScale;                             // 0x03C0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        DensityVariationPower;                             // 0x0420(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        DensityVariationOutFirst;                          // 0x0480(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        DensityVariationOutSecond;                         // 0x04E0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        DensityVariationDarkMinDensity;                    // 0x0540(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        CloudBaseCapMaskRadius;                            // 0x05A0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        CloudBaseSpeedMultiplier;                          // 0x0600(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  CloudBaseECX;                                      // 0x0660(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        CloudBasePreExponentialDensity;                    // 0x06C0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  CloudBaseAlbedo;                                   // 0x0720(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  CloudBaseSecondAlbedo;                             // 0x0780(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  EmissionParamPositionIntensity;                    // 0x07E0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  EmissionParamColor;                                // 0x0840(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        PhaseBlend;                                        // 0x08A0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        PhaseG;                                            // 0x0900(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        PhaseGSecond;                                      // 0x0960(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        MultiScatteringContribution;                       // 0x09C0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        MultiScatteringOcclusion;                          // 0x0A20(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        MultiScatteringOcclusionPower;                     // 0x0A80(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        MultiScatteringEccentricity;                       // 0x0AE0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        LayerHeight;                                       // 0x0B40(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        LayerBottomAltitude;                               // 0x0BA0(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVolumetricCloudState) == 0x000008, "Wrong alignment on FVolumetricCloudState");
static_assert(sizeof(FVolumetricCloudState) == 0x000C00, "Wrong size on FVolumetricCloudState");
static_assert(offsetof(FVolumetricCloudState, CloudMapBias) == 0x000000, "Member 'FVolumetricCloudState::CloudMapBias' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, CloudMapDensity) == 0x000060, "Member 'FVolumetricCloudState::CloudMapDensity' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, NoiseFlowMapAMultiplier) == 0x0000C0, "Member 'FVolumetricCloudState::NoiseFlowMapAMultiplier' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, NoiseFlowMapABias) == 0x000120, "Member 'FVolumetricCloudState::NoiseFlowMapABias' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, NoiseFlowMapADetail) == 0x000180, "Member 'FVolumetricCloudState::NoiseFlowMapADetail' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, NoiseFlowMapABottomNoise) == 0x0001E0, "Member 'FVolumetricCloudState::NoiseFlowMapABottomNoise' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, NoiseFlowMapBBias) == 0x000240, "Member 'FVolumetricCloudState::NoiseFlowMapBBias' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, NoiseFlowMapBDetail) == 0x0002A0, "Member 'FVolumetricCloudState::NoiseFlowMapBDetail' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, NoiseFlowMapBScale) == 0x000300, "Member 'FVolumetricCloudState::NoiseFlowMapBScale' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, BillowyStormyCloudsHeight) == 0x000360, "Member 'FVolumetricCloudState::BillowyStormyCloudsHeight' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, DensityVariationScale) == 0x0003C0, "Member 'FVolumetricCloudState::DensityVariationScale' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, DensityVariationPower) == 0x000420, "Member 'FVolumetricCloudState::DensityVariationPower' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, DensityVariationOutFirst) == 0x000480, "Member 'FVolumetricCloudState::DensityVariationOutFirst' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, DensityVariationOutSecond) == 0x0004E0, "Member 'FVolumetricCloudState::DensityVariationOutSecond' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, DensityVariationDarkMinDensity) == 0x000540, "Member 'FVolumetricCloudState::DensityVariationDarkMinDensity' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, CloudBaseCapMaskRadius) == 0x0005A0, "Member 'FVolumetricCloudState::CloudBaseCapMaskRadius' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, CloudBaseSpeedMultiplier) == 0x000600, "Member 'FVolumetricCloudState::CloudBaseSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, CloudBaseECX) == 0x000660, "Member 'FVolumetricCloudState::CloudBaseECX' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, CloudBasePreExponentialDensity) == 0x0006C0, "Member 'FVolumetricCloudState::CloudBasePreExponentialDensity' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, CloudBaseAlbedo) == 0x000720, "Member 'FVolumetricCloudState::CloudBaseAlbedo' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, CloudBaseSecondAlbedo) == 0x000780, "Member 'FVolumetricCloudState::CloudBaseSecondAlbedo' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, EmissionParamPositionIntensity) == 0x0007E0, "Member 'FVolumetricCloudState::EmissionParamPositionIntensity' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, EmissionParamColor) == 0x000840, "Member 'FVolumetricCloudState::EmissionParamColor' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, PhaseBlend) == 0x0008A0, "Member 'FVolumetricCloudState::PhaseBlend' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, PhaseG) == 0x000900, "Member 'FVolumetricCloudState::PhaseG' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, PhaseGSecond) == 0x000960, "Member 'FVolumetricCloudState::PhaseGSecond' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, MultiScatteringContribution) == 0x0009C0, "Member 'FVolumetricCloudState::MultiScatteringContribution' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, MultiScatteringOcclusion) == 0x000A20, "Member 'FVolumetricCloudState::MultiScatteringOcclusion' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, MultiScatteringOcclusionPower) == 0x000A80, "Member 'FVolumetricCloudState::MultiScatteringOcclusionPower' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, MultiScatteringEccentricity) == 0x000AE0, "Member 'FVolumetricCloudState::MultiScatteringEccentricity' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, LayerHeight) == 0x000B40, "Member 'FVolumetricCloudState::LayerHeight' has a wrong offset!");
static_assert(offsetof(FVolumetricCloudState, LayerBottomAltitude) == 0x000BA0, "Member 'FVolumetricCloudState::LayerBottomAltitude' has a wrong offset!");

// ScriptStruct Stalker2.AnimSequenceWeighted
// 0x0010 (0x0010 - 0x0000)
struct FAnimSequenceWeighted final
{
public:
	float                                         ChanceToPlay;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSequenceWeighted) == 0x000008, "Wrong alignment on FAnimSequenceWeighted");
static_assert(sizeof(FAnimSequenceWeighted) == 0x000010, "Wrong size on FAnimSequenceWeighted");
static_assert(offsetof(FAnimSequenceWeighted, ChanceToPlay) == 0x000000, "Member 'FAnimSequenceWeighted::ChanceToPlay' has a wrong offset!");
static_assert(offsetof(FAnimSequenceWeighted, Animation) == 0x000008, "Member 'FAnimSequenceWeighted::Animation' has a wrong offset!");

// ScriptStruct Stalker2.AnimHumanDialogData
// 0x00A8 (0x00A8 - 0x0000)
struct FAnimHumanDialogData final
{
public:
	TArray<struct FAnimSequenceWeighted>          DialogIdleAnims;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastWaitingIdleAnimsCount;                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInDialog;                                         // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            DialogWaitingIdleAnimCooldownRange;                // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            DialogTalkingIdleAnimCooldownRange;                // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x70];                                      // 0x0038(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimHumanDialogData) == 0x000008, "Wrong alignment on FAnimHumanDialogData");
static_assert(sizeof(FAnimHumanDialogData) == 0x0000A8, "Wrong size on FAnimHumanDialogData");
static_assert(offsetof(FAnimHumanDialogData, DialogIdleAnims) == 0x000000, "Member 'FAnimHumanDialogData::DialogIdleAnims' has a wrong offset!");
static_assert(offsetof(FAnimHumanDialogData, LastWaitingIdleAnimsCount) == 0x000010, "Member 'FAnimHumanDialogData::LastWaitingIdleAnimsCount' has a wrong offset!");
static_assert(offsetof(FAnimHumanDialogData, bInDialog) == 0x000014, "Member 'FAnimHumanDialogData::bInDialog' has a wrong offset!");
static_assert(offsetof(FAnimHumanDialogData, DialogWaitingIdleAnimCooldownRange) == 0x000018, "Member 'FAnimHumanDialogData::DialogWaitingIdleAnimCooldownRange' has a wrong offset!");
static_assert(offsetof(FAnimHumanDialogData, DialogTalkingIdleAnimCooldownRange) == 0x000028, "Member 'FAnimHumanDialogData::DialogTalkingIdleAnimCooldownRange' has a wrong offset!");

// ScriptStruct Stalker2.SkyAtmosphereRayleighMieState
// 0x0360 (0x0360 - 0x0000)
struct FSkyAtmosphereRayleighMieState final
{
public:
	struct FFloatParameter                        RayleighScatteringScale;                           // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  RayleighScattering;                                // 0x0060(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        RayleighExponentialDistribution;                   // 0x00C0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        MieScatteringScale;                                // 0x0120(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  MieScattering;                                     // 0x0180(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        MieScatteringAbsorption;                           // 0x01E0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  MieAbsorption;                                     // 0x0240(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        MieAnisotropy;                                     // 0x02A0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        MieExponentialDistribution;                        // 0x0300(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkyAtmosphereRayleighMieState) == 0x000008, "Wrong alignment on FSkyAtmosphereRayleighMieState");
static_assert(sizeof(FSkyAtmosphereRayleighMieState) == 0x000360, "Wrong size on FSkyAtmosphereRayleighMieState");
static_assert(offsetof(FSkyAtmosphereRayleighMieState, RayleighScatteringScale) == 0x000000, "Member 'FSkyAtmosphereRayleighMieState::RayleighScatteringScale' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereRayleighMieState, RayleighScattering) == 0x000060, "Member 'FSkyAtmosphereRayleighMieState::RayleighScattering' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereRayleighMieState, RayleighExponentialDistribution) == 0x0000C0, "Member 'FSkyAtmosphereRayleighMieState::RayleighExponentialDistribution' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereRayleighMieState, MieScatteringScale) == 0x000120, "Member 'FSkyAtmosphereRayleighMieState::MieScatteringScale' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereRayleighMieState, MieScattering) == 0x000180, "Member 'FSkyAtmosphereRayleighMieState::MieScattering' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereRayleighMieState, MieScatteringAbsorption) == 0x0001E0, "Member 'FSkyAtmosphereRayleighMieState::MieScatteringAbsorption' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereRayleighMieState, MieAbsorption) == 0x000240, "Member 'FSkyAtmosphereRayleighMieState::MieAbsorption' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereRayleighMieState, MieAnisotropy) == 0x0002A0, "Member 'FSkyAtmosphereRayleighMieState::MieAnisotropy' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereRayleighMieState, MieExponentialDistribution) == 0x000300, "Member 'FSkyAtmosphereRayleighMieState::MieExponentialDistribution' has a wrong offset!");

// ScriptStruct Stalker2.HumanAnimLocomotionData
// 0x0088 (0x0088 - 0x0000)
struct alignas(0x08) FHumanAnimLocomotionData final
{
public:
	float                                         Velocity;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleDirection;                                    // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampedDirection;                                  // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BPDirection;                                       // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDirections                                   Direction;                                         // 0x000D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDirectionBlendData                    DirectionBlendParams;                              // 0x0010(0x0024)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x54];                                      // 0x0034(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHumanAnimLocomotionData) == 0x000008, "Wrong alignment on FHumanAnimLocomotionData");
static_assert(sizeof(FHumanAnimLocomotionData) == 0x000088, "Wrong size on FHumanAnimLocomotionData");
static_assert(offsetof(FHumanAnimLocomotionData, Velocity) == 0x000000, "Member 'FHumanAnimLocomotionData::Velocity' has a wrong offset!");
static_assert(offsetof(FHumanAnimLocomotionData, AngleDirection) == 0x000004, "Member 'FHumanAnimLocomotionData::AngleDirection' has a wrong offset!");
static_assert(offsetof(FHumanAnimLocomotionData, ClampedDirection) == 0x000008, "Member 'FHumanAnimLocomotionData::ClampedDirection' has a wrong offset!");
static_assert(offsetof(FHumanAnimLocomotionData, BPDirection) == 0x00000C, "Member 'FHumanAnimLocomotionData::BPDirection' has a wrong offset!");
static_assert(offsetof(FHumanAnimLocomotionData, Direction) == 0x00000D, "Member 'FHumanAnimLocomotionData::Direction' has a wrong offset!");
static_assert(offsetof(FHumanAnimLocomotionData, DirectionBlendParams) == 0x000010, "Member 'FHumanAnimLocomotionData::DirectionBlendParams' has a wrong offset!");

// ScriptStruct Stalker2.SkyLightState
// 0x00C0 (0x00C0 - 0x0000)
struct FSkyLightState final
{
public:
	struct FFloatParameter                        Intensity;                                         // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  SkyLightColor;                                     // 0x0060(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkyLightState) == 0x000008, "Wrong alignment on FSkyLightState");
static_assert(sizeof(FSkyLightState) == 0x0000C0, "Wrong size on FSkyLightState");
static_assert(offsetof(FSkyLightState, Intensity) == 0x000000, "Member 'FSkyLightState::Intensity' has a wrong offset!");
static_assert(offsetof(FSkyLightState, SkyLightColor) == 0x000060, "Member 'FSkyLightState::SkyLightColor' has a wrong offset!");

// ScriptStruct Stalker2.RestrictionsMap
// 0x0038 (0x0038 - 0x0000)
struct FRestrictionsMap final
{
public:
	bool                                          bIsFullBodyRotationBlocked;                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpperBodyHorizontalLimit;                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBodyVerticalLimit;                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateFullBodyDespiteUpperBody;                   // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractLimit;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyHeadRotateOnUpperBody;                        // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         bFullBodyRotateSatisfyAngle;                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               PoseRotationOffset;                                // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRestrictionsMap) == 0x000008, "Wrong alignment on FRestrictionsMap");
static_assert(sizeof(FRestrictionsMap) == 0x000038, "Wrong size on FRestrictionsMap");
static_assert(offsetof(FRestrictionsMap, bIsFullBodyRotationBlocked) == 0x000000, "Member 'FRestrictionsMap::bIsFullBodyRotationBlocked' has a wrong offset!");
static_assert(offsetof(FRestrictionsMap, UpperBodyHorizontalLimit) == 0x000004, "Member 'FRestrictionsMap::UpperBodyHorizontalLimit' has a wrong offset!");
static_assert(offsetof(FRestrictionsMap, UpperBodyVerticalLimit) == 0x000008, "Member 'FRestrictionsMap::UpperBodyVerticalLimit' has a wrong offset!");
static_assert(offsetof(FRestrictionsMap, bRotateFullBodyDespiteUpperBody) == 0x00000C, "Member 'FRestrictionsMap::bRotateFullBodyDespiteUpperBody' has a wrong offset!");
static_assert(offsetof(FRestrictionsMap, InteractLimit) == 0x000010, "Member 'FRestrictionsMap::InteractLimit' has a wrong offset!");
static_assert(offsetof(FRestrictionsMap, bOnlyHeadRotateOnUpperBody) == 0x000014, "Member 'FRestrictionsMap::bOnlyHeadRotateOnUpperBody' has a wrong offset!");
static_assert(offsetof(FRestrictionsMap, bFullBodyRotateSatisfyAngle) == 0x000018, "Member 'FRestrictionsMap::bFullBodyRotateSatisfyAngle' has a wrong offset!");
static_assert(offsetof(FRestrictionsMap, PoseRotationOffset) == 0x000020, "Member 'FRestrictionsMap::PoseRotationOffset' has a wrong offset!");

// ScriptStruct Stalker2.RotationBodyPart
// 0x000C (0x000C - 0x0000)
struct FRotationBodyPart final
{
public:
	ERotationPartType                             BodyType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Rotation;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalRotation;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRotationBodyPart) == 0x000004, "Wrong alignment on FRotationBodyPart");
static_assert(sizeof(FRotationBodyPart) == 0x00000C, "Wrong size on FRotationBodyPart");
static_assert(offsetof(FRotationBodyPart, BodyType) == 0x000000, "Member 'FRotationBodyPart::BodyType' has a wrong offset!");
static_assert(offsetof(FRotationBodyPart, Rotation) == 0x000004, "Member 'FRotationBodyPart::Rotation' has a wrong offset!");
static_assert(offsetof(FRotationBodyPart, FinalRotation) == 0x000008, "Member 'FRotationBodyPart::FinalRotation' has a wrong offset!");

// ScriptStruct Stalker2.AnimHumanLookAtData
// 0x01B0 (0x01B0 - 0x0000)
struct FAnimHumanLookAtData final
{
public:
	class ULookAtRestrictionsDataAsset*           RestrictionsConfigDA;                              // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRotationBodyPart>              HorizontalBodyParts;                               // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRotationBodyPart>              VerticalBodyParts;                                 // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              TargetRotation;                                    // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0xF8];                                      // 0x0038(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsRotating;                                       // 0x0130(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRotatingFullBody;                               // 0x0131(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELookAtOwnerState                             CurrentOwnerState;                                 // 0x0132(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_133[0x1];                                      // 0x0133(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FullBodyRotationRate;                              // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullBodyRotationTimeGap;                           // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCombatLookAt;                               // 0x013C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLookAtAlphaChangeSpeed;                         // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtLocation;                                    // 0x0148(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAlpha;                                       // 0x0160(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyHeadRotateOnUpperBody;                        // 0x0164(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponRotationInterpSpeed;                         // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponRotationAngleOffset;                         // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetWeaponRotation;                              // 0x0170(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AdditionalWeaponTransformAlpha;                    // 0x0188(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CloseToBodyWeaponShift;                            // 0x0190(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWeaponShiftOnReload;                            // 0x01A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFullBodyRotatingBlockedOutside;                 // 0x01AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimHumanLookAtData) == 0x000008, "Wrong alignment on FAnimHumanLookAtData");
static_assert(sizeof(FAnimHumanLookAtData) == 0x0001B0, "Wrong size on FAnimHumanLookAtData");
static_assert(offsetof(FAnimHumanLookAtData, RestrictionsConfigDA) == 0x000000, "Member 'FAnimHumanLookAtData::RestrictionsConfigDA' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, HorizontalBodyParts) == 0x000008, "Member 'FAnimHumanLookAtData::HorizontalBodyParts' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, VerticalBodyParts) == 0x000018, "Member 'FAnimHumanLookAtData::VerticalBodyParts' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, TargetRotation) == 0x000028, "Member 'FAnimHumanLookAtData::TargetRotation' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, bIsRotating) == 0x000130, "Member 'FAnimHumanLookAtData::bIsRotating' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, bIsRotatingFullBody) == 0x000131, "Member 'FAnimHumanLookAtData::bIsRotatingFullBody' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, CurrentOwnerState) == 0x000132, "Member 'FAnimHumanLookAtData::CurrentOwnerState' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, FullBodyRotationRate) == 0x000134, "Member 'FAnimHumanLookAtData::FullBodyRotationRate' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, FullBodyRotationTimeGap) == 0x000138, "Member 'FAnimHumanLookAtData::FullBodyRotationTimeGap' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, bEnableCombatLookAt) == 0x00013C, "Member 'FAnimHumanLookAtData::bEnableCombatLookAt' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, MaxLookAtAlphaChangeSpeed) == 0x000140, "Member 'FAnimHumanLookAtData::MaxLookAtAlphaChangeSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, LookAtLocation) == 0x000148, "Member 'FAnimHumanLookAtData::LookAtLocation' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, LookAtAlpha) == 0x000160, "Member 'FAnimHumanLookAtData::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, bOnlyHeadRotateOnUpperBody) == 0x000164, "Member 'FAnimHumanLookAtData::bOnlyHeadRotateOnUpperBody' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, WeaponRotationInterpSpeed) == 0x000168, "Member 'FAnimHumanLookAtData::WeaponRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, WeaponRotationAngleOffset) == 0x00016C, "Member 'FAnimHumanLookAtData::WeaponRotationAngleOffset' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, TargetWeaponRotation) == 0x000170, "Member 'FAnimHumanLookAtData::TargetWeaponRotation' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, AdditionalWeaponTransformAlpha) == 0x000188, "Member 'FAnimHumanLookAtData::AdditionalWeaponTransformAlpha' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, CloseToBodyWeaponShift) == 0x000190, "Member 'FAnimHumanLookAtData::CloseToBodyWeaponShift' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, MaxWeaponShiftOnReload) == 0x0001A8, "Member 'FAnimHumanLookAtData::MaxWeaponShiftOnReload' has a wrong offset!");
static_assert(offsetof(FAnimHumanLookAtData, bIsFullBodyRotatingBlockedOutside) == 0x0001AC, "Member 'FAnimHumanLookAtData::bIsFullBodyRotatingBlockedOutside' has a wrong offset!");

// ScriptStruct Stalker2.AnimStateData
// 0x0009 (0x0009 - 0x0000)
struct FAnimStateData
{
public:
	bool                                          bAlive;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoving;                                           // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWalking;                                          // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunning;                                          // 0x0003(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSprinting;                                        // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInAir;                                            // 0x0005(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCutscene;                                         // 0x0006(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInContextualAction;                             // 0x0007(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCombat;                                         // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimStateData) == 0x000001, "Wrong alignment on FAnimStateData");
static_assert(sizeof(FAnimStateData) == 0x000009, "Wrong size on FAnimStateData");
static_assert(offsetof(FAnimStateData, bAlive) == 0x000000, "Member 'FAnimStateData::bAlive' has a wrong offset!");
static_assert(offsetof(FAnimStateData, bMoving) == 0x000001, "Member 'FAnimStateData::bMoving' has a wrong offset!");
static_assert(offsetof(FAnimStateData, bWalking) == 0x000002, "Member 'FAnimStateData::bWalking' has a wrong offset!");
static_assert(offsetof(FAnimStateData, bRunning) == 0x000003, "Member 'FAnimStateData::bRunning' has a wrong offset!");
static_assert(offsetof(FAnimStateData, bSprinting) == 0x000004, "Member 'FAnimStateData::bSprinting' has a wrong offset!");
static_assert(offsetof(FAnimStateData, bInAir) == 0x000005, "Member 'FAnimStateData::bInAir' has a wrong offset!");
static_assert(offsetof(FAnimStateData, bCutscene) == 0x000006, "Member 'FAnimStateData::bCutscene' has a wrong offset!");
static_assert(offsetof(FAnimStateData, bIsInContextualAction) == 0x000007, "Member 'FAnimStateData::bIsInContextualAction' has a wrong offset!");
static_assert(offsetof(FAnimStateData, bInCombat) == 0x000008, "Member 'FAnimStateData::bInCombat' has a wrong offset!");

// ScriptStruct Stalker2.AnimHumanStateData
// 0x0033 (0x003C - 0x0009)
struct FAnimHumanStateData final : public FAnimStateData
{
public:
	bool                                          bWounded;                                          // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKnockedDown;                                      // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KnockedDownPoseBlendTime;                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouching;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSitting;                                          // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotating;                                         // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurveGaitValue;                                    // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicGaitValue;                                  // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateCurveValue;                                   // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimationStates                              CurveGaitState;                                    // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMovementInput;                                 // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasContextualItemInHands;                         // 0x0022(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZombie;                                           // 0x0023(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnedAsZombie;                                  // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStandingUpAsZombie;                               // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayLongBHIdle;                             // 0x0026(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDragDeadBody;                                     // 0x0027(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDisableLegIK;                               // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRenderRelevant;                                 // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IsRotatingAngleThreshold;                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDisableInertialization;                     // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementShouldDisableLookAt;                      // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCopyVirtualWeaponBone;                      // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEmptyHandsInDialog;                            // 0x0033(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDeadAsNotZombie;                                // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDeadAsZombie;                                   // 0x0035(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTransitionToWeaponRelaxedIdle;              // 0x0036(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStandToRelaxIdle;                                 // 0x0037(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLegIKPaused;                                    // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHideWeaponWarning;                              // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelaxToStandIdle;                                 // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInitialIdleRelaxed;                             // 0x003B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanStateData) == 0x000004, "Wrong alignment on FAnimHumanStateData");
static_assert(sizeof(FAnimHumanStateData) == 0x00003C, "Wrong size on FAnimHumanStateData");
static_assert(offsetof(FAnimHumanStateData, bWounded) == 0x000009, "Member 'FAnimHumanStateData::bWounded' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bKnockedDown) == 0x00000A, "Member 'FAnimHumanStateData::bKnockedDown' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, KnockedDownPoseBlendTime) == 0x00000C, "Member 'FAnimHumanStateData::KnockedDownPoseBlendTime' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bCrouching) == 0x000010, "Member 'FAnimHumanStateData::bCrouching' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bSitting) == 0x000011, "Member 'FAnimHumanStateData::bSitting' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bRotating) == 0x000012, "Member 'FAnimHumanStateData::bRotating' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, CurveGaitValue) == 0x000014, "Member 'FAnimHumanStateData::CurveGaitValue' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, DynamicGaitValue) == 0x000018, "Member 'FAnimHumanStateData::DynamicGaitValue' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, StateCurveValue) == 0x00001C, "Member 'FAnimHumanStateData::StateCurveValue' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, CurveGaitState) == 0x000020, "Member 'FAnimHumanStateData::CurveGaitState' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bHasMovementInput) == 0x000021, "Member 'FAnimHumanStateData::bHasMovementInput' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bHasContextualItemInHands) == 0x000022, "Member 'FAnimHumanStateData::bHasContextualItemInHands' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bZombie) == 0x000023, "Member 'FAnimHumanStateData::bZombie' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bSpawnedAsZombie) == 0x000024, "Member 'FAnimHumanStateData::bSpawnedAsZombie' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bStandingUpAsZombie) == 0x000025, "Member 'FAnimHumanStateData::bStandingUpAsZombie' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bShouldPlayLongBHIdle) == 0x000026, "Member 'FAnimHumanStateData::bShouldPlayLongBHIdle' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bDragDeadBody) == 0x000027, "Member 'FAnimHumanStateData::bDragDeadBody' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bShouldDisableLegIK) == 0x000028, "Member 'FAnimHumanStateData::bShouldDisableLegIK' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bIsRenderRelevant) == 0x000029, "Member 'FAnimHumanStateData::bIsRenderRelevant' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, IsRotatingAngleThreshold) == 0x00002C, "Member 'FAnimHumanStateData::IsRotatingAngleThreshold' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bShouldDisableInertialization) == 0x000030, "Member 'FAnimHumanStateData::bShouldDisableInertialization' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bMovementShouldDisableLookAt) == 0x000031, "Member 'FAnimHumanStateData::bMovementShouldDisableLookAt' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bShouldCopyVirtualWeaponBone) == 0x000032, "Member 'FAnimHumanStateData::bShouldCopyVirtualWeaponBone' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bHasEmptyHandsInDialog) == 0x000033, "Member 'FAnimHumanStateData::bHasEmptyHandsInDialog' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bIsDeadAsNotZombie) == 0x000034, "Member 'FAnimHumanStateData::bIsDeadAsNotZombie' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bIsDeadAsZombie) == 0x000035, "Member 'FAnimHumanStateData::bIsDeadAsZombie' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bShouldTransitionToWeaponRelaxedIdle) == 0x000036, "Member 'FAnimHumanStateData::bShouldTransitionToWeaponRelaxedIdle' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bStandToRelaxIdle) == 0x000037, "Member 'FAnimHumanStateData::bStandToRelaxIdle' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bIsLegIKPaused) == 0x000038, "Member 'FAnimHumanStateData::bIsLegIKPaused' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bIsHideWeaponWarning) == 0x000039, "Member 'FAnimHumanStateData::bIsHideWeaponWarning' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bRelaxToStandIdle) == 0x00003A, "Member 'FAnimHumanStateData::bRelaxToStandIdle' has a wrong offset!");
static_assert(offsetof(FAnimHumanStateData, bIsInitialIdleRelaxed) == 0x00003B, "Member 'FAnimHumanStateData::bIsInitialIdleRelaxed' has a wrong offset!");

// ScriptStruct Stalker2.AnimHumanAimingData
// 0x0001 (0x0001 - 0x0000)
struct FAnimHumanAimingData final
{
public:
	bool                                          bIsAiming;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanAimingData) == 0x000001, "Wrong alignment on FAnimHumanAimingData");
static_assert(sizeof(FAnimHumanAimingData) == 0x000001, "Wrong size on FAnimHumanAimingData");
static_assert(offsetof(FAnimHumanAimingData, bIsAiming) == 0x000000, "Member 'FAnimHumanAimingData::bIsAiming' has a wrong offset!");

// ScriptStruct Stalker2.AnimHumanWeaponConfig
// 0x0020 (0x0020 - 0x0000)
struct FAnimHumanWeaponConfig final
{
public:
	float                                         CloseToBodyWeaponMinShift;                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseToBodyWeaponMaxShift;                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HandIKEffectorOffset;                              // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanWeaponConfig) == 0x000008, "Wrong alignment on FAnimHumanWeaponConfig");
static_assert(sizeof(FAnimHumanWeaponConfig) == 0x000020, "Wrong size on FAnimHumanWeaponConfig");
static_assert(offsetof(FAnimHumanWeaponConfig, CloseToBodyWeaponMinShift) == 0x000000, "Member 'FAnimHumanWeaponConfig::CloseToBodyWeaponMinShift' has a wrong offset!");
static_assert(offsetof(FAnimHumanWeaponConfig, CloseToBodyWeaponMaxShift) == 0x000004, "Member 'FAnimHumanWeaponConfig::CloseToBodyWeaponMaxShift' has a wrong offset!");
static_assert(offsetof(FAnimHumanWeaponConfig, HandIKEffectorOffset) == 0x000008, "Member 'FAnimHumanWeaponConfig::HandIKEffectorOffset' has a wrong offset!");

// ScriptStruct Stalker2.AnimHumanWeaponData
// 0x0038 (0x0038 - 0x0000)
struct FAnimHumanWeaponData final
{
public:
	bool                                          bHasWeaponInHands;                                 // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanAimingData                   AimingData;                                        // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsZombie;                                         // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 WeaponMesh;                                        // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 AttachMesh;                                        // 0x0010(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WeaponIKEffectorOffset;                            // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOneHanded;                                      // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimWeaponAdditivePoseMode                   WeaponAdditivePoseMode;                            // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimHumanWeaponData) == 0x000008, "Wrong alignment on FAnimHumanWeaponData");
static_assert(sizeof(FAnimHumanWeaponData) == 0x000038, "Wrong size on FAnimHumanWeaponData");
static_assert(offsetof(FAnimHumanWeaponData, bHasWeaponInHands) == 0x000000, "Member 'FAnimHumanWeaponData::bHasWeaponInHands' has a wrong offset!");
static_assert(offsetof(FAnimHumanWeaponData, AimingData) == 0x000001, "Member 'FAnimHumanWeaponData::AimingData' has a wrong offset!");
static_assert(offsetof(FAnimHumanWeaponData, bIsZombie) == 0x000002, "Member 'FAnimHumanWeaponData::bIsZombie' has a wrong offset!");
static_assert(offsetof(FAnimHumanWeaponData, WeaponMesh) == 0x000008, "Member 'FAnimHumanWeaponData::WeaponMesh' has a wrong offset!");
static_assert(offsetof(FAnimHumanWeaponData, AttachMesh) == 0x000010, "Member 'FAnimHumanWeaponData::AttachMesh' has a wrong offset!");
static_assert(offsetof(FAnimHumanWeaponData, WeaponIKEffectorOffset) == 0x000018, "Member 'FAnimHumanWeaponData::WeaponIKEffectorOffset' has a wrong offset!");
static_assert(offsetof(FAnimHumanWeaponData, bIsOneHanded) == 0x000030, "Member 'FAnimHumanWeaponData::bIsOneHanded' has a wrong offset!");
static_assert(offsetof(FAnimHumanWeaponData, WeaponAdditivePoseMode) == 0x000031, "Member 'FAnimHumanWeaponData::WeaponAdditivePoseMode' has a wrong offset!");

// ScriptStruct Stalker2.LightState
// 0x0300 (0x0300 - 0x0000)
struct FLightState final
{
public:
	struct FFloatParameter                        Intensity;                                         // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  LightColor;                                        // 0x0060(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        Temperature;                                       // 0x00C0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        ShadowAmount;                                      // 0x0120(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        MoonOpacity;                                       // 0x0180(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  CloudScatteredLuminanceScale;                      // 0x01E0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  SunDiskColorScale;                                 // 0x0240(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        VolumetricScatteringIntensity;                     // 0x02A0(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightState) == 0x000008, "Wrong alignment on FLightState");
static_assert(sizeof(FLightState) == 0x000300, "Wrong size on FLightState");
static_assert(offsetof(FLightState, Intensity) == 0x000000, "Member 'FLightState::Intensity' has a wrong offset!");
static_assert(offsetof(FLightState, LightColor) == 0x000060, "Member 'FLightState::LightColor' has a wrong offset!");
static_assert(offsetof(FLightState, Temperature) == 0x0000C0, "Member 'FLightState::Temperature' has a wrong offset!");
static_assert(offsetof(FLightState, ShadowAmount) == 0x000120, "Member 'FLightState::ShadowAmount' has a wrong offset!");
static_assert(offsetof(FLightState, MoonOpacity) == 0x000180, "Member 'FLightState::MoonOpacity' has a wrong offset!");
static_assert(offsetof(FLightState, CloudScatteredLuminanceScale) == 0x0001E0, "Member 'FLightState::CloudScatteredLuminanceScale' has a wrong offset!");
static_assert(offsetof(FLightState, SunDiskColorScale) == 0x000240, "Member 'FLightState::SunDiskColorScale' has a wrong offset!");
static_assert(offsetof(FLightState, VolumetricScatteringIntensity) == 0x0002A0, "Member 'FLightState::VolumetricScatteringIntensity' has a wrong offset!");

// ScriptStruct Stalker2.DirectionalLightState
// 0x0360 (0x0360 - 0x0000)
struct FDirectionalLightState final
{
public:
	struct FLightState                            Light;                                             // 0x0000(0x0300)(Edit, NativeAccessSpecifierPublic)
	struct FLightShaftsState                      LightShafts;                                       // 0x0300(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectionalLightState) == 0x000008, "Wrong alignment on FDirectionalLightState");
static_assert(sizeof(FDirectionalLightState) == 0x000360, "Wrong size on FDirectionalLightState");
static_assert(offsetof(FDirectionalLightState, Light) == 0x000000, "Member 'FDirectionalLightState::Light' has a wrong offset!");
static_assert(offsetof(FDirectionalLightState, LightShafts) == 0x000300, "Member 'FDirectionalLightState::LightShafts' has a wrong offset!");

// ScriptStruct Stalker2.SkyAtmosphereBaseState
// 0x02A0 (0x02A0 - 0x0000)
struct FSkyAtmosphereBaseState final
{
public:
	struct FFloatParameter                        MultiScattering;                                   // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        AbsorptionScale;                                   // 0x0060(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  Absorption;                                        // 0x00C0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  SkyLuminanceFactor;                                // 0x0120(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        AerialPerspectiveDistanceScale;                    // 0x0180(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        HeightFogContribution;                             // 0x01E0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        ColorPower;                                        // 0x0240(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkyAtmosphereBaseState) == 0x000008, "Wrong alignment on FSkyAtmosphereBaseState");
static_assert(sizeof(FSkyAtmosphereBaseState) == 0x0002A0, "Wrong size on FSkyAtmosphereBaseState");
static_assert(offsetof(FSkyAtmosphereBaseState, MultiScattering) == 0x000000, "Member 'FSkyAtmosphereBaseState::MultiScattering' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereBaseState, AbsorptionScale) == 0x000060, "Member 'FSkyAtmosphereBaseState::AbsorptionScale' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereBaseState, Absorption) == 0x0000C0, "Member 'FSkyAtmosphereBaseState::Absorption' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereBaseState, SkyLuminanceFactor) == 0x000120, "Member 'FSkyAtmosphereBaseState::SkyLuminanceFactor' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereBaseState, AerialPerspectiveDistanceScale) == 0x000180, "Member 'FSkyAtmosphereBaseState::AerialPerspectiveDistanceScale' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereBaseState, HeightFogContribution) == 0x0001E0, "Member 'FSkyAtmosphereBaseState::HeightFogContribution' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereBaseState, ColorPower) == 0x000240, "Member 'FSkyAtmosphereBaseState::ColorPower' has a wrong offset!");

// ScriptStruct Stalker2.SkyAtmosphereState
// 0x0600 (0x0600 - 0x0000)
struct FSkyAtmosphereState final
{
public:
	struct FSkyAtmosphereBaseState                Base;                                              // 0x0000(0x02A0)(Edit, NativeAccessSpecifierPublic)
	struct FSkyAtmosphereRayleighMieState         RayleighMie;                                       // 0x02A0(0x0360)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkyAtmosphereState) == 0x000008, "Wrong alignment on FSkyAtmosphereState");
static_assert(sizeof(FSkyAtmosphereState) == 0x000600, "Wrong size on FSkyAtmosphereState");
static_assert(offsetof(FSkyAtmosphereState, Base) == 0x000000, "Member 'FSkyAtmosphereState::Base' has a wrong offset!");
static_assert(offsetof(FSkyAtmosphereState, RayleighMie) == 0x0002A0, "Member 'FSkyAtmosphereState::RayleighMie' has a wrong offset!");

// ScriptStruct Stalker2.ExponentialHeightFogState
// 0x0480 (0x0480 - 0x0000)
struct FExponentialHeightFogState final
{
public:
	struct FFloatParameter                        FogDensity;                                        // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        FogHeightFalloff;                                  // 0x0060(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        SecondFogDensity;                                  // 0x00C0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        SecondFogFalloff;                                  // 0x0120(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        SecondFogOffset;                                   // 0x0180(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        ScatteringDistribution;                            // 0x01E0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  Albedo;                                            // 0x0240(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  Emissive;                                          // 0x02A0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        ExtinctionScale;                                   // 0x0300(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  SkyAtmosphereAmbientContributionColorScale;        // 0x0360(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  DirectionalInscatteringColor;                      // 0x03C0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        DirectionalInscatteringExponent;                   // 0x0420(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExponentialHeightFogState) == 0x000008, "Wrong alignment on FExponentialHeightFogState");
static_assert(sizeof(FExponentialHeightFogState) == 0x000480, "Wrong size on FExponentialHeightFogState");
static_assert(offsetof(FExponentialHeightFogState, FogDensity) == 0x000000, "Member 'FExponentialHeightFogState::FogDensity' has a wrong offset!");
static_assert(offsetof(FExponentialHeightFogState, FogHeightFalloff) == 0x000060, "Member 'FExponentialHeightFogState::FogHeightFalloff' has a wrong offset!");
static_assert(offsetof(FExponentialHeightFogState, SecondFogDensity) == 0x0000C0, "Member 'FExponentialHeightFogState::SecondFogDensity' has a wrong offset!");
static_assert(offsetof(FExponentialHeightFogState, SecondFogFalloff) == 0x000120, "Member 'FExponentialHeightFogState::SecondFogFalloff' has a wrong offset!");
static_assert(offsetof(FExponentialHeightFogState, SecondFogOffset) == 0x000180, "Member 'FExponentialHeightFogState::SecondFogOffset' has a wrong offset!");
static_assert(offsetof(FExponentialHeightFogState, ScatteringDistribution) == 0x0001E0, "Member 'FExponentialHeightFogState::ScatteringDistribution' has a wrong offset!");
static_assert(offsetof(FExponentialHeightFogState, Albedo) == 0x000240, "Member 'FExponentialHeightFogState::Albedo' has a wrong offset!");
static_assert(offsetof(FExponentialHeightFogState, Emissive) == 0x0002A0, "Member 'FExponentialHeightFogState::Emissive' has a wrong offset!");
static_assert(offsetof(FExponentialHeightFogState, ExtinctionScale) == 0x000300, "Member 'FExponentialHeightFogState::ExtinctionScale' has a wrong offset!");
static_assert(offsetof(FExponentialHeightFogState, SkyAtmosphereAmbientContributionColorScale) == 0x000360, "Member 'FExponentialHeightFogState::SkyAtmosphereAmbientContributionColorScale' has a wrong offset!");
static_assert(offsetof(FExponentialHeightFogState, DirectionalInscatteringColor) == 0x0003C0, "Member 'FExponentialHeightFogState::DirectionalInscatteringColor' has a wrong offset!");
static_assert(offsetof(FExponentialHeightFogState, DirectionalInscatteringExponent) == 0x000420, "Member 'FExponentialHeightFogState::DirectionalInscatteringExponent' has a wrong offset!");

// ScriptStruct Stalker2.RainState
// 0x0240 (0x0240 - 0x0000)
struct FRainState final
{
public:
	struct FFloatParameter                        Intensity;                                         // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        WeatherLightningSpawnRate;                         // 0x0060(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        Wetness;                                           // 0x00C0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        Drying;                                            // 0x0120(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        MaxWetnessValue;                                   // 0x0180(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColorParameter                  LightningColor;                                    // 0x01E0(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRainState) == 0x000008, "Wrong alignment on FRainState");
static_assert(sizeof(FRainState) == 0x000240, "Wrong size on FRainState");
static_assert(offsetof(FRainState, Intensity) == 0x000000, "Member 'FRainState::Intensity' has a wrong offset!");
static_assert(offsetof(FRainState, WeatherLightningSpawnRate) == 0x000060, "Member 'FRainState::WeatherLightningSpawnRate' has a wrong offset!");
static_assert(offsetof(FRainState, Wetness) == 0x0000C0, "Member 'FRainState::Wetness' has a wrong offset!");
static_assert(offsetof(FRainState, Drying) == 0x000120, "Member 'FRainState::Drying' has a wrong offset!");
static_assert(offsetof(FRainState, MaxWetnessValue) == 0x000180, "Member 'FRainState::MaxWetnessValue' has a wrong offset!");
static_assert(offsetof(FRainState, LightningColor) == 0x0001E0, "Member 'FRainState::LightningColor' has a wrong offset!");

// ScriptStruct Stalker2.PostProcessState
// 0x00C0 (0x00C0 - 0x0000)
struct FPostProcessState final
{
public:
	struct FFloatParameter                        DiffuseColorBoost;                                 // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        SkylightLeaking;                                   // 0x0060(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPostProcessState) == 0x000008, "Wrong alignment on FPostProcessState");
static_assert(sizeof(FPostProcessState) == 0x0000C0, "Wrong size on FPostProcessState");
static_assert(offsetof(FPostProcessState, DiffuseColorBoost) == 0x000000, "Member 'FPostProcessState::DiffuseColorBoost' has a wrong offset!");
static_assert(offsetof(FPostProcessState, SkylightLeaking) == 0x000060, "Member 'FPostProcessState::SkylightLeaking' has a wrong offset!");

// ScriptStruct Stalker2.WeatherState
// 0x2390 (0x2390 - 0x0000)
struct FWeatherState final
{
public:
	struct FSkySphereState                        SkySphere;                                         // 0x0000(0x0180)(Edit, NativeAccessSpecifierPublic)
	struct FDirectionalLightState                 DirLight;                                          // 0x0180(0x0360)(Edit, NativeAccessSpecifierPublic)
	struct FSkyLightState                         SkyLight;                                          // 0x04E0(0x00C0)(Edit, NativeAccessSpecifierPublic)
	struct FSkyAtmosphereState                    SkyAtmosphere;                                     // 0x05A0(0x0600)(Edit, NativeAccessSpecifierPublic)
	struct FVolumetricCloudState                  VolumetricCloud;                                   // 0x0BA0(0x0C00)(Edit, NativeAccessSpecifierPublic)
	struct FExponentialHeightFogState             ExponentialHeightFog;                              // 0x17A0(0x0480)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        GlobalVolumetricValue;                             // 0x1C20(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        LocalVolumetricValue;                              // 0x1C80(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FRainState                             Rain;                                              // 0x1CE0(0x0240)(Edit, NativeAccessSpecifierPublic)
	struct FPostProcessState                      PostProcess;                                       // 0x1F20(0x00C0)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        WindIntensity;                                     // 0x1FE0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        WaterWindNormalMultiplier;                         // 0x2040(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        WaterWindBaseSpeedMultiplier;                      // 0x20A0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        FoliageAnimationSpeed;                             // 0x2100(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        FoliageWindIntensityAmplitude;                     // 0x2160(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        FoliageRotationAmount;                             // 0x21C0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        FoliageRotationSpeedFraction;                      // 0x2220(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        FoliageVariationSpeedFraction;                     // 0x2280(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFloatParameter                        FoliageVariationAmount;                            // 0x22E0(0x0060)(Edit, NativeAccessSpecifierPublic)
	TMap<EWeather, float>                         TransitionDurations;                               // 0x2340(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeatherState) == 0x000008, "Wrong alignment on FWeatherState");
static_assert(sizeof(FWeatherState) == 0x002390, "Wrong size on FWeatherState");
static_assert(offsetof(FWeatherState, SkySphere) == 0x000000, "Member 'FWeatherState::SkySphere' has a wrong offset!");
static_assert(offsetof(FWeatherState, DirLight) == 0x000180, "Member 'FWeatherState::DirLight' has a wrong offset!");
static_assert(offsetof(FWeatherState, SkyLight) == 0x0004E0, "Member 'FWeatherState::SkyLight' has a wrong offset!");
static_assert(offsetof(FWeatherState, SkyAtmosphere) == 0x0005A0, "Member 'FWeatherState::SkyAtmosphere' has a wrong offset!");
static_assert(offsetof(FWeatherState, VolumetricCloud) == 0x000BA0, "Member 'FWeatherState::VolumetricCloud' has a wrong offset!");
static_assert(offsetof(FWeatherState, ExponentialHeightFog) == 0x0017A0, "Member 'FWeatherState::ExponentialHeightFog' has a wrong offset!");
static_assert(offsetof(FWeatherState, GlobalVolumetricValue) == 0x001C20, "Member 'FWeatherState::GlobalVolumetricValue' has a wrong offset!");
static_assert(offsetof(FWeatherState, LocalVolumetricValue) == 0x001C80, "Member 'FWeatherState::LocalVolumetricValue' has a wrong offset!");
static_assert(offsetof(FWeatherState, Rain) == 0x001CE0, "Member 'FWeatherState::Rain' has a wrong offset!");
static_assert(offsetof(FWeatherState, PostProcess) == 0x001F20, "Member 'FWeatherState::PostProcess' has a wrong offset!");
static_assert(offsetof(FWeatherState, WindIntensity) == 0x001FE0, "Member 'FWeatherState::WindIntensity' has a wrong offset!");
static_assert(offsetof(FWeatherState, WaterWindNormalMultiplier) == 0x002040, "Member 'FWeatherState::WaterWindNormalMultiplier' has a wrong offset!");
static_assert(offsetof(FWeatherState, WaterWindBaseSpeedMultiplier) == 0x0020A0, "Member 'FWeatherState::WaterWindBaseSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FWeatherState, FoliageAnimationSpeed) == 0x002100, "Member 'FWeatherState::FoliageAnimationSpeed' has a wrong offset!");
static_assert(offsetof(FWeatherState, FoliageWindIntensityAmplitude) == 0x002160, "Member 'FWeatherState::FoliageWindIntensityAmplitude' has a wrong offset!");
static_assert(offsetof(FWeatherState, FoliageRotationAmount) == 0x0021C0, "Member 'FWeatherState::FoliageRotationAmount' has a wrong offset!");
static_assert(offsetof(FWeatherState, FoliageRotationSpeedFraction) == 0x002220, "Member 'FWeatherState::FoliageRotationSpeedFraction' has a wrong offset!");
static_assert(offsetof(FWeatherState, FoliageVariationSpeedFraction) == 0x002280, "Member 'FWeatherState::FoliageVariationSpeedFraction' has a wrong offset!");
static_assert(offsetof(FWeatherState, FoliageVariationAmount) == 0x0022E0, "Member 'FWeatherState::FoliageVariationAmount' has a wrong offset!");
static_assert(offsetof(FWeatherState, TransitionDurations) == 0x002340, "Member 'FWeatherState::TransitionDurations' has a wrong offset!");

// ScriptStruct Stalker2.AnimKnockDownData
// 0x0002 (0x0002 - 0x0000)
struct FAnimKnockDownData final
{
public:
	EKnockedDownState                             KnockedDownState;                                  // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStillKnockedDown;                               // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimKnockDownData) == 0x000001, "Wrong alignment on FAnimKnockDownData");
static_assert(sizeof(FAnimKnockDownData) == 0x000002, "Wrong size on FAnimKnockDownData");
static_assert(offsetof(FAnimKnockDownData, KnockedDownState) == 0x000000, "Member 'FAnimKnockDownData::KnockedDownState' has a wrong offset!");
static_assert(offsetof(FAnimKnockDownData, bIsStillKnockedDown) == 0x000001, "Member 'FAnimKnockDownData::bIsStillKnockedDown' has a wrong offset!");

// ScriptStruct Stalker2.LegIKData
// 0x0010 (0x0010 - 0x0000)
struct FLegIKData final
{
public:
	class FName                                   FootName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FootSocketName;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegIKData) == 0x000004, "Wrong alignment on FLegIKData");
static_assert(sizeof(FLegIKData) == 0x000010, "Wrong size on FLegIKData");
static_assert(offsetof(FLegIKData, FootName) == 0x000000, "Member 'FLegIKData::FootName' has a wrong offset!");
static_assert(offsetof(FLegIKData, FootSocketName) == 0x000008, "Member 'FLegIKData::FootSocketName' has a wrong offset!");

// ScriptStruct Stalker2.BaseLegIKData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FBaseLegIKData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseLegIKData) == 0x000008, "Wrong alignment on FBaseLegIKData");
static_assert(sizeof(FBaseLegIKData) == 0x000008, "Wrong size on FBaseLegIKData");

// ScriptStruct Stalker2.TwoLegIKData
// 0x0020 (0x0028 - 0x0008)
struct FTwoLegIKData final : public FBaseLegIKData
{
public:
	struct FLegIKData                             LeftFootIKData;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLegIKData                             RightFootIKData;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTwoLegIKData) == 0x000008, "Wrong alignment on FTwoLegIKData");
static_assert(sizeof(FTwoLegIKData) == 0x000028, "Wrong size on FTwoLegIKData");
static_assert(offsetof(FTwoLegIKData, LeftFootIKData) == 0x000008, "Member 'FTwoLegIKData::LeftFootIKData' has a wrong offset!");
static_assert(offsetof(FTwoLegIKData, RightFootIKData) == 0x000018, "Member 'FTwoLegIKData::RightFootIKData' has a wrong offset!");

// ScriptStruct Stalker2.FourLegIKData
// 0x0040 (0x0048 - 0x0008)
struct FFourLegIKData final : public FBaseLegIKData
{
public:
	struct FLegIKData                             FrontLeftFootIKData;                               // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLegIKData                             FrontRightFootIKData;                              // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLegIKData                             BackLeftFootIKData;                                // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLegIKData                             BackRightFootIKData;                               // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFourLegIKData) == 0x000008, "Wrong alignment on FFourLegIKData");
static_assert(sizeof(FFourLegIKData) == 0x000048, "Wrong size on FFourLegIKData");
static_assert(offsetof(FFourLegIKData, FrontLeftFootIKData) == 0x000008, "Member 'FFourLegIKData::FrontLeftFootIKData' has a wrong offset!");
static_assert(offsetof(FFourLegIKData, FrontRightFootIKData) == 0x000018, "Member 'FFourLegIKData::FrontRightFootIKData' has a wrong offset!");
static_assert(offsetof(FFourLegIKData, BackLeftFootIKData) == 0x000028, "Member 'FFourLegIKData::BackLeftFootIKData' has a wrong offset!");
static_assert(offsetof(FFourLegIKData, BackRightFootIKData) == 0x000038, "Member 'FFourLegIKData::BackRightFootIKData' has a wrong offset!");

// ScriptStruct Stalker2.MovementPlayRateStructure
// 0x0014 (0x0014 - 0x0000)
struct FMovementPlayRateStructure final
{
public:
	float                                         ForwardValue;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightValue;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastForwardValue;                                  // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRightValue;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovementPlayRateStructure) == 0x000004, "Wrong alignment on FMovementPlayRateStructure");
static_assert(sizeof(FMovementPlayRateStructure) == 0x000014, "Wrong size on FMovementPlayRateStructure");
static_assert(offsetof(FMovementPlayRateStructure, ForwardValue) == 0x000000, "Member 'FMovementPlayRateStructure::ForwardValue' has a wrong offset!");
static_assert(offsetof(FMovementPlayRateStructure, RightValue) == 0x000004, "Member 'FMovementPlayRateStructure::RightValue' has a wrong offset!");
static_assert(offsetof(FMovementPlayRateStructure, PlayRate) == 0x000008, "Member 'FMovementPlayRateStructure::PlayRate' has a wrong offset!");
static_assert(offsetof(FMovementPlayRateStructure, LastForwardValue) == 0x00000C, "Member 'FMovementPlayRateStructure::LastForwardValue' has a wrong offset!");
static_assert(offsetof(FMovementPlayRateStructure, LastRightValue) == 0x000010, "Member 'FMovementPlayRateStructure::LastRightValue' has a wrong offset!");

// ScriptStruct Stalker2.MovementRotationStructure
// 0x0028 (0x0028 - 0x0000)
struct FMovementRotationStructure final
{
public:
	float                                         TurnTime;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngle;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTurnInterp;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInterpSpeed;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInterpThreshold;                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x14];                                      // 0x0014(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovementRotationStructure) == 0x000004, "Wrong alignment on FMovementRotationStructure");
static_assert(sizeof(FMovementRotationStructure) == 0x000028, "Wrong size on FMovementRotationStructure");
static_assert(offsetof(FMovementRotationStructure, TurnTime) == 0x000000, "Member 'FMovementRotationStructure::TurnTime' has a wrong offset!");
static_assert(offsetof(FMovementRotationStructure, TurnAngle) == 0x000004, "Member 'FMovementRotationStructure::TurnAngle' has a wrong offset!");
static_assert(offsetof(FMovementRotationStructure, bEnableTurnInterp) == 0x000008, "Member 'FMovementRotationStructure::bEnableTurnInterp' has a wrong offset!");
static_assert(offsetof(FMovementRotationStructure, TurnInterpSpeed) == 0x00000C, "Member 'FMovementRotationStructure::TurnInterpSpeed' has a wrong offset!");
static_assert(offsetof(FMovementRotationStructure, TurnInterpThreshold) == 0x000010, "Member 'FMovementRotationStructure::TurnInterpThreshold' has a wrong offset!");

// ScriptStruct Stalker2.AnimLocomotionData
// 0x0130 (0x0130 - 0x0000)
struct FAnimLocomotionData final
{
public:
	float                                         Velocity;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleDirection;                                    // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampedDirection;                                  // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BPDirection;                                       // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDirections                                   Direction;                                         // 0x000D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDirectionBlendData                    DirectionBlendParams;                              // 0x0010(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMovementRotationStructure             MovementRotation;                                  // 0x0034(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LegIKAlpha;                                        // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLegIKEnabled;                                     // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovementPlayRateStructure             MovementPlayRate;                                  // 0x0064(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnablePlayRateCurves;                             // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EStateTag, class UCurveFloat*>           MovementPlayRateCurves;                            // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x48];                                      // 0x00D0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HeadEvasionOffset;                                 // 0x0118(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimLocomotionData) == 0x000008, "Wrong alignment on FAnimLocomotionData");
static_assert(sizeof(FAnimLocomotionData) == 0x000130, "Wrong size on FAnimLocomotionData");
static_assert(offsetof(FAnimLocomotionData, Velocity) == 0x000000, "Member 'FAnimLocomotionData::Velocity' has a wrong offset!");
static_assert(offsetof(FAnimLocomotionData, AngleDirection) == 0x000004, "Member 'FAnimLocomotionData::AngleDirection' has a wrong offset!");
static_assert(offsetof(FAnimLocomotionData, ClampedDirection) == 0x000008, "Member 'FAnimLocomotionData::ClampedDirection' has a wrong offset!");
static_assert(offsetof(FAnimLocomotionData, BPDirection) == 0x00000C, "Member 'FAnimLocomotionData::BPDirection' has a wrong offset!");
static_assert(offsetof(FAnimLocomotionData, Direction) == 0x00000D, "Member 'FAnimLocomotionData::Direction' has a wrong offset!");
static_assert(offsetof(FAnimLocomotionData, DirectionBlendParams) == 0x000010, "Member 'FAnimLocomotionData::DirectionBlendParams' has a wrong offset!");
static_assert(offsetof(FAnimLocomotionData, MovementRotation) == 0x000034, "Member 'FAnimLocomotionData::MovementRotation' has a wrong offset!");
static_assert(offsetof(FAnimLocomotionData, LegIKAlpha) == 0x00005C, "Member 'FAnimLocomotionData::LegIKAlpha' has a wrong offset!");
static_assert(offsetof(FAnimLocomotionData, bLegIKEnabled) == 0x000060, "Member 'FAnimLocomotionData::bLegIKEnabled' has a wrong offset!");
static_assert(offsetof(FAnimLocomotionData, MovementPlayRate) == 0x000064, "Member 'FAnimLocomotionData::MovementPlayRate' has a wrong offset!");
static_assert(offsetof(FAnimLocomotionData, bEnablePlayRateCurves) == 0x000078, "Member 'FAnimLocomotionData::bEnablePlayRateCurves' has a wrong offset!");
static_assert(offsetof(FAnimLocomotionData, MovementPlayRateCurves) == 0x000080, "Member 'FAnimLocomotionData::MovementPlayRateCurves' has a wrong offset!");
static_assert(offsetof(FAnimLocomotionData, HeadEvasionOffset) == 0x000118, "Member 'FAnimLocomotionData::HeadEvasionOffset' has a wrong offset!");

// ScriptStruct Stalker2.AnimMutantCollectionsData
// 0x0008 (0x0008 - 0x0000)
struct FAnimMutantCollectionsData final
{
public:
	class UMutantAnimCollection*                  AnimCollection;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimMutantCollectionsData) == 0x000008, "Wrong alignment on FAnimMutantCollectionsData");
static_assert(sizeof(FAnimMutantCollectionsData) == 0x000008, "Wrong size on FAnimMutantCollectionsData");
static_assert(offsetof(FAnimMutantCollectionsData, AnimCollection) == 0x000000, "Member 'FAnimMutantCollectionsData::AnimCollection' has a wrong offset!");

// ScriptStruct Stalker2.LookAtMutantData
// 0x0020 (0x0020 - 0x0000)
struct FLookAtMutantData final
{
public:
	double                                        AimingYaw;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        AimingPitch;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationAngleYaw;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationAnglePitch;                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeed;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLookAtMutantData) == 0x000008, "Wrong alignment on FLookAtMutantData");
static_assert(sizeof(FLookAtMutantData) == 0x000020, "Wrong size on FLookAtMutantData");
static_assert(offsetof(FLookAtMutantData, AimingYaw) == 0x000000, "Member 'FLookAtMutantData::AimingYaw' has a wrong offset!");
static_assert(offsetof(FLookAtMutantData, AimingPitch) == 0x000008, "Member 'FLookAtMutantData::AimingPitch' has a wrong offset!");
static_assert(offsetof(FLookAtMutantData, MaxRotationAngleYaw) == 0x000010, "Member 'FLookAtMutantData::MaxRotationAngleYaw' has a wrong offset!");
static_assert(offsetof(FLookAtMutantData, MaxRotationAnglePitch) == 0x000014, "Member 'FLookAtMutantData::MaxRotationAnglePitch' has a wrong offset!");
static_assert(offsetof(FLookAtMutantData, RotationSpeed) == 0x000018, "Member 'FLookAtMutantData::RotationSpeed' has a wrong offset!");

// ScriptStruct Stalker2.AnimMutantStateData
// 0x000F (0x0018 - 0x0009)
struct FAnimMutantStateData final : public FAnimStateData
{
public:
	bool                                          bRotating;                                         // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStandToSit;                                       // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeftHanded;                                     // 0x000B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToBeLeftHanded;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsRotatingAngleThreshold;                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAwareness                                    Awareness;                                         // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDisableLegIK;                               // 0x0015(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDisableInertialization;                     // 0x0016(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimMutantStateData) == 0x000004, "Wrong alignment on FAnimMutantStateData");
static_assert(sizeof(FAnimMutantStateData) == 0x000018, "Wrong size on FAnimMutantStateData");
static_assert(offsetof(FAnimMutantStateData, bRotating) == 0x000009, "Member 'FAnimMutantStateData::bRotating' has a wrong offset!");
static_assert(offsetof(FAnimMutantStateData, bStandToSit) == 0x00000A, "Member 'FAnimMutantStateData::bStandToSit' has a wrong offset!");
static_assert(offsetof(FAnimMutantStateData, bIsLeftHanded) == 0x00000B, "Member 'FAnimMutantStateData::bIsLeftHanded' has a wrong offset!");
static_assert(offsetof(FAnimMutantStateData, ChanceToBeLeftHanded) == 0x00000C, "Member 'FAnimMutantStateData::ChanceToBeLeftHanded' has a wrong offset!");
static_assert(offsetof(FAnimMutantStateData, IsRotatingAngleThreshold) == 0x000010, "Member 'FAnimMutantStateData::IsRotatingAngleThreshold' has a wrong offset!");
static_assert(offsetof(FAnimMutantStateData, Awareness) == 0x000014, "Member 'FAnimMutantStateData::Awareness' has a wrong offset!");
static_assert(offsetof(FAnimMutantStateData, bShouldDisableLegIK) == 0x000015, "Member 'FAnimMutantStateData::bShouldDisableLegIK' has a wrong offset!");
static_assert(offsetof(FAnimMutantStateData, bShouldDisableInertialization) == 0x000016, "Member 'FAnimMutantStateData::bShouldDisableInertialization' has a wrong offset!");

// ScriptStruct Stalker2.WeightedFacialAnimation
// 0x0018 (0x0018 - 0x0000)
struct FWeightedFacialAnimation final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      FaceAnimation;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeightedFacialAnimation) == 0x000008, "Wrong alignment on FWeightedFacialAnimation");
static_assert(sizeof(FWeightedFacialAnimation) == 0x000018, "Wrong size on FWeightedFacialAnimation");
static_assert(offsetof(FWeightedFacialAnimation, Weight) == 0x000000, "Member 'FWeightedFacialAnimation::Weight' has a wrong offset!");
static_assert(offsetof(FWeightedFacialAnimation, FaceAnimation) == 0x000008, "Member 'FWeightedFacialAnimation::FaceAnimation' has a wrong offset!");
static_assert(offsetof(FWeightedFacialAnimation, StartTime) == 0x000010, "Member 'FWeightedFacialAnimation::StartTime' has a wrong offset!");

// ScriptStruct Stalker2.AnimPhysicSpaceControl
// 0x00A8 (0x00A8 - 0x0000)
struct FAnimPhysicSpaceControl final
{
public:
	struct FPhysicsControlData                    Data;                                              // 0x0000(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPhysicsControlSettings                Settings;                                          // 0x0020(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FPhysicsControlNames> LimbControls;                                     // 0x0048(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPhysicsControlNames                   AllControls;                                       // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimPhysicSpaceControl) == 0x000008, "Wrong alignment on FAnimPhysicSpaceControl");
static_assert(sizeof(FAnimPhysicSpaceControl) == 0x0000A8, "Wrong size on FAnimPhysicSpaceControl");
static_assert(offsetof(FAnimPhysicSpaceControl, Data) == 0x000000, "Member 'FAnimPhysicSpaceControl::Data' has a wrong offset!");
static_assert(offsetof(FAnimPhysicSpaceControl, Settings) == 0x000020, "Member 'FAnimPhysicSpaceControl::Settings' has a wrong offset!");
static_assert(offsetof(FAnimPhysicSpaceControl, LimbControls) == 0x000048, "Member 'FAnimPhysicSpaceControl::LimbControls' has a wrong offset!");
static_assert(offsetof(FAnimPhysicSpaceControl, AllControls) == 0x000098, "Member 'FAnimPhysicSpaceControl::AllControls' has a wrong offset!");

// ScriptStruct Stalker2.AnimBonesArray
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAnimBonesArray final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimBonesArray) == 0x000008, "Wrong alignment on FAnimBonesArray");
static_assert(sizeof(FAnimBonesArray) == 0x000010, "Wrong size on FAnimBonesArray");

// ScriptStruct Stalker2.AnimHitPhysCurves
// 0x00F8 (0x00F8 - 0x0000)
struct FAnimHitPhysCurves final
{
public:
	struct FPhysicsControlMultiplier              WorldSpaceControlMultiplier;                       // 0x0000(0x0070)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            WorldSpaceStrengthMultiplier;                      // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            WorldSpaceBlendValue;                              // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPhysicsControlMultiplier              ParentSpaceControlMultiplier;                      // 0x0080(0x0070)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ParentSpaceStrengthMultiplier;                     // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHitPhysCurves) == 0x000008, "Wrong alignment on FAnimHitPhysCurves");
static_assert(sizeof(FAnimHitPhysCurves) == 0x0000F8, "Wrong size on FAnimHitPhysCurves");
static_assert(offsetof(FAnimHitPhysCurves, WorldSpaceControlMultiplier) == 0x000000, "Member 'FAnimHitPhysCurves::WorldSpaceControlMultiplier' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysCurves, WorldSpaceStrengthMultiplier) == 0x000070, "Member 'FAnimHitPhysCurves::WorldSpaceStrengthMultiplier' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysCurves, WorldSpaceBlendValue) == 0x000078, "Member 'FAnimHitPhysCurves::WorldSpaceBlendValue' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysCurves, ParentSpaceControlMultiplier) == 0x000080, "Member 'FAnimHitPhysCurves::ParentSpaceControlMultiplier' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysCurves, ParentSpaceStrengthMultiplier) == 0x0000F0, "Member 'FAnimHitPhysCurves::ParentSpaceStrengthMultiplier' has a wrong offset!");

// ScriptStruct Stalker2.AnimHitPhysics
// 0x0380 (0x0380 - 0x0000)
struct FAnimHitPhysics final
{
public:
	class UPhysicsControlComponent*               Control;                                           // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPhysicsControlNames                   AllBodyModifiers;                                  // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FPhysicsControlNames> LimbBodyModifiers;                                // 0x0018(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EAnimConstraintProfile                        HitConstraintProfile;                              // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimPhysicSpaceControl                WorldSpaceControls;                                // 0x0070(0x00A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAnimPhysicSpaceControl                ParentSpaceControls;                               // 0x0118(0x00A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FPhysicsControlLimbSetupData>   LimbSetup;                                         // 0x01C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FAnimHitPhysCurves>  HitCurvesForLimbs;                                 // 0x01D0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         ImpulseDelay;                                      // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStrength;                                       // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadHitStrength;                                   // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDamageSource, float>                    DeathDamageSourceImpulses;                         // 0x0230(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FAnimBonesArray>     SetsOfBoneModifiersArray;                          // 0x0280(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           BodyModifierForKinematicMovement;                  // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0xA0];                                     // 0x02E0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimHitPhysics) == 0x000008, "Wrong alignment on FAnimHitPhysics");
static_assert(sizeof(FAnimHitPhysics) == 0x000380, "Wrong size on FAnimHitPhysics");
static_assert(offsetof(FAnimHitPhysics, Control) == 0x000000, "Member 'FAnimHitPhysics::Control' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysics, AllBodyModifiers) == 0x000008, "Member 'FAnimHitPhysics::AllBodyModifiers' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysics, LimbBodyModifiers) == 0x000018, "Member 'FAnimHitPhysics::LimbBodyModifiers' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysics, HitConstraintProfile) == 0x000068, "Member 'FAnimHitPhysics::HitConstraintProfile' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysics, WorldSpaceControls) == 0x000070, "Member 'FAnimHitPhysics::WorldSpaceControls' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysics, ParentSpaceControls) == 0x000118, "Member 'FAnimHitPhysics::ParentSpaceControls' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysics, LimbSetup) == 0x0001C0, "Member 'FAnimHitPhysics::LimbSetup' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysics, HitCurvesForLimbs) == 0x0001D0, "Member 'FAnimHitPhysics::HitCurvesForLimbs' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysics, ImpulseDelay) == 0x000220, "Member 'FAnimHitPhysics::ImpulseDelay' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysics, HitStrength) == 0x000224, "Member 'FAnimHitPhysics::HitStrength' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysics, DeadHitStrength) == 0x000228, "Member 'FAnimHitPhysics::DeadHitStrength' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysics, DeathDamageSourceImpulses) == 0x000230, "Member 'FAnimHitPhysics::DeathDamageSourceImpulses' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysics, SetsOfBoneModifiersArray) == 0x000280, "Member 'FAnimHitPhysics::SetsOfBoneModifiersArray' has a wrong offset!");
static_assert(offsetof(FAnimHitPhysics, BodyModifierForKinematicMovement) == 0x0002D0, "Member 'FAnimHitPhysics::BodyModifierForKinematicMovement' has a wrong offset!");

// ScriptStruct Stalker2.AnimPhysicalData
// 0x03D0 (0x03D0 - 0x0000)
struct FAnimPhysicalData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnablePhysicalHit;                                // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimHitPhysics                        Hit;                                               // 0x0008(0x0380)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bRagdollEnabled;                                   // 0x0388(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRagdollStaticPose;                                // 0x0389(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasInRagdoll;                                     // 0x038A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpBodyDirection;                                  // 0x038B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseSnapshot                          RagdollSnapshotPose;                               // 0x0390(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPhysicalData) == 0x000008, "Wrong alignment on FAnimPhysicalData");
static_assert(sizeof(FAnimPhysicalData) == 0x0003D0, "Wrong size on FAnimPhysicalData");
static_assert(offsetof(FAnimPhysicalData, bEnablePhysicalHit) == 0x000001, "Member 'FAnimPhysicalData::bEnablePhysicalHit' has a wrong offset!");
static_assert(offsetof(FAnimPhysicalData, Hit) == 0x000008, "Member 'FAnimPhysicalData::Hit' has a wrong offset!");
static_assert(offsetof(FAnimPhysicalData, bRagdollEnabled) == 0x000388, "Member 'FAnimPhysicalData::bRagdollEnabled' has a wrong offset!");
static_assert(offsetof(FAnimPhysicalData, bRagdollStaticPose) == 0x000389, "Member 'FAnimPhysicalData::bRagdollStaticPose' has a wrong offset!");
static_assert(offsetof(FAnimPhysicalData, bWasInRagdoll) == 0x00038A, "Member 'FAnimPhysicalData::bWasInRagdoll' has a wrong offset!");
static_assert(offsetof(FAnimPhysicalData, bUpBodyDirection) == 0x00038B, "Member 'FAnimPhysicalData::bUpBodyDirection' has a wrong offset!");
static_assert(offsetof(FAnimPhysicalData, RagdollSnapshotPose) == 0x000390, "Member 'FAnimPhysicalData::RagdollSnapshotPose' has a wrong offset!");

// ScriptStruct Stalker2.PDAUsageAnimations
// 0x0018 (0x0018 - 0x0000)
struct FPDAUsageAnimations final
{
public:
	class UAnimSequenceBase*                      EquipPDA;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      InteractWithPDA;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      UnequipPDA;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPDAUsageAnimations) == 0x000008, "Wrong alignment on FPDAUsageAnimations");
static_assert(sizeof(FPDAUsageAnimations) == 0x000018, "Wrong size on FPDAUsageAnimations");
static_assert(offsetof(FPDAUsageAnimations, EquipPDA) == 0x000000, "Member 'FPDAUsageAnimations::EquipPDA' has a wrong offset!");
static_assert(offsetof(FPDAUsageAnimations, InteractWithPDA) == 0x000008, "Member 'FPDAUsageAnimations::InteractWithPDA' has a wrong offset!");
static_assert(offsetof(FPDAUsageAnimations, UnequipPDA) == 0x000010, "Member 'FPDAUsageAnimations::UnequipPDA' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerAutoCoverData
// 0x0088 (0x0088 - 0x0000)
struct FAnimPlayerAutoCoverData final
{
public:
	bool                                          bFrontTraceBlocked;                                // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRightTraceBlocked;                                // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeftTraceBlocked;                                 // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpTraceBlocked;                                   // 0x0003(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CapturedSideTraceStart;                            // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCaptureSideTrace;                              // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCover;                                          // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoCoverActionActive;                            // 0x0022(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimLeanTime;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApproachTransitionPlayRate;                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaningAlpha;                                      // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaningRightAlpha;                                 // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaningLeftAlpha;                                  // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanChangeLeanSide;                                // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverlessLeaning;                                 // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverlessLeaningRight;                            // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRangeDistanceToCover;                           // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceCapsuleRadius;                                // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverForwardTraceRange;                            // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverUpperTraceRange;                              // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverSideTracesRange;                              // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverLeanTracesRange;                              // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CoverLeanTracesIterations;                         // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverTraceHorizontalShift;                         // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverTraceVerticalShift;                           // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCoverWidth;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApproachTransitionMinPlayRate;                     // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApproachTransitionMaxPlayRate;                     // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutoCoverState                               CoverState;                                        // 0x006C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x006D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadHeightStand;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadHeightCrouch;                                  // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadHeightLowCrouch;                               // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickInterval;                                      // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedTime;                                   // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceDirectionBindedToCamera;                     // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerAutoCoverData) == 0x000008, "Wrong alignment on FAnimPlayerAutoCoverData");
static_assert(sizeof(FAnimPlayerAutoCoverData) == 0x000088, "Wrong size on FAnimPlayerAutoCoverData");
static_assert(offsetof(FAnimPlayerAutoCoverData, bFrontTraceBlocked) == 0x000000, "Member 'FAnimPlayerAutoCoverData::bFrontTraceBlocked' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, bRightTraceBlocked) == 0x000001, "Member 'FAnimPlayerAutoCoverData::bRightTraceBlocked' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, bLeftTraceBlocked) == 0x000002, "Member 'FAnimPlayerAutoCoverData::bLeftTraceBlocked' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, bUpTraceBlocked) == 0x000003, "Member 'FAnimPlayerAutoCoverData::bUpTraceBlocked' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, CapturedSideTraceStart) == 0x000008, "Member 'FAnimPlayerAutoCoverData::CapturedSideTraceStart' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, bCanCaptureSideTrace) == 0x000020, "Member 'FAnimPlayerAutoCoverData::bCanCaptureSideTrace' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, bInCover) == 0x000021, "Member 'FAnimPlayerAutoCoverData::bInCover' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, bAutoCoverActionActive) == 0x000022, "Member 'FAnimPlayerAutoCoverData::bAutoCoverActionActive' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, AimLeanTime) == 0x000024, "Member 'FAnimPlayerAutoCoverData::AimLeanTime' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, ApproachTransitionPlayRate) == 0x000028, "Member 'FAnimPlayerAutoCoverData::ApproachTransitionPlayRate' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, LeaningAlpha) == 0x00002C, "Member 'FAnimPlayerAutoCoverData::LeaningAlpha' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, LeaningRightAlpha) == 0x000030, "Member 'FAnimPlayerAutoCoverData::LeaningRightAlpha' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, LeaningLeftAlpha) == 0x000034, "Member 'FAnimPlayerAutoCoverData::LeaningLeftAlpha' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, bCanChangeLeanSide) == 0x000038, "Member 'FAnimPlayerAutoCoverData::bCanChangeLeanSide' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, bCoverlessLeaning) == 0x000039, "Member 'FAnimPlayerAutoCoverData::bCoverlessLeaning' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, bCoverlessLeaningRight) == 0x00003A, "Member 'FAnimPlayerAutoCoverData::bCoverlessLeaningRight' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, MinRangeDistanceToCover) == 0x00003C, "Member 'FAnimPlayerAutoCoverData::MinRangeDistanceToCover' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, TraceCapsuleRadius) == 0x000040, "Member 'FAnimPlayerAutoCoverData::TraceCapsuleRadius' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, CoverForwardTraceRange) == 0x000044, "Member 'FAnimPlayerAutoCoverData::CoverForwardTraceRange' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, CoverUpperTraceRange) == 0x000048, "Member 'FAnimPlayerAutoCoverData::CoverUpperTraceRange' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, CoverSideTracesRange) == 0x00004C, "Member 'FAnimPlayerAutoCoverData::CoverSideTracesRange' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, CoverLeanTracesRange) == 0x000050, "Member 'FAnimPlayerAutoCoverData::CoverLeanTracesRange' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, CoverLeanTracesIterations) == 0x000054, "Member 'FAnimPlayerAutoCoverData::CoverLeanTracesIterations' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, CoverTraceHorizontalShift) == 0x000058, "Member 'FAnimPlayerAutoCoverData::CoverTraceHorizontalShift' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, CoverTraceVerticalShift) == 0x00005C, "Member 'FAnimPlayerAutoCoverData::CoverTraceVerticalShift' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, MinCoverWidth) == 0x000060, "Member 'FAnimPlayerAutoCoverData::MinCoverWidth' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, ApproachTransitionMinPlayRate) == 0x000064, "Member 'FAnimPlayerAutoCoverData::ApproachTransitionMinPlayRate' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, ApproachTransitionMaxPlayRate) == 0x000068, "Member 'FAnimPlayerAutoCoverData::ApproachTransitionMaxPlayRate' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, CoverState) == 0x00006C, "Member 'FAnimPlayerAutoCoverData::CoverState' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, TraceChannel) == 0x00006D, "Member 'FAnimPlayerAutoCoverData::TraceChannel' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, HeadHeightStand) == 0x000070, "Member 'FAnimPlayerAutoCoverData::HeadHeightStand' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, HeadHeightCrouch) == 0x000074, "Member 'FAnimPlayerAutoCoverData::HeadHeightCrouch' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, HeadHeightLowCrouch) == 0x000078, "Member 'FAnimPlayerAutoCoverData::HeadHeightLowCrouch' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, TickInterval) == 0x00007C, "Member 'FAnimPlayerAutoCoverData::TickInterval' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, AccumulatedTime) == 0x000080, "Member 'FAnimPlayerAutoCoverData::AccumulatedTime' has a wrong offset!");
static_assert(offsetof(FAnimPlayerAutoCoverData, bTraceDirectionBindedToCamera) == 0x000084, "Member 'FAnimPlayerAutoCoverData::bTraceDirectionBindedToCamera' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerCameraData
// 0x0090 (0x0090 - 0x0000)
struct FAnimPlayerCameraData final
{
public:
	struct FTransform                             TargetCameraTransform;                             // 0x0000(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTransformAlpha;                              // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectorCameraShakeAlpha;                          // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampedControlPitch;                               // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x24];                                      // 0x006C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerCameraData) == 0x000010, "Wrong alignment on FAnimPlayerCameraData");
static_assert(sizeof(FAnimPlayerCameraData) == 0x000090, "Wrong size on FAnimPlayerCameraData");
static_assert(offsetof(FAnimPlayerCameraData, TargetCameraTransform) == 0x000000, "Member 'FAnimPlayerCameraData::TargetCameraTransform' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCameraData, CameraTransformAlpha) == 0x000060, "Member 'FAnimPlayerCameraData::CameraTransformAlpha' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCameraData, DetectorCameraShakeAlpha) == 0x000064, "Member 'FAnimPlayerCameraData::DetectorCameraShakeAlpha' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCameraData, ClampedControlPitch) == 0x000068, "Member 'FAnimPlayerCameraData::ClampedControlPitch' has a wrong offset!");

// ScriptStruct Stalker2.MaterialScalarDrivingProperties
// 0x0028 (0x0028 - 0x0000)
struct FMaterialScalarDrivingProperties final
{
public:
	class UMaterialParameterCollection*           MaterialCollectionToUpdate;                        // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTime;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetValue;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialScalarDrivingProperties) == 0x000008, "Wrong alignment on FMaterialScalarDrivingProperties");
static_assert(sizeof(FMaterialScalarDrivingProperties) == 0x000028, "Wrong size on FMaterialScalarDrivingProperties");
static_assert(offsetof(FMaterialScalarDrivingProperties, MaterialCollectionToUpdate) == 0x000000, "Member 'FMaterialScalarDrivingProperties::MaterialCollectionToUpdate' has a wrong offset!");
static_assert(offsetof(FMaterialScalarDrivingProperties, ParameterName) == 0x000008, "Member 'FMaterialScalarDrivingProperties::ParameterName' has a wrong offset!");
static_assert(offsetof(FMaterialScalarDrivingProperties, InterpolationTime) == 0x000010, "Member 'FMaterialScalarDrivingProperties::InterpolationTime' has a wrong offset!");
static_assert(offsetof(FMaterialScalarDrivingProperties, TargetValue) == 0x000014, "Member 'FMaterialScalarDrivingProperties::TargetValue' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerClimbingData
// 0x0120 (0x0120 - 0x0000)
struct FAnimPlayerClimbingData final
{
public:
	bool                                          bAnimClimbStarted;                                 // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimClimbState                               AnimClimbState;                                    // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbSpeed;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraYaw;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitch;                                       // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLongIdleEnable;                                   // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpingOffLadderState;                            // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpingOffLadderBottomState;                      // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELadderType                                   LadderType;                                        // 0x0013(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BottomOffset;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ELadderType, float>                      FrontOffset;                                       // 0x0018(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         SingleStepHeight;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFocusOnExitTime;                             // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFocusOnExitInterpSpeed;                      // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            EnterTransitionCurve;                              // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToStartLongIdle;                               // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x9C];                                      // 0x0084(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerClimbingData) == 0x000008, "Wrong alignment on FAnimPlayerClimbingData");
static_assert(sizeof(FAnimPlayerClimbingData) == 0x000120, "Wrong size on FAnimPlayerClimbingData");
static_assert(offsetof(FAnimPlayerClimbingData, bAnimClimbStarted) == 0x000000, "Member 'FAnimPlayerClimbingData::bAnimClimbStarted' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, AnimClimbState) == 0x000001, "Member 'FAnimPlayerClimbingData::AnimClimbState' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, ClimbSpeed) == 0x000004, "Member 'FAnimPlayerClimbingData::ClimbSpeed' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, CameraYaw) == 0x000008, "Member 'FAnimPlayerClimbingData::CameraYaw' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, CameraPitch) == 0x00000C, "Member 'FAnimPlayerClimbingData::CameraPitch' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, bLongIdleEnable) == 0x000010, "Member 'FAnimPlayerClimbingData::bLongIdleEnable' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, bJumpingOffLadderState) == 0x000011, "Member 'FAnimPlayerClimbingData::bJumpingOffLadderState' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, bJumpingOffLadderBottomState) == 0x000012, "Member 'FAnimPlayerClimbingData::bJumpingOffLadderBottomState' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, LadderType) == 0x000013, "Member 'FAnimPlayerClimbingData::LadderType' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, BottomOffset) == 0x000014, "Member 'FAnimPlayerClimbingData::BottomOffset' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, FrontOffset) == 0x000018, "Member 'FAnimPlayerClimbingData::FrontOffset' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, SingleStepHeight) == 0x000068, "Member 'FAnimPlayerClimbingData::SingleStepHeight' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, CameraFocusOnExitTime) == 0x00006C, "Member 'FAnimPlayerClimbingData::CameraFocusOnExitTime' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, CameraFocusOnExitInterpSpeed) == 0x000070, "Member 'FAnimPlayerClimbingData::CameraFocusOnExitInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, EnterTransitionCurve) == 0x000078, "Member 'FAnimPlayerClimbingData::EnterTransitionCurve' has a wrong offset!");
static_assert(offsetof(FAnimPlayerClimbingData, TimeToStartLongIdle) == 0x000080, "Member 'FAnimPlayerClimbingData::TimeToStartLongIdle' has a wrong offset!");

// ScriptStruct Stalker2.PlayerLocomotionAnimations
// 0x0128 (0x0128 - 0x0000)
struct FPlayerLocomotionAnimations final
{
public:
	class UAnimSequence*                          StandIdleInHip;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchIdleInHip;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LowCrouchIdleInHip;                                // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransitionAnimations                  StandToCrouch;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransitionAnimations                  CrouchToLowCrouch;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransitionAnimations                  StandToLowCrouch;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Sprint;                                            // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            SprintWithDetector;                                // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Run;                                               // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            RunWithDetector;                                   // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            RunCombat;                                         // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Walk;                                              // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            WalkWithDetector;                                  // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            WalkAim;                                           // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            WalkLimp;                                          // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Crouch;                                            // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CrouchAim;                                         // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            LowCrouch;                                         // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            LowCrouchAim;                                      // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            WalkStart;                                         // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            WalkStop;                                          // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            RunStart;                                          // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            RunStop;                                           // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            RunToSprint;                                       // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            SprintStop;                                        // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SprintToRun;                                       // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandTurnInPlace;                                  // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchTurnInPlace;                                 // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpStart;                                         // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpLoop;                                          // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpEnd;                                           // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpStartLowCrouch;                                // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpLoopLowCrouch;                                 // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpEndLowCrouch;                                  // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerLocomotionAnimations) == 0x000008, "Wrong alignment on FPlayerLocomotionAnimations");
static_assert(sizeof(FPlayerLocomotionAnimations) == 0x000128, "Wrong size on FPlayerLocomotionAnimations");
static_assert(offsetof(FPlayerLocomotionAnimations, StandIdleInHip) == 0x000000, "Member 'FPlayerLocomotionAnimations::StandIdleInHip' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, CrouchIdleInHip) == 0x000008, "Member 'FPlayerLocomotionAnimations::CrouchIdleInHip' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, LowCrouchIdleInHip) == 0x000010, "Member 'FPlayerLocomotionAnimations::LowCrouchIdleInHip' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, StandToCrouch) == 0x000018, "Member 'FPlayerLocomotionAnimations::StandToCrouch' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, CrouchToLowCrouch) == 0x000028, "Member 'FPlayerLocomotionAnimations::CrouchToLowCrouch' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, StandToLowCrouch) == 0x000038, "Member 'FPlayerLocomotionAnimations::StandToLowCrouch' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, Sprint) == 0x000048, "Member 'FPlayerLocomotionAnimations::Sprint' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, SprintWithDetector) == 0x000050, "Member 'FPlayerLocomotionAnimations::SprintWithDetector' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, Run) == 0x000058, "Member 'FPlayerLocomotionAnimations::Run' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, RunWithDetector) == 0x000060, "Member 'FPlayerLocomotionAnimations::RunWithDetector' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, RunCombat) == 0x000068, "Member 'FPlayerLocomotionAnimations::RunCombat' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, Walk) == 0x000070, "Member 'FPlayerLocomotionAnimations::Walk' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, WalkWithDetector) == 0x000078, "Member 'FPlayerLocomotionAnimations::WalkWithDetector' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, WalkAim) == 0x000080, "Member 'FPlayerLocomotionAnimations::WalkAim' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, WalkLimp) == 0x000088, "Member 'FPlayerLocomotionAnimations::WalkLimp' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, Crouch) == 0x000090, "Member 'FPlayerLocomotionAnimations::Crouch' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, CrouchAim) == 0x000098, "Member 'FPlayerLocomotionAnimations::CrouchAim' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, LowCrouch) == 0x0000A0, "Member 'FPlayerLocomotionAnimations::LowCrouch' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, LowCrouchAim) == 0x0000A8, "Member 'FPlayerLocomotionAnimations::LowCrouchAim' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, WalkStart) == 0x0000B0, "Member 'FPlayerLocomotionAnimations::WalkStart' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, WalkStop) == 0x0000B8, "Member 'FPlayerLocomotionAnimations::WalkStop' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, RunStart) == 0x0000C0, "Member 'FPlayerLocomotionAnimations::RunStart' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, RunStop) == 0x0000C8, "Member 'FPlayerLocomotionAnimations::RunStop' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, RunToSprint) == 0x0000D0, "Member 'FPlayerLocomotionAnimations::RunToSprint' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, SprintStop) == 0x0000D8, "Member 'FPlayerLocomotionAnimations::SprintStop' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, SprintToRun) == 0x0000E0, "Member 'FPlayerLocomotionAnimations::SprintToRun' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, StandTurnInPlace) == 0x0000E8, "Member 'FPlayerLocomotionAnimations::StandTurnInPlace' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, CrouchTurnInPlace) == 0x0000F0, "Member 'FPlayerLocomotionAnimations::CrouchTurnInPlace' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, JumpStart) == 0x0000F8, "Member 'FPlayerLocomotionAnimations::JumpStart' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, JumpLoop) == 0x000100, "Member 'FPlayerLocomotionAnimations::JumpLoop' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, JumpEnd) == 0x000108, "Member 'FPlayerLocomotionAnimations::JumpEnd' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, JumpStartLowCrouch) == 0x000110, "Member 'FPlayerLocomotionAnimations::JumpStartLowCrouch' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, JumpLoopLowCrouch) == 0x000118, "Member 'FPlayerLocomotionAnimations::JumpLoopLowCrouch' has a wrong offset!");
static_assert(offsetof(FPlayerLocomotionAnimations, JumpEndLowCrouch) == 0x000120, "Member 'FPlayerLocomotionAnimations::JumpEndLowCrouch' has a wrong offset!");

// ScriptStruct Stalker2.PlayerLeansAnimations
// 0x0020 (0x0020 - 0x0000)
struct FPlayerLeansAnimations final
{
public:
	class UAnimSequence*                          LeanLeftIn;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LeanLeftOut;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LeanRightIn;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LeanRightOut;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerLeansAnimations) == 0x000008, "Wrong alignment on FPlayerLeansAnimations");
static_assert(sizeof(FPlayerLeansAnimations) == 0x000020, "Wrong size on FPlayerLeansAnimations");
static_assert(offsetof(FPlayerLeansAnimations, LeanLeftIn) == 0x000000, "Member 'FPlayerLeansAnimations::LeanLeftIn' has a wrong offset!");
static_assert(offsetof(FPlayerLeansAnimations, LeanLeftOut) == 0x000008, "Member 'FPlayerLeansAnimations::LeanLeftOut' has a wrong offset!");
static_assert(offsetof(FPlayerLeansAnimations, LeanRightIn) == 0x000010, "Member 'FPlayerLeansAnimations::LeanRightIn' has a wrong offset!");
static_assert(offsetof(FPlayerLeansAnimations, LeanRightOut) == 0x000018, "Member 'FPlayerLeansAnimations::LeanRightOut' has a wrong offset!");

// ScriptStruct Stalker2.PlayerExternalAnimations
// 0x0278 (0x0278 - 0x0000)
struct FPlayerExternalAnimations final
{
public:
	struct FPlayerLocomotionAnimations            UpperBody;                                         // 0x0000(0x0128)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlayerLocomotionAnimations            LowerBody;                                         // 0x0128(0x0128)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LookVertical;                                      // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerLeansAnimations                 Leans;                                             // 0x0258(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerExternalAnimations) == 0x000008, "Wrong alignment on FPlayerExternalAnimations");
static_assert(sizeof(FPlayerExternalAnimations) == 0x000278, "Wrong size on FPlayerExternalAnimations");
static_assert(offsetof(FPlayerExternalAnimations, UpperBody) == 0x000000, "Member 'FPlayerExternalAnimations::UpperBody' has a wrong offset!");
static_assert(offsetof(FPlayerExternalAnimations, LowerBody) == 0x000128, "Member 'FPlayerExternalAnimations::LowerBody' has a wrong offset!");
static_assert(offsetof(FPlayerExternalAnimations, LookVertical) == 0x000250, "Member 'FPlayerExternalAnimations::LookVertical' has a wrong offset!");
static_assert(offsetof(FPlayerExternalAnimations, Leans) == 0x000258, "Member 'FPlayerExternalAnimations::Leans' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerCollectionsData
// 0x0328 (0x0328 - 0x0000)
struct FAnimPlayerCollectionsData final
{
public:
	class UPlayerDefaultAnimCollection*           DefaultAnimCollection;                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerDefaultAnimCollection*           DragDeadBodyAnimCollection;                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerAnimCollection*                  AnimCollection;                                    // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerFirearmAnimCollection*           FirearmAnimCollection;                             // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerThrowableItemAnimCollection*     ThrowableAnimCollection;                           // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerKnifeAnimCollection*             KnifeAnimCollection;                               // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAnimCollection*                    ItemAnimCollection;                                // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableAnimCollection*            ItemInteractableAnimCollection;                    // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachAnimCollection*            AttachAnimCollection;                              // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerDetectorAnimCollection*          DetectorAnimCollection;                            // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerExternalAnimations              ExternalAnimations;                                // 0x0050(0x0278)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bWeaponSubgraphToggle;                             // 0x02C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponSubgraphBlend;                               // 0x02CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdditionalSubgraphToggle;                         // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalSubgraphBlend;                           // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ESubgraphBlendTypes, float>              SubgraphDefaultBlendTime;                          // 0x02D8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimPlayerCollectionsData) == 0x000008, "Wrong alignment on FAnimPlayerCollectionsData");
static_assert(sizeof(FAnimPlayerCollectionsData) == 0x000328, "Wrong size on FAnimPlayerCollectionsData");
static_assert(offsetof(FAnimPlayerCollectionsData, DefaultAnimCollection) == 0x000000, "Member 'FAnimPlayerCollectionsData::DefaultAnimCollection' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, DragDeadBodyAnimCollection) == 0x000008, "Member 'FAnimPlayerCollectionsData::DragDeadBodyAnimCollection' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, AnimCollection) == 0x000010, "Member 'FAnimPlayerCollectionsData::AnimCollection' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, FirearmAnimCollection) == 0x000018, "Member 'FAnimPlayerCollectionsData::FirearmAnimCollection' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, ThrowableAnimCollection) == 0x000020, "Member 'FAnimPlayerCollectionsData::ThrowableAnimCollection' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, KnifeAnimCollection) == 0x000028, "Member 'FAnimPlayerCollectionsData::KnifeAnimCollection' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, ItemAnimCollection) == 0x000030, "Member 'FAnimPlayerCollectionsData::ItemAnimCollection' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, ItemInteractableAnimCollection) == 0x000038, "Member 'FAnimPlayerCollectionsData::ItemInteractableAnimCollection' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, AttachAnimCollection) == 0x000040, "Member 'FAnimPlayerCollectionsData::AttachAnimCollection' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, DetectorAnimCollection) == 0x000048, "Member 'FAnimPlayerCollectionsData::DetectorAnimCollection' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, ExternalAnimations) == 0x000050, "Member 'FAnimPlayerCollectionsData::ExternalAnimations' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, bWeaponSubgraphToggle) == 0x0002C8, "Member 'FAnimPlayerCollectionsData::bWeaponSubgraphToggle' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, WeaponSubgraphBlend) == 0x0002CC, "Member 'FAnimPlayerCollectionsData::WeaponSubgraphBlend' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, bAdditionalSubgraphToggle) == 0x0002D0, "Member 'FAnimPlayerCollectionsData::bAdditionalSubgraphToggle' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, AdditionalSubgraphBlend) == 0x0002D4, "Member 'FAnimPlayerCollectionsData::AdditionalSubgraphBlend' has a wrong offset!");
static_assert(offsetof(FAnimPlayerCollectionsData, SubgraphDefaultBlendTime) == 0x0002D8, "Member 'FAnimPlayerCollectionsData::SubgraphDefaultBlendTime' has a wrong offset!");

// ScriptStruct Stalker2.InspectArtifactAnimations
// 0x0010 (0x0010 - 0x0000)
struct FInspectArtifactAnimations final
{
public:
	class UAnimMontage*                           InspectArtifact;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           InspectArtifactWithBackpack;                       // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInspectArtifactAnimations) == 0x000008, "Wrong alignment on FInspectArtifactAnimations");
static_assert(sizeof(FInspectArtifactAnimations) == 0x000010, "Wrong size on FInspectArtifactAnimations");
static_assert(offsetof(FInspectArtifactAnimations, InspectArtifact) == 0x000000, "Member 'FInspectArtifactAnimations::InspectArtifact' has a wrong offset!");
static_assert(offsetof(FInspectArtifactAnimations, InspectArtifactWithBackpack) == 0x000008, "Member 'FInspectArtifactAnimations::InspectArtifactWithBackpack' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerDetectorData
// 0x0128 (0x0128 - 0x0000)
struct FAnimPlayerDetectorData final
{
public:
	bool                                          bHasDetectorInHands;                               // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 DetectorSkeletal;                                  // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimPlayerWeaponSwingData             SwingData;                                         // 0x0010(0x0080)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimPlayerWeaponInertiaData           InertiaData;                                       // 0x0090(0x0098)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimPlayerDetectorData) == 0x000008, "Wrong alignment on FAnimPlayerDetectorData");
static_assert(sizeof(FAnimPlayerDetectorData) == 0x000128, "Wrong size on FAnimPlayerDetectorData");
static_assert(offsetof(FAnimPlayerDetectorData, bHasDetectorInHands) == 0x000000, "Member 'FAnimPlayerDetectorData::bHasDetectorInHands' has a wrong offset!");
static_assert(offsetof(FAnimPlayerDetectorData, DetectorSkeletal) == 0x000008, "Member 'FAnimPlayerDetectorData::DetectorSkeletal' has a wrong offset!");
static_assert(offsetof(FAnimPlayerDetectorData, SwingData) == 0x000010, "Member 'FAnimPlayerDetectorData::SwingData' has a wrong offset!");
static_assert(offsetof(FAnimPlayerDetectorData, InertiaData) == 0x000090, "Member 'FAnimPlayerDetectorData::InertiaData' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerDialogData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FAnimPlayerDialogData final
{
public:
	bool                                          bInDialog;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerDialogData) == 0x000004, "Wrong alignment on FAnimPlayerDialogData");
static_assert(sizeof(FAnimPlayerDialogData) == 0x000008, "Wrong size on FAnimPlayerDialogData");
static_assert(offsetof(FAnimPlayerDialogData, bInDialog) == 0x000000, "Member 'FAnimPlayerDialogData::bInDialog' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerDodgeData
// 0x0068 (0x0068 - 0x0000)
struct FAnimPlayerDodgeData final
{
public:
	TSet<class AObj*>                             CollidedObjects;                                   // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerDodgeData) == 0x000008, "Wrong alignment on FAnimPlayerDodgeData");
static_assert(sizeof(FAnimPlayerDodgeData) == 0x000068, "Wrong size on FAnimPlayerDodgeData");
static_assert(offsetof(FAnimPlayerDodgeData, CollidedObjects) == 0x000000, "Member 'FAnimPlayerDodgeData::CollidedObjects' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerGuitarData
// 0x0024 (0x0024 - 0x0000)
struct FAnimPlayerGuitarData final
{
public:
	float                                         CameraPitchLimit;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraYawLimit;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraResetInterpSpeed;                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentChord;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimGuitarState                              AnimGuitarState;                                   // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimGuitarRightHandState                     RightHandState;                                    // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayingGuitar;                                    // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayFromContextual;                               // 0x0013(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMajorScale;                                     // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldExitGuitar;                                 // 0x0015(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoStrumMode;                                    // 0x0016(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraYaw;                                         // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitch;                                       // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x4];                                       // 0x0020(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerGuitarData) == 0x000004, "Wrong alignment on FAnimPlayerGuitarData");
static_assert(sizeof(FAnimPlayerGuitarData) == 0x000024, "Wrong size on FAnimPlayerGuitarData");
static_assert(offsetof(FAnimPlayerGuitarData, CameraPitchLimit) == 0x000000, "Member 'FAnimPlayerGuitarData::CameraPitchLimit' has a wrong offset!");
static_assert(offsetof(FAnimPlayerGuitarData, CameraYawLimit) == 0x000004, "Member 'FAnimPlayerGuitarData::CameraYawLimit' has a wrong offset!");
static_assert(offsetof(FAnimPlayerGuitarData, CameraResetInterpSpeed) == 0x000008, "Member 'FAnimPlayerGuitarData::CameraResetInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimPlayerGuitarData, CurrentChord) == 0x00000C, "Member 'FAnimPlayerGuitarData::CurrentChord' has a wrong offset!");
static_assert(offsetof(FAnimPlayerGuitarData, AnimGuitarState) == 0x000010, "Member 'FAnimPlayerGuitarData::AnimGuitarState' has a wrong offset!");
static_assert(offsetof(FAnimPlayerGuitarData, RightHandState) == 0x000011, "Member 'FAnimPlayerGuitarData::RightHandState' has a wrong offset!");
static_assert(offsetof(FAnimPlayerGuitarData, bPlayingGuitar) == 0x000012, "Member 'FAnimPlayerGuitarData::bPlayingGuitar' has a wrong offset!");
static_assert(offsetof(FAnimPlayerGuitarData, bPlayFromContextual) == 0x000013, "Member 'FAnimPlayerGuitarData::bPlayFromContextual' has a wrong offset!");
static_assert(offsetof(FAnimPlayerGuitarData, bIsMajorScale) == 0x000014, "Member 'FAnimPlayerGuitarData::bIsMajorScale' has a wrong offset!");
static_assert(offsetof(FAnimPlayerGuitarData, bShouldExitGuitar) == 0x000015, "Member 'FAnimPlayerGuitarData::bShouldExitGuitar' has a wrong offset!");
static_assert(offsetof(FAnimPlayerGuitarData, bAutoStrumMode) == 0x000016, "Member 'FAnimPlayerGuitarData::bAutoStrumMode' has a wrong offset!");
static_assert(offsetof(FAnimPlayerGuitarData, CameraYaw) == 0x000018, "Member 'FAnimPlayerGuitarData::CameraYaw' has a wrong offset!");
static_assert(offsetof(FAnimPlayerGuitarData, CameraPitch) == 0x00001C, "Member 'FAnimPlayerGuitarData::CameraPitch' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerHitData
// 0x0080 (0x0080 - 0x0000)
struct FAnimPlayerHitData final
{
public:
	class UAnimSequence*                          DeathSequence;                                     // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathCameraDistance;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitDirection;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerAnimDamageSource                       DeathDamageSource;                                 // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimDirections                               HitAnimDirection;                                  // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDeathAnimationType                           DeathAnimationType;                                // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiedLyingDown;                                    // 0x002B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDeathAnimationEnded;                            // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKnockedDown;                                      // 0x002D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               KnockDownRotation;                                 // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            KnockDownRotateCurve;                              // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x30];                                      // 0x0050(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerHitData) == 0x000008, "Wrong alignment on FAnimPlayerHitData");
static_assert(sizeof(FAnimPlayerHitData) == 0x000080, "Wrong size on FAnimPlayerHitData");
static_assert(offsetof(FAnimPlayerHitData, DeathSequence) == 0x000000, "Member 'FAnimPlayerHitData::DeathSequence' has a wrong offset!");
static_assert(offsetof(FAnimPlayerHitData, DeathCameraDistance) == 0x000008, "Member 'FAnimPlayerHitData::DeathCameraDistance' has a wrong offset!");
static_assert(offsetof(FAnimPlayerHitData, HitDirection) == 0x00000C, "Member 'FAnimPlayerHitData::HitDirection' has a wrong offset!");
static_assert(offsetof(FAnimPlayerHitData, HitLocation) == 0x000010, "Member 'FAnimPlayerHitData::HitLocation' has a wrong offset!");
static_assert(offsetof(FAnimPlayerHitData, DeathDamageSource) == 0x000028, "Member 'FAnimPlayerHitData::DeathDamageSource' has a wrong offset!");
static_assert(offsetof(FAnimPlayerHitData, HitAnimDirection) == 0x000029, "Member 'FAnimPlayerHitData::HitAnimDirection' has a wrong offset!");
static_assert(offsetof(FAnimPlayerHitData, DeathAnimationType) == 0x00002A, "Member 'FAnimPlayerHitData::DeathAnimationType' has a wrong offset!");
static_assert(offsetof(FAnimPlayerHitData, bDiedLyingDown) == 0x00002B, "Member 'FAnimPlayerHitData::bDiedLyingDown' has a wrong offset!");
static_assert(offsetof(FAnimPlayerHitData, bIsDeathAnimationEnded) == 0x00002C, "Member 'FAnimPlayerHitData::bIsDeathAnimationEnded' has a wrong offset!");
static_assert(offsetof(FAnimPlayerHitData, bKnockedDown) == 0x00002D, "Member 'FAnimPlayerHitData::bKnockedDown' has a wrong offset!");
static_assert(offsetof(FAnimPlayerHitData, KnockDownRotation) == 0x000030, "Member 'FAnimPlayerHitData::KnockDownRotation' has a wrong offset!");
static_assert(offsetof(FAnimPlayerHitData, KnockDownRotateCurve) == 0x000048, "Member 'FAnimPlayerHitData::KnockDownRotateCurve' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerIdleSwayData
// 0x00F0 (0x00F0 - 0x0000)
struct FAnimPlayerIdleSwayData final
{
public:
	class UCurveVector*                           BaseCurve;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           StaminaAmplitudeCurve;                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StaminaCycleTimeCurve;                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDelay;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandCycleTimeModifier;                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandAmplitudeXModifier;                           // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandAmplitudeYModifier;                           // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchCycleTimeModifier;                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchAmplitudeXModifier;                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchAmplitudeYModifier;                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveCycleTimeModifier;                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveAmplitudeXModifier;                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveAmplitudeYModifier;                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           ActiveCurve;                                       // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x84];                                      // 0x006C(0x0084)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerIdleSwayData) == 0x000008, "Wrong alignment on FAnimPlayerIdleSwayData");
static_assert(sizeof(FAnimPlayerIdleSwayData) == 0x0000F0, "Wrong size on FAnimPlayerIdleSwayData");
static_assert(offsetof(FAnimPlayerIdleSwayData, BaseCurve) == 0x000000, "Member 'FAnimPlayerIdleSwayData::BaseCurve' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, StaminaAmplitudeCurve) == 0x000008, "Member 'FAnimPlayerIdleSwayData::StaminaAmplitudeCurve' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, StaminaCycleTimeCurve) == 0x000010, "Member 'FAnimPlayerIdleSwayData::StaminaCycleTimeCurve' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, InitialDelay) == 0x000018, "Member 'FAnimPlayerIdleSwayData::InitialDelay' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, StandCycleTimeModifier) == 0x00001C, "Member 'FAnimPlayerIdleSwayData::StandCycleTimeModifier' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, StandAmplitudeXModifier) == 0x000020, "Member 'FAnimPlayerIdleSwayData::StandAmplitudeXModifier' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, StandAmplitudeYModifier) == 0x000024, "Member 'FAnimPlayerIdleSwayData::StandAmplitudeYModifier' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, CrouchCycleTimeModifier) == 0x000028, "Member 'FAnimPlayerIdleSwayData::CrouchCycleTimeModifier' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, CrouchAmplitudeXModifier) == 0x00002C, "Member 'FAnimPlayerIdleSwayData::CrouchAmplitudeXModifier' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, CrouchAmplitudeYModifier) == 0x000030, "Member 'FAnimPlayerIdleSwayData::CrouchAmplitudeYModifier' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, MoveCycleTimeModifier) == 0x000034, "Member 'FAnimPlayerIdleSwayData::MoveCycleTimeModifier' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, MoveAmplitudeXModifier) == 0x000038, "Member 'FAnimPlayerIdleSwayData::MoveAmplitudeXModifier' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, MoveAmplitudeYModifier) == 0x00003C, "Member 'FAnimPlayerIdleSwayData::MoveAmplitudeYModifier' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, Rotation) == 0x000040, "Member 'FAnimPlayerIdleSwayData::Rotation' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, Alpha) == 0x000058, "Member 'FAnimPlayerIdleSwayData::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, ActiveCurve) == 0x000060, "Member 'FAnimPlayerIdleSwayData::ActiveCurve' has a wrong offset!");
static_assert(offsetof(FAnimPlayerIdleSwayData, InterpSpeed) == 0x000068, "Member 'FAnimPlayerIdleSwayData::InterpSpeed' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerMaterialData
// 0x0008 (0x0008 - 0x0000)
struct FAnimPlayerMaterialData final
{
public:
	class UMaterialParameterCollection*           FoliageCollectionAsset;                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimPlayerMaterialData) == 0x000008, "Wrong alignment on FAnimPlayerMaterialData");
static_assert(sizeof(FAnimPlayerMaterialData) == 0x000008, "Wrong size on FAnimPlayerMaterialData");
static_assert(offsetof(FAnimPlayerMaterialData, FoliageCollectionAsset) == 0x000000, "Member 'FAnimPlayerMaterialData::FoliageCollectionAsset' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerShadowData
// 0x0030 (0x0030 - 0x0000)
struct FAnimPlayerShadowData final
{
public:
	TArray<struct FSnapshotMapping>               SnapshotMapping;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasWeaponInHands;                                 // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAiming;                                           // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUseBHLocomotion;                            // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngleDirection;                                    // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnTime;                                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovementPlayRateStructure             MovementPlayRate;                                  // 0x001C(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimPlayerShadowData) == 0x000008, "Wrong alignment on FAnimPlayerShadowData");
static_assert(sizeof(FAnimPlayerShadowData) == 0x000030, "Wrong size on FAnimPlayerShadowData");
static_assert(offsetof(FAnimPlayerShadowData, SnapshotMapping) == 0x000000, "Member 'FAnimPlayerShadowData::SnapshotMapping' has a wrong offset!");
static_assert(offsetof(FAnimPlayerShadowData, bHasWeaponInHands) == 0x000010, "Member 'FAnimPlayerShadowData::bHasWeaponInHands' has a wrong offset!");
static_assert(offsetof(FAnimPlayerShadowData, bAiming) == 0x000011, "Member 'FAnimPlayerShadowData::bAiming' has a wrong offset!");
static_assert(offsetof(FAnimPlayerShadowData, bShouldUseBHLocomotion) == 0x000012, "Member 'FAnimPlayerShadowData::bShouldUseBHLocomotion' has a wrong offset!");
static_assert(offsetof(FAnimPlayerShadowData, AngleDirection) == 0x000014, "Member 'FAnimPlayerShadowData::AngleDirection' has a wrong offset!");
static_assert(offsetof(FAnimPlayerShadowData, TurnTime) == 0x000018, "Member 'FAnimPlayerShadowData::TurnTime' has a wrong offset!");
static_assert(offsetof(FAnimPlayerShadowData, MovementPlayRate) == 0x00001C, "Member 'FAnimPlayerShadowData::MovementPlayRate' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerStateData
// 0x0037 (0x0040 - 0x0009)
struct FAnimPlayerStateData final : public FAnimStateData
{
public:
	bool                                          bWalkingOverride;                                  // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouching;                                        // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLowCrouching;                                     // 0x000B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClimbing;                                         // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimping;                                          // 0x000D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShootingUnfocusableTarget;                        // 0x000E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDragDeadBody;                                     // 0x000F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeftHandBusy;                                   // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInspectingItem;                                 // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActionSlotActive;                                 // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullBodySlotActive;                               // 0x0013(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouchingOverride;                                // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLowCrouchingOverride;                             // 0x0015(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSprintingOverride;                                // 0x0016(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInAirOverride;                                    // 0x0017(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchingInWaterInterruptionTime;                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintingInWaterInterruptionTime;                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAirInWaterInterruptionTime;                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombatIdleDuration;                                // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCombatMoveIdle;                                   // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCombatCrouchIdle;                                 // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCombatActionActive;                               // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CombatIdleCooldown;                                // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceBindedHandsLookVertical;                     // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasExoskeleton;                                   // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurveGaitValue;                                    // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicGaitValue;                                  // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimationStates                              EnumGaitState;                                     // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerStateData) == 0x000004, "Wrong alignment on FAnimPlayerStateData");
static_assert(sizeof(FAnimPlayerStateData) == 0x000040, "Wrong size on FAnimPlayerStateData");
static_assert(offsetof(FAnimPlayerStateData, bWalkingOverride) == 0x000009, "Member 'FAnimPlayerStateData::bWalkingOverride' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bCrouching) == 0x00000A, "Member 'FAnimPlayerStateData::bCrouching' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bLowCrouching) == 0x00000B, "Member 'FAnimPlayerStateData::bLowCrouching' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bClimbing) == 0x00000C, "Member 'FAnimPlayerStateData::bClimbing' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bLimping) == 0x00000D, "Member 'FAnimPlayerStateData::bLimping' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bShootingUnfocusableTarget) == 0x00000E, "Member 'FAnimPlayerStateData::bShootingUnfocusableTarget' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bDragDeadBody) == 0x00000F, "Member 'FAnimPlayerStateData::bDragDeadBody' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bIsLeftHandBusy) == 0x000010, "Member 'FAnimPlayerStateData::bIsLeftHandBusy' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bIsInspectingItem) == 0x000011, "Member 'FAnimPlayerStateData::bIsInspectingItem' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bActionSlotActive) == 0x000012, "Member 'FAnimPlayerStateData::bActionSlotActive' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bFullBodySlotActive) == 0x000013, "Member 'FAnimPlayerStateData::bFullBodySlotActive' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bCrouchingOverride) == 0x000014, "Member 'FAnimPlayerStateData::bCrouchingOverride' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bLowCrouchingOverride) == 0x000015, "Member 'FAnimPlayerStateData::bLowCrouchingOverride' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bSprintingOverride) == 0x000016, "Member 'FAnimPlayerStateData::bSprintingOverride' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bInAirOverride) == 0x000017, "Member 'FAnimPlayerStateData::bInAirOverride' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, CrouchingInWaterInterruptionTime) == 0x000018, "Member 'FAnimPlayerStateData::CrouchingInWaterInterruptionTime' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, SprintingInWaterInterruptionTime) == 0x00001C, "Member 'FAnimPlayerStateData::SprintingInWaterInterruptionTime' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, InAirInWaterInterruptionTime) == 0x000020, "Member 'FAnimPlayerStateData::InAirInWaterInterruptionTime' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, CombatIdleDuration) == 0x000024, "Member 'FAnimPlayerStateData::CombatIdleDuration' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bCombatMoveIdle) == 0x000028, "Member 'FAnimPlayerStateData::bCombatMoveIdle' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bCombatCrouchIdle) == 0x000029, "Member 'FAnimPlayerStateData::bCombatCrouchIdle' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bCombatActionActive) == 0x00002A, "Member 'FAnimPlayerStateData::bCombatActionActive' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, CombatIdleCooldown) == 0x00002C, "Member 'FAnimPlayerStateData::CombatIdleCooldown' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bForceBindedHandsLookVertical) == 0x000030, "Member 'FAnimPlayerStateData::bForceBindedHandsLookVertical' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, bHasExoskeleton) == 0x000031, "Member 'FAnimPlayerStateData::bHasExoskeleton' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, CurveGaitValue) == 0x000034, "Member 'FAnimPlayerStateData::CurveGaitValue' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, DynamicGaitValue) == 0x000038, "Member 'FAnimPlayerStateData::DynamicGaitValue' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStateData, EnumGaitState) == 0x00003C, "Member 'FAnimPlayerStateData::EnumGaitState' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerVaultingData
// 0x0158 (0x0158 - 0x0000)
struct FAnimPlayerVaultingData final
{
public:
	EVaultState                                   State;                                             // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVaulting;                                       // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnimInProgress;                                 // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVaultingOver;                                   // 0x0003(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVaultingOnTop;                                  // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Sequence;                                          // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultAlpha;                                        // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EMainHandEquipmentType, class UAnimSequence*> VaultingSequences;                            // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EMainHandEquipmentType, class UAnimSequence*> VaultingCrouchedSequences;                    // 0x0068(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EMainHandEquipmentType, class UAnimSequence*> VaultOverSequences;                           // 0x00B8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EMainHandEquipmentType, class UAnimSequence*> VaultOverCrouchedSequences;                   // 0x0108(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimPlayerVaultingData) == 0x000008, "Wrong alignment on FAnimPlayerVaultingData");
static_assert(sizeof(FAnimPlayerVaultingData) == 0x000158, "Wrong size on FAnimPlayerVaultingData");
static_assert(offsetof(FAnimPlayerVaultingData, State) == 0x000000, "Member 'FAnimPlayerVaultingData::State' has a wrong offset!");
static_assert(offsetof(FAnimPlayerVaultingData, bIsVaulting) == 0x000001, "Member 'FAnimPlayerVaultingData::bIsVaulting' has a wrong offset!");
static_assert(offsetof(FAnimPlayerVaultingData, bIsAnimInProgress) == 0x000002, "Member 'FAnimPlayerVaultingData::bIsAnimInProgress' has a wrong offset!");
static_assert(offsetof(FAnimPlayerVaultingData, bIsVaultingOver) == 0x000003, "Member 'FAnimPlayerVaultingData::bIsVaultingOver' has a wrong offset!");
static_assert(offsetof(FAnimPlayerVaultingData, bIsVaultingOnTop) == 0x000004, "Member 'FAnimPlayerVaultingData::bIsVaultingOnTop' has a wrong offset!");
static_assert(offsetof(FAnimPlayerVaultingData, Sequence) == 0x000008, "Member 'FAnimPlayerVaultingData::Sequence' has a wrong offset!");
static_assert(offsetof(FAnimPlayerVaultingData, VaultAlpha) == 0x000010, "Member 'FAnimPlayerVaultingData::VaultAlpha' has a wrong offset!");
static_assert(offsetof(FAnimPlayerVaultingData, VaultingSequences) == 0x000018, "Member 'FAnimPlayerVaultingData::VaultingSequences' has a wrong offset!");
static_assert(offsetof(FAnimPlayerVaultingData, VaultingCrouchedSequences) == 0x000068, "Member 'FAnimPlayerVaultingData::VaultingCrouchedSequences' has a wrong offset!");
static_assert(offsetof(FAnimPlayerVaultingData, VaultOverSequences) == 0x0000B8, "Member 'FAnimPlayerVaultingData::VaultOverSequences' has a wrong offset!");
static_assert(offsetof(FAnimPlayerVaultingData, VaultOverCrouchedSequences) == 0x000108, "Member 'FAnimPlayerVaultingData::VaultOverCrouchedSequences' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerStealthData
// 0x0020 (0x0020 - 0x0000)
struct FAnimPlayerStealthData final
{
public:
	bool                                          bStealth;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StealthInFrame;                                    // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StealthOutFrame;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StealthAlpha;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimationStealthState                        StealthState;                                      // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StealthKillSnapCurve;                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimPlayerStealthData) == 0x000008, "Wrong alignment on FAnimPlayerStealthData");
static_assert(sizeof(FAnimPlayerStealthData) == 0x000020, "Wrong size on FAnimPlayerStealthData");
static_assert(offsetof(FAnimPlayerStealthData, bStealth) == 0x000000, "Member 'FAnimPlayerStealthData::bStealth' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStealthData, StealthInFrame) == 0x000004, "Member 'FAnimPlayerStealthData::StealthInFrame' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStealthData, StealthOutFrame) == 0x000008, "Member 'FAnimPlayerStealthData::StealthOutFrame' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStealthData, StealthAlpha) == 0x00000C, "Member 'FAnimPlayerStealthData::StealthAlpha' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStealthData, StealthState) == 0x000010, "Member 'FAnimPlayerStealthData::StealthState' has a wrong offset!");
static_assert(offsetof(FAnimPlayerStealthData, StealthKillSnapCurve) == 0x000018, "Member 'FAnimPlayerStealthData::StealthKillSnapCurve' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerTransitionData
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x10) FAnimPlayerTransitionData final
{
public:
	bool                                          bHasVelocity;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovingUp;                                         // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovingDown;                                       // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReadyForLanding;                                  // 0x0003(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterSprint;                                   // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LerpToTargetAlpha;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpToTargetTime;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x60];                                      // 0x0010(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerTransitionData) == 0x000010, "Wrong alignment on FAnimPlayerTransitionData");
static_assert(sizeof(FAnimPlayerTransitionData) == 0x000070, "Wrong size on FAnimPlayerTransitionData");
static_assert(offsetof(FAnimPlayerTransitionData, bHasVelocity) == 0x000000, "Member 'FAnimPlayerTransitionData::bHasVelocity' has a wrong offset!");
static_assert(offsetof(FAnimPlayerTransitionData, bMovingUp) == 0x000001, "Member 'FAnimPlayerTransitionData::bMovingUp' has a wrong offset!");
static_assert(offsetof(FAnimPlayerTransitionData, bMovingDown) == 0x000002, "Member 'FAnimPlayerTransitionData::bMovingDown' has a wrong offset!");
static_assert(offsetof(FAnimPlayerTransitionData, bReadyForLanding) == 0x000003, "Member 'FAnimPlayerTransitionData::bReadyForLanding' has a wrong offset!");
static_assert(offsetof(FAnimPlayerTransitionData, bCanEnterSprint) == 0x000004, "Member 'FAnimPlayerTransitionData::bCanEnterSprint' has a wrong offset!");
static_assert(offsetof(FAnimPlayerTransitionData, LerpToTargetAlpha) == 0x000008, "Member 'FAnimPlayerTransitionData::LerpToTargetAlpha' has a wrong offset!");
static_assert(offsetof(FAnimPlayerTransitionData, LerpToTargetTime) == 0x00000C, "Member 'FAnimPlayerTransitionData::LerpToTargetTime' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerUnfocusableTargetData
// 0x0001 (0x0001 - 0x0000)
struct FAnimPlayerUnfocusableTargetData final
{
public:
	bool                                          bTargetingUnfocusable;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimPlayerUnfocusableTargetData) == 0x000001, "Wrong alignment on FAnimPlayerUnfocusableTargetData");
static_assert(sizeof(FAnimPlayerUnfocusableTargetData) == 0x000001, "Wrong size on FAnimPlayerUnfocusableTargetData");
static_assert(offsetof(FAnimPlayerUnfocusableTargetData, bTargetingUnfocusable) == 0x000000, "Member 'FAnimPlayerUnfocusableTargetData::bTargetingUnfocusable' has a wrong offset!");

// ScriptStruct Stalker2.CharacterItemWeightedAnimations
// 0x0018 (0x0018 - 0x0000)
struct FCharacterItemWeightedAnimations final
{
public:
	class UAnimSequence*                          Character;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Item;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterItemWeightedAnimations) == 0x000008, "Wrong alignment on FCharacterItemWeightedAnimations");
static_assert(sizeof(FCharacterItemWeightedAnimations) == 0x000018, "Wrong size on FCharacterItemWeightedAnimations");
static_assert(offsetof(FCharacterItemWeightedAnimations, Character) == 0x000000, "Member 'FCharacterItemWeightedAnimations::Character' has a wrong offset!");
static_assert(offsetof(FCharacterItemWeightedAnimations, Item) == 0x000008, "Member 'FCharacterItemWeightedAnimations::Item' has a wrong offset!");
static_assert(offsetof(FCharacterItemWeightedAnimations, Weight) == 0x000010, "Member 'FCharacterItemWeightedAnimations::Weight' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerBaseWeaponData
// 0x0030 (0x0030 - 0x0000)
struct FAnimPlayerBaseWeaponData final
{
public:
	ELongIdleType                                 LongIdleType;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterItemWeightedAnimations       InactiveIdle;                                      // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InactiveIdleFrame;                                 // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveIdleValue;                                    // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActionSlotActive;                                 // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerBaseWeaponData) == 0x000008, "Wrong alignment on FAnimPlayerBaseWeaponData");
static_assert(sizeof(FAnimPlayerBaseWeaponData) == 0x000030, "Wrong size on FAnimPlayerBaseWeaponData");
static_assert(offsetof(FAnimPlayerBaseWeaponData, LongIdleType) == 0x000000, "Member 'FAnimPlayerBaseWeaponData::LongIdleType' has a wrong offset!");
static_assert(offsetof(FAnimPlayerBaseWeaponData, InactiveIdle) == 0x000008, "Member 'FAnimPlayerBaseWeaponData::InactiveIdle' has a wrong offset!");
static_assert(offsetof(FAnimPlayerBaseWeaponData, InactiveIdleFrame) == 0x000020, "Member 'FAnimPlayerBaseWeaponData::InactiveIdleFrame' has a wrong offset!");
static_assert(offsetof(FAnimPlayerBaseWeaponData, CurveIdleValue) == 0x000024, "Member 'FAnimPlayerBaseWeaponData::CurveIdleValue' has a wrong offset!");
static_assert(offsetof(FAnimPlayerBaseWeaponData, bActionSlotActive) == 0x000028, "Member 'FAnimPlayerBaseWeaponData::bActionSlotActive' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerFirearmData
// 0x001C (0x001C - 0x0000)
struct FAnimPlayerFirearmData final
{
public:
	EWeaponIdleType                               IdleType;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShutterState                                 ShutterState;                                      // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsJammed;                                          // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         JamIdleIndex;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTwinMagazineShifted;                              // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponCustomAdditionalIdle                   AdditionalIdle;                                    // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFireType                                     FireTypes;                                         // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftHandCurveValueInverse;                         // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponLeftHandCurveValueInverse;                   // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandMovementAlpha;                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeftHandIdleUnlocked;                           // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerFirearmData) == 0x000004, "Wrong alignment on FAnimPlayerFirearmData");
static_assert(sizeof(FAnimPlayerFirearmData) == 0x00001C, "Wrong size on FAnimPlayerFirearmData");
static_assert(offsetof(FAnimPlayerFirearmData, IdleType) == 0x000000, "Member 'FAnimPlayerFirearmData::IdleType' has a wrong offset!");
static_assert(offsetof(FAnimPlayerFirearmData, ShutterState) == 0x000001, "Member 'FAnimPlayerFirearmData::ShutterState' has a wrong offset!");
static_assert(offsetof(FAnimPlayerFirearmData, IsJammed) == 0x000002, "Member 'FAnimPlayerFirearmData::IsJammed' has a wrong offset!");
static_assert(offsetof(FAnimPlayerFirearmData, JamIdleIndex) == 0x000004, "Member 'FAnimPlayerFirearmData::JamIdleIndex' has a wrong offset!");
static_assert(offsetof(FAnimPlayerFirearmData, bTwinMagazineShifted) == 0x000008, "Member 'FAnimPlayerFirearmData::bTwinMagazineShifted' has a wrong offset!");
static_assert(offsetof(FAnimPlayerFirearmData, AdditionalIdle) == 0x000009, "Member 'FAnimPlayerFirearmData::AdditionalIdle' has a wrong offset!");
static_assert(offsetof(FAnimPlayerFirearmData, FireTypes) == 0x00000A, "Member 'FAnimPlayerFirearmData::FireTypes' has a wrong offset!");
static_assert(offsetof(FAnimPlayerFirearmData, LeftHandCurveValueInverse) == 0x00000C, "Member 'FAnimPlayerFirearmData::LeftHandCurveValueInverse' has a wrong offset!");
static_assert(offsetof(FAnimPlayerFirearmData, WeaponLeftHandCurveValueInverse) == 0x000010, "Member 'FAnimPlayerFirearmData::WeaponLeftHandCurveValueInverse' has a wrong offset!");
static_assert(offsetof(FAnimPlayerFirearmData, LeftHandMovementAlpha) == 0x000014, "Member 'FAnimPlayerFirearmData::LeftHandMovementAlpha' has a wrong offset!");
static_assert(offsetof(FAnimPlayerFirearmData, bIsLeftHandIdleUnlocked) == 0x000018, "Member 'FAnimPlayerFirearmData::bIsLeftHandIdleUnlocked' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerWeaponData
// 0x0080 (0x0080 - 0x0000)
struct FAnimPlayerWeaponData final
{
public:
	bool                                          bHasWeaponInHands;                                 // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 WeaponMesh;                                        // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 AttachMesh;                                        // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimPlayerBaseWeaponData              BaseWeaponData;                                    // 0x0018(0x0030)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimPlayerAimingData                  AimingData;                                        // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimPlayerFirearmData                 FirearmData;                                       // 0x0060(0x001C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerWeaponData) == 0x000008, "Wrong alignment on FAnimPlayerWeaponData");
static_assert(sizeof(FAnimPlayerWeaponData) == 0x000080, "Wrong size on FAnimPlayerWeaponData");
static_assert(offsetof(FAnimPlayerWeaponData, bHasWeaponInHands) == 0x000000, "Member 'FAnimPlayerWeaponData::bHasWeaponInHands' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponData, WeaponMesh) == 0x000008, "Member 'FAnimPlayerWeaponData::WeaponMesh' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponData, AttachMesh) == 0x000010, "Member 'FAnimPlayerWeaponData::AttachMesh' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponData, BaseWeaponData) == 0x000018, "Member 'FAnimPlayerWeaponData::BaseWeaponData' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponData, AimingData) == 0x000048, "Member 'FAnimPlayerWeaponData::AimingData' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponData, FirearmData) == 0x000060, "Member 'FAnimPlayerWeaponData::FirearmData' has a wrong offset!");

// ScriptStruct Stalker2.AnimPlayerWeaponPushbackData
// 0x0080 (0x0080 - 0x0000)
struct FAnimPlayerWeaponPushbackData final
{
public:
	float                                         PushbackInteprolateTolerance;                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushbackInteprolateSpeed;                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimPushbackState                            State;                                             // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Alpha;                                             // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WeaponTranslation;                                 // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               WeaponRotation;                                    // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FAlphaBlend                            Blend;                                             // 0x0040(0x0030)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPlayerWeaponPushbackData) == 0x000008, "Wrong alignment on FAnimPlayerWeaponPushbackData");
static_assert(sizeof(FAnimPlayerWeaponPushbackData) == 0x000080, "Wrong size on FAnimPlayerWeaponPushbackData");
static_assert(offsetof(FAnimPlayerWeaponPushbackData, PushbackInteprolateTolerance) == 0x000000, "Member 'FAnimPlayerWeaponPushbackData::PushbackInteprolateTolerance' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponPushbackData, PushbackInteprolateSpeed) == 0x000004, "Member 'FAnimPlayerWeaponPushbackData::PushbackInteprolateSpeed' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponPushbackData, State) == 0x000008, "Member 'FAnimPlayerWeaponPushbackData::State' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponPushbackData, Alpha) == 0x00000C, "Member 'FAnimPlayerWeaponPushbackData::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponPushbackData, WeaponTranslation) == 0x000010, "Member 'FAnimPlayerWeaponPushbackData::WeaponTranslation' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponPushbackData, WeaponRotation) == 0x000028, "Member 'FAnimPlayerWeaponPushbackData::WeaponRotation' has a wrong offset!");
static_assert(offsetof(FAnimPlayerWeaponPushbackData, Blend) == 0x000040, "Member 'FAnimPlayerWeaponPushbackData::Blend' has a wrong offset!");

// ScriptStruct Stalker2.AnimPoseSearchLocomotionData
// 0x01D0 (0x01D0 - 0x0000)
struct FAnimPoseSearchLocomotionData final
{
public:
	struct FTrajectorySampleRange                 Trajectory;                                        // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Tags;                                              // 0x0018(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StrafeRotateInterpSpeedCurve;                      // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForcedIdling;                                     // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldInterrupt;                                  // 0x0041(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnableLookAtAlpha;                                 // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMotionMatchingSettings                Settings;                                          // 0x0048(0x0030)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseSearchProceduralMovement          ProceduralMovement;                                // 0x0080(0x0070)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FWarpingVectorValue                    FloorNormal;                                       // 0x00F0(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UPoseSearchSearchableAsset*             Searchable;                                        // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrideScale;                                       // 0x0118(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegIKAlpha;                                        // 0x011C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRelaxLocomotion;                               // 0x0120(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0xB];                                      // 0x0121(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HistoryExpirationSeconds;                          // 0x012C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EAnimPoseSearchMoveType, float>          MoveTypeStayInIndexTime;                           // 0x0130(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ESmartCoverType                               SmartCoverType;                                    // 0x0180(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsingSmartCoverAnimPose;                          // 0x0181(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182[0x2];                                      // 0x0182(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveBehaviorOnlyTransitionUseTime;                 // 0x0184(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x38];                                     // 0x0188(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UPoseSearchLocomotionCharacterMovementComponent* MovementComponent;                        // 0x01C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPoseSearchLocomotionData) == 0x000010, "Wrong alignment on FAnimPoseSearchLocomotionData");
static_assert(sizeof(FAnimPoseSearchLocomotionData) == 0x0001D0, "Wrong size on FAnimPoseSearchLocomotionData");
static_assert(offsetof(FAnimPoseSearchLocomotionData, Trajectory) == 0x000000, "Member 'FAnimPoseSearchLocomotionData::Trajectory' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, Tags) == 0x000018, "Member 'FAnimPoseSearchLocomotionData::Tags' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, StrafeRotateInterpSpeedCurve) == 0x000038, "Member 'FAnimPoseSearchLocomotionData::StrafeRotateInterpSpeedCurve' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, bForcedIdling) == 0x000040, "Member 'FAnimPoseSearchLocomotionData::bForcedIdling' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, bShouldInterrupt) == 0x000041, "Member 'FAnimPoseSearchLocomotionData::bShouldInterrupt' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, EnableLookAtAlpha) == 0x000044, "Member 'FAnimPoseSearchLocomotionData::EnableLookAtAlpha' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, Settings) == 0x000048, "Member 'FAnimPoseSearchLocomotionData::Settings' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, ProceduralMovement) == 0x000080, "Member 'FAnimPoseSearchLocomotionData::ProceduralMovement' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, FloorNormal) == 0x0000F0, "Member 'FAnimPoseSearchLocomotionData::FloorNormal' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, Searchable) == 0x000110, "Member 'FAnimPoseSearchLocomotionData::Searchable' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, StrideScale) == 0x000118, "Member 'FAnimPoseSearchLocomotionData::StrideScale' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, LegIKAlpha) == 0x00011C, "Member 'FAnimPoseSearchLocomotionData::LegIKAlpha' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, bUseRelaxLocomotion) == 0x000120, "Member 'FAnimPoseSearchLocomotionData::bUseRelaxLocomotion' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, HistoryExpirationSeconds) == 0x00012C, "Member 'FAnimPoseSearchLocomotionData::HistoryExpirationSeconds' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, MoveTypeStayInIndexTime) == 0x000130, "Member 'FAnimPoseSearchLocomotionData::MoveTypeStayInIndexTime' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, SmartCoverType) == 0x000180, "Member 'FAnimPoseSearchLocomotionData::SmartCoverType' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, bUsingSmartCoverAnimPose) == 0x000181, "Member 'FAnimPoseSearchLocomotionData::bUsingSmartCoverAnimPose' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, MoveBehaviorOnlyTransitionUseTime) == 0x000184, "Member 'FAnimPoseSearchLocomotionData::MoveBehaviorOnlyTransitionUseTime' has a wrong offset!");
static_assert(offsetof(FAnimPoseSearchLocomotionData, MovementComponent) == 0x0001C0, "Member 'FAnimPoseSearchLocomotionData::MovementComponent' has a wrong offset!");

// ScriptStruct Stalker2.AnimValveData
// 0x0001 (0x0001 - 0x0000)
struct FAnimValveData final
{
public:
	EValveState                                   ValveState;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimValveData) == 0x000001, "Wrong alignment on FAnimValveData");
static_assert(sizeof(FAnimValveData) == 0x000001, "Wrong size on FAnimValveData");
static_assert(offsetof(FAnimValveData, ValveState) == 0x000000, "Member 'FAnimValveData::ValveState' has a wrong offset!");

// ScriptStruct Stalker2.AnomalyCollection
// 0x0030 (0x0098 - 0x0068)
struct FAnomalyCollection final : public FBaseTickAggregationCollection
{
public:
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnomalyCollection) == 0x000008, "Wrong alignment on FAnomalyCollection");
static_assert(sizeof(FAnomalyCollection) == 0x000098, "Wrong size on FAnomalyCollection");

// ScriptStruct Stalker2.AnomalyModelCollection
// 0x0000 (0x00A0 - 0x00A0)
struct FAnomalyModelCollection final : public FBaseModelCollection
{
};
static_assert(alignof(FAnomalyModelCollection) == 0x000008, "Wrong alignment on FAnomalyModelCollection");
static_assert(sizeof(FAnomalyModelCollection) == 0x0000A0, "Wrong size on FAnomalyModelCollection");

// ScriptStruct Stalker2.ModelSpawnerParams
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FModelSpawnerParams final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModelSpawnerParams) == 0x000004, "Wrong alignment on FModelSpawnerParams");
static_assert(sizeof(FModelSpawnerParams) == 0x000010, "Wrong size on FModelSpawnerParams");

// ScriptStruct Stalker2.InteractEffectData
// 0x0040 (0x0040 - 0x0000)
struct FInteractEffectData final
{
public:
	struct FPrototypeSID                          PrototypeSID;                                      // 0x0000(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractEffectData) == 0x000008, "Wrong alignment on FInteractEffectData");
static_assert(sizeof(FInteractEffectData) == 0x000040, "Wrong size on FInteractEffectData");
static_assert(offsetof(FInteractEffectData, PrototypeSID) == 0x000000, "Member 'FInteractEffectData::PrototypeSID' has a wrong offset!");

// ScriptStruct Stalker2.ArtifactCollection
// 0x0030 (0x0098 - 0x0068)
struct FArtifactCollection final : public FBaseTickAggregationCollection
{
public:
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArtifactCollection) == 0x000008, "Wrong alignment on FArtifactCollection");
static_assert(sizeof(FArtifactCollection) == 0x000098, "Wrong size on FArtifactCollection");

// ScriptStruct Stalker2.TipPositionArgs
// 0x0028 (0x0028 - 0x0000)
struct FTipPositionArgs final
{
public:
	int32                                         Row;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Column;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        size;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlotDirection                                Direction;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Translation;                                       // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTipPositionArgs) == 0x000008, "Wrong alignment on FTipPositionArgs");
static_assert(sizeof(FTipPositionArgs) == 0x000028, "Wrong size on FTipPositionArgs");
static_assert(offsetof(FTipPositionArgs, Row) == 0x000000, "Member 'FTipPositionArgs::Row' has a wrong offset!");
static_assert(offsetof(FTipPositionArgs, Column) == 0x000004, "Member 'FTipPositionArgs::Column' has a wrong offset!");
static_assert(offsetof(FTipPositionArgs, size) == 0x000008, "Member 'FTipPositionArgs::size' has a wrong offset!");
static_assert(offsetof(FTipPositionArgs, Direction) == 0x000010, "Member 'FTipPositionArgs::Direction' has a wrong offset!");
static_assert(offsetof(FTipPositionArgs, HorizontalAlignment) == 0x000011, "Member 'FTipPositionArgs::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(FTipPositionArgs, VerticalAlignment) == 0x000012, "Member 'FTipPositionArgs::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(FTipPositionArgs, Translation) == 0x000018, "Member 'FTipPositionArgs::Translation' has a wrong offset!");

// ScriptStruct Stalker2.InteractionData
// 0x0018 (0x0018 - 0x0000)
struct FInteractionData
{
public:
	class FString                                 InteractableTextToolAction;                        // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionData) == 0x000008, "Wrong alignment on FInteractionData");
static_assert(sizeof(FInteractionData) == 0x000018, "Wrong size on FInteractionData");
static_assert(offsetof(FInteractionData, InteractableTextToolAction) == 0x000000, "Member 'FInteractionData::InteractableTextToolAction' has a wrong offset!");

// ScriptStruct Stalker2.AutoInteractionData
// 0x0000 (0x0018 - 0x0018)
struct FAutoInteractionData final : public FInteractionData
{
};
static_assert(alignof(FAutoInteractionData) == 0x000008, "Wrong alignment on FAutoInteractionData");
static_assert(sizeof(FAutoInteractionData) == 0x000018, "Wrong size on FAutoInteractionData");

// ScriptStruct Stalker2.ManagerTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FManagerTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManagerTickFunction) == 0x000008, "Wrong alignment on FManagerTickFunction");
static_assert(sizeof(FManagerTickFunction) == 0x000030, "Wrong size on FManagerTickFunction");

// ScriptStruct Stalker2.BodyMeshSIDSelector
// 0x0010 (0x0010 - 0x0000)
struct FBodyMeshSIDSelector final
{
public:
	class FString                                 Value;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBodyMeshSIDSelector) == 0x000008, "Wrong alignment on FBodyMeshSIDSelector");
static_assert(sizeof(FBodyMeshSIDSelector) == 0x000010, "Wrong size on FBodyMeshSIDSelector");
static_assert(offsetof(FBodyMeshSIDSelector, Value) == 0x000000, "Member 'FBodyMeshSIDSelector::Value' has a wrong offset!");

// ScriptStruct Stalker2.VictoryInput
// 0x0040 (0x0040 - 0x0000)
struct FVictoryInput final
{
public:
	class FString                                 ActionName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0010(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyAsString;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShift;                                            // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCtrl;                                             // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlt;                                              // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCmd;                                              // 0x003B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGamepad;                                          // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKeyCategory                                  Category;                                          // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVictoryInput) == 0x000008, "Wrong alignment on FVictoryInput");
static_assert(sizeof(FVictoryInput) == 0x000040, "Wrong size on FVictoryInput");
static_assert(offsetof(FVictoryInput, ActionName) == 0x000000, "Member 'FVictoryInput::ActionName' has a wrong offset!");
static_assert(offsetof(FVictoryInput, Key) == 0x000010, "Member 'FVictoryInput::Key' has a wrong offset!");
static_assert(offsetof(FVictoryInput, KeyAsString) == 0x000028, "Member 'FVictoryInput::KeyAsString' has a wrong offset!");
static_assert(offsetof(FVictoryInput, bShift) == 0x000038, "Member 'FVictoryInput::bShift' has a wrong offset!");
static_assert(offsetof(FVictoryInput, bCtrl) == 0x000039, "Member 'FVictoryInput::bCtrl' has a wrong offset!");
static_assert(offsetof(FVictoryInput, bAlt) == 0x00003A, "Member 'FVictoryInput::bAlt' has a wrong offset!");
static_assert(offsetof(FVictoryInput, bCmd) == 0x00003B, "Member 'FVictoryInput::bCmd' has a wrong offset!");
static_assert(offsetof(FVictoryInput, bGamepad) == 0x00003C, "Member 'FVictoryInput::bGamepad' has a wrong offset!");
static_assert(offsetof(FVictoryInput, Category) == 0x00003D, "Member 'FVictoryInput::Category' has a wrong offset!");

// ScriptStruct Stalker2.VictoryInputAxis
// 0x0040 (0x0040 - 0x0000)
struct FVictoryInputAxis final
{
public:
	class FString                                 AxisName;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyAsString;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0020(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKeyCategory                                  Category;                                          // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVictoryInputAxis) == 0x000008, "Wrong alignment on FVictoryInputAxis");
static_assert(sizeof(FVictoryInputAxis) == 0x000040, "Wrong size on FVictoryInputAxis");
static_assert(offsetof(FVictoryInputAxis, AxisName) == 0x000000, "Member 'FVictoryInputAxis::AxisName' has a wrong offset!");
static_assert(offsetof(FVictoryInputAxis, KeyAsString) == 0x000010, "Member 'FVictoryInputAxis::KeyAsString' has a wrong offset!");
static_assert(offsetof(FVictoryInputAxis, Key) == 0x000020, "Member 'FVictoryInputAxis::Key' has a wrong offset!");
static_assert(offsetof(FVictoryInputAxis, Scale) == 0x000038, "Member 'FVictoryInputAxis::Scale' has a wrong offset!");
static_assert(offsetof(FVictoryInputAxis, Category) == 0x00003C, "Member 'FVictoryInputAxis::Category' has a wrong offset!");

// ScriptStruct Stalker2.PostProcessSimplifiedSettings
// 0x0080 (0x0080 - 0x0000)
struct FPostProcessSimplifiedSettings final
{
public:
	struct FVector4                               ColorSaturation;                                   // 0x0000(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorContrast;                                     // 0x0020(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorGamma;                                        // 0x0040(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ColorSaturation : 1;                     // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorContrast : 1;                       // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGamma : 1;                          // 0x0060(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FilmToe;                                           // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FilmToe : 1;                             // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeightedBlendables                    WeightedBlendables;                                // 0x0070(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPostProcessSimplifiedSettings) == 0x000010, "Wrong alignment on FPostProcessSimplifiedSettings");
static_assert(sizeof(FPostProcessSimplifiedSettings) == 0x000080, "Wrong size on FPostProcessSimplifiedSettings");
static_assert(offsetof(FPostProcessSimplifiedSettings, ColorSaturation) == 0x000000, "Member 'FPostProcessSimplifiedSettings::ColorSaturation' has a wrong offset!");
static_assert(offsetof(FPostProcessSimplifiedSettings, ColorContrast) == 0x000020, "Member 'FPostProcessSimplifiedSettings::ColorContrast' has a wrong offset!");
static_assert(offsetof(FPostProcessSimplifiedSettings, ColorGamma) == 0x000040, "Member 'FPostProcessSimplifiedSettings::ColorGamma' has a wrong offset!");
static_assert(offsetof(FPostProcessSimplifiedSettings, FilmToe) == 0x000064, "Member 'FPostProcessSimplifiedSettings::FilmToe' has a wrong offset!");
static_assert(offsetof(FPostProcessSimplifiedSettings, WeightedBlendables) == 0x000070, "Member 'FPostProcessSimplifiedSettings::WeightedBlendables' has a wrong offset!");

// ScriptStruct Stalker2.AbilityCamModifierStage
// 0x0090 (0x0090 - 0x0000)
struct FAbilityCamModifierStage final
{
public:
	float                                         StageDuration;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistPercent;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostProcessBlendWeight;                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPostProcessSimplifiedSettings         PostProcessSettings;                               // 0x0010(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityCamModifierStage) == 0x000010, "Wrong alignment on FAbilityCamModifierStage");
static_assert(sizeof(FAbilityCamModifierStage) == 0x000090, "Wrong size on FAbilityCamModifierStage");
static_assert(offsetof(FAbilityCamModifierStage, StageDuration) == 0x000000, "Member 'FAbilityCamModifierStage::StageDuration' has a wrong offset!");
static_assert(offsetof(FAbilityCamModifierStage, DistPercent) == 0x000004, "Member 'FAbilityCamModifierStage::DistPercent' has a wrong offset!");
static_assert(offsetof(FAbilityCamModifierStage, FOV) == 0x000008, "Member 'FAbilityCamModifierStage::FOV' has a wrong offset!");
static_assert(offsetof(FAbilityCamModifierStage, PostProcessBlendWeight) == 0x00000C, "Member 'FAbilityCamModifierStage::PostProcessBlendWeight' has a wrong offset!");
static_assert(offsetof(FAbilityCamModifierStage, PostProcessSettings) == 0x000010, "Member 'FAbilityCamModifierStage::PostProcessSettings' has a wrong offset!");

// ScriptStruct Stalker2.ContextualActionGlobalVariablePrototypeSID
// 0x0010 (0x0010 - 0x0000)
struct FContextualActionGlobalVariablePrototypeSID final
{
public:
	class FString                                 Value;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContextualActionGlobalVariablePrototypeSID) == 0x000008, "Wrong alignment on FContextualActionGlobalVariablePrototypeSID");
static_assert(sizeof(FContextualActionGlobalVariablePrototypeSID) == 0x000010, "Wrong size on FContextualActionGlobalVariablePrototypeSID");
static_assert(offsetof(FContextualActionGlobalVariablePrototypeSID, Value) == 0x000000, "Member 'FContextualActionGlobalVariablePrototypeSID::Value' has a wrong offset!");

// ScriptStruct Stalker2.ContextualActionModelCollection
// 0x0000 (0x00A0 - 0x00A0)
struct FContextualActionModelCollection final : public FBaseModelCollection
{
};
static_assert(alignof(FContextualActionModelCollection) == 0x000008, "Wrong alignment on FContextualActionModelCollection");
static_assert(sizeof(FContextualActionModelCollection) == 0x0000A0, "Wrong size on FContextualActionModelCollection");

// ScriptStruct Stalker2.ContextualItemAttachment
// 0x0030 (0x0030 - 0x0000)
struct FContextualItemAttachment final
{
public:
	EContextualItemAttachType                     ContextualItemAttachType;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachmentName;                                    // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            MeshToBeAttached;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkeletalMeshToBeAttached;                          // 0x0020(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         NiagaraAsset;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContextualItemAttachment) == 0x000008, "Wrong alignment on FContextualItemAttachment");
static_assert(sizeof(FContextualItemAttachment) == 0x000030, "Wrong size on FContextualItemAttachment");
static_assert(offsetof(FContextualItemAttachment, ContextualItemAttachType) == 0x000000, "Member 'FContextualItemAttachment::ContextualItemAttachType' has a wrong offset!");
static_assert(offsetof(FContextualItemAttachment, SocketName) == 0x000004, "Member 'FContextualItemAttachment::SocketName' has a wrong offset!");
static_assert(offsetof(FContextualItemAttachment, AttachmentName) == 0x00000C, "Member 'FContextualItemAttachment::AttachmentName' has a wrong offset!");
static_assert(offsetof(FContextualItemAttachment, MeshToBeAttached) == 0x000018, "Member 'FContextualItemAttachment::MeshToBeAttached' has a wrong offset!");
static_assert(offsetof(FContextualItemAttachment, SkeletalMeshToBeAttached) == 0x000020, "Member 'FContextualItemAttachment::SkeletalMeshToBeAttached' has a wrong offset!");
static_assert(offsetof(FContextualItemAttachment, NiagaraAsset) == 0x000028, "Member 'FContextualItemAttachment::NiagaraAsset' has a wrong offset!");

// ScriptStruct Stalker2.NiagaraValueCopyFromTo
// 0x0018 (0x0018 - 0x0000)
struct FNiagaraValueCopyFromTo final
{
public:
	class FName                                   AttachmentName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CopyFrom;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CopyTo;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNiagaraValueCopyFromTo) == 0x000004, "Wrong alignment on FNiagaraValueCopyFromTo");
static_assert(sizeof(FNiagaraValueCopyFromTo) == 0x000018, "Wrong size on FNiagaraValueCopyFromTo");
static_assert(offsetof(FNiagaraValueCopyFromTo, AttachmentName) == 0x000000, "Member 'FNiagaraValueCopyFromTo::AttachmentName' has a wrong offset!");
static_assert(offsetof(FNiagaraValueCopyFromTo, CopyFrom) == 0x000008, "Member 'FNiagaraValueCopyFromTo::CopyFrom' has a wrong offset!");
static_assert(offsetof(FNiagaraValueCopyFromTo, CopyTo) == 0x000010, "Member 'FNiagaraValueCopyFromTo::CopyTo' has a wrong offset!");

// ScriptStruct Stalker2.SpawnNiagaraSystemAtLocation
// 0x0018 (0x0018 - 0x0000)
struct FSpawnNiagaraSystemAtLocation final
{
public:
	class FName                                   AttachmentName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpawnNiagaraAtLocation                       SpawnNiagaraAtLocation;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         NiagaraAsset;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnNiagaraSystemAtLocation) == 0x000008, "Wrong alignment on FSpawnNiagaraSystemAtLocation");
static_assert(sizeof(FSpawnNiagaraSystemAtLocation) == 0x000018, "Wrong size on FSpawnNiagaraSystemAtLocation");
static_assert(offsetof(FSpawnNiagaraSystemAtLocation, AttachmentName) == 0x000000, "Member 'FSpawnNiagaraSystemAtLocation::AttachmentName' has a wrong offset!");
static_assert(offsetof(FSpawnNiagaraSystemAtLocation, SpawnNiagaraAtLocation) == 0x000008, "Member 'FSpawnNiagaraSystemAtLocation::SpawnNiagaraAtLocation' has a wrong offset!");
static_assert(offsetof(FSpawnNiagaraSystemAtLocation, NiagaraAsset) == 0x000010, "Member 'FSpawnNiagaraSystemAtLocation::NiagaraAsset' has a wrong offset!");

// ScriptStruct Stalker2.PlayAnimationOnAttachedItemData
// 0x0010 (0x0010 - 0x0000)
struct FPlayAnimationOnAttachedItemData final
{
public:
	class FName                                   AttachmentName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        AnimationAsset;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayAnimationOnAttachedItemData) == 0x000008, "Wrong alignment on FPlayAnimationOnAttachedItemData");
static_assert(sizeof(FPlayAnimationOnAttachedItemData) == 0x000010, "Wrong size on FPlayAnimationOnAttachedItemData");
static_assert(offsetof(FPlayAnimationOnAttachedItemData, AttachmentName) == 0x000000, "Member 'FPlayAnimationOnAttachedItemData::AttachmentName' has a wrong offset!");
static_assert(offsetof(FPlayAnimationOnAttachedItemData, AnimationAsset) == 0x000008, "Member 'FPlayAnimationOnAttachedItemData::AnimationAsset' has a wrong offset!");

// ScriptStruct Stalker2.CreatorTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FCreatorTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreatorTickFunction) == 0x000008, "Wrong alignment on FCreatorTickFunction");
static_assert(sizeof(FCreatorTickFunction) == 0x000030, "Wrong size on FCreatorTickFunction");

// ScriptStruct Stalker2.NameDisplaySettings
// 0x0014 (0x0014 - 0x0000)
struct FNameDisplaySettings final
{
public:
	struct FMargin                                Margin;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNameDisplaySettings) == 0x000004, "Wrong alignment on FNameDisplaySettings");
static_assert(sizeof(FNameDisplaySettings) == 0x000014, "Wrong size on FNameDisplaySettings");
static_assert(offsetof(FNameDisplaySettings, Margin) == 0x000000, "Member 'FNameDisplaySettings::Margin' has a wrong offset!");
static_assert(offsetof(FNameDisplaySettings, HorizontalAlignment) == 0x000010, "Member 'FNameDisplaySettings::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(FNameDisplaySettings, VerticalAlignment) == 0x000011, "Member 'FNameDisplaySettings::VerticalAlignment' has a wrong offset!");

// ScriptStruct Stalker2.NamesWidgetDisplaySettings
// 0x001C (0x001C - 0x0000)
struct FNamesWidgetDisplaySettings final
{
public:
	struct FMargin                                Margin;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateChildSize                        SlateChildSize;                                    // 0x0014(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamesWidgetDisplaySettings) == 0x000004, "Wrong alignment on FNamesWidgetDisplaySettings");
static_assert(sizeof(FNamesWidgetDisplaySettings) == 0x00001C, "Wrong size on FNamesWidgetDisplaySettings");
static_assert(offsetof(FNamesWidgetDisplaySettings, Margin) == 0x000000, "Member 'FNamesWidgetDisplaySettings::Margin' has a wrong offset!");
static_assert(offsetof(FNamesWidgetDisplaySettings, HorizontalAlignment) == 0x000010, "Member 'FNamesWidgetDisplaySettings::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(FNamesWidgetDisplaySettings, VerticalAlignment) == 0x000011, "Member 'FNamesWidgetDisplaySettings::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(FNamesWidgetDisplaySettings, SlateChildSize) == 0x000014, "Member 'FNamesWidgetDisplaySettings::SlateChildSize' has a wrong offset!");

// ScriptStruct Stalker2.SectionTitleDisplaySettings
// 0x0014 (0x0014 - 0x0000)
struct FSectionTitleDisplaySettings final
{
public:
	struct FMargin                                Margin;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSectionTitleDisplaySettings) == 0x000004, "Wrong alignment on FSectionTitleDisplaySettings");
static_assert(sizeof(FSectionTitleDisplaySettings) == 0x000014, "Wrong size on FSectionTitleDisplaySettings");
static_assert(offsetof(FSectionTitleDisplaySettings, Margin) == 0x000000, "Member 'FSectionTitleDisplaySettings::Margin' has a wrong offset!");
static_assert(offsetof(FSectionTitleDisplaySettings, HorizontalAlignment) == 0x000010, "Member 'FSectionTitleDisplaySettings::HorizontalAlignment' has a wrong offset!");

// ScriptStruct Stalker2.RoleDisplaySettings
// 0x0010 (0x0010 - 0x0000)
struct FRoleDisplaySettings final
{
public:
	struct FMargin                                Margin;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoleDisplaySettings) == 0x000004, "Wrong alignment on FRoleDisplaySettings");
static_assert(sizeof(FRoleDisplaySettings) == 0x000010, "Wrong size on FRoleDisplaySettings");
static_assert(offsetof(FRoleDisplaySettings, Margin) == 0x000000, "Member 'FRoleDisplaySettings::Margin' has a wrong offset!");

// ScriptStruct Stalker2.DeadBodyInteractionData
// 0x0008 (0x0020 - 0x0018)
struct FDeadBodyInteractionData final : public FActorInteractionData
{
public:
	bool                                          bOverweight;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeadBodyInteractionData) == 0x000008, "Wrong alignment on FDeadBodyInteractionData");
static_assert(sizeof(FDeadBodyInteractionData) == 0x000020, "Wrong size on FDeadBodyInteractionData");
static_assert(offsetof(FDeadBodyInteractionData, bOverweight) == 0x000018, "Member 'FDeadBodyInteractionData::bOverweight' has a wrong offset!");

// ScriptStruct Stalker2.DeathData
// 0x0020 (0x0020 - 0x0000)
struct FDeathData final
{
public:
	TArray<EDamageSource>                         DamageSources;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EDamageType>                           DamageTypes;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeathData) == 0x000008, "Wrong alignment on FDeathData");
static_assert(sizeof(FDeathData) == 0x000020, "Wrong size on FDeathData");
static_assert(offsetof(FDeathData, DamageSources) == 0x000000, "Member 'FDeathData::DamageSources' has a wrong offset!");
static_assert(offsetof(FDeathData, DamageTypes) == 0x000010, "Member 'FDeathData::DamageTypes' has a wrong offset!");

// ScriptStruct Stalker2.DeathScreenSIDData
// 0x0028 (0x0028 - 0x0000)
struct FDeathScreenSIDData final
{
public:
	class FName                                   SID;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDeathData                             DeathData;                                         // 0x0008(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeathScreenSIDData) == 0x000008, "Wrong alignment on FDeathScreenSIDData");
static_assert(sizeof(FDeathScreenSIDData) == 0x000028, "Wrong size on FDeathScreenSIDData");
static_assert(offsetof(FDeathScreenSIDData, SID) == 0x000000, "Member 'FDeathScreenSIDData::SID' has a wrong offset!");
static_assert(offsetof(FDeathScreenSIDData, DeathData) == 0x000008, "Member 'FDeathScreenSIDData::DeathData' has a wrong offset!");

// ScriptStruct Stalker2.DeathScreenImageData
// 0x0050 (0x0050 - 0x0000)
struct FDeathScreenImageData final
{
public:
	TSoftObjectPtr<class UTexture2D>              DeathImage;                                        // 0x0000(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDeathData                             DeathData;                                         // 0x0030(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeathScreenImageData) == 0x000008, "Wrong alignment on FDeathScreenImageData");
static_assert(sizeof(FDeathScreenImageData) == 0x000050, "Wrong size on FDeathScreenImageData");
static_assert(offsetof(FDeathScreenImageData, DeathImage) == 0x000000, "Member 'FDeathScreenImageData::DeathImage' has a wrong offset!");
static_assert(offsetof(FDeathScreenImageData, DeathData) == 0x000030, "Member 'FDeathScreenImageData::DeathData' has a wrong offset!");

// ScriptStruct Stalker2.RengeSettings
// 0x0018 (0x0018 - 0x0000)
struct FRengeSettings final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           WarningColor;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRengeSettings) == 0x000004, "Wrong alignment on FRengeSettings");
static_assert(sizeof(FRengeSettings) == 0x000018, "Wrong size on FRengeSettings");
static_assert(offsetof(FRengeSettings, Min) == 0x000000, "Member 'FRengeSettings::Min' has a wrong offset!");
static_assert(offsetof(FRengeSettings, Max) == 0x000004, "Member 'FRengeSettings::Max' has a wrong offset!");
static_assert(offsetof(FRengeSettings, WarningColor) == 0x000008, "Member 'FRengeSettings::WarningColor' has a wrong offset!");

// ScriptStruct Stalker2.WarningSettings
// 0x0020 (0x0020 - 0x0000)
struct FWarningSettings final
{
public:
	TArray<ELocalizationLanguage>                 Localization;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRengeSettings>                 RengeSettings;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWarningSettings) == 0x000008, "Wrong alignment on FWarningSettings");
static_assert(sizeof(FWarningSettings) == 0x000020, "Wrong size on FWarningSettings");
static_assert(offsetof(FWarningSettings, Localization) == 0x000000, "Member 'FWarningSettings::Localization' has a wrong offset!");
static_assert(offsetof(FWarningSettings, RengeSettings) == 0x000010, "Member 'FWarningSettings::RengeSettings' has a wrong offset!");

// ScriptStruct Stalker2.UIWarningSettings
// 0x0048 (0x0050 - 0x0008)
struct FUIWarningSettings final : public FTableRowBase
{
public:
	bool                                          IsGlobalEnable;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIWorningType                                WorningType;                                       // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PerfectTextSize;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldIgnoreTag;                                  // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RowSize;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerfectRow;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWarningSettings                       DefoultRengeSettings;                              // 0x0020(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FWarningSettings>               RengeSettings;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIWarningSettings) == 0x000008, "Wrong alignment on FUIWarningSettings");
static_assert(sizeof(FUIWarningSettings) == 0x000050, "Wrong size on FUIWarningSettings");
static_assert(offsetof(FUIWarningSettings, IsGlobalEnable) == 0x000008, "Member 'FUIWarningSettings::IsGlobalEnable' has a wrong offset!");
static_assert(offsetof(FUIWarningSettings, WorningType) == 0x000009, "Member 'FUIWarningSettings::WorningType' has a wrong offset!");
static_assert(offsetof(FUIWarningSettings, PerfectTextSize) == 0x00000C, "Member 'FUIWarningSettings::PerfectTextSize' has a wrong offset!");
static_assert(offsetof(FUIWarningSettings, bShouldIgnoreTag) == 0x000010, "Member 'FUIWarningSettings::bShouldIgnoreTag' has a wrong offset!");
static_assert(offsetof(FUIWarningSettings, RowSize) == 0x000014, "Member 'FUIWarningSettings::RowSize' has a wrong offset!");
static_assert(offsetof(FUIWarningSettings, PerfectRow) == 0x000018, "Member 'FUIWarningSettings::PerfectRow' has a wrong offset!");
static_assert(offsetof(FUIWarningSettings, DefoultRengeSettings) == 0x000020, "Member 'FUIWarningSettings::DefoultRengeSettings' has a wrong offset!");
static_assert(offsetof(FUIWarningSettings, RengeSettings) == 0x000040, "Member 'FUIWarningSettings::RengeSettings' has a wrong offset!");

// ScriptStruct Stalker2.DestructibleObjectCollection
// 0x0030 (0x0098 - 0x0068)
struct FDestructibleObjectCollection final : public FBaseTickAggregationCollection
{
public:
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDestructibleObjectCollection) == 0x000008, "Wrong alignment on FDestructibleObjectCollection");
static_assert(sizeof(FDestructibleObjectCollection) == 0x000098, "Wrong size on FDestructibleObjectCollection");

// ScriptStruct Stalker2.DestructionAction
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDestructionAction final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDestructionAction) == 0x000008, "Wrong alignment on FDestructionAction");
static_assert(sizeof(FDestructionAction) == 0x000018, "Wrong size on FDestructionAction");

// ScriptStruct Stalker2.ObjectPhaseSettings
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FObjectPhaseSettings final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectPhaseSettings) == 0x000008, "Wrong alignment on FObjectPhaseSettings");
static_assert(sizeof(FObjectPhaseSettings) == 0x000028, "Wrong size on FObjectPhaseSettings");

// ScriptStruct Stalker2.RazerChromaEvent
// 0x0018 (0x0018 - 0x0000)
struct FRazerChromaEvent final
{
public:
	class FString                                 AnimationName;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopAnimation;                                    // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSendSensaEvent;                                   // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSendSensaOnlyIfActive;                            // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRazerChromaEvent) == 0x000008, "Wrong alignment on FRazerChromaEvent");
static_assert(sizeof(FRazerChromaEvent) == 0x000018, "Wrong size on FRazerChromaEvent");
static_assert(offsetof(FRazerChromaEvent, AnimationName) == 0x000000, "Member 'FRazerChromaEvent::AnimationName' has a wrong offset!");
static_assert(offsetof(FRazerChromaEvent, Priority) == 0x000010, "Member 'FRazerChromaEvent::Priority' has a wrong offset!");
static_assert(offsetof(FRazerChromaEvent, bLoopAnimation) == 0x000014, "Member 'FRazerChromaEvent::bLoopAnimation' has a wrong offset!");
static_assert(offsetof(FRazerChromaEvent, bSendSensaEvent) == 0x000015, "Member 'FRazerChromaEvent::bSendSensaEvent' has a wrong offset!");
static_assert(offsetof(FRazerChromaEvent, bSendSensaOnlyIfActive) == 0x000016, "Member 'FRazerChromaEvent::bSendSensaOnlyIfActive' has a wrong offset!");

// ScriptStruct Stalker2.RazerChromaVitalsSettings
// 0x0020 (0x0020 - 0x0000)
struct FRazerChromaVitalsSettings final
{
public:
	struct FRazerChromaEvent                      Event;                                             // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         Threshold;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableIfHigher;                                   // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRazerChromaVitalsSettings) == 0x000008, "Wrong alignment on FRazerChromaVitalsSettings");
static_assert(sizeof(FRazerChromaVitalsSettings) == 0x000020, "Wrong size on FRazerChromaVitalsSettings");
static_assert(offsetof(FRazerChromaVitalsSettings, Event) == 0x000000, "Member 'FRazerChromaVitalsSettings::Event' has a wrong offset!");
static_assert(offsetof(FRazerChromaVitalsSettings, Threshold) == 0x000018, "Member 'FRazerChromaVitalsSettings::Threshold' has a wrong offset!");
static_assert(offsetof(FRazerChromaVitalsSettings, bEnableIfHigher) == 0x00001C, "Member 'FRazerChromaVitalsSettings::bEnableIfHigher' has a wrong offset!");

// ScriptStruct Stalker2.DialogAnimationType
// 0x0010 (0x0010 - 0x0000)
struct FDialogAnimationType final
{
public:
	EDialogAnimationType                          Value;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDialogAnimationCategory                      DialogAnimationCategory;                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogAnimationType) == 0x000008, "Wrong alignment on FDialogAnimationType");
static_assert(sizeof(FDialogAnimationType) == 0x000010, "Wrong size on FDialogAnimationType");
static_assert(offsetof(FDialogAnimationType, Value) == 0x000000, "Member 'FDialogAnimationType::Value' has a wrong offset!");
static_assert(offsetof(FDialogAnimationType, DialogAnimationCategory) == 0x000008, "Member 'FDialogAnimationType::DialogAnimationCategory' has a wrong offset!");

// ScriptStruct Stalker2.DialogMemberData
// 0x0018 (0x0018 - 0x0000)
struct FDialogMemberData final
{
public:
	class FString                                 DialogMemberName;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOptionalMember;                                   // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogMemberData) == 0x000008, "Wrong alignment on FDialogMemberData");
static_assert(sizeof(FDialogMemberData) == 0x000018, "Wrong size on FDialogMemberData");
static_assert(offsetof(FDialogMemberData, DialogMemberName) == 0x000000, "Member 'FDialogMemberData::DialogMemberName' has a wrong offset!");
static_assert(offsetof(FDialogMemberData, bOptionalMember) == 0x000010, "Member 'FDialogMemberData::bOptionalMember' has a wrong offset!");

// ScriptStruct Stalker2.ObjectArmorData
// 0x000C (0x000C - 0x0000)
struct FObjectArmorData final
{
public:
	float                                         Armor;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorDifferenceCoef;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCalculateAsHumanoid;                              // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectArmorData) == 0x000004, "Wrong alignment on FObjectArmorData");
static_assert(sizeof(FObjectArmorData) == 0x00000C, "Wrong size on FObjectArmorData");
static_assert(offsetof(FObjectArmorData, Armor) == 0x000000, "Member 'FObjectArmorData::Armor' has a wrong offset!");
static_assert(offsetof(FObjectArmorData, ArmorDifferenceCoef) == 0x000004, "Member 'FObjectArmorData::ArmorDifferenceCoef' has a wrong offset!");
static_assert(offsetof(FObjectArmorData, bCalculateAsHumanoid) == 0x000008, "Member 'FObjectArmorData::bCalculateAsHumanoid' has a wrong offset!");

// ScriptStruct Stalker2.DifficultyData
// 0x0010 (0x0010 - 0x0000)
struct FDifficultyData final
{
public:
	class UTexture2D*                             DifficultyImage;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USetDifficulty*                         DifficultyButtonAction;                            // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDifficultyData) == 0x000008, "Wrong alignment on FDifficultyData");
static_assert(sizeof(FDifficultyData) == 0x000010, "Wrong size on FDifficultyData");
static_assert(offsetof(FDifficultyData, DifficultyImage) == 0x000000, "Member 'FDifficultyData::DifficultyImage' has a wrong offset!");
static_assert(offsetof(FDifficultyData, DifficultyButtonAction) == 0x000008, "Member 'FDifficultyData::DifficultyButtonAction' has a wrong offset!");

// ScriptStruct Stalker2.DoorMovableData
// 0x0028 (0x0028 - 0x0000)
struct FDoorMovableData final
{
public:
	class FName                                   ComponentName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenAngularSpeed;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenAngle;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StealthOpenAngularSpeed;                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StealthOpenAngle;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DoorMeshComponent;                                 // 0x0018(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAngle;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x1];                                       // 0x0024(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EDoorMoveDirection                            CurrentDirection;                                  // 0x0025(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDoorMovableData) == 0x000008, "Wrong alignment on FDoorMovableData");
static_assert(sizeof(FDoorMovableData) == 0x000028, "Wrong size on FDoorMovableData");
static_assert(offsetof(FDoorMovableData, ComponentName) == 0x000000, "Member 'FDoorMovableData::ComponentName' has a wrong offset!");
static_assert(offsetof(FDoorMovableData, OpenAngularSpeed) == 0x000008, "Member 'FDoorMovableData::OpenAngularSpeed' has a wrong offset!");
static_assert(offsetof(FDoorMovableData, OpenAngle) == 0x00000C, "Member 'FDoorMovableData::OpenAngle' has a wrong offset!");
static_assert(offsetof(FDoorMovableData, StealthOpenAngularSpeed) == 0x000010, "Member 'FDoorMovableData::StealthOpenAngularSpeed' has a wrong offset!");
static_assert(offsetof(FDoorMovableData, StealthOpenAngle) == 0x000014, "Member 'FDoorMovableData::StealthOpenAngle' has a wrong offset!");
static_assert(offsetof(FDoorMovableData, DoorMeshComponent) == 0x000018, "Member 'FDoorMovableData::DoorMeshComponent' has a wrong offset!");
static_assert(offsetof(FDoorMovableData, InitialAngle) == 0x000020, "Member 'FDoorMovableData::InitialAngle' has a wrong offset!");
static_assert(offsetof(FDoorMovableData, CurrentDirection) == 0x000025, "Member 'FDoorMovableData::CurrentDirection' has a wrong offset!");

// ScriptStruct Stalker2.ParticleConditionPrototype
// 0x0000 (0x0008 - 0x0008)
struct FParticleConditionPrototype : public FEnvironmentParticlePrototype
{
};
static_assert(alignof(FParticleConditionPrototype) == 0x000008, "Wrong alignment on FParticleConditionPrototype");
static_assert(sizeof(FParticleConditionPrototype) == 0x000008, "Wrong size on FParticleConditionPrototype");

// ScriptStruct Stalker2.ParticleWindIntensityPrototype
// 0x0008 (0x0010 - 0x0008)
struct FParticleWindIntensityPrototype final : public FParticleConditionPrototype
{
public:
	struct FFloatInterval                         AllowedWindIntensityInterval;                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleWindIntensityPrototype) == 0x000008, "Wrong alignment on FParticleWindIntensityPrototype");
static_assert(sizeof(FParticleWindIntensityPrototype) == 0x000010, "Wrong size on FParticleWindIntensityPrototype");
static_assert(offsetof(FParticleWindIntensityPrototype, AllowedWindIntensityInterval) == 0x000008, "Member 'FParticleWindIntensityPrototype::AllowedWindIntensityInterval' has a wrong offset!");

// ScriptStruct Stalker2.ParticleIndoorSpawnPrototype
// 0x0028 (0x0030 - 0x0008)
struct FParticleIndoorSpawnPrototype final : public FEnvironmentParticlePrototype
{
public:
	TArray<EAudioRoomPresetBase>                  IgnoredAudioRoomPresets;                           // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EAudioRoomPresetBandwidth>             ForbiddenBandwidthTypes;                           // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinDistanceToAudioVolume;                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParticleIndoorSpawnPrototype) == 0x000008, "Wrong alignment on FParticleIndoorSpawnPrototype");
static_assert(sizeof(FParticleIndoorSpawnPrototype) == 0x000030, "Wrong size on FParticleIndoorSpawnPrototype");
static_assert(offsetof(FParticleIndoorSpawnPrototype, IgnoredAudioRoomPresets) == 0x000008, "Member 'FParticleIndoorSpawnPrototype::IgnoredAudioRoomPresets' has a wrong offset!");
static_assert(offsetof(FParticleIndoorSpawnPrototype, ForbiddenBandwidthTypes) == 0x000018, "Member 'FParticleIndoorSpawnPrototype::ForbiddenBandwidthTypes' has a wrong offset!");
static_assert(offsetof(FParticleIndoorSpawnPrototype, MinDistanceToAudioVolume) == 0x000028, "Member 'FParticleIndoorSpawnPrototype::MinDistanceToAudioVolume' has a wrong offset!");

// ScriptStruct Stalker2.ParticleBiomePrototype
// 0x0030 (0x0038 - 0x0008)
struct FParticleBiomePrototype final : public FParticleConditionPrototype
{
public:
	TArray<class FString>                         AllowedBiomeNames;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         CountableBiomeNames;                               // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BiomeCheckRadius;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBiomeCompatabilityPercent;                      // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParticleBiomePrototype) == 0x000008, "Wrong alignment on FParticleBiomePrototype");
static_assert(sizeof(FParticleBiomePrototype) == 0x000038, "Wrong size on FParticleBiomePrototype");
static_assert(offsetof(FParticleBiomePrototype, AllowedBiomeNames) == 0x000008, "Member 'FParticleBiomePrototype::AllowedBiomeNames' has a wrong offset!");
static_assert(offsetof(FParticleBiomePrototype, CountableBiomeNames) == 0x000018, "Member 'FParticleBiomePrototype::CountableBiomeNames' has a wrong offset!");
static_assert(offsetof(FParticleBiomePrototype, BiomeCheckRadius) == 0x000028, "Member 'FParticleBiomePrototype::BiomeCheckRadius' has a wrong offset!");
static_assert(offsetof(FParticleBiomePrototype, MinBiomeCompatabilityPercent) == 0x00002C, "Member 'FParticleBiomePrototype::MinBiomeCompatabilityPercent' has a wrong offset!");

// ScriptStruct Stalker2.LightningStrikeVFXMaterialPrototype
// 0x0040 (0x0040 - 0x0000)
struct FLightningStrikeVFXMaterialPrototype final
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          NiagaraSystem;                                     // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPhysicalMaterialType>                 PhysicalMaterialTypes;                             // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightningStrikeVFXMaterialPrototype) == 0x000008, "Wrong alignment on FLightningStrikeVFXMaterialPrototype");
static_assert(sizeof(FLightningStrikeVFXMaterialPrototype) == 0x000040, "Wrong size on FLightningStrikeVFXMaterialPrototype");
static_assert(offsetof(FLightningStrikeVFXMaterialPrototype, NiagaraSystem) == 0x000000, "Member 'FLightningStrikeVFXMaterialPrototype::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(FLightningStrikeVFXMaterialPrototype, PhysicalMaterialTypes) == 0x000030, "Member 'FLightningStrikeVFXMaterialPrototype::PhysicalMaterialTypes' has a wrong offset!");

// ScriptStruct Stalker2.LightningStrikeParticleVFXPrototype
// 0x00F0 (0x00F8 - 0x0008)
struct FLightningStrikeParticleVFXPrototype final : public FEnvironmentParticlePrototype
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          LightningStrikeDefault;                            // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightningStrikeVFXMaterialPrototype   LightningStrikeMetal;                              // 0x0038(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLightningStrikeVFXMaterialPrototype   LightningStrikeWater;                              // 0x0078(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLightningStrikeVFXMaterialPrototype   LightningStrikeWood;                               // 0x00B8(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightningStrikeParticleVFXPrototype) == 0x000008, "Wrong alignment on FLightningStrikeParticleVFXPrototype");
static_assert(sizeof(FLightningStrikeParticleVFXPrototype) == 0x0000F8, "Wrong size on FLightningStrikeParticleVFXPrototype");
static_assert(offsetof(FLightningStrikeParticleVFXPrototype, LightningStrikeDefault) == 0x000008, "Member 'FLightningStrikeParticleVFXPrototype::LightningStrikeDefault' has a wrong offset!");
static_assert(offsetof(FLightningStrikeParticleVFXPrototype, LightningStrikeMetal) == 0x000038, "Member 'FLightningStrikeParticleVFXPrototype::LightningStrikeMetal' has a wrong offset!");
static_assert(offsetof(FLightningStrikeParticleVFXPrototype, LightningStrikeWater) == 0x000078, "Member 'FLightningStrikeParticleVFXPrototype::LightningStrikeWater' has a wrong offset!");
static_assert(offsetof(FLightningStrikeParticleVFXPrototype, LightningStrikeWood) == 0x0000B8, "Member 'FLightningStrikeParticleVFXPrototype::LightningStrikeWood' has a wrong offset!");

// ScriptStruct Stalker2.ParticleDistancePrototype
// 0x0008 (0x0010 - 0x0008)
struct FParticleDistancePrototype final : public FParticleConditionPrototype
{
public:
	float                                         MaxDistance;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParticleDistancePrototype) == 0x000008, "Wrong alignment on FParticleDistancePrototype");
static_assert(sizeof(FParticleDistancePrototype) == 0x000010, "Wrong size on FParticleDistancePrototype");
static_assert(offsetof(FParticleDistancePrototype, MaxDistance) == 0x000008, "Member 'FParticleDistancePrototype::MaxDistance' has a wrong offset!");

// ScriptStruct Stalker2.ParticleActorSpawnPrototype
// 0x0028 (0x0030 - 0x0008)
struct FParticleActorSpawnPrototype final : public FEnvironmentParticlePrototype
{
public:
	float                                         BaseSpawnProbability;                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnProbabilityIncrement;                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnProbabilityCheckTime;                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpawnDistance;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpawnDistance;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceHeightOffset;                               // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationCheckTime;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxParticleCount;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnInPlayerViewport;                            // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParticleActorSpawnPrototype) == 0x000008, "Wrong alignment on FParticleActorSpawnPrototype");
static_assert(sizeof(FParticleActorSpawnPrototype) == 0x000030, "Wrong size on FParticleActorSpawnPrototype");
static_assert(offsetof(FParticleActorSpawnPrototype, BaseSpawnProbability) == 0x000008, "Member 'FParticleActorSpawnPrototype::BaseSpawnProbability' has a wrong offset!");
static_assert(offsetof(FParticleActorSpawnPrototype, SpawnProbabilityIncrement) == 0x00000C, "Member 'FParticleActorSpawnPrototype::SpawnProbabilityIncrement' has a wrong offset!");
static_assert(offsetof(FParticleActorSpawnPrototype, SpawnProbabilityCheckTime) == 0x000010, "Member 'FParticleActorSpawnPrototype::SpawnProbabilityCheckTime' has a wrong offset!");
static_assert(offsetof(FParticleActorSpawnPrototype, MinSpawnDistance) == 0x000014, "Member 'FParticleActorSpawnPrototype::MinSpawnDistance' has a wrong offset!");
static_assert(offsetof(FParticleActorSpawnPrototype, MaxSpawnDistance) == 0x000018, "Member 'FParticleActorSpawnPrototype::MaxSpawnDistance' has a wrong offset!");
static_assert(offsetof(FParticleActorSpawnPrototype, SurfaceHeightOffset) == 0x00001C, "Member 'FParticleActorSpawnPrototype::SurfaceHeightOffset' has a wrong offset!");
static_assert(offsetof(FParticleActorSpawnPrototype, LocationCheckTime) == 0x000020, "Member 'FParticleActorSpawnPrototype::LocationCheckTime' has a wrong offset!");
static_assert(offsetof(FParticleActorSpawnPrototype, MaxParticleCount) == 0x000024, "Member 'FParticleActorSpawnPrototype::MaxParticleCount' has a wrong offset!");
static_assert(offsetof(FParticleActorSpawnPrototype, bSpawnInPlayerViewport) == 0x000028, "Member 'FParticleActorSpawnPrototype::bSpawnInPlayerViewport' has a wrong offset!");

// ScriptStruct Stalker2.ParticleActorComponentSpawnPrototype
// 0x0060 (0x0068 - 0x0008)
struct FParticleActorComponentSpawnPrototype final : public FEnvironmentParticlePrototype
{
public:
	struct FParticleActorSpawnPrototype           ActorSpawnPrototype;                               // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParticlePlayerComponentSpawnPrototype PlayerComponentSpawnPrototype;                     // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleActorComponentSpawnPrototype) == 0x000008, "Wrong alignment on FParticleActorComponentSpawnPrototype");
static_assert(sizeof(FParticleActorComponentSpawnPrototype) == 0x000068, "Wrong size on FParticleActorComponentSpawnPrototype");
static_assert(offsetof(FParticleActorComponentSpawnPrototype, ActorSpawnPrototype) == 0x000008, "Member 'FParticleActorComponentSpawnPrototype::ActorSpawnPrototype' has a wrong offset!");
static_assert(offsetof(FParticleActorComponentSpawnPrototype, PlayerComponentSpawnPrototype) == 0x000038, "Member 'FParticleActorComponentSpawnPrototype::PlayerComponentSpawnPrototype' has a wrong offset!");

// ScriptStruct Stalker2.EffectPrototypeSID
// 0x0040 (0x0040 - 0x0000)
struct FEffectPrototypeSID final
{
public:
	struct FPrototypeSID                          EffectSID;                                         // 0x0000(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectPrototypeSID) == 0x000008, "Wrong alignment on FEffectPrototypeSID");
static_assert(sizeof(FEffectPrototypeSID) == 0x000040, "Wrong size on FEffectPrototypeSID");
static_assert(offsetof(FEffectPrototypeSID, EffectSID) == 0x000000, "Member 'FEffectPrototypeSID::EffectSID' has a wrong offset!");

// ScriptStruct Stalker2.LightningStrikeDamagePrototype
// 0x0030 (0x0038 - 0x0008)
struct FLightningStrikeDamagePrototype final : public FEnvironmentParticlePrototype
{
public:
	float                                         PlayerHitProbability;                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerHitCheckTime;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightPriorityRadius;                              // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightPriorityUsageProbability;                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEffectPrototypeSID>            PlayerHitEffects;                                  // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEffectPrototypeSID>            NPCHitEffects;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightningStrikeDamagePrototype) == 0x000008, "Wrong alignment on FLightningStrikeDamagePrototype");
static_assert(sizeof(FLightningStrikeDamagePrototype) == 0x000038, "Wrong size on FLightningStrikeDamagePrototype");
static_assert(offsetof(FLightningStrikeDamagePrototype, PlayerHitProbability) == 0x000008, "Member 'FLightningStrikeDamagePrototype::PlayerHitProbability' has a wrong offset!");
static_assert(offsetof(FLightningStrikeDamagePrototype, PlayerHitCheckTime) == 0x00000C, "Member 'FLightningStrikeDamagePrototype::PlayerHitCheckTime' has a wrong offset!");
static_assert(offsetof(FLightningStrikeDamagePrototype, HeightPriorityRadius) == 0x000010, "Member 'FLightningStrikeDamagePrototype::HeightPriorityRadius' has a wrong offset!");
static_assert(offsetof(FLightningStrikeDamagePrototype, HeightPriorityUsageProbability) == 0x000014, "Member 'FLightningStrikeDamagePrototype::HeightPriorityUsageProbability' has a wrong offset!");
static_assert(offsetof(FLightningStrikeDamagePrototype, PlayerHitEffects) == 0x000018, "Member 'FLightningStrikeDamagePrototype::PlayerHitEffects' has a wrong offset!");
static_assert(offsetof(FLightningStrikeDamagePrototype, NPCHitEffects) == 0x000028, "Member 'FLightningStrikeDamagePrototype::NPCHitEffects' has a wrong offset!");

// ScriptStruct Stalker2.DynamicEnvironmentParticleDataRow
// 0x0348 (0x0350 - 0x0008)
struct FDynamicEnvironmentParticleDataRow final : public FTableRowBase
{
public:
	EDynamicParticleType                          ParticleType;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class UNiagaraParameterProvider>> Providers;                                    // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bCanSpawnOnWater;                                  // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopOnCutscene;                                   // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FParticleIndoorSpawnPrototype          IndoorSpawnPrototype;                              // 0x0068(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParticleBiomePrototype                BiomeSpawnPrototype;                               // 0x0098(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParticleDistancePrototype             PlayerDistancePrototype;                           // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParticleWindIntensityPrototype        WindIntensityPrototype;                            // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EWeather, struct FParticleActorSpawnPrototype> ActorSpawnPrototypes;                        // 0x00F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EWeather, struct FParticlePlayerComponentSpawnPrototype> PlayerComponentSpawnPrototypes;    // 0x0140(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EWeather, struct FParticleActorComponentSpawnPrototype> ActorComponentSpawnPrototypes;      // 0x0190(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UNiagaraSystem>>  ActorParticleVFXes;                                // 0x01E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          PlayerParticleVFX;                                 // 0x01F0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightningStrikeParticleVFXPrototype   LightningStrikeVFX;                                // 0x0220(0x00F8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLightningStrikeDamagePrototype        LightningStrikeDamagePrototype;                    // 0x0318(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDynamicEnvironmentParticleDataRow) == 0x000008, "Wrong alignment on FDynamicEnvironmentParticleDataRow");
static_assert(sizeof(FDynamicEnvironmentParticleDataRow) == 0x000350, "Wrong size on FDynamicEnvironmentParticleDataRow");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, ParticleType) == 0x000008, "Member 'FDynamicEnvironmentParticleDataRow::ParticleType' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, Providers) == 0x000010, "Member 'FDynamicEnvironmentParticleDataRow::Providers' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, bCanSpawnOnWater) == 0x000060, "Member 'FDynamicEnvironmentParticleDataRow::bCanSpawnOnWater' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, bStopOnCutscene) == 0x000061, "Member 'FDynamicEnvironmentParticleDataRow::bStopOnCutscene' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, IndoorSpawnPrototype) == 0x000068, "Member 'FDynamicEnvironmentParticleDataRow::IndoorSpawnPrototype' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, BiomeSpawnPrototype) == 0x000098, "Member 'FDynamicEnvironmentParticleDataRow::BiomeSpawnPrototype' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, PlayerDistancePrototype) == 0x0000D0, "Member 'FDynamicEnvironmentParticleDataRow::PlayerDistancePrototype' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, WindIntensityPrototype) == 0x0000E0, "Member 'FDynamicEnvironmentParticleDataRow::WindIntensityPrototype' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, ActorSpawnPrototypes) == 0x0000F0, "Member 'FDynamicEnvironmentParticleDataRow::ActorSpawnPrototypes' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, PlayerComponentSpawnPrototypes) == 0x000140, "Member 'FDynamicEnvironmentParticleDataRow::PlayerComponentSpawnPrototypes' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, ActorComponentSpawnPrototypes) == 0x000190, "Member 'FDynamicEnvironmentParticleDataRow::ActorComponentSpawnPrototypes' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, ActorParticleVFXes) == 0x0001E0, "Member 'FDynamicEnvironmentParticleDataRow::ActorParticleVFXes' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, PlayerParticleVFX) == 0x0001F0, "Member 'FDynamicEnvironmentParticleDataRow::PlayerParticleVFX' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, LightningStrikeVFX) == 0x000220, "Member 'FDynamicEnvironmentParticleDataRow::LightningStrikeVFX' has a wrong offset!");
static_assert(offsetof(FDynamicEnvironmentParticleDataRow, LightningStrikeDamagePrototype) == 0x000318, "Member 'FDynamicEnvironmentParticleDataRow::LightningStrikeDamagePrototype' has a wrong offset!");

// ScriptStruct Stalker2.QuestNodeCollection
// 0x0030 (0x0098 - 0x0068)
struct FQuestNodeCollection final : public FBaseTickAggregationCollection
{
public:
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestNodeCollection) == 0x000008, "Wrong alignment on FQuestNodeCollection");
static_assert(sizeof(FQuestNodeCollection) == 0x000098, "Wrong size on FQuestNodeCollection");

// ScriptStruct Stalker2.NavModifierHolder
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FNavModifierHolder final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavModifierHolder) == 0x000008, "Wrong alignment on FNavModifierHolder");
static_assert(sizeof(FNavModifierHolder) == 0x000030, "Wrong size on FNavModifierHolder");

// ScriptStruct Stalker2.ParticleWeatherPrototype
// 0x0010 (0x0018 - 0x0008)
struct FParticleWeatherPrototype final : public FParticleConditionPrototype
{
public:
	TArray<EWeather>                              AllowedWeatherTypes;                               // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleWeatherPrototype) == 0x000008, "Wrong alignment on FParticleWeatherPrototype");
static_assert(sizeof(FParticleWeatherPrototype) == 0x000018, "Wrong size on FParticleWeatherPrototype");
static_assert(offsetof(FParticleWeatherPrototype, AllowedWeatherTypes) == 0x000008, "Member 'FParticleWeatherPrototype::AllowedWeatherTypes' has a wrong offset!");

// ScriptStruct Stalker2.DebugRestrictionSettings
// 0x0020 (0x0020 - 0x0000)
struct FDebugRestrictionSettings final
{
public:
	TArray<TSubclassOf<class UNavArea>>           InRestrictedAreas;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UNavArea>>           OutRestrictedAreas;                                // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugRestrictionSettings) == 0x000008, "Wrong alignment on FDebugRestrictionSettings");
static_assert(sizeof(FDebugRestrictionSettings) == 0x000020, "Wrong size on FDebugRestrictionSettings");
static_assert(offsetof(FDebugRestrictionSettings, InRestrictedAreas) == 0x000000, "Member 'FDebugRestrictionSettings::InRestrictedAreas' has a wrong offset!");
static_assert(offsetof(FDebugRestrictionSettings, OutRestrictedAreas) == 0x000010, "Member 'FDebugRestrictionSettings::OutRestrictedAreas' has a wrong offset!");

// ScriptStruct Stalker2.ParticleLairPrototype
// 0x0018 (0x0020 - 0x0008)
struct FParticleLairPrototype final : public FParticleConditionPrototype
{
public:
	float                                         LairCheckDistance;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAgentType>                            AllowedNPCTypes;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleLairPrototype) == 0x000008, "Wrong alignment on FParticleLairPrototype");
static_assert(sizeof(FParticleLairPrototype) == 0x000020, "Wrong size on FParticleLairPrototype");
static_assert(offsetof(FParticleLairPrototype, LairCheckDistance) == 0x000008, "Member 'FParticleLairPrototype::LairCheckDistance' has a wrong offset!");
static_assert(offsetof(FParticleLairPrototype, AllowedNPCTypes) == 0x000010, "Member 'FParticleLairPrototype::AllowedNPCTypes' has a wrong offset!");

// ScriptStruct Stalker2.PhysicalManagerCollection
// 0x0010 (0x0078 - 0x0068)
struct FPhysicalManagerCollection final : public FBaseTickAggregationCollection
{
public:
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPhysicalManagerCollection) == 0x000008, "Wrong alignment on FPhysicalManagerCollection");
static_assert(sizeof(FPhysicalManagerCollection) == 0x000078, "Wrong size on FPhysicalManagerCollection");

// ScriptStruct Stalker2.DynamicObstacleAvoidanceSystemSettings
// 0x0008 (0x0008 - 0x0000)
struct FDynamicObstacleAvoidanceSystemSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxUpdateAgentsPerTick;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDynamicObstacleAvoidanceSystemSettings) == 0x000004, "Wrong alignment on FDynamicObstacleAvoidanceSystemSettings");
static_assert(sizeof(FDynamicObstacleAvoidanceSystemSettings) == 0x000008, "Wrong size on FDynamicObstacleAvoidanceSystemSettings");
static_assert(offsetof(FDynamicObstacleAvoidanceSystemSettings, bEnabled) == 0x000000, "Member 'FDynamicObstacleAvoidanceSystemSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceSystemSettings, MaxUpdateAgentsPerTick) == 0x000004, "Member 'FDynamicObstacleAvoidanceSystemSettings::MaxUpdateAgentsPerTick' has a wrong offset!");

// ScriptStruct Stalker2.NoteFilterSettings
// 0x0008 (0x0008 - 0x0000)
struct FNoteFilterSettings final
{
public:
	bool                                          bIsEnableFilter;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ENoteType                                     Filter;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNoteFilterSettings) == 0x000004, "Wrong alignment on FNoteFilterSettings");
static_assert(sizeof(FNoteFilterSettings) == 0x000008, "Wrong size on FNoteFilterSettings");
static_assert(offsetof(FNoteFilterSettings, bIsEnableFilter) == 0x000000, "Member 'FNoteFilterSettings::bIsEnableFilter' has a wrong offset!");
static_assert(offsetof(FNoteFilterSettings, Filter) == 0x000004, "Member 'FNoteFilterSettings::Filter' has a wrong offset!");

// ScriptStruct Stalker2.DynamicObstacleAvoidanceQuerrySettings
// 0x0018 (0x0018 - 0x0000)
struct FDynamicObstacleAvoidanceQuerrySettings final
{
public:
	float                                         StartTrackingDistance;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTrackingOffset;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreferredAvoidanceCorridorWidth;                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCorridorSectionLength;                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObstaclesQueryDistance;                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentMinAvoidanceSampleStep;                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDynamicObstacleAvoidanceQuerrySettings) == 0x000004, "Wrong alignment on FDynamicObstacleAvoidanceQuerrySettings");
static_assert(sizeof(FDynamicObstacleAvoidanceQuerrySettings) == 0x000018, "Wrong size on FDynamicObstacleAvoidanceQuerrySettings");
static_assert(offsetof(FDynamicObstacleAvoidanceQuerrySettings, StartTrackingDistance) == 0x000000, "Member 'FDynamicObstacleAvoidanceQuerrySettings::StartTrackingDistance' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceQuerrySettings, EndTrackingOffset) == 0x000004, "Member 'FDynamicObstacleAvoidanceQuerrySettings::EndTrackingOffset' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceQuerrySettings, PreferredAvoidanceCorridorWidth) == 0x000008, "Member 'FDynamicObstacleAvoidanceQuerrySettings::PreferredAvoidanceCorridorWidth' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceQuerrySettings, MaxCorridorSectionLength) == 0x00000C, "Member 'FDynamicObstacleAvoidanceQuerrySettings::MaxCorridorSectionLength' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceQuerrySettings, ObstaclesQueryDistance) == 0x000010, "Member 'FDynamicObstacleAvoidanceQuerrySettings::ObstaclesQueryDistance' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceQuerrySettings, AgentMinAvoidanceSampleStep) == 0x000014, "Member 'FDynamicObstacleAvoidanceQuerrySettings::AgentMinAvoidanceSampleStep' has a wrong offset!");

// ScriptStruct Stalker2.DynamicObstacleAvoidanceAgentSettings
// 0x0020 (0x0020 - 0x0000)
struct FDynamicObstacleAvoidanceAgentSettings final
{
public:
	float                                         AgentAvoidanceRadiusMargin;                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinMovementSpeed;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentTimeOfImpactToConsiderWaiting;                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedRecoveryTimeout;                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentPriorityTimeout;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentRepathingTimeout;                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentFailMovementTimeout;                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPriorityAgent;                                // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMergeObstacles;                                   // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanFailMovement;                                  // 0x001E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDynamicObstacleAvoidanceAgentSettings) == 0x000004, "Wrong alignment on FDynamicObstacleAvoidanceAgentSettings");
static_assert(sizeof(FDynamicObstacleAvoidanceAgentSettings) == 0x000020, "Wrong size on FDynamicObstacleAvoidanceAgentSettings");
static_assert(offsetof(FDynamicObstacleAvoidanceAgentSettings, AgentAvoidanceRadiusMargin) == 0x000000, "Member 'FDynamicObstacleAvoidanceAgentSettings::AgentAvoidanceRadiusMargin' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceAgentSettings, MinMovementSpeed) == 0x000004, "Member 'FDynamicObstacleAvoidanceAgentSettings::MinMovementSpeed' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceAgentSettings, AgentTimeOfImpactToConsiderWaiting) == 0x000008, "Member 'FDynamicObstacleAvoidanceAgentSettings::AgentTimeOfImpactToConsiderWaiting' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceAgentSettings, SpeedRecoveryTimeout) == 0x00000C, "Member 'FDynamicObstacleAvoidanceAgentSettings::SpeedRecoveryTimeout' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceAgentSettings, AgentPriorityTimeout) == 0x000010, "Member 'FDynamicObstacleAvoidanceAgentSettings::AgentPriorityTimeout' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceAgentSettings, AgentRepathingTimeout) == 0x000014, "Member 'FDynamicObstacleAvoidanceAgentSettings::AgentRepathingTimeout' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceAgentSettings, AgentFailMovementTimeout) == 0x000018, "Member 'FDynamicObstacleAvoidanceAgentSettings::AgentFailMovementTimeout' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceAgentSettings, AllowPriorityAgent) == 0x00001C, "Member 'FDynamicObstacleAvoidanceAgentSettings::AllowPriorityAgent' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceAgentSettings, bMergeObstacles) == 0x00001D, "Member 'FDynamicObstacleAvoidanceAgentSettings::bMergeObstacles' has a wrong offset!");
static_assert(offsetof(FDynamicObstacleAvoidanceAgentSettings, bCanFailMovement) == 0x00001E, "Member 'FDynamicObstacleAvoidanceAgentSettings::bCanFailMovement' has a wrong offset!");

// ScriptStruct Stalker2.ParticleExplosionPrototype
// 0x0008 (0x0010 - 0x0008)
struct FParticleExplosionPrototype final : public FEnvironmentParticlePrototype
{
public:
	float                                         ExplosionDistance;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParticleExplosionPrototype) == 0x000008, "Wrong alignment on FParticleExplosionPrototype");
static_assert(sizeof(FParticleExplosionPrototype) == 0x000010, "Wrong size on FParticleExplosionPrototype");
static_assert(offsetof(FParticleExplosionPrototype, ExplosionDistance) == 0x000008, "Member 'FParticleExplosionPrototype::ExplosionDistance' has a wrong offset!");

// ScriptStruct Stalker2.ElectroAnomalyBakedData
// 0x0038 (0x0038 - 0x0000)
struct FElectroAnomalyBakedData final
{
public:
	int32                                         CirclePointsCount;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        TraceStartPoints;                                  // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        TraceEndPoints;                                    // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        TraceUpVectors;                                    // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FElectroAnomalyBakedData) == 0x000008, "Wrong alignment on FElectroAnomalyBakedData");
static_assert(sizeof(FElectroAnomalyBakedData) == 0x000038, "Wrong size on FElectroAnomalyBakedData");
static_assert(offsetof(FElectroAnomalyBakedData, CirclePointsCount) == 0x000000, "Member 'FElectroAnomalyBakedData::CirclePointsCount' has a wrong offset!");
static_assert(offsetof(FElectroAnomalyBakedData, TraceStartPoints) == 0x000008, "Member 'FElectroAnomalyBakedData::TraceStartPoints' has a wrong offset!");
static_assert(offsetof(FElectroAnomalyBakedData, TraceEndPoints) == 0x000018, "Member 'FElectroAnomalyBakedData::TraceEndPoints' has a wrong offset!");
static_assert(offsetof(FElectroAnomalyBakedData, TraceUpVectors) == 0x000028, "Member 'FElectroAnomalyBakedData::TraceUpVectors' has a wrong offset!");

// ScriptStruct Stalker2.ElectroAnomalyBakedDataFloat
// 0x0038 (0x0038 - 0x0000)
struct FElectroAnomalyBakedDataFloat final
{
public:
	int32                                         CirclePointsCount;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector3f>                      TraceStartPoints;                                  // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector3f>                      TraceEndPoints;                                    // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector3f>                      TraceUpVectors;                                    // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FElectroAnomalyBakedDataFloat) == 0x000008, "Wrong alignment on FElectroAnomalyBakedDataFloat");
static_assert(sizeof(FElectroAnomalyBakedDataFloat) == 0x000038, "Wrong size on FElectroAnomalyBakedDataFloat");
static_assert(offsetof(FElectroAnomalyBakedDataFloat, CirclePointsCount) == 0x000000, "Member 'FElectroAnomalyBakedDataFloat::CirclePointsCount' has a wrong offset!");
static_assert(offsetof(FElectroAnomalyBakedDataFloat, TraceStartPoints) == 0x000008, "Member 'FElectroAnomalyBakedDataFloat::TraceStartPoints' has a wrong offset!");
static_assert(offsetof(FElectroAnomalyBakedDataFloat, TraceEndPoints) == 0x000018, "Member 'FElectroAnomalyBakedDataFloat::TraceEndPoints' has a wrong offset!");
static_assert(offsetof(FElectroAnomalyBakedDataFloat, TraceUpVectors) == 0x000028, "Member 'FElectroAnomalyBakedDataFloat::TraceUpVectors' has a wrong offset!");

// ScriptStruct Stalker2.TutorialFilterSettings
// 0x0008 (0x0008 - 0x0000)
struct FTutorialFilterSettings final
{
public:
	bool                                          bIsEnableFilter;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EPDATutorialCategory                          Filter;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialFilterSettings) == 0x000004, "Wrong alignment on FTutorialFilterSettings");
static_assert(sizeof(FTutorialFilterSettings) == 0x000008, "Wrong size on FTutorialFilterSettings");
static_assert(offsetof(FTutorialFilterSettings, bIsEnableFilter) == 0x000000, "Member 'FTutorialFilterSettings::bIsEnableFilter' has a wrong offset!");
static_assert(offsetof(FTutorialFilterSettings, Filter) == 0x000004, "Member 'FTutorialFilterSettings::Filter' has a wrong offset!");

// ScriptStruct Stalker2.ObjPrototypeSID
// 0x0040 (0x0040 - 0x0000)
struct FObjPrototypeSID final
{
public:
	struct FPrototypeSID                          ObjSID;                                            // 0x0000(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjPrototypeSID) == 0x000008, "Wrong alignment on FObjPrototypeSID");
static_assert(sizeof(FObjPrototypeSID) == 0x000040, "Wrong size on FObjPrototypeSID");
static_assert(offsetof(FObjPrototypeSID, ObjSID) == 0x000000, "Member 'FObjPrototypeSID::ObjSID' has a wrong offset!");

// ScriptStruct Stalker2.EncounterSpawnPointData
// 0x00B0 (0x00B0 - 0x0000)
struct FEncounterSpawnPointData final
{
public:
	struct FTransform                             SpawnTransform;                                    // 0x0000(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FObjPrototypeSID                       ObjPrototypeSID;                                   // 0x0060(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EPsyNPCType                                   PsyNPCType;                                        // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0xF];                                       // 0x00A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEncounterSpawnPointData) == 0x000010, "Wrong alignment on FEncounterSpawnPointData");
static_assert(sizeof(FEncounterSpawnPointData) == 0x0000B0, "Wrong size on FEncounterSpawnPointData");
static_assert(offsetof(FEncounterSpawnPointData, SpawnTransform) == 0x000000, "Member 'FEncounterSpawnPointData::SpawnTransform' has a wrong offset!");
static_assert(offsetof(FEncounterSpawnPointData, ObjPrototypeSID) == 0x000060, "Member 'FEncounterSpawnPointData::ObjPrototypeSID' has a wrong offset!");
static_assert(offsetof(FEncounterSpawnPointData, PsyNPCType) == 0x0000A0, "Member 'FEncounterSpawnPointData::PsyNPCType' has a wrong offset!");

// ScriptStruct Stalker2.EquipUnequipAnimations
// 0x0018 (0x0018 - 0x0000)
struct FEquipUnequipAnimations final
{
public:
	class UAnimMontage*                           Equip;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Unequip;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FastUnequip;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipUnequipAnimations) == 0x000008, "Wrong alignment on FEquipUnequipAnimations");
static_assert(sizeof(FEquipUnequipAnimations) == 0x000018, "Wrong size on FEquipUnequipAnimations");
static_assert(offsetof(FEquipUnequipAnimations, Equip) == 0x000000, "Member 'FEquipUnequipAnimations::Equip' has a wrong offset!");
static_assert(offsetof(FEquipUnequipAnimations, Unequip) == 0x000008, "Member 'FEquipUnequipAnimations::Unequip' has a wrong offset!");
static_assert(offsetof(FEquipUnequipAnimations, FastUnequip) == 0x000010, "Member 'FEquipUnequipAnimations::FastUnequip' has a wrong offset!");

// ScriptStruct Stalker2.AnimWeaponSwingContainer
// 0x0038 (0x0038 - 0x0000)
struct FAnimWeaponSwingContainer final
{
public:
	class UCurveFloat*                            ItemRotationCurve;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ItemHorizontalTranslationShiftCurve;               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ItemSocketHorizontalTranslationShiftCurve;         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ItemVerticalTranslationShiftCurve;                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ItemExtraVerticalTranslationShiftCurve;            // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalItemTranslationInterpSpeed;              // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalItemTranslationInterpSpeed;                // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemRotationInterpSpeed;                           // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimWeaponSwingContainer) == 0x000008, "Wrong alignment on FAnimWeaponSwingContainer");
static_assert(sizeof(FAnimWeaponSwingContainer) == 0x000038, "Wrong size on FAnimWeaponSwingContainer");
static_assert(offsetof(FAnimWeaponSwingContainer, ItemRotationCurve) == 0x000000, "Member 'FAnimWeaponSwingContainer::ItemRotationCurve' has a wrong offset!");
static_assert(offsetof(FAnimWeaponSwingContainer, ItemHorizontalTranslationShiftCurve) == 0x000008, "Member 'FAnimWeaponSwingContainer::ItemHorizontalTranslationShiftCurve' has a wrong offset!");
static_assert(offsetof(FAnimWeaponSwingContainer, ItemSocketHorizontalTranslationShiftCurve) == 0x000010, "Member 'FAnimWeaponSwingContainer::ItemSocketHorizontalTranslationShiftCurve' has a wrong offset!");
static_assert(offsetof(FAnimWeaponSwingContainer, ItemVerticalTranslationShiftCurve) == 0x000018, "Member 'FAnimWeaponSwingContainer::ItemVerticalTranslationShiftCurve' has a wrong offset!");
static_assert(offsetof(FAnimWeaponSwingContainer, ItemExtraVerticalTranslationShiftCurve) == 0x000020, "Member 'FAnimWeaponSwingContainer::ItemExtraVerticalTranslationShiftCurve' has a wrong offset!");
static_assert(offsetof(FAnimWeaponSwingContainer, HorizontalItemTranslationInterpSpeed) == 0x000028, "Member 'FAnimWeaponSwingContainer::HorizontalItemTranslationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimWeaponSwingContainer, VerticalItemTranslationInterpSpeed) == 0x00002C, "Member 'FAnimWeaponSwingContainer::VerticalItemTranslationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimWeaponSwingContainer, ItemRotationInterpSpeed) == 0x000030, "Member 'FAnimWeaponSwingContainer::ItemRotationInterpSpeed' has a wrong offset!");

// ScriptStruct Stalker2.WeaponInertiaContainer
// 0x0020 (0x0020 - 0x0000)
struct FWeaponInertiaContainer final
{
public:
	class UCurveVector*                           InertiaRotationCurve;                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           InertiaTranslationCurve;                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            InertiaTimeScaleCurve;                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AmplitudeScaleCurve;                               // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponInertiaContainer) == 0x000008, "Wrong alignment on FWeaponInertiaContainer");
static_assert(sizeof(FWeaponInertiaContainer) == 0x000020, "Wrong size on FWeaponInertiaContainer");
static_assert(offsetof(FWeaponInertiaContainer, InertiaRotationCurve) == 0x000000, "Member 'FWeaponInertiaContainer::InertiaRotationCurve' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaContainer, InertiaTranslationCurve) == 0x000008, "Member 'FWeaponInertiaContainer::InertiaTranslationCurve' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaContainer, InertiaTimeScaleCurve) == 0x000010, "Member 'FWeaponInertiaContainer::InertiaTimeScaleCurve' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaContainer, AmplitudeScaleCurve) == 0x000018, "Member 'FWeaponInertiaContainer::AmplitudeScaleCurve' has a wrong offset!");

// ScriptStruct Stalker2.WeaponPushbackContainer
// 0x0038 (0x0038 - 0x0000)
struct FWeaponPushbackContainer final
{
public:
	float                                         DelayBeforeBlendStarting;                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlendArgs                        BlendInArgs;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAlphaBlendArgs                        BlendOutArgs;                                      // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveVector*                           PushbackRotationCurve;                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           PushbackTranslationCurve;                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponPushbackContainer) == 0x000008, "Wrong alignment on FWeaponPushbackContainer");
static_assert(sizeof(FWeaponPushbackContainer) == 0x000038, "Wrong size on FWeaponPushbackContainer");
static_assert(offsetof(FWeaponPushbackContainer, DelayBeforeBlendStarting) == 0x000000, "Member 'FWeaponPushbackContainer::DelayBeforeBlendStarting' has a wrong offset!");
static_assert(offsetof(FWeaponPushbackContainer, BlendInArgs) == 0x000008, "Member 'FWeaponPushbackContainer::BlendInArgs' has a wrong offset!");
static_assert(offsetof(FWeaponPushbackContainer, BlendOutArgs) == 0x000018, "Member 'FWeaponPushbackContainer::BlendOutArgs' has a wrong offset!");
static_assert(offsetof(FWeaponPushbackContainer, PushbackRotationCurve) == 0x000028, "Member 'FWeaponPushbackContainer::PushbackRotationCurve' has a wrong offset!");
static_assert(offsetof(FWeaponPushbackContainer, PushbackTranslationCurve) == 0x000030, "Member 'FWeaponPushbackContainer::PushbackTranslationCurve' has a wrong offset!");

// ScriptStruct Stalker2.PlayerWeaponIdlingAnimations
// 0x0018 (0x0018 - 0x0000)
struct FPlayerWeaponIdlingAnimations final
{
public:
	float                                         TimeToLaunchInactiveIdle;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterItemWeightedAnimations> Idles;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerWeaponIdlingAnimations) == 0x000008, "Wrong alignment on FPlayerWeaponIdlingAnimations");
static_assert(sizeof(FPlayerWeaponIdlingAnimations) == 0x000018, "Wrong size on FPlayerWeaponIdlingAnimations");
static_assert(offsetof(FPlayerWeaponIdlingAnimations, TimeToLaunchInactiveIdle) == 0x000000, "Member 'FPlayerWeaponIdlingAnimations::TimeToLaunchInactiveIdle' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponIdlingAnimations, Idles) == 0x000008, "Member 'FPlayerWeaponIdlingAnimations::Idles' has a wrong offset!");

// ScriptStruct Stalker2.PlayerWeaponAnimations
// 0x0230 (0x0230 - 0x0000)
struct FPlayerWeaponAnimations final
{
public:
	class UPlayerAnimCollection*                  AnimCollection;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UPlayerFirearmAnimCollection*> AttachWeaponAnimCollections;              // 0x0008(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	class UClass*                                 PlayerAnimBlueprint;                               // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             EquipWeapon;                                       // 0x0060(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             UnequipWeapon;                                     // 0x0080(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AttachSelectorUnequip;                             // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEquipUnequipAnimations                RemoveReturnLeftHand;                              // 0x00A8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimWeaponSwingContainer              WeaponSwingConfigInHip;                            // 0x00C0(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimWeaponSwingContainer              WeaponSwingConfigInAim;                            // 0x00F8(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponInertiaContainer                StopHipSwingInertia;                               // 0x0130(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponInertiaContainer                StopAimSwingInertia;                               // 0x0150(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponInertiaContainer                SprintStopInertia;                                 // 0x0170(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponPushbackContainer               HipPushback;                                       // 0x0190(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FWeaponPushbackContainer> AimPushback;                                  // 0x01C8(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FPlayerWeaponIdlingAnimations          InactiveLongIdles;                                 // 0x0218(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerWeaponAnimations) == 0x000008, "Wrong alignment on FPlayerWeaponAnimations");
static_assert(sizeof(FPlayerWeaponAnimations) == 0x000230, "Wrong size on FPlayerWeaponAnimations");
static_assert(offsetof(FPlayerWeaponAnimations, AnimCollection) == 0x000000, "Member 'FPlayerWeaponAnimations::AnimCollection' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, AttachWeaponAnimCollections) == 0x000008, "Member 'FPlayerWeaponAnimations::AttachWeaponAnimCollections' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, PlayerAnimBlueprint) == 0x000058, "Member 'FPlayerWeaponAnimations::PlayerAnimBlueprint' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, EquipWeapon) == 0x000060, "Member 'FPlayerWeaponAnimations::EquipWeapon' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, UnequipWeapon) == 0x000080, "Member 'FPlayerWeaponAnimations::UnequipWeapon' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, AttachSelectorUnequip) == 0x0000A0, "Member 'FPlayerWeaponAnimations::AttachSelectorUnequip' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, RemoveReturnLeftHand) == 0x0000A8, "Member 'FPlayerWeaponAnimations::RemoveReturnLeftHand' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, WeaponSwingConfigInHip) == 0x0000C0, "Member 'FPlayerWeaponAnimations::WeaponSwingConfigInHip' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, WeaponSwingConfigInAim) == 0x0000F8, "Member 'FPlayerWeaponAnimations::WeaponSwingConfigInAim' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, StopHipSwingInertia) == 0x000130, "Member 'FPlayerWeaponAnimations::StopHipSwingInertia' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, StopAimSwingInertia) == 0x000150, "Member 'FPlayerWeaponAnimations::StopAimSwingInertia' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, SprintStopInertia) == 0x000170, "Member 'FPlayerWeaponAnimations::SprintStopInertia' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, HipPushback) == 0x000190, "Member 'FPlayerWeaponAnimations::HipPushback' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, AimPushback) == 0x0001C8, "Member 'FPlayerWeaponAnimations::AimPushback' has a wrong offset!");
static_assert(offsetof(FPlayerWeaponAnimations, InactiveLongIdles) == 0x000218, "Member 'FPlayerWeaponAnimations::InactiveLongIdles' has a wrong offset!");

// ScriptStruct Stalker2.EquipmentItemSlot
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FEquipmentItemSlot final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEquipmentItemSlot) == 0x000008, "Wrong alignment on FEquipmentItemSlot");
static_assert(sizeof(FEquipmentItemSlot) == 0x000018, "Wrong size on FEquipmentItemSlot");

// ScriptStruct Stalker2.EquipmentNavigationPath
// 0x0018 (0x0018 - 0x0000)
struct FEquipmentNavigationPath final
{
public:
	double                                        MinAngle;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxAngle;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventoryEquipmentSlot                       TargetSlot;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEquipmentNavigationPath) == 0x000008, "Wrong alignment on FEquipmentNavigationPath");
static_assert(sizeof(FEquipmentNavigationPath) == 0x000018, "Wrong size on FEquipmentNavigationPath");
static_assert(offsetof(FEquipmentNavigationPath, MinAngle) == 0x000000, "Member 'FEquipmentNavigationPath::MinAngle' has a wrong offset!");
static_assert(offsetof(FEquipmentNavigationPath, MaxAngle) == 0x000008, "Member 'FEquipmentNavigationPath::MaxAngle' has a wrong offset!");
static_assert(offsetof(FEquipmentNavigationPath, TargetSlot) == 0x000010, "Member 'FEquipmentNavigationPath::TargetSlot' has a wrong offset!");

// ScriptStruct Stalker2.InputStoryDataEntry
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FInputStoryDataEntry final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputStoryDataEntry) == 0x000008, "Wrong alignment on FInputStoryDataEntry");
static_assert(sizeof(FInputStoryDataEntry) == 0x000018, "Wrong size on FInputStoryDataEntry");

// ScriptStruct Stalker2.EquipmentNavigationPaths
// 0x0010 (0x0010 - 0x0000)
struct FEquipmentNavigationPaths final
{
public:
	TArray<struct FEquipmentNavigationPath>       NavigationPaths;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipmentNavigationPaths) == 0x000008, "Wrong alignment on FEquipmentNavigationPaths");
static_assert(sizeof(FEquipmentNavigationPaths) == 0x000010, "Wrong size on FEquipmentNavigationPaths");
static_assert(offsetof(FEquipmentNavigationPaths, NavigationPaths) == 0x000000, "Member 'FEquipmentNavigationPaths::NavigationPaths' has a wrong offset!");

// ScriptStruct Stalker2.FactionSelector
// 0x0060 (0x0060 - 0x0000)
struct FFactionSelector final
{
public:
	class FString                                 Value;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FString>                           AllowedFactionsFilter;                             // 0x0010(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFactionSelector) == 0x000008, "Wrong alignment on FFactionSelector");
static_assert(sizeof(FFactionSelector) == 0x000060, "Wrong size on FFactionSelector");
static_assert(offsetof(FFactionSelector, Value) == 0x000000, "Member 'FFactionSelector::Value' has a wrong offset!");
static_assert(offsetof(FFactionSelector, AllowedFactionsFilter) == 0x000010, "Member 'FFactionSelector::AllowedFactionsFilter' has a wrong offset!");

// ScriptStruct Stalker2.QuestStageSelectSettings
// 0x0028 (0x0028 - 0x0000)
struct FQuestStageSelectSettings final
{
public:
	struct FLinearColor                           CollorMein;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CollorSecondary;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestStageSelectSettings) == 0x000008, "Wrong alignment on FQuestStageSelectSettings");
static_assert(sizeof(FQuestStageSelectSettings) == 0x000028, "Wrong size on FQuestStageSelectSettings");
static_assert(offsetof(FQuestStageSelectSettings, CollorMein) == 0x000000, "Member 'FQuestStageSelectSettings::CollorMein' has a wrong offset!");
static_assert(offsetof(FQuestStageSelectSettings, CollorSecondary) == 0x000010, "Member 'FQuestStageSelectSettings::CollorSecondary' has a wrong offset!");
static_assert(offsetof(FQuestStageSelectSettings, Icon) == 0x000020, "Member 'FQuestStageSelectSettings::Icon' has a wrong offset!");

// ScriptStruct Stalker2.FactionSelectorArray
// 0x0010 (0x0010 - 0x0000)
struct FFactionSelectorArray final
{
public:
	TArray<struct FFactionSelector>               Factions;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFactionSelectorArray) == 0x000008, "Wrong alignment on FFactionSelectorArray");
static_assert(sizeof(FFactionSelectorArray) == 0x000010, "Wrong size on FFactionSelectorArray");
static_assert(offsetof(FFactionSelectorArray, Factions) == 0x000000, "Member 'FFactionSelectorArray::Factions' has a wrong offset!");

// ScriptStruct Stalker2.FireTypeSlotSettings
// 0x0008 (0x0008 - 0x0000)
struct FFireTypeSlotSettings final
{
public:
	class UTexture*                               BackgroundTexture;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFireTypeSlotSettings) == 0x000008, "Wrong alignment on FFireTypeSlotSettings");
static_assert(sizeof(FFireTypeSlotSettings) == 0x000008, "Wrong size on FFireTypeSlotSettings");
static_assert(offsetof(FFireTypeSlotSettings, BackgroundTexture) == 0x000000, "Member 'FFireTypeSlotSettings::BackgroundTexture' has a wrong offset!");

// ScriptStruct Stalker2.FogParams
// 0x000C (0x000C - 0x0000)
struct FFogParams final
{
public:
	float                                         Density;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         Height;                                            // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFogParams) == 0x000004, "Wrong alignment on FFogParams");
static_assert(sizeof(FFogParams) == 0x00000C, "Wrong size on FFogParams");
static_assert(offsetof(FFogParams, Density) == 0x000000, "Member 'FFogParams::Density' has a wrong offset!");
static_assert(offsetof(FFogParams, Height) == 0x000004, "Member 'FFogParams::Height' has a wrong offset!");

// ScriptStruct Stalker2.ProcessorsArray
// 0x0010 (0x0010 - 0x0000)
struct FProcessorsArray final
{
public:
	TArray<class UForceFeedbackProcessorBase*>    ListOfProcessors;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProcessorsArray) == 0x000008, "Wrong alignment on FProcessorsArray");
static_assert(sizeof(FProcessorsArray) == 0x000010, "Wrong size on FProcessorsArray");
static_assert(offsetof(FProcessorsArray, ListOfProcessors) == 0x000000, "Member 'FProcessorsArray::ListOfProcessors' has a wrong offset!");

// ScriptStruct Stalker2.AttachDetachAnimations
// 0x0068 (0x0068 - 0x0000)
struct FAttachDetachAnimations final
{
public:
	struct FCharacterWeaponAnimations             AttachAnimation;                                   // 0x0000(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             DetachAnimation;                                   // 0x0020(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             DetachTwinMagazineShifted;                         // 0x0040(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UClass*                                 AttachAnimBlueprint;                               // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttachDetachAnimations) == 0x000008, "Wrong alignment on FAttachDetachAnimations");
static_assert(sizeof(FAttachDetachAnimations) == 0x000068, "Wrong size on FAttachDetachAnimations");
static_assert(offsetof(FAttachDetachAnimations, AttachAnimation) == 0x000000, "Member 'FAttachDetachAnimations::AttachAnimation' has a wrong offset!");
static_assert(offsetof(FAttachDetachAnimations, DetachAnimation) == 0x000020, "Member 'FAttachDetachAnimations::DetachAnimation' has a wrong offset!");
static_assert(offsetof(FAttachDetachAnimations, DetachTwinMagazineShifted) == 0x000040, "Member 'FAttachDetachAnimations::DetachTwinMagazineShifted' has a wrong offset!");
static_assert(offsetof(FAttachDetachAnimations, AttachAnimBlueprint) == 0x000060, "Member 'FAttachDetachAnimations::AttachAnimBlueprint' has a wrong offset!");

// ScriptStruct Stalker2.ForceFeedbackParams
// 0x000C (0x000C - 0x0000)
struct FForceFeedbackParams final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTimeDilation;                               // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayWhilePaused;                                  // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FForceFeedbackParams) == 0x000004, "Wrong alignment on FForceFeedbackParams");
static_assert(sizeof(FForceFeedbackParams) == 0x00000C, "Wrong size on FForceFeedbackParams");
static_assert(offsetof(FForceFeedbackParams, Tag) == 0x000000, "Member 'FForceFeedbackParams::Tag' has a wrong offset!");
static_assert(offsetof(FForceFeedbackParams, bLooping) == 0x000008, "Member 'FForceFeedbackParams::bLooping' has a wrong offset!");
static_assert(offsetof(FForceFeedbackParams, bIgnoreTimeDilation) == 0x000009, "Member 'FForceFeedbackParams::bIgnoreTimeDilation' has a wrong offset!");
static_assert(offsetof(FForceFeedbackParams, bPlayWhilePaused) == 0x00000A, "Member 'FForceFeedbackParams::bPlayWhilePaused' has a wrong offset!");

// ScriptStruct Stalker2.GameGraphSceneProxyDrawParams
// 0x0010 (0x0010 - 0x0000)
struct FGameGraphSceneProxyDrawParams final
{
public:
	bool                                          bEnableMinMaxPathColoring;                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAgentSupportMaskColoring;                   // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableComponentColoring;                          // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePolyBindConnectivityColoring;               // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugContextualActions;                           // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PolyBindConnectivityNavDataIdx;                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DefaultGGColor;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameGraphSceneProxyDrawParams) == 0x000004, "Wrong alignment on FGameGraphSceneProxyDrawParams");
static_assert(sizeof(FGameGraphSceneProxyDrawParams) == 0x000010, "Wrong size on FGameGraphSceneProxyDrawParams");
static_assert(offsetof(FGameGraphSceneProxyDrawParams, bEnableMinMaxPathColoring) == 0x000000, "Member 'FGameGraphSceneProxyDrawParams::bEnableMinMaxPathColoring' has a wrong offset!");
static_assert(offsetof(FGameGraphSceneProxyDrawParams, bEnableAgentSupportMaskColoring) == 0x000001, "Member 'FGameGraphSceneProxyDrawParams::bEnableAgentSupportMaskColoring' has a wrong offset!");
static_assert(offsetof(FGameGraphSceneProxyDrawParams, bEnableComponentColoring) == 0x000002, "Member 'FGameGraphSceneProxyDrawParams::bEnableComponentColoring' has a wrong offset!");
static_assert(offsetof(FGameGraphSceneProxyDrawParams, bEnablePolyBindConnectivityColoring) == 0x000003, "Member 'FGameGraphSceneProxyDrawParams::bEnablePolyBindConnectivityColoring' has a wrong offset!");
static_assert(offsetof(FGameGraphSceneProxyDrawParams, bDebugContextualActions) == 0x000004, "Member 'FGameGraphSceneProxyDrawParams::bDebugContextualActions' has a wrong offset!");
static_assert(offsetof(FGameGraphSceneProxyDrawParams, PolyBindConnectivityNavDataIdx) == 0x000008, "Member 'FGameGraphSceneProxyDrawParams::PolyBindConnectivityNavDataIdx' has a wrong offset!");
static_assert(offsetof(FGameGraphSceneProxyDrawParams, DefaultGGColor) == 0x00000C, "Member 'FGameGraphSceneProxyDrawParams::DefaultGGColor' has a wrong offset!");

// ScriptStruct Stalker2.GameGraphContextualAction
// 0x0010 (0x0010 - 0x0000)
struct FGameGraphContextualAction final
{
public:
	struct FGuid                                  QuestGuid;                                         // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameGraphContextualAction) == 0x000004, "Wrong alignment on FGameGraphContextualAction");
static_assert(sizeof(FGameGraphContextualAction) == 0x000010, "Wrong size on FGameGraphContextualAction");
static_assert(offsetof(FGameGraphContextualAction, QuestGuid) == 0x000000, "Member 'FGameGraphContextualAction::QuestGuid' has a wrong offset!");

// ScriptStruct Stalker2.GameGraphContextualActions
// 0x0010 (0x0010 - 0x0000)
struct FGameGraphContextualActions final
{
public:
	TArray<struct FGameGraphContextualAction>     ContextualActions;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameGraphContextualActions) == 0x000008, "Wrong alignment on FGameGraphContextualActions");
static_assert(sizeof(FGameGraphContextualActions) == 0x000010, "Wrong size on FGameGraphContextualActions");
static_assert(offsetof(FGameGraphContextualActions, ContextualActions) == 0x000000, "Member 'FGameGraphContextualActions::ContextualActions' has a wrong offset!");

// ScriptStruct Stalker2.ContextualActionsGameGraphInfo
// 0x0010 (0x0010 - 0x0000)
struct FContextualActionsGameGraphInfo final
{
public:
	TArray<uint32>                                GameGraphVertices;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContextualActionsGameGraphInfo) == 0x000008, "Wrong alignment on FContextualActionsGameGraphInfo");
static_assert(sizeof(FContextualActionsGameGraphInfo) == 0x000010, "Wrong size on FContextualActionsGameGraphInfo");
static_assert(offsetof(FContextualActionsGameGraphInfo, GameGraphVertices) == 0x000000, "Member 'FContextualActionsGameGraphInfo::GameGraphVertices' has a wrong offset!");

// ScriptStruct Stalker2.ChangeFireTypeAnimations
// 0x0010 (0x0010 - 0x0000)
struct FChangeFireTypeAnimations final
{
public:
	TArray<struct FChangeFireTypeAnimation>       AnimationsArray;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChangeFireTypeAnimations) == 0x000008, "Wrong alignment on FChangeFireTypeAnimations");
static_assert(sizeof(FChangeFireTypeAnimations) == 0x000010, "Wrong size on FChangeFireTypeAnimations");
static_assert(offsetof(FChangeFireTypeAnimations, AnimationsArray) == 0x000000, "Member 'FChangeFireTypeAnimations::AnimationsArray' has a wrong offset!");

// ScriptStruct Stalker2.GlobalVariable
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FGlobalVariable final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGlobalVariable) == 0x000008, "Wrong alignment on FGlobalVariable");
static_assert(sizeof(FGlobalVariable) == 0x000018, "Wrong size on FGlobalVariable");

// ScriptStruct Stalker2.GroomVariation
// 0x00E0 (0x00E0 - 0x0000)
struct alignas(0x08) FGroomVariation final
{
public:
	uint8                                         Pad_0[0xE0];                                       // 0x0000(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGroomVariation) == 0x000008, "Wrong alignment on FGroomVariation");
static_assert(sizeof(FGroomVariation) == 0x0000E0, "Wrong size on FGroomVariation");

// ScriptStruct Stalker2.GSCComponentReference
// 0x0050 (0x0050 - 0x0000)
struct FGSCComponentReference final
{
public:
	TSoftObjectPtr<class AActor>                  OtherActor;                                        // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentProperty;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToComponent;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGSCComponentReference) == 0x000008, "Wrong alignment on FGSCComponentReference");
static_assert(sizeof(FGSCComponentReference) == 0x000050, "Wrong size on FGSCComponentReference");
static_assert(offsetof(FGSCComponentReference, OtherActor) == 0x000000, "Member 'FGSCComponentReference::OtherActor' has a wrong offset!");
static_assert(offsetof(FGSCComponentReference, ComponentProperty) == 0x000030, "Member 'FGSCComponentReference::ComponentProperty' has a wrong offset!");
static_assert(offsetof(FGSCComponentReference, PathToComponent) == 0x000038, "Member 'FGSCComponentReference::PathToComponent' has a wrong offset!");

// ScriptStruct Stalker2.PlayerKnifeInternalAnimations
// 0x00B0 (0x00B0 - 0x0000)
struct FPlayerKnifeInternalAnimations final
{
public:
	struct FCharacterWeaponAnimations             Hit;                                               // 0x0000(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             OneHandHit;                                        // 0x0020(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EAnimStealthKillPose, struct FCharacterWeaponAnimations> StealthKills;                      // 0x0040(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             PlayingWithKnife;                                  // 0x0090(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerKnifeInternalAnimations) == 0x000008, "Wrong alignment on FPlayerKnifeInternalAnimations");
static_assert(sizeof(FPlayerKnifeInternalAnimations) == 0x0000B0, "Wrong size on FPlayerKnifeInternalAnimations");
static_assert(offsetof(FPlayerKnifeInternalAnimations, Hit) == 0x000000, "Member 'FPlayerKnifeInternalAnimations::Hit' has a wrong offset!");
static_assert(offsetof(FPlayerKnifeInternalAnimations, OneHandHit) == 0x000020, "Member 'FPlayerKnifeInternalAnimations::OneHandHit' has a wrong offset!");
static_assert(offsetof(FPlayerKnifeInternalAnimations, StealthKills) == 0x000040, "Member 'FPlayerKnifeInternalAnimations::StealthKills' has a wrong offset!");
static_assert(offsetof(FPlayerKnifeInternalAnimations, PlayingWithKnife) == 0x000090, "Member 'FPlayerKnifeInternalAnimations::PlayingWithKnife' has a wrong offset!");

// ScriptStruct Stalker2.NavModifierBodyConfig
// 0x0018 (0x0018 - 0x0000)
struct FNavModifierBodyConfig final
{
public:
	class FName                                   PhysicalBodyName;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ShapeIndexesToProcess;                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavModifierBodyConfig) == 0x000008, "Wrong alignment on FNavModifierBodyConfig");
static_assert(sizeof(FNavModifierBodyConfig) == 0x000018, "Wrong size on FNavModifierBodyConfig");
static_assert(offsetof(FNavModifierBodyConfig, PhysicalBodyName) == 0x000000, "Member 'FNavModifierBodyConfig::PhysicalBodyName' has a wrong offset!");
static_assert(offsetof(FNavModifierBodyConfig, ShapeIndexesToProcess) == 0x000008, "Member 'FNavModifierBodyConfig::ShapeIndexesToProcess' has a wrong offset!");

// ScriptStruct Stalker2.HeadFlashlightComponentCollection
// 0x0030 (0x0098 - 0x0068)
struct FHeadFlashlightComponentCollection final : public FBaseTickAggregationCollection
{
public:
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeadFlashlightComponentCollection) == 0x000008, "Wrong alignment on FHeadFlashlightComponentCollection");
static_assert(sizeof(FHeadFlashlightComponentCollection) == 0x000098, "Wrong size on FHeadFlashlightComponentCollection");

// ScriptStruct Stalker2.HoverAction
// 0x0038 (0x0038 - 0x0000)
struct FHoverAction final
{
public:
	EHintHoverActionType                          HoverAction;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            ActionWidget;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HoverColorAndOpacity;                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UnHoverColorAndOpacity;                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              HoverVisibility;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              UnHoverVisibility;                                 // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoverAction) == 0x000008, "Wrong alignment on FHoverAction");
static_assert(sizeof(FHoverAction) == 0x000038, "Wrong size on FHoverAction");
static_assert(offsetof(FHoverAction, HoverAction) == 0x000000, "Member 'FHoverAction::HoverAction' has a wrong offset!");
static_assert(offsetof(FHoverAction, ActionWidget) == 0x000008, "Member 'FHoverAction::ActionWidget' has a wrong offset!");
static_assert(offsetof(FHoverAction, HoverColorAndOpacity) == 0x000010, "Member 'FHoverAction::HoverColorAndOpacity' has a wrong offset!");
static_assert(offsetof(FHoverAction, UnHoverColorAndOpacity) == 0x000020, "Member 'FHoverAction::UnHoverColorAndOpacity' has a wrong offset!");
static_assert(offsetof(FHoverAction, HoverVisibility) == 0x000030, "Member 'FHoverAction::HoverVisibility' has a wrong offset!");
static_assert(offsetof(FHoverAction, UnHoverVisibility) == 0x000031, "Member 'FHoverAction::UnHoverVisibility' has a wrong offset!");

// ScriptStruct Stalker2.AsyncSettings
// 0x0028 (0x0028 - 0x0000)
struct FAsyncSettings final
{
public:
	bool                                          HandleAsync;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAsyncActionBase*>               OnLoadingStart;                                    // 0x0008(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAsyncActionBase*>               OnLoadingFinished;                                 // 0x0018(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAsyncSettings) == 0x000008, "Wrong alignment on FAsyncSettings");
static_assert(sizeof(FAsyncSettings) == 0x000028, "Wrong size on FAsyncSettings");
static_assert(offsetof(FAsyncSettings, HandleAsync) == 0x000000, "Member 'FAsyncSettings::HandleAsync' has a wrong offset!");
static_assert(offsetof(FAsyncSettings, OnLoadingStart) == 0x000008, "Member 'FAsyncSettings::OnLoadingStart' has a wrong offset!");
static_assert(offsetof(FAsyncSettings, OnLoadingFinished) == 0x000018, "Member 'FAsyncSettings::OnLoadingFinished' has a wrong offset!");

// ScriptStruct Stalker2.PlayerDeathAnimArray
// 0x0010 (0x0010 - 0x0000)
struct FPlayerDeathAnimArray final
{
public:
	TArray<class UAnimMontage*>                   Animations;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDeathAnimArray) == 0x000008, "Wrong alignment on FPlayerDeathAnimArray");
static_assert(sizeof(FPlayerDeathAnimArray) == 0x000010, "Wrong size on FPlayerDeathAnimArray");
static_assert(offsetof(FPlayerDeathAnimArray, Animations) == 0x000000, "Member 'FPlayerDeathAnimArray::Animations' has a wrong offset!");

// ScriptStruct Stalker2.PlayerDeathAnimations
// 0x00F0 (0x00F0 - 0x0000)
struct FPlayerDeathAnimations final
{
public:
	TMap<EAnimDirections, struct FPlayerDeathAnimArray> BulletDeathAnimations;                       // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EAnimDirections, struct FPlayerDeathAnimArray> ExplosionDeathAnimations;                    // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EPlayerAnimDamageSource, struct FPlayerDeathAnimArray> DeathAnimations;                     // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDeathAnimations) == 0x000008, "Wrong alignment on FPlayerDeathAnimations");
static_assert(sizeof(FPlayerDeathAnimations) == 0x0000F0, "Wrong size on FPlayerDeathAnimations");
static_assert(offsetof(FPlayerDeathAnimations, BulletDeathAnimations) == 0x000000, "Member 'FPlayerDeathAnimations::BulletDeathAnimations' has a wrong offset!");
static_assert(offsetof(FPlayerDeathAnimations, ExplosionDeathAnimations) == 0x000050, "Member 'FPlayerDeathAnimations::ExplosionDeathAnimations' has a wrong offset!");
static_assert(offsetof(FPlayerDeathAnimations, DeathAnimations) == 0x0000A0, "Member 'FPlayerDeathAnimations::DeathAnimations' has a wrong offset!");

// ScriptStruct Stalker2.AdvancedControllerSettings
// 0x0008 (0x0008 - 0x0000)
struct FAdvancedControllerSettings final
{
public:
	int32                                         MappingIndex;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerIndex;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAdvancedControllerSettings) == 0x000004, "Wrong alignment on FAdvancedControllerSettings");
static_assert(sizeof(FAdvancedControllerSettings) == 0x000008, "Wrong size on FAdvancedControllerSettings");
static_assert(offsetof(FAdvancedControllerSettings, MappingIndex) == 0x000000, "Member 'FAdvancedControllerSettings::MappingIndex' has a wrong offset!");
static_assert(offsetof(FAdvancedControllerSettings, TriggerIndex) == 0x000004, "Member 'FAdvancedControllerSettings::TriggerIndex' has a wrong offset!");

// ScriptStruct Stalker2.HintControllerSettings
// 0x0050 (0x0050 - 0x0000)
struct FHintControllerSettings final
{
public:
	class FName                                   InputAction;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomInputIconName;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMappingContext                               MappingContext;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAdvancedControllerSettings            GamepadAdvancedSettings;                           // 0x0014(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAdvancedControllerSettings            KeyboardAdvancedSettings;                          // 0x001C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAsyncSettings                         AsyncSettings;                                     // 0x0028(0x0028)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHintControllerSettings) == 0x000008, "Wrong alignment on FHintControllerSettings");
static_assert(sizeof(FHintControllerSettings) == 0x000050, "Wrong size on FHintControllerSettings");
static_assert(offsetof(FHintControllerSettings, InputAction) == 0x000000, "Member 'FHintControllerSettings::InputAction' has a wrong offset!");
static_assert(offsetof(FHintControllerSettings, CustomInputIconName) == 0x000008, "Member 'FHintControllerSettings::CustomInputIconName' has a wrong offset!");
static_assert(offsetof(FHintControllerSettings, MappingContext) == 0x000010, "Member 'FHintControllerSettings::MappingContext' has a wrong offset!");
static_assert(offsetof(FHintControllerSettings, GamepadAdvancedSettings) == 0x000014, "Member 'FHintControllerSettings::GamepadAdvancedSettings' has a wrong offset!");
static_assert(offsetof(FHintControllerSettings, KeyboardAdvancedSettings) == 0x00001C, "Member 'FHintControllerSettings::KeyboardAdvancedSettings' has a wrong offset!");
static_assert(offsetof(FHintControllerSettings, AsyncSettings) == 0x000028, "Member 'FHintControllerSettings::AsyncSettings' has a wrong offset!");

// ScriptStruct Stalker2.HintsData
// 0x0168 (0x0170 - 0x0008)
struct FHintsData final : public FTableRowBase
{
public:
	TMap<EGSCInputDeviceType, struct FSlateBrush> PlatformIcons;                                     // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackgroundColor;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideBackgroundBrush;                          // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            BackgroundBrush;                                   // 0x0070(0x00F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMargin                                BackgroundPadding;                                 // 0x0160(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHintsData) == 0x000010, "Wrong alignment on FHintsData");
static_assert(sizeof(FHintsData) == 0x000170, "Wrong size on FHintsData");
static_assert(offsetof(FHintsData, PlatformIcons) == 0x000008, "Member 'FHintsData::PlatformIcons' has a wrong offset!");
static_assert(offsetof(FHintsData, BackgroundColor) == 0x000058, "Member 'FHintsData::BackgroundColor' has a wrong offset!");
static_assert(offsetof(FHintsData, bOverrideBackgroundBrush) == 0x000068, "Member 'FHintsData::bOverrideBackgroundBrush' has a wrong offset!");
static_assert(offsetof(FHintsData, BackgroundBrush) == 0x000070, "Member 'FHintsData::BackgroundBrush' has a wrong offset!");
static_assert(offsetof(FHintsData, BackgroundPadding) == 0x000160, "Member 'FHintsData::BackgroundPadding' has a wrong offset!");

// ScriptStruct Stalker2.InteractionHitInfo
// 0x0020 (0x0020 - 0x0000)
struct FInteractionHitInfo final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UInteractionComponent>> Interactions;                                // 0x0010(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionHitInfo) == 0x000008, "Wrong alignment on FInteractionHitInfo");
static_assert(sizeof(FInteractionHitInfo) == 0x000020, "Wrong size on FInteractionHitInfo");
static_assert(offsetof(FInteractionHitInfo, HitActor) == 0x000000, "Member 'FInteractionHitInfo::HitActor' has a wrong offset!");
static_assert(offsetof(FInteractionHitInfo, HitComponent) == 0x000008, "Member 'FInteractionHitInfo::HitComponent' has a wrong offset!");
static_assert(offsetof(FInteractionHitInfo, Interactions) == 0x000010, "Member 'FInteractionHitInfo::Interactions' has a wrong offset!");

// ScriptStruct Stalker2.HintsDataTable
// 0x00A8 (0x00B0 - 0x0008)
struct FHintsDataTable final : public FTableRowBase
{
public:
	bool                                          bCheckPlatform;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGSCInputDeviceType, struct FSlateBrush> PlatformIcons;                                     // 0x0010(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EGSCInputDeviceType, struct FHintsData>  PlatformData;                                      // 0x0060(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHintsDataTable) == 0x000008, "Wrong alignment on FHintsDataTable");
static_assert(sizeof(FHintsDataTable) == 0x0000B0, "Wrong size on FHintsDataTable");
static_assert(offsetof(FHintsDataTable, bCheckPlatform) == 0x000008, "Member 'FHintsDataTable::bCheckPlatform' has a wrong offset!");
static_assert(offsetof(FHintsDataTable, PlatformIcons) == 0x000010, "Member 'FHintsDataTable::PlatformIcons' has a wrong offset!");
static_assert(offsetof(FHintsDataTable, PlatformData) == 0x000060, "Member 'FHintsDataTable::PlatformData' has a wrong offset!");

// ScriptStruct Stalker2.HintsInputDataTable
// 0x00F8 (0x0100 - 0x0008)
struct FHintsInputDataTable final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            PlatformIcons;                                     // 0x0010(0x00F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHintsInputDataTable) == 0x000010, "Wrong alignment on FHintsInputDataTable");
static_assert(sizeof(FHintsInputDataTable) == 0x000100, "Wrong size on FHintsInputDataTable");
static_assert(offsetof(FHintsInputDataTable, PlatformIcons) == 0x000010, "Member 'FHintsInputDataTable::PlatformIcons' has a wrong offset!");

// ScriptStruct Stalker2.CodelockInteractionAnimations
// 0x0008 (0x0008 - 0x0000)
struct FCodelockInteractionAnimations final
{
public:
	class UAnimMontage*                           CodelockMontage;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCodelockInteractionAnimations) == 0x000008, "Wrong alignment on FCodelockInteractionAnimations");
static_assert(sizeof(FCodelockInteractionAnimations) == 0x000008, "Wrong size on FCodelockInteractionAnimations");
static_assert(offsetof(FCodelockInteractionAnimations, CodelockMontage) == 0x000000, "Member 'FCodelockInteractionAnimations::CodelockMontage' has a wrong offset!");

// ScriptStruct Stalker2.HintViewSettings
// 0x0020 (0x0020 - 0x0000)
struct FHintViewSettings final
{
public:
	class FName                                   InputAction;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMappingContext                               MappingContext;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputMappingIndex;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHintProgressType                             ProgressType;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HintHeight;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomInputAction;                                 // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHintViewSettings) == 0x000004, "Wrong alignment on FHintViewSettings");
static_assert(sizeof(FHintViewSettings) == 0x000020, "Wrong size on FHintViewSettings");
static_assert(offsetof(FHintViewSettings, InputAction) == 0x000000, "Member 'FHintViewSettings::InputAction' has a wrong offset!");
static_assert(offsetof(FHintViewSettings, MappingContext) == 0x000008, "Member 'FHintViewSettings::MappingContext' has a wrong offset!");
static_assert(offsetof(FHintViewSettings, InputMappingIndex) == 0x00000C, "Member 'FHintViewSettings::InputMappingIndex' has a wrong offset!");
static_assert(offsetof(FHintViewSettings, ProgressType) == 0x000010, "Member 'FHintViewSettings::ProgressType' has a wrong offset!");
static_assert(offsetof(FHintViewSettings, HintHeight) == 0x000014, "Member 'FHintViewSettings::HintHeight' has a wrong offset!");
static_assert(offsetof(FHintViewSettings, CustomInputAction) == 0x000018, "Member 'FHintViewSettings::CustomInputAction' has a wrong offset!");

// ScriptStruct Stalker2.ProgressMaterialData
// 0x0100 (0x0100 - 0x0000)
struct FProgressMaterialData final
{
public:
	struct FSlateBrush                            ProgressMaterialBrush;                             // 0x0000(0x00F0)(Edit, NativeAccessSpecifierPublic)
	class FName                                   MaterialParameterName;                             // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProgressMaterialData) == 0x000010, "Wrong alignment on FProgressMaterialData");
static_assert(sizeof(FProgressMaterialData) == 0x000100, "Wrong size on FProgressMaterialData");
static_assert(offsetof(FProgressMaterialData, ProgressMaterialBrush) == 0x000000, "Member 'FProgressMaterialData::ProgressMaterialBrush' has a wrong offset!");
static_assert(offsetof(FProgressMaterialData, MaterialParameterName) == 0x0000F0, "Member 'FProgressMaterialData::MaterialParameterName' has a wrong offset!");

// ScriptStruct Stalker2.ProjectileCollection
// 0x0010 (0x0078 - 0x0068)
struct FProjectileCollection final : public FBaseTickAggregationCollection
{
public:
	TArray<class AProjectile*>                    Projectiles;                                       // 0x0068(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FProjectileCollection) == 0x000008, "Wrong alignment on FProjectileCollection");
static_assert(sizeof(FProjectileCollection) == 0x000078, "Wrong size on FProjectileCollection");
static_assert(offsetof(FProjectileCollection, Projectiles) == 0x000068, "Member 'FProjectileCollection::Projectiles' has a wrong offset!");

// ScriptStruct Stalker2.HoldInteractionData
// 0x0010 (0x0028 - 0x0018)
struct FHoldInteractionData final : public FInteractionData
{
public:
	float                                         HoldTime;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseTime;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotDecrease;                                    // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoldInteractionData) == 0x000008, "Wrong alignment on FHoldInteractionData");
static_assert(sizeof(FHoldInteractionData) == 0x000028, "Wrong size on FHoldInteractionData");
static_assert(offsetof(FHoldInteractionData, HoldTime) == 0x000018, "Member 'FHoldInteractionData::HoldTime' has a wrong offset!");
static_assert(offsetof(FHoldInteractionData, DecreaseTime) == 0x00001C, "Member 'FHoldInteractionData::DecreaseTime' has a wrong offset!");
static_assert(offsetof(FHoldInteractionData, bDoNotDecrease) == 0x000020, "Member 'FHoldInteractionData::bDoNotDecrease' has a wrong offset!");

// ScriptStruct Stalker2.SoftAnimWeighted
// 0x0038 (0x0038 - 0x0000)
struct FSoftAnimWeighted final
{
public:
	float                                         ChanceToPlay;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimSequenceBase>       Animation;                                         // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoftAnimWeighted) == 0x000008, "Wrong alignment on FSoftAnimWeighted");
static_assert(sizeof(FSoftAnimWeighted) == 0x000038, "Wrong size on FSoftAnimWeighted");
static_assert(offsetof(FSoftAnimWeighted, ChanceToPlay) == 0x000000, "Member 'FSoftAnimWeighted::ChanceToPlay' has a wrong offset!");
static_assert(offsetof(FSoftAnimWeighted, Animation) == 0x000008, "Member 'FSoftAnimWeighted::Animation' has a wrong offset!");

// ScriptStruct Stalker2.RazerSensaEvent
// 0x0010 (0x0010 - 0x0000)
struct FRazerSensaEvent final
{
public:
	class FString                                 HapticsName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRazerSensaEvent) == 0x000008, "Wrong alignment on FRazerSensaEvent");
static_assert(sizeof(FRazerSensaEvent) == 0x000010, "Wrong size on FRazerSensaEvent");
static_assert(offsetof(FRazerSensaEvent, HapticsName) == 0x000000, "Member 'FRazerSensaEvent::HapticsName' has a wrong offset!");

// ScriptStruct Stalker2.AnimSequenceWeightedArray
// 0x0010 (0x0010 - 0x0000)
struct FAnimSequenceWeightedArray final
{
public:
	TArray<struct FSoftAnimWeighted>              Animations;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSequenceWeightedArray) == 0x000008, "Wrong alignment on FAnimSequenceWeightedArray");
static_assert(sizeof(FAnimSequenceWeightedArray) == 0x000010, "Wrong size on FAnimSequenceWeightedArray");
static_assert(offsetof(FAnimSequenceWeightedArray, Animations) == 0x000000, "Member 'FAnimSequenceWeightedArray::Animations' has a wrong offset!");

// ScriptStruct Stalker2.AnimDialogContextualWeightedArray
// 0x0050 (0x0050 - 0x0000)
struct FAnimDialogContextualWeightedArray final
{
public:
	TMap<ELookAtOwnerState, struct FAnimSequenceWeightedArray> DialogContextualAnimations;           // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimDialogContextualWeightedArray) == 0x000008, "Wrong alignment on FAnimDialogContextualWeightedArray");
static_assert(sizeof(FAnimDialogContextualWeightedArray) == 0x000050, "Wrong size on FAnimDialogContextualWeightedArray");
static_assert(offsetof(FAnimDialogContextualWeightedArray, DialogContextualAnimations) == 0x000000, "Member 'FAnimDialogContextualWeightedArray::DialogContextualAnimations' has a wrong offset!");

// ScriptStruct Stalker2.AbilityPrototypeSID
// 0x0048 (0x0048 - 0x0000)
struct FAbilityPrototypeSID final
{
public:
	struct FPrototypeSID                          AbilitySID;                                        // 0x0000(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivationTag;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityPrototypeSID) == 0x000008, "Wrong alignment on FAbilityPrototypeSID");
static_assert(sizeof(FAbilityPrototypeSID) == 0x000048, "Wrong size on FAbilityPrototypeSID");
static_assert(offsetof(FAbilityPrototypeSID, AbilitySID) == 0x000000, "Member 'FAbilityPrototypeSID::AbilitySID' has a wrong offset!");
static_assert(offsetof(FAbilityPrototypeSID, ActivationTag) == 0x000040, "Member 'FAbilityPrototypeSID::ActivationTag' has a wrong offset!");

// ScriptStruct Stalker2.AnimSequenceArray
// 0x0010 (0x0010 - 0x0000)
struct FAnimSequenceArray final
{
public:
	TArray<TSoftObjectPtr<class UAnimSequenceBase>> Animations;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSequenceArray) == 0x000008, "Wrong alignment on FAnimSequenceArray");
static_assert(sizeof(FAnimSequenceArray) == 0x000010, "Wrong size on FAnimSequenceArray");
static_assert(offsetof(FAnimSequenceArray, Animations) == 0x000000, "Member 'FAnimSequenceArray::Animations' has a wrong offset!");

// ScriptStruct Stalker2.AnimDialogContextualArray
// 0x0050 (0x0050 - 0x0000)
struct FAnimDialogContextualArray final
{
public:
	TMap<ELookAtOwnerState, struct FAnimSequenceArray> DialogContextualAnimations;                   // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimDialogContextualArray) == 0x000008, "Wrong alignment on FAnimDialogContextualArray");
static_assert(sizeof(FAnimDialogContextualArray) == 0x000050, "Wrong size on FAnimDialogContextualArray");
static_assert(offsetof(FAnimDialogContextualArray, DialogContextualAnimations) == 0x000000, "Member 'FAnimDialogContextualArray::DialogContextualAnimations' has a wrong offset!");

// ScriptStruct Stalker2.PoseSearchForceRunInsteadSprintConfigs
// 0x0010 (0x0010 - 0x0000)
struct FPoseSearchForceRunInsteadSprintConfigs final
{
public:
	float                                         DistanceFromPathStart;                             // 0x0000(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToPathEnd;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToNextPortal;                              // 0x0008(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortalRotationAngleThreshold;                      // 0x000C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoseSearchForceRunInsteadSprintConfigs) == 0x000004, "Wrong alignment on FPoseSearchForceRunInsteadSprintConfigs");
static_assert(sizeof(FPoseSearchForceRunInsteadSprintConfigs) == 0x000010, "Wrong size on FPoseSearchForceRunInsteadSprintConfigs");
static_assert(offsetof(FPoseSearchForceRunInsteadSprintConfigs, DistanceFromPathStart) == 0x000000, "Member 'FPoseSearchForceRunInsteadSprintConfigs::DistanceFromPathStart' has a wrong offset!");
static_assert(offsetof(FPoseSearchForceRunInsteadSprintConfigs, DistanceToPathEnd) == 0x000004, "Member 'FPoseSearchForceRunInsteadSprintConfigs::DistanceToPathEnd' has a wrong offset!");
static_assert(offsetof(FPoseSearchForceRunInsteadSprintConfigs, DistanceToNextPortal) == 0x000008, "Member 'FPoseSearchForceRunInsteadSprintConfigs::DistanceToNextPortal' has a wrong offset!");
static_assert(offsetof(FPoseSearchForceRunInsteadSprintConfigs, PortalRotationAngleThreshold) == 0x00000C, "Member 'FPoseSearchForceRunInsteadSprintConfigs::PortalRotationAngleThreshold' has a wrong offset!");

// ScriptStruct Stalker2.PoseSearchMovementTagConfigs
// 0x0010 (0x0010 - 0x0000)
struct FPoseSearchMovementTagConfigs final
{
public:
	struct FPoseSearchForceRunInsteadSprintConfigs ForceRunInsteadSprintConfigs;                     // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoseSearchMovementTagConfigs) == 0x000004, "Wrong alignment on FPoseSearchMovementTagConfigs");
static_assert(sizeof(FPoseSearchMovementTagConfigs) == 0x000010, "Wrong size on FPoseSearchMovementTagConfigs");
static_assert(offsetof(FPoseSearchMovementTagConfigs, ForceRunInsteadSprintConfigs) == 0x000000, "Member 'FPoseSearchMovementTagConfigs::ForceRunInsteadSprintConfigs' has a wrong offset!");

// ScriptStruct Stalker2.MagazineReloadAnimations
// 0x0050 (0x0050 - 0x0000)
struct FMagazineReloadAnimations final
{
public:
	TMap<EAnimationReloadTypes, struct FCharacterWeaponAnimations> MagazineReloadAnimations;         // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMagazineReloadAnimations) == 0x000008, "Wrong alignment on FMagazineReloadAnimations");
static_assert(sizeof(FMagazineReloadAnimations) == 0x000050, "Wrong size on FMagazineReloadAnimations");
static_assert(offsetof(FMagazineReloadAnimations, MagazineReloadAnimations) == 0x000000, "Member 'FMagazineReloadAnimations::MagazineReloadAnimations' has a wrong offset!");

// ScriptStruct Stalker2.HumanStateReloadAnimations
// 0x0050 (0x0050 - 0x0000)
struct FHumanStateReloadAnimations final
{
public:
	TMap<class FName, struct FMagazineReloadAnimations> MagazineReload;                              // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHumanStateReloadAnimations) == 0x000008, "Wrong alignment on FHumanStateReloadAnimations");
static_assert(sizeof(FHumanStateReloadAnimations) == 0x000050, "Wrong size on FHumanStateReloadAnimations");
static_assert(offsetof(FHumanStateReloadAnimations, MagazineReload) == 0x000000, "Member 'FHumanStateReloadAnimations::MagazineReload' has a wrong offset!");

// ScriptStruct Stalker2.HumanHumanAttachAnimBlueprintsBySID
// 0x0008 (0x0008 - 0x0000)
struct FHumanHumanAttachAnimBlueprintsBySID final
{
public:
	class UClass*                                 AttachAnimBlueprint;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHumanHumanAttachAnimBlueprintsBySID) == 0x000008, "Wrong alignment on FHumanHumanAttachAnimBlueprintsBySID");
static_assert(sizeof(FHumanHumanAttachAnimBlueprintsBySID) == 0x000008, "Wrong size on FHumanHumanAttachAnimBlueprintsBySID");
static_assert(offsetof(FHumanHumanAttachAnimBlueprintsBySID, AttachAnimBlueprint) == 0x000000, "Member 'FHumanHumanAttachAnimBlueprintsBySID::AttachAnimBlueprint' has a wrong offset!");

// ScriptStruct Stalker2.RightClickMenuData
// 0x06D8 (0x06D8 - 0x0000)
struct FRightClickMenuData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemSlotBaseWidget*                    ClickedItemSlot;                                   // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x6C8];                                     // 0x0010(0x06C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRightClickMenuData) == 0x000008, "Wrong alignment on FRightClickMenuData");
static_assert(sizeof(FRightClickMenuData) == 0x0006D8, "Wrong size on FRightClickMenuData");
static_assert(offsetof(FRightClickMenuData, ClickedItemSlot) == 0x000008, "Member 'FRightClickMenuData::ClickedItemSlot' has a wrong offset!");

// ScriptStruct Stalker2.HumanFirearmInternalAnimations
// 0x00D0 (0x00D0 - 0x0000)
struct FHumanFirearmInternalAnimations final
{
public:
	struct FCharacterWeaponAnimations             ShootingInHip;                                     // 0x0000(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EAnimationStates, struct FHumanStateReloadAnimations> Reloading;                            // 0x0020(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EAnimationStates, struct FHumanStateReloadAnimations> ReloadingInCover;                     // 0x0070(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   Melee;                                             // 0x00C0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHumanFirearmInternalAnimations) == 0x000008, "Wrong alignment on FHumanFirearmInternalAnimations");
static_assert(sizeof(FHumanFirearmInternalAnimations) == 0x0000D0, "Wrong size on FHumanFirearmInternalAnimations");
static_assert(offsetof(FHumanFirearmInternalAnimations, ShootingInHip) == 0x000000, "Member 'FHumanFirearmInternalAnimations::ShootingInHip' has a wrong offset!");
static_assert(offsetof(FHumanFirearmInternalAnimations, Reloading) == 0x000020, "Member 'FHumanFirearmInternalAnimations::Reloading' has a wrong offset!");
static_assert(offsetof(FHumanFirearmInternalAnimations, ReloadingInCover) == 0x000070, "Member 'FHumanFirearmInternalAnimations::ReloadingInCover' has a wrong offset!");
static_assert(offsetof(FHumanFirearmInternalAnimations, Melee) == 0x0000C0, "Member 'FHumanFirearmInternalAnimations::Melee' has a wrong offset!");

// ScriptStruct Stalker2.HumanWeaponAnimations
// 0x0120 (0x0120 - 0x0000)
struct FHumanWeaponAnimations final
{
public:
	class UHumanAnimCollection*                   AnimCollection;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 HumanAnimBlueprint;                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FHumanHumanAttachAnimBlueprintsBySID> AttachBlueprintbySID;           // 0x0010(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             EquipWeapon;                                       // 0x0060(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             UnequipWeapon;                                     // 0x0080(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             EquipWeaponFast;                                   // 0x00A0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             UnequipWeaponFast;                                 // 0x00C0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             EquipWeaponRelax;                                  // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             UnequipWeaponRelax;                                // 0x0100(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHumanWeaponAnimations) == 0x000008, "Wrong alignment on FHumanWeaponAnimations");
static_assert(sizeof(FHumanWeaponAnimations) == 0x000120, "Wrong size on FHumanWeaponAnimations");
static_assert(offsetof(FHumanWeaponAnimations, AnimCollection) == 0x000000, "Member 'FHumanWeaponAnimations::AnimCollection' has a wrong offset!");
static_assert(offsetof(FHumanWeaponAnimations, HumanAnimBlueprint) == 0x000008, "Member 'FHumanWeaponAnimations::HumanAnimBlueprint' has a wrong offset!");
static_assert(offsetof(FHumanWeaponAnimations, AttachBlueprintbySID) == 0x000010, "Member 'FHumanWeaponAnimations::AttachBlueprintbySID' has a wrong offset!");
static_assert(offsetof(FHumanWeaponAnimations, EquipWeapon) == 0x000060, "Member 'FHumanWeaponAnimations::EquipWeapon' has a wrong offset!");
static_assert(offsetof(FHumanWeaponAnimations, UnequipWeapon) == 0x000080, "Member 'FHumanWeaponAnimations::UnequipWeapon' has a wrong offset!");
static_assert(offsetof(FHumanWeaponAnimations, EquipWeaponFast) == 0x0000A0, "Member 'FHumanWeaponAnimations::EquipWeaponFast' has a wrong offset!");
static_assert(offsetof(FHumanWeaponAnimations, UnequipWeaponFast) == 0x0000C0, "Member 'FHumanWeaponAnimations::UnequipWeaponFast' has a wrong offset!");
static_assert(offsetof(FHumanWeaponAnimations, EquipWeaponRelax) == 0x0000E0, "Member 'FHumanWeaponAnimations::EquipWeaponRelax' has a wrong offset!");
static_assert(offsetof(FHumanWeaponAnimations, UnequipWeaponRelax) == 0x000100, "Member 'FHumanWeaponAnimations::UnequipWeaponRelax' has a wrong offset!");

// ScriptStruct Stalker2.VortexSplineDataPoint
// 0x000C (0x000C - 0x0000)
struct FVortexSplineDataPoint final
{
public:
	float                                         TargetSpeed;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFromStart;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointIndex;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVortexSplineDataPoint) == 0x000004, "Wrong alignment on FVortexSplineDataPoint");
static_assert(sizeof(FVortexSplineDataPoint) == 0x00000C, "Wrong size on FVortexSplineDataPoint");
static_assert(offsetof(FVortexSplineDataPoint, TargetSpeed) == 0x000000, "Member 'FVortexSplineDataPoint::TargetSpeed' has a wrong offset!");
static_assert(offsetof(FVortexSplineDataPoint, DistanceFromStart) == 0x000004, "Member 'FVortexSplineDataPoint::DistanceFromStart' has a wrong offset!");
static_assert(offsetof(FVortexSplineDataPoint, PointIndex) == 0x000008, "Member 'FVortexSplineDataPoint::PointIndex' has a wrong offset!");

// ScriptStruct Stalker2.HumanTransitionAnimations
// 0x0010 (0x0010 - 0x0000)
struct FHumanTransitionAnimations final
{
public:
	class UAnimMontage*                           TransitionTo;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TransitionFrom;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHumanTransitionAnimations) == 0x000008, "Wrong alignment on FHumanTransitionAnimations");
static_assert(sizeof(FHumanTransitionAnimations) == 0x000010, "Wrong size on FHumanTransitionAnimations");
static_assert(offsetof(FHumanTransitionAnimations, TransitionTo) == 0x000000, "Member 'FHumanTransitionAnimations::TransitionTo' has a wrong offset!");
static_assert(offsetof(FHumanTransitionAnimations, TransitionFrom) == 0x000008, "Member 'FHumanTransitionAnimations::TransitionFrom' has a wrong offset!");

// ScriptStruct Stalker2.DirectionalAnimation
// 0x0018 (0x0018 - 0x0000)
struct FDirectionalAnimation final
{
public:
	float                                         MinAngle;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationAngle;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Animation;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectionalAnimation) == 0x000008, "Wrong alignment on FDirectionalAnimation");
static_assert(sizeof(FDirectionalAnimation) == 0x000018, "Wrong size on FDirectionalAnimation");
static_assert(offsetof(FDirectionalAnimation, MinAngle) == 0x000000, "Member 'FDirectionalAnimation::MinAngle' has a wrong offset!");
static_assert(offsetof(FDirectionalAnimation, MaxAngle) == 0x000004, "Member 'FDirectionalAnimation::MaxAngle' has a wrong offset!");
static_assert(offsetof(FDirectionalAnimation, AnimationAngle) == 0x000008, "Member 'FDirectionalAnimation::AnimationAngle' has a wrong offset!");
static_assert(offsetof(FDirectionalAnimation, Animation) == 0x000010, "Member 'FDirectionalAnimation::Animation' has a wrong offset!");

// ScriptStruct Stalker2.GSC_RelationColors
// 0x0008 (0x0010 - 0x0008)
struct FGSC_RelationColors final : public FTableRowBase
{
public:
	class FName                                   ColourStyleID;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGSC_RelationColors) == 0x000008, "Wrong alignment on FGSC_RelationColors");
static_assert(sizeof(FGSC_RelationColors) == 0x000010, "Wrong size on FGSC_RelationColors");
static_assert(offsetof(FGSC_RelationColors, ColourStyleID) == 0x000008, "Member 'FGSC_RelationColors::ColourStyleID' has a wrong offset!");

// ScriptStruct Stalker2.CriticalHitAnimations
// 0x0060 (0x0060 - 0x0000)
struct FCriticalHitAnimations final
{
public:
	TSet<class FName>                             HitBones;                                          // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FDirectionalAnimation>          DirectionalAnimations;                             // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCriticalHitAnimations) == 0x000008, "Wrong alignment on FCriticalHitAnimations");
static_assert(sizeof(FCriticalHitAnimations) == 0x000060, "Wrong size on FCriticalHitAnimations");
static_assert(offsetof(FCriticalHitAnimations, HitBones) == 0x000000, "Member 'FCriticalHitAnimations::HitBones' has a wrong offset!");
static_assert(offsetof(FCriticalHitAnimations, DirectionalAnimations) == 0x000050, "Member 'FCriticalHitAnimations::DirectionalAnimations' has a wrong offset!");

// ScriptStruct Stalker2.HumanDeathAnimArray
// 0x0010 (0x0010 - 0x0000)
struct FHumanDeathAnimArray final
{
public:
	TArray<class UAnimMontage*>                   Animations;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHumanDeathAnimArray) == 0x000008, "Wrong alignment on FHumanDeathAnimArray");
static_assert(sizeof(FHumanDeathAnimArray) == 0x000010, "Wrong size on FHumanDeathAnimArray");
static_assert(offsetof(FHumanDeathAnimArray, Animations) == 0x000000, "Member 'FHumanDeathAnimArray::Animations' has a wrong offset!");

// ScriptStruct Stalker2.ReactionDesc
// 0x0008 (0x0008 - 0x0000)
struct FReactionDesc final
{
public:
	ERelationLevel                                RelationToProvoker;                                // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERelationLevel                                RelationToRequester;                               // 0x0001(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReactionValue;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReactionDesc) == 0x000004, "Wrong alignment on FReactionDesc");
static_assert(sizeof(FReactionDesc) == 0x000008, "Wrong size on FReactionDesc");
static_assert(offsetof(FReactionDesc, RelationToProvoker) == 0x000000, "Member 'FReactionDesc::RelationToProvoker' has a wrong offset!");
static_assert(offsetof(FReactionDesc, RelationToRequester) == 0x000001, "Member 'FReactionDesc::RelationToRequester' has a wrong offset!");
static_assert(offsetof(FReactionDesc, ReactionValue) == 0x000004, "Member 'FReactionDesc::ReactionValue' has a wrong offset!");

// ScriptStruct Stalker2.RelationRequestDesc
// 0x0010 (0x0010 - 0x0000)
struct FRelationRequestDesc final
{
public:
	TArray<struct FReactionDesc>                  Reactions;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRelationRequestDesc) == 0x000008, "Wrong alignment on FRelationRequestDesc");
static_assert(sizeof(FRelationRequestDesc) == 0x000010, "Wrong size on FRelationRequestDesc");
static_assert(offsetof(FRelationRequestDesc, Reactions) == 0x000000, "Member 'FRelationRequestDesc::Reactions' has a wrong offset!");

// ScriptStruct Stalker2.HumanDeathDirectionalAnimMap
// 0x0050 (0x0050 - 0x0000)
struct FHumanDeathDirectionalAnimMap final
{
public:
	TMap<EAnimDirections, struct FHumanDeathAnimArray> DirectionalAnimations;                        // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHumanDeathDirectionalAnimMap) == 0x000008, "Wrong alignment on FHumanDeathDirectionalAnimMap");
static_assert(sizeof(FHumanDeathDirectionalAnimMap) == 0x000050, "Wrong size on FHumanDeathDirectionalAnimMap");
static_assert(offsetof(FHumanDeathDirectionalAnimMap, DirectionalAnimations) == 0x000000, "Member 'FHumanDeathDirectionalAnimMap::DirectionalAnimations' has a wrong offset!");

// ScriptStruct Stalker2.HumanDeathAnimations
// 0x00F0 (0x00F0 - 0x0000)
struct FHumanDeathAnimations final
{
public:
	TMap<EAnimHitBodyPart, struct FHumanDeathDirectionalAnimMap> BulletDeathAnimations;              // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EAnimDirections, struct FHumanDeathAnimArray> ExplosionDeathAnimations;                     // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EHumanAnimDamageSource, struct FHumanDeathAnimArray> DeathAnimations;                       // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHumanDeathAnimations) == 0x000008, "Wrong alignment on FHumanDeathAnimations");
static_assert(sizeof(FHumanDeathAnimations) == 0x0000F0, "Wrong size on FHumanDeathAnimations");
static_assert(offsetof(FHumanDeathAnimations, BulletDeathAnimations) == 0x000000, "Member 'FHumanDeathAnimations::BulletDeathAnimations' has a wrong offset!");
static_assert(offsetof(FHumanDeathAnimations, ExplosionDeathAnimations) == 0x000050, "Member 'FHumanDeathAnimations::ExplosionDeathAnimations' has a wrong offset!");
static_assert(offsetof(FHumanDeathAnimations, DeathAnimations) == 0x0000A0, "Member 'FHumanDeathAnimations::DeathAnimations' has a wrong offset!");

// ScriptStruct Stalker2.DialogUIInfo
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FDialogUIInfo final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogUIInfo) == 0x000008, "Wrong alignment on FDialogUIInfo");
static_assert(sizeof(FDialogUIInfo) == 0x000060, "Wrong size on FDialogUIInfo");

// ScriptStruct Stalker2.IconSettings
// 0x0120 (0x0120 - 0x0000)
struct FIconSettings final
{
public:
	EStyleManagerActionType                       StyleAction;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIconCheckPlatform;                                // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0xE];                                        // 0x0002(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0010(0x00F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEnableResize;                                     // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              IconSize;                                          // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIconSettings) == 0x000010, "Wrong alignment on FIconSettings");
static_assert(sizeof(FIconSettings) == 0x000120, "Wrong size on FIconSettings");
static_assert(offsetof(FIconSettings, StyleAction) == 0x000000, "Member 'FIconSettings::StyleAction' has a wrong offset!");
static_assert(offsetof(FIconSettings, bIconCheckPlatform) == 0x000001, "Member 'FIconSettings::bIconCheckPlatform' has a wrong offset!");
static_assert(offsetof(FIconSettings, Brush) == 0x000010, "Member 'FIconSettings::Brush' has a wrong offset!");
static_assert(offsetof(FIconSettings, bEnableResize) == 0x000100, "Member 'FIconSettings::bEnableResize' has a wrong offset!");
static_assert(offsetof(FIconSettings, IconSize) == 0x000108, "Member 'FIconSettings::IconSize' has a wrong offset!");

// ScriptStruct Stalker2.InputMappingSettingsElementModels
// 0x0090 (0x0090 - 0x0000)
struct FInputMappingSettingsElementModels final
{
public:
	bool                                          IsAnchor;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnchorLocalization;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SaveAnchor;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           Action;                                            // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMappingContext                               MappingContext;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMappable;                                        // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PlayerMappableOption;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AlternativePlayerMappableOption;                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActive;                                          // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHaveBindedActions;                                // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BindedPlayerMappableOption;                        // 0x0044(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BindedAltPlayerMappableOption;                     // 0x004C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayCategory;                                   // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 NameLocSID;                                        // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DescriptionLocSID;                                 // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputMappingSettingsElementModels) == 0x000008, "Wrong alignment on FInputMappingSettingsElementModels");
static_assert(sizeof(FInputMappingSettingsElementModels) == 0x000090, "Wrong size on FInputMappingSettingsElementModels");
static_assert(offsetof(FInputMappingSettingsElementModels, IsAnchor) == 0x000000, "Member 'FInputMappingSettingsElementModels::IsAnchor' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, AnchorLocalization) == 0x000008, "Member 'FInputMappingSettingsElementModels::AnchorLocalization' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, SaveAnchor) == 0x000018, "Member 'FInputMappingSettingsElementModels::SaveAnchor' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, Action) == 0x000020, "Member 'FInputMappingSettingsElementModels::Action' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, MappingContext) == 0x000028, "Member 'FInputMappingSettingsElementModels::MappingContext' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, IsMappable) == 0x00002C, "Member 'FInputMappingSettingsElementModels::IsMappable' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, PlayerMappableOption) == 0x000030, "Member 'FInputMappingSettingsElementModels::PlayerMappableOption' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, AlternativePlayerMappableOption) == 0x000038, "Member 'FInputMappingSettingsElementModels::AlternativePlayerMappableOption' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, IsActive) == 0x000040, "Member 'FInputMappingSettingsElementModels::IsActive' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, bHaveBindedActions) == 0x000041, "Member 'FInputMappingSettingsElementModels::bHaveBindedActions' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, BindedPlayerMappableOption) == 0x000044, "Member 'FInputMappingSettingsElementModels::BindedPlayerMappableOption' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, BindedAltPlayerMappableOption) == 0x00004C, "Member 'FInputMappingSettingsElementModels::BindedAltPlayerMappableOption' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, DisplayCategory) == 0x000058, "Member 'FInputMappingSettingsElementModels::DisplayCategory' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, NameLocSID) == 0x000070, "Member 'FInputMappingSettingsElementModels::NameLocSID' has a wrong offset!");
static_assert(offsetof(FInputMappingSettingsElementModels, DescriptionLocSID) == 0x000080, "Member 'FInputMappingSettingsElementModels::DescriptionLocSID' has a wrong offset!");

// ScriptStruct Stalker2.ValueLocalisationPair
// 0x0020 (0x0020 - 0x0000)
struct FValueLocalisationPair final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Loc10N;                                            // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FValueLocalisationPair) == 0x000008, "Wrong alignment on FValueLocalisationPair");
static_assert(sizeof(FValueLocalisationPair) == 0x000020, "Wrong size on FValueLocalisationPair");
static_assert(offsetof(FValueLocalisationPair, Value) == 0x000000, "Member 'FValueLocalisationPair::Value' has a wrong offset!");
static_assert(offsetof(FValueLocalisationPair, Loc10N) == 0x000008, "Member 'FValueLocalisationPair::Loc10N' has a wrong offset!");

// ScriptStruct Stalker2.InputBufferIPUStruct
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FInputBufferIPUStruct final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputBufferIPUStruct) == 0x000008, "Wrong alignment on FInputBufferIPUStruct");
static_assert(sizeof(FInputBufferIPUStruct) == 0x000070, "Wrong size on FInputBufferIPUStruct");

// ScriptStruct Stalker2.InteractableDisplayInfo
// 0x0050 (0x0050 - 0x0000)
struct FInteractableDisplayInfo final
{
public:
	class FText                                   TitleText;                                         // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   InteractActionText;                                // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   InteractActionTextSmall;                           // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EInteractionType                              InteractionType;                                   // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDisplayPriority                              DisplayPriority;                                   // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverweight;                                       // 0x004A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDurability;                                   // 0x004B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowUpgrade;                                      // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractableDisplayInfo) == 0x000008, "Wrong alignment on FInteractableDisplayInfo");
static_assert(sizeof(FInteractableDisplayInfo) == 0x000050, "Wrong size on FInteractableDisplayInfo");
static_assert(offsetof(FInteractableDisplayInfo, TitleText) == 0x000000, "Member 'FInteractableDisplayInfo::TitleText' has a wrong offset!");
static_assert(offsetof(FInteractableDisplayInfo, InteractActionText) == 0x000018, "Member 'FInteractableDisplayInfo::InteractActionText' has a wrong offset!");
static_assert(offsetof(FInteractableDisplayInfo, InteractActionTextSmall) == 0x000030, "Member 'FInteractableDisplayInfo::InteractActionTextSmall' has a wrong offset!");
static_assert(offsetof(FInteractableDisplayInfo, InteractionType) == 0x000048, "Member 'FInteractableDisplayInfo::InteractionType' has a wrong offset!");
static_assert(offsetof(FInteractableDisplayInfo, DisplayPriority) == 0x000049, "Member 'FInteractableDisplayInfo::DisplayPriority' has a wrong offset!");
static_assert(offsetof(FInteractableDisplayInfo, bOverweight) == 0x00004A, "Member 'FInteractableDisplayInfo::bOverweight' has a wrong offset!");
static_assert(offsetof(FInteractableDisplayInfo, bShowDurability) == 0x00004B, "Member 'FInteractableDisplayInfo::bShowDurability' has a wrong offset!");
static_assert(offsetof(FInteractableDisplayInfo, bShowUpgrade) == 0x00004C, "Member 'FInteractableDisplayInfo::bShowUpgrade' has a wrong offset!");

// ScriptStruct Stalker2.RelationLevelRange
// 0x0008 (0x0008 - 0x0000)
struct FRelationLevelRange final
{
public:
	int32                                         Start;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         End;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRelationLevelRange) == 0x000004, "Wrong alignment on FRelationLevelRange");
static_assert(sizeof(FRelationLevelRange) == 0x000008, "Wrong size on FRelationLevelRange");
static_assert(offsetof(FRelationLevelRange, Start) == 0x000000, "Member 'FRelationLevelRange::Start' has a wrong offset!");
static_assert(offsetof(FRelationLevelRange, End) == 0x000004, "Member 'FRelationLevelRange::End' has a wrong offset!");

// ScriptStruct Stalker2.WeaponFireEvents
// 0x0018 (0x0018 - 0x0000)
struct FWeaponFireEvents final
{
public:
	class UAkAudioEvent*                          FireEventOneShot;                                  // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          FireEventLoop;                                     // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          FireEventBreak;                                    // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponFireEvents) == 0x000008, "Wrong alignment on FWeaponFireEvents");
static_assert(sizeof(FWeaponFireEvents) == 0x000018, "Wrong size on FWeaponFireEvents");
static_assert(offsetof(FWeaponFireEvents, FireEventOneShot) == 0x000000, "Member 'FWeaponFireEvents::FireEventOneShot' has a wrong offset!");
static_assert(offsetof(FWeaponFireEvents, FireEventLoop) == 0x000008, "Member 'FWeaponFireEvents::FireEventLoop' has a wrong offset!");
static_assert(offsetof(FWeaponFireEvents, FireEventBreak) == 0x000010, "Member 'FWeaponFireEvents::FireEventBreak' has a wrong offset!");

// ScriptStruct Stalker2.ItemContainerData
// 0x0010 (0x0028 - 0x0018)
struct FItemContainerData final : public FActorInteractionData
{
public:
	bool                                          bShowDurability;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurabilityPercent;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowUpgrade;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemContainerData) == 0x000008, "Wrong alignment on FItemContainerData");
static_assert(sizeof(FItemContainerData) == 0x000028, "Wrong size on FItemContainerData");
static_assert(offsetof(FItemContainerData, bShowDurability) == 0x000018, "Member 'FItemContainerData::bShowDurability' has a wrong offset!");
static_assert(offsetof(FItemContainerData, DurabilityPercent) == 0x00001C, "Member 'FItemContainerData::DurabilityPercent' has a wrong offset!");
static_assert(offsetof(FItemContainerData, bShowUpgrade) == 0x000020, "Member 'FItemContainerData::bShowUpgrade' has a wrong offset!");

// ScriptStruct Stalker2.DialogAnswerInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FDialogAnswerInfo final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAvailable;                                        // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDialogAnswerColor                            AnswerColor;                                       // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x22];                                       // 0x0006(0x0022)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogAnswerInfo) == 0x000008, "Wrong alignment on FDialogAnswerInfo");
static_assert(sizeof(FDialogAnswerInfo) == 0x000028, "Wrong size on FDialogAnswerInfo");
static_assert(offsetof(FDialogAnswerInfo, bAvailable) == 0x000004, "Member 'FDialogAnswerInfo::bAvailable' has a wrong offset!");
static_assert(offsetof(FDialogAnswerInfo, AnswerColor) == 0x000005, "Member 'FDialogAnswerInfo::AnswerColor' has a wrong offset!");

// ScriptStruct Stalker2.ItemContainerModelCollection
// 0x0030 (0x0098 - 0x0068)
struct FItemContainerModelCollection final : public FBaseTickAggregationCollection
{
public:
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemContainerModelCollection) == 0x000008, "Wrong alignment on FItemContainerModelCollection");
static_assert(sizeof(FItemContainerModelCollection) == 0x000098, "Wrong size on FItemContainerModelCollection");

// ScriptStruct Stalker2.InteractObjectData
// 0x0050 (0x0050 - 0x0000)
struct FInteractObjectData final
{
public:
	struct FPrototypeSID                          PrototypeSID;                                      // 0x0000(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDurability;                                     // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDurability;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnWeaponWithoutAmmo;                           // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractObjectData) == 0x000008, "Wrong alignment on FInteractObjectData");
static_assert(sizeof(FInteractObjectData) == 0x000050, "Wrong size on FInteractObjectData");
static_assert(offsetof(FInteractObjectData, PrototypeSID) == 0x000000, "Member 'FInteractObjectData::PrototypeSID' has a wrong offset!");
static_assert(offsetof(FInteractObjectData, Count) == 0x000040, "Member 'FInteractObjectData::Count' has a wrong offset!");
static_assert(offsetof(FInteractObjectData, MinDurability) == 0x000044, "Member 'FInteractObjectData::MinDurability' has a wrong offset!");
static_assert(offsetof(FInteractObjectData, MaxDurability) == 0x000048, "Member 'FInteractObjectData::MaxDurability' has a wrong offset!");
static_assert(offsetof(FInteractObjectData, bSpawnWeaponWithoutAmmo) == 0x00004C, "Member 'FInteractObjectData::bSpawnWeaponWithoutAmmo' has a wrong offset!");

// ScriptStruct Stalker2.SmartCoverActionWithSide
// 0x0010 (0x0010 - 0x0000)
struct FSmartCoverActionWithSide final
{
public:
	EAvailableCoverActionsSide                    Side;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSmartCoverActionWithSide) == 0x000008, "Wrong alignment on FSmartCoverActionWithSide");
static_assert(sizeof(FSmartCoverActionWithSide) == 0x000010, "Wrong size on FSmartCoverActionWithSide");
static_assert(offsetof(FSmartCoverActionWithSide, Side) == 0x000000, "Member 'FSmartCoverActionWithSide::Side' has a wrong offset!");
static_assert(offsetof(FSmartCoverActionWithSide, Montage) == 0x000008, "Member 'FSmartCoverActionWithSide::Montage' has a wrong offset!");

// ScriptStruct Stalker2.FireTypeDisplayInfo
// 0x0018 (0x0018 - 0x0000)
struct FFireTypeDisplayInfo final
{
public:
	class FString                                 DisplayTextSid;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DisplayTexture;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFireTypeDisplayInfo) == 0x000008, "Wrong alignment on FFireTypeDisplayInfo");
static_assert(sizeof(FFireTypeDisplayInfo) == 0x000018, "Wrong size on FFireTypeDisplayInfo");
static_assert(offsetof(FFireTypeDisplayInfo, DisplayTextSid) == 0x000000, "Member 'FFireTypeDisplayInfo::DisplayTextSid' has a wrong offset!");
static_assert(offsetof(FFireTypeDisplayInfo, DisplayTexture) == 0x000010, "Member 'FFireTypeDisplayInfo::DisplayTexture' has a wrong offset!");

// ScriptStruct Stalker2.InteractObject
// 0x0048 (0x0048 - 0x0000)
struct FInteractObject final
{
public:
	struct FPrototypeSID                          PrototypeSID;                                      // 0x0000(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsumedOnUse;                                    // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractObject) == 0x000008, "Wrong alignment on FInteractObject");
static_assert(sizeof(FInteractObject) == 0x000048, "Wrong size on FInteractObject");
static_assert(offsetof(FInteractObject, PrototypeSID) == 0x000000, "Member 'FInteractObject::PrototypeSID' has a wrong offset!");
static_assert(offsetof(FInteractObject, Count) == 0x000040, "Member 'FInteractObject::Count' has a wrong offset!");
static_assert(offsetof(FInteractObject, bConsumedOnUse) == 0x000044, "Member 'FInteractObject::bConsumedOnUse' has a wrong offset!");

// ScriptStruct Stalker2.SignalToSend
// 0x0060 (0x0060 - 0x0000)
struct FSignalToSend final
{
public:
	struct FGSCComponentReference                 ReceiverComponentRef;                              // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FGuid                                  ReceiverGuid;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSignalToSend) == 0x000008, "Wrong alignment on FSignalToSend");
static_assert(sizeof(FSignalToSend) == 0x000060, "Wrong size on FSignalToSend");
static_assert(offsetof(FSignalToSend, ReceiverComponentRef) == 0x000000, "Member 'FSignalToSend::ReceiverComponentRef' has a wrong offset!");
static_assert(offsetof(FSignalToSend, ReceiverGuid) == 0x000050, "Member 'FSignalToSend::ReceiverGuid' has a wrong offset!");

// ScriptStruct Stalker2.JournalQuest
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FJournalQuest final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJournalQuest) == 0x000008, "Wrong alignment on FJournalQuest");
static_assert(sizeof(FJournalQuest) == 0x000070, "Wrong size on FJournalQuest");

// ScriptStruct Stalker2.JournalQuestStageData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FJournalQuestStageData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJournalQuestStageData) == 0x000004, "Wrong alignment on FJournalQuestStageData");
static_assert(sizeof(FJournalQuestStageData) == 0x00000C, "Wrong size on FJournalQuestStageData");

// ScriptStruct Stalker2.ShootingPatternKey
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FShootingPatternKey final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShootingPatternKey) == 0x000004, "Wrong alignment on FShootingPatternKey");
static_assert(sizeof(FShootingPatternKey) == 0x00000C, "Wrong size on FShootingPatternKey");

// ScriptStruct Stalker2.OverridableProperty
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FOverridableProperty
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOverridableProperty) == 0x000008, "Wrong alignment on FOverridableProperty");
static_assert(sizeof(FOverridableProperty) == 0x000018, "Wrong size on FOverridableProperty");

// ScriptStruct Stalker2.FactionOverridableProperty
// 0x00C0 (0x00D8 - 0x0018)
struct FFactionOverridableProperty final : public FOverridableProperty
{
public:
	struct FFactionSelector                       DefaultValue;                                      // 0x0018(0x0060)(NativeAccessSpecifierPublic)
	struct FFactionSelector                       CurrentValue;                                      // 0x0078(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFactionOverridableProperty) == 0x000008, "Wrong alignment on FFactionOverridableProperty");
static_assert(sizeof(FFactionOverridableProperty) == 0x0000D8, "Wrong size on FFactionOverridableProperty");
static_assert(offsetof(FFactionOverridableProperty, DefaultValue) == 0x000018, "Member 'FFactionOverridableProperty::DefaultValue' has a wrong offset!");
static_assert(offsetof(FFactionOverridableProperty, CurrentValue) == 0x000078, "Member 'FFactionOverridableProperty::CurrentValue' has a wrong offset!");

// ScriptStruct Stalker2.SmartCoverExitTypes
// 0x0002 (0x0002 - 0x0000)
struct FSmartCoverExitTypes final
{
public:
	EAvailableCoverActionsSide                    Side;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAvailableCoverExitTypes                      ExitType;                                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSmartCoverExitTypes) == 0x000001, "Wrong alignment on FSmartCoverExitTypes");
static_assert(sizeof(FSmartCoverExitTypes) == 0x000002, "Wrong size on FSmartCoverExitTypes");
static_assert(offsetof(FSmartCoverExitTypes, Side) == 0x000000, "Member 'FSmartCoverExitTypes::Side' has a wrong offset!");
static_assert(offsetof(FSmartCoverExitTypes, ExitType) == 0x000001, "Member 'FSmartCoverExitTypes::ExitType' has a wrong offset!");

// ScriptStruct Stalker2.StringOverridableProperty
// 0x0020 (0x0038 - 0x0018)
struct FStringOverridableProperty final : public FOverridableProperty
{
public:
	class FString                                 DefaultValue;                                      // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentValue;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStringOverridableProperty) == 0x000008, "Wrong alignment on FStringOverridableProperty");
static_assert(sizeof(FStringOverridableProperty) == 0x000038, "Wrong size on FStringOverridableProperty");
static_assert(offsetof(FStringOverridableProperty, DefaultValue) == 0x000018, "Member 'FStringOverridableProperty::DefaultValue' has a wrong offset!");
static_assert(offsetof(FStringOverridableProperty, CurrentValue) == 0x000028, "Member 'FStringOverridableProperty::CurrentValue' has a wrong offset!");

// ScriptStruct Stalker2.BoolOverridableProperty
// 0x0008 (0x0020 - 0x0018)
struct FBoolOverridableProperty final : public FOverridableProperty
{
public:
	bool                                          DefaultValue;                                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CurrentValue;                                      // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoolOverridableProperty) == 0x000008, "Wrong alignment on FBoolOverridableProperty");
static_assert(sizeof(FBoolOverridableProperty) == 0x000020, "Wrong size on FBoolOverridableProperty");
static_assert(offsetof(FBoolOverridableProperty, DefaultValue) == 0x000018, "Member 'FBoolOverridableProperty::DefaultValue' has a wrong offset!");
static_assert(offsetof(FBoolOverridableProperty, CurrentValue) == 0x000019, "Member 'FBoolOverridableProperty::CurrentValue' has a wrong offset!");

// ScriptStruct Stalker2.SpawnedItem
// 0x0020 (0x0020 - 0x0000)
struct FSpawnedItem final
{
public:
	class FString                                 PrototypeSID;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinDurability;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDurability;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnedItem) == 0x000008, "Wrong alignment on FSpawnedItem");
static_assert(sizeof(FSpawnedItem) == 0x000020, "Wrong size on FSpawnedItem");
static_assert(offsetof(FSpawnedItem, PrototypeSID) == 0x000000, "Member 'FSpawnedItem::PrototypeSID' has a wrong offset!");
static_assert(offsetof(FSpawnedItem, Weight) == 0x000010, "Member 'FSpawnedItem::Weight' has a wrong offset!");
static_assert(offsetof(FSpawnedItem, MinDurability) == 0x000014, "Member 'FSpawnedItem::MinDurability' has a wrong offset!");
static_assert(offsetof(FSpawnedItem, MaxDurability) == 0x000018, "Member 'FSpawnedItem::MaxDurability' has a wrong offset!");

// ScriptStruct Stalker2.SpawnSettingsPerArchetype
// 0x0048 (0x0048 - 0x0000)
struct FSpawnSettingsPerArchetype final
{
public:
	struct FPrototypeSID                          PrototypeSID;                                      // 0x0000(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinQuantity;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnWeight;                                       // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnSettingsPerArchetype) == 0x000008, "Wrong alignment on FSpawnSettingsPerArchetype");
static_assert(sizeof(FSpawnSettingsPerArchetype) == 0x000048, "Wrong size on FSpawnSettingsPerArchetype");
static_assert(offsetof(FSpawnSettingsPerArchetype, PrototypeSID) == 0x000000, "Member 'FSpawnSettingsPerArchetype::PrototypeSID' has a wrong offset!");
static_assert(offsetof(FSpawnSettingsPerArchetype, MinQuantity) == 0x000040, "Member 'FSpawnSettingsPerArchetype::MinQuantity' has a wrong offset!");
static_assert(offsetof(FSpawnSettingsPerArchetype, SpawnWeight) == 0x000044, "Member 'FSpawnSettingsPerArchetype::SpawnWeight' has a wrong offset!");

// ScriptStruct Stalker2.IntInterval
// 0x0008 (0x0008 - 0x0000)
struct FIntInterval final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntInterval) == 0x000004, "Wrong alignment on FIntInterval");
static_assert(sizeof(FIntInterval) == 0x000008, "Wrong size on FIntInterval");
static_assert(offsetof(FIntInterval, Min) == 0x000000, "Member 'FIntInterval::Min' has a wrong offset!");
static_assert(offsetof(FIntInterval, Max) == 0x000004, "Member 'FIntInterval::Max' has a wrong offset!");

// ScriptStruct Stalker2.SmartCoverEnterTypes
// 0x0002 (0x0002 - 0x0000)
struct FSmartCoverEnterTypes final
{
public:
	EAvailableCoverActionsSide                    Side;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAvailableCoverEnterTypes                     EnterType;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSmartCoverEnterTypes) == 0x000001, "Wrong alignment on FSmartCoverEnterTypes");
static_assert(sizeof(FSmartCoverEnterTypes) == 0x000002, "Wrong size on FSmartCoverEnterTypes");
static_assert(offsetof(FSmartCoverEnterTypes, Side) == 0x000000, "Member 'FSmartCoverEnterTypes::Side' has a wrong offset!");
static_assert(offsetof(FSmartCoverEnterTypes, EnterType) == 0x000001, "Member 'FSmartCoverEnterTypes::EnterType' has a wrong offset!");

// ScriptStruct Stalker2.SmartCoverActionSide
// 0x0001 (0x0001 - 0x0000)
struct FSmartCoverActionSide final
{
public:
	EAvailableCoverActionsSide                    Side;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSmartCoverActionSide) == 0x000001, "Wrong alignment on FSmartCoverActionSide");
static_assert(sizeof(FSmartCoverActionSide) == 0x000001, "Wrong size on FSmartCoverActionSide");
static_assert(offsetof(FSmartCoverActionSide, Side) == 0x000000, "Member 'FSmartCoverActionSide::Side' has a wrong offset!");

// ScriptStruct Stalker2.SmartCoverTransitionSides
// 0x0002 (0x0002 - 0x0000)
struct FSmartCoverTransitionSides final
{
public:
	EAvailableCoverActionsSide                    Side;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAvailableCoverActionsSide                    ResultSide;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSmartCoverTransitionSides) == 0x000001, "Wrong alignment on FSmartCoverTransitionSides");
static_assert(sizeof(FSmartCoverTransitionSides) == 0x000002, "Wrong size on FSmartCoverTransitionSides");
static_assert(offsetof(FSmartCoverTransitionSides, Side) == 0x000000, "Member 'FSmartCoverTransitionSides::Side' has a wrong offset!");
static_assert(offsetof(FSmartCoverTransitionSides, ResultSide) == 0x000001, "Member 'FSmartCoverTransitionSides::ResultSide' has a wrong offset!");

// ScriptStruct Stalker2.SmartCoverAnimationMainLoopData
// 0x0038 (0x0038 - 0x0000)
struct FSmartCoverAnimationMainLoopData final
{
public:
	ESmartCoverActionType                         ActionType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELookAtOwnerState                             LookAtOwnerState;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAvailableCoverActionsSide                    TargetActionSide;                                  // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSmartCoverActionWithSide>      LookFromCoverMontages;                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSmartCoverActionWithSide>      HideBehindCoverMontages;                           // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           IdleMontage;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThrowGrenadeMontage;                               // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSmartCoverAnimationMainLoopData) == 0x000008, "Wrong alignment on FSmartCoverAnimationMainLoopData");
static_assert(sizeof(FSmartCoverAnimationMainLoopData) == 0x000038, "Wrong size on FSmartCoverAnimationMainLoopData");
static_assert(offsetof(FSmartCoverAnimationMainLoopData, ActionType) == 0x000000, "Member 'FSmartCoverAnimationMainLoopData::ActionType' has a wrong offset!");
static_assert(offsetof(FSmartCoverAnimationMainLoopData, LookAtOwnerState) == 0x000001, "Member 'FSmartCoverAnimationMainLoopData::LookAtOwnerState' has a wrong offset!");
static_assert(offsetof(FSmartCoverAnimationMainLoopData, TargetActionSide) == 0x000002, "Member 'FSmartCoverAnimationMainLoopData::TargetActionSide' has a wrong offset!");
static_assert(offsetof(FSmartCoverAnimationMainLoopData, LookFromCoverMontages) == 0x000008, "Member 'FSmartCoverAnimationMainLoopData::LookFromCoverMontages' has a wrong offset!");
static_assert(offsetof(FSmartCoverAnimationMainLoopData, HideBehindCoverMontages) == 0x000018, "Member 'FSmartCoverAnimationMainLoopData::HideBehindCoverMontages' has a wrong offset!");
static_assert(offsetof(FSmartCoverAnimationMainLoopData, IdleMontage) == 0x000028, "Member 'FSmartCoverAnimationMainLoopData::IdleMontage' has a wrong offset!");
static_assert(offsetof(FSmartCoverAnimationMainLoopData, ThrowGrenadeMontage) == 0x000030, "Member 'FSmartCoverAnimationMainLoopData::ThrowGrenadeMontage' has a wrong offset!");

// ScriptStruct Stalker2.SmartCoverPerCoverTypeData
// 0x0058 (0x0058 - 0x0000)
struct FSmartCoverPerCoverTypeData final
{
public:
	TArray<struct FSmartCoverEnterTypes>          EnterData;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSmartCoverExitTypes>           ExitData;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSmartCoverActionSide>          IdlesData;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSmartCoverTransitionSides>     TransitionsData;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TransitionMontage;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSmartCoverAnimationMainLoopData> ActionAnimationsData;                            // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSmartCoverPerCoverTypeData) == 0x000008, "Wrong alignment on FSmartCoverPerCoverTypeData");
static_assert(sizeof(FSmartCoverPerCoverTypeData) == 0x000058, "Wrong size on FSmartCoverPerCoverTypeData");
static_assert(offsetof(FSmartCoverPerCoverTypeData, EnterData) == 0x000000, "Member 'FSmartCoverPerCoverTypeData::EnterData' has a wrong offset!");
static_assert(offsetof(FSmartCoverPerCoverTypeData, ExitData) == 0x000010, "Member 'FSmartCoverPerCoverTypeData::ExitData' has a wrong offset!");
static_assert(offsetof(FSmartCoverPerCoverTypeData, IdlesData) == 0x000020, "Member 'FSmartCoverPerCoverTypeData::IdlesData' has a wrong offset!");
static_assert(offsetof(FSmartCoverPerCoverTypeData, TransitionsData) == 0x000030, "Member 'FSmartCoverPerCoverTypeData::TransitionsData' has a wrong offset!");
static_assert(offsetof(FSmartCoverPerCoverTypeData, TransitionMontage) == 0x000040, "Member 'FSmartCoverPerCoverTypeData::TransitionMontage' has a wrong offset!");
static_assert(offsetof(FSmartCoverPerCoverTypeData, ActionAnimationsData) == 0x000048, "Member 'FSmartCoverPerCoverTypeData::ActionAnimationsData' has a wrong offset!");

// ScriptStruct Stalker2.SpawnSettingsPerPlayerRank
// 0x0028 (0x0028 - 0x0000)
struct FSpawnSettingsPerPlayerRank final
{
public:
	ERank                                         PlayerRank;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxSpawnQuantity;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSpawnQuantityPercent;                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSpawnQuantityRespawnTimeSeconds;            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpawnQuantityRespawnTimeSeconds;                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WipeRespawnTimeoutSeconds;                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpawnSettingsPerArchetype>     SpawnSettingsPerArchetypes;                        // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnSettingsPerPlayerRank) == 0x000008, "Wrong alignment on FSpawnSettingsPerPlayerRank");
static_assert(sizeof(FSpawnSettingsPerPlayerRank) == 0x000028, "Wrong size on FSpawnSettingsPerPlayerRank");
static_assert(offsetof(FSpawnSettingsPerPlayerRank, PlayerRank) == 0x000000, "Member 'FSpawnSettingsPerPlayerRank::PlayerRank' has a wrong offset!");
static_assert(offsetof(FSpawnSettingsPerPlayerRank, MaxSpawnQuantity) == 0x000004, "Member 'FSpawnSettingsPerPlayerRank::MaxSpawnQuantity' has a wrong offset!");
static_assert(offsetof(FSpawnSettingsPerPlayerRank, InitialSpawnQuantityPercent) == 0x000008, "Member 'FSpawnSettingsPerPlayerRank::InitialSpawnQuantityPercent' has a wrong offset!");
static_assert(offsetof(FSpawnSettingsPerPlayerRank, InitialSpawnQuantityRespawnTimeSeconds) == 0x00000C, "Member 'FSpawnSettingsPerPlayerRank::InitialSpawnQuantityRespawnTimeSeconds' has a wrong offset!");
static_assert(offsetof(FSpawnSettingsPerPlayerRank, MaxSpawnQuantityRespawnTimeSeconds) == 0x000010, "Member 'FSpawnSettingsPerPlayerRank::MaxSpawnQuantityRespawnTimeSeconds' has a wrong offset!");
static_assert(offsetof(FSpawnSettingsPerPlayerRank, WipeRespawnTimeoutSeconds) == 0x000014, "Member 'FSpawnSettingsPerPlayerRank::WipeRespawnTimeoutSeconds' has a wrong offset!");
static_assert(offsetof(FSpawnSettingsPerPlayerRank, SpawnSettingsPerArchetypes) == 0x000018, "Member 'FSpawnSettingsPerPlayerRank::SpawnSettingsPerArchetypes' has a wrong offset!");

// ScriptStruct Stalker2.PossibleInhabitantFaction
// 0x0100 (0x0100 - 0x0000)
struct FPossibleInhabitantFaction final
{
public:
	struct FFactionSelector                       Faction;                                           // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FSpawnSettingsPerPlayerRank            SpawnSettingsPerPlayerRanks[0x4];                  // 0x0060(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPossibleInhabitantFaction) == 0x000008, "Wrong alignment on FPossibleInhabitantFaction");
static_assert(sizeof(FPossibleInhabitantFaction) == 0x000100, "Wrong size on FPossibleInhabitantFaction");
static_assert(offsetof(FPossibleInhabitantFaction, Faction) == 0x000000, "Member 'FPossibleInhabitantFaction::Faction' has a wrong offset!");
static_assert(offsetof(FPossibleInhabitantFaction, SpawnSettingsPerPlayerRanks) == 0x000060, "Member 'FPossibleInhabitantFaction::SpawnSettingsPerPlayerRanks' has a wrong offset!");

// ScriptStruct Stalker2.PossibleInhabitantFactionsOverridableProperty
// 0x0020 (0x0038 - 0x0018)
struct FPossibleInhabitantFactionsOverridableProperty final : public FOverridableProperty
{
public:
	TArray<struct FPossibleInhabitantFaction>     DefaultValue;                                      // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPossibleInhabitantFaction>     CurrentValue;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPossibleInhabitantFactionsOverridableProperty) == 0x000008, "Wrong alignment on FPossibleInhabitantFactionsOverridableProperty");
static_assert(sizeof(FPossibleInhabitantFactionsOverridableProperty) == 0x000038, "Wrong size on FPossibleInhabitantFactionsOverridableProperty");
static_assert(offsetof(FPossibleInhabitantFactionsOverridableProperty, DefaultValue) == 0x000018, "Member 'FPossibleInhabitantFactionsOverridableProperty::DefaultValue' has a wrong offset!");
static_assert(offsetof(FPossibleInhabitantFactionsOverridableProperty, CurrentValue) == 0x000028, "Member 'FPossibleInhabitantFactionsOverridableProperty::CurrentValue' has a wrong offset!");

// ScriptStruct Stalker2.LightningBallNavigationData
// 0x0030 (0x0030 - 0x0000)
struct FLightningBallNavigationData final
{
public:
	bool                                          bIsPatrolPoint;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PointLocation;                                     // 0x0008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 NeighborPoints;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightningBallNavigationData) == 0x000008, "Wrong alignment on FLightningBallNavigationData");
static_assert(sizeof(FLightningBallNavigationData) == 0x000030, "Wrong size on FLightningBallNavigationData");
static_assert(offsetof(FLightningBallNavigationData, bIsPatrolPoint) == 0x000000, "Member 'FLightningBallNavigationData::bIsPatrolPoint' has a wrong offset!");
static_assert(offsetof(FLightningBallNavigationData, PointLocation) == 0x000008, "Member 'FLightningBallNavigationData::PointLocation' has a wrong offset!");
static_assert(offsetof(FLightningBallNavigationData, NeighborPoints) == 0x000020, "Member 'FLightningBallNavigationData::NeighborPoints' has a wrong offset!");

// ScriptStruct Stalker2.LoadingScreenBehaviourSettings
// 0x0008 (0x0008 - 0x0000)
struct FLoadingScreenBehaviourSettings final
{
public:
	float                                         MinimumLoadingScreenDisplayTime;                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoCompleteWhenLoadingComplete;                  // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitForManualStop;                                // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingScreenBehaviourSettings) == 0x000004, "Wrong alignment on FLoadingScreenBehaviourSettings");
static_assert(sizeof(FLoadingScreenBehaviourSettings) == 0x000008, "Wrong size on FLoadingScreenBehaviourSettings");
static_assert(offsetof(FLoadingScreenBehaviourSettings, MinimumLoadingScreenDisplayTime) == 0x000000, "Member 'FLoadingScreenBehaviourSettings::MinimumLoadingScreenDisplayTime' has a wrong offset!");
static_assert(offsetof(FLoadingScreenBehaviourSettings, bAutoCompleteWhenLoadingComplete) == 0x000004, "Member 'FLoadingScreenBehaviourSettings::bAutoCompleteWhenLoadingComplete' has a wrong offset!");
static_assert(offsetof(FLoadingScreenBehaviourSettings, bWaitForManualStop) == 0x000005, "Member 'FLoadingScreenBehaviourSettings::bWaitForManualStop' has a wrong offset!");

// ScriptStruct Stalker2.InfoScreenSettings
// 0x0050 (0x0050 - 0x0000)
struct FInfoScreenSettings final
{
public:
	class FText                                   TitleText;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DescriptionText;                                   // 0x0018(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Image;                                             // 0x0030(0x0020)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInfoScreenSettings) == 0x000008, "Wrong alignment on FInfoScreenSettings");
static_assert(sizeof(FInfoScreenSettings) == 0x000050, "Wrong size on FInfoScreenSettings");
static_assert(offsetof(FInfoScreenSettings, TitleText) == 0x000000, "Member 'FInfoScreenSettings::TitleText' has a wrong offset!");
static_assert(offsetof(FInfoScreenSettings, DescriptionText) == 0x000018, "Member 'FInfoScreenSettings::DescriptionText' has a wrong offset!");
static_assert(offsetof(FInfoScreenSettings, Image) == 0x000030, "Member 'FInfoScreenSettings::Image' has a wrong offset!");

// ScriptStruct Stalker2.GridInfo
// 0x0010 (0x0010 - 0x0000)
struct FGridInfo final
{
public:
	class FName                                   GridName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        OverrideStreamingDistance;                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridInfo) == 0x000008, "Wrong alignment on FGridInfo");
static_assert(sizeof(FGridInfo) == 0x000010, "Wrong size on FGridInfo");
static_assert(offsetof(FGridInfo, GridName) == 0x000000, "Member 'FGridInfo::GridName' has a wrong offset!");
static_assert(offsetof(FGridInfo, OverrideStreamingDistance) == 0x000008, "Member 'FGridInfo::OverrideStreamingDistance' has a wrong offset!");

// ScriptStruct Stalker2.ItemLock
// 0x0008 (0x0008 - 0x0000)
struct FItemLock final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemCount;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemLock) == 0x000004, "Wrong alignment on FItemLock");
static_assert(sizeof(FItemLock) == 0x000008, "Wrong size on FItemLock");
static_assert(offsetof(FItemLock, ItemCount) == 0x000004, "Member 'FItemLock::ItemCount' has a wrong offset!");

// ScriptStruct Stalker2.LockStruct
// 0x0060 (0x0060 - 0x0000)
struct FLockStruct final
{
public:
	TArray<struct FItemLock>                      LockedByItems;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGlobalVariable>   LockedByGlobalVariables;                           // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLockStruct) == 0x000008, "Wrong alignment on FLockStruct");
static_assert(sizeof(FLockStruct) == 0x000060, "Wrong size on FLockStruct");
static_assert(offsetof(FLockStruct, LockedByItems) == 0x000000, "Member 'FLockStruct::LockedByItems' has a wrong offset!");
static_assert(offsetof(FLockStruct, LockedByGlobalVariables) == 0x000010, "Member 'FLockStruct::LockedByGlobalVariables' has a wrong offset!");

// ScriptStruct Stalker2.BodyPartRestriction
// 0x000C (0x000C - 0x0000)
struct FBodyPartRestriction final
{
public:
	float                                         RotationLimit;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeed;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotationBlocked;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldRotateIndependently;                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBodyPartRestriction) == 0x000004, "Wrong alignment on FBodyPartRestriction");
static_assert(sizeof(FBodyPartRestriction) == 0x00000C, "Wrong size on FBodyPartRestriction");
static_assert(offsetof(FBodyPartRestriction, RotationLimit) == 0x000000, "Member 'FBodyPartRestriction::RotationLimit' has a wrong offset!");
static_assert(offsetof(FBodyPartRestriction, RotationSpeed) == 0x000004, "Member 'FBodyPartRestriction::RotationSpeed' has a wrong offset!");
static_assert(offsetof(FBodyPartRestriction, RotationBlocked) == 0x000008, "Member 'FBodyPartRestriction::RotationBlocked' has a wrong offset!");
static_assert(offsetof(FBodyPartRestriction, bShouldRotateIndependently) == 0x000009, "Member 'FBodyPartRestriction::bShouldRotateIndependently' has a wrong offset!");

// ScriptStruct Stalker2.LookAtAngleParams
// 0x0060 (0x0060 - 0x0000)
struct FLookAtAngleParams final
{
public:
	bool                                          bAllowEyeRotate;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               MaxAngleOfEyeRotate;                               // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAllowHeadRotate;                                  // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               MaxAngleOfHeadRotate;                              // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAllowBodyRotate;                                  // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               MaxAngleOfBodyRotate;                              // 0x0048(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLookAtAngleParams) == 0x000008, "Wrong alignment on FLookAtAngleParams");
static_assert(sizeof(FLookAtAngleParams) == 0x000060, "Wrong size on FLookAtAngleParams");
static_assert(offsetof(FLookAtAngleParams, bAllowEyeRotate) == 0x000000, "Member 'FLookAtAngleParams::bAllowEyeRotate' has a wrong offset!");
static_assert(offsetof(FLookAtAngleParams, MaxAngleOfEyeRotate) == 0x000008, "Member 'FLookAtAngleParams::MaxAngleOfEyeRotate' has a wrong offset!");
static_assert(offsetof(FLookAtAngleParams, bAllowHeadRotate) == 0x000020, "Member 'FLookAtAngleParams::bAllowHeadRotate' has a wrong offset!");
static_assert(offsetof(FLookAtAngleParams, MaxAngleOfHeadRotate) == 0x000028, "Member 'FLookAtAngleParams::MaxAngleOfHeadRotate' has a wrong offset!");
static_assert(offsetof(FLookAtAngleParams, bAllowBodyRotate) == 0x000040, "Member 'FLookAtAngleParams::bAllowBodyRotate' has a wrong offset!");
static_assert(offsetof(FLookAtAngleParams, MaxAngleOfBodyRotate) == 0x000048, "Member 'FLookAtAngleParams::MaxAngleOfBodyRotate' has a wrong offset!");

// ScriptStruct Stalker2.PlayerAutoCoverAnimations
// 0x0078 (0x0078 - 0x0000)
struct FPlayerAutoCoverAnimations final
{
public:
	class UAnimSequence*                          StandInCoverPose;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ApproachCover;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ApproachCoverLeft;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ApproachCoverRight;                                // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ExitCover;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CanLeanLeftPose;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CanLeanRightPose;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AimLeftPose;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AimRightPose;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            AimLeftPoseBlendSpace;                             // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            AimRightPoseBlendSpace;                            // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AimUpPose;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AimlessShootLeftPose;                              // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AimlessShootRightPose;                             // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AimlessShootUpPose;                                // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerAutoCoverAnimations) == 0x000008, "Wrong alignment on FPlayerAutoCoverAnimations");
static_assert(sizeof(FPlayerAutoCoverAnimations) == 0x000078, "Wrong size on FPlayerAutoCoverAnimations");
static_assert(offsetof(FPlayerAutoCoverAnimations, StandInCoverPose) == 0x000000, "Member 'FPlayerAutoCoverAnimations::StandInCoverPose' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, ApproachCover) == 0x000008, "Member 'FPlayerAutoCoverAnimations::ApproachCover' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, ApproachCoverLeft) == 0x000010, "Member 'FPlayerAutoCoverAnimations::ApproachCoverLeft' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, ApproachCoverRight) == 0x000018, "Member 'FPlayerAutoCoverAnimations::ApproachCoverRight' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, ExitCover) == 0x000020, "Member 'FPlayerAutoCoverAnimations::ExitCover' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, CanLeanLeftPose) == 0x000028, "Member 'FPlayerAutoCoverAnimations::CanLeanLeftPose' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, CanLeanRightPose) == 0x000030, "Member 'FPlayerAutoCoverAnimations::CanLeanRightPose' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, AimLeftPose) == 0x000038, "Member 'FPlayerAutoCoverAnimations::AimLeftPose' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, AimRightPose) == 0x000040, "Member 'FPlayerAutoCoverAnimations::AimRightPose' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, AimLeftPoseBlendSpace) == 0x000048, "Member 'FPlayerAutoCoverAnimations::AimLeftPoseBlendSpace' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, AimRightPoseBlendSpace) == 0x000050, "Member 'FPlayerAutoCoverAnimations::AimRightPoseBlendSpace' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, AimUpPose) == 0x000058, "Member 'FPlayerAutoCoverAnimations::AimUpPose' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, AimlessShootLeftPose) == 0x000060, "Member 'FPlayerAutoCoverAnimations::AimlessShootLeftPose' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, AimlessShootRightPose) == 0x000068, "Member 'FPlayerAutoCoverAnimations::AimlessShootRightPose' has a wrong offset!");
static_assert(offsetof(FPlayerAutoCoverAnimations, AimlessShootUpPose) == 0x000070, "Member 'FPlayerAutoCoverAnimations::AimlessShootUpPose' has a wrong offset!");

// ScriptStruct Stalker2.CaptureConfig
// 0x0048 (0x0048 - 0x0000)
struct FCaptureConfig final
{
public:
	float                                         CaptureAngle;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureWarmup;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileLimitsForZCoords;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadTileOverlapSize;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureTileOverlap;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CaptureStartLocation;                              // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldPartitionTiles;                               // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LargeImagesNum;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IterativeCellSize;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SingleTileMinimapResolution;                       // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetGamma;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateFoliage;                                    // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCaptureConfig) == 0x000008, "Wrong alignment on FCaptureConfig");
static_assert(sizeof(FCaptureConfig) == 0x000048, "Wrong size on FCaptureConfig");
static_assert(offsetof(FCaptureConfig, CaptureAngle) == 0x000000, "Member 'FCaptureConfig::CaptureAngle' has a wrong offset!");
static_assert(offsetof(FCaptureConfig, CaptureWarmup) == 0x000004, "Member 'FCaptureConfig::CaptureWarmup' has a wrong offset!");
static_assert(offsetof(FCaptureConfig, TileLimitsForZCoords) == 0x000008, "Member 'FCaptureConfig::TileLimitsForZCoords' has a wrong offset!");
static_assert(offsetof(FCaptureConfig, LoadTileOverlapSize) == 0x00000C, "Member 'FCaptureConfig::LoadTileOverlapSize' has a wrong offset!");
static_assert(offsetof(FCaptureConfig, CaptureTileOverlap) == 0x000010, "Member 'FCaptureConfig::CaptureTileOverlap' has a wrong offset!");
static_assert(offsetof(FCaptureConfig, CaptureStartLocation) == 0x000018, "Member 'FCaptureConfig::CaptureStartLocation' has a wrong offset!");
static_assert(offsetof(FCaptureConfig, WorldPartitionTiles) == 0x000030, "Member 'FCaptureConfig::WorldPartitionTiles' has a wrong offset!");
static_assert(offsetof(FCaptureConfig, LargeImagesNum) == 0x000034, "Member 'FCaptureConfig::LargeImagesNum' has a wrong offset!");
static_assert(offsetof(FCaptureConfig, IterativeCellSize) == 0x000038, "Member 'FCaptureConfig::IterativeCellSize' has a wrong offset!");
static_assert(offsetof(FCaptureConfig, SingleTileMinimapResolution) == 0x00003C, "Member 'FCaptureConfig::SingleTileMinimapResolution' has a wrong offset!");
static_assert(offsetof(FCaptureConfig, TargetGamma) == 0x000040, "Member 'FCaptureConfig::TargetGamma' has a wrong offset!");
static_assert(offsetof(FCaptureConfig, bCreateFoliage) == 0x000044, "Member 'FCaptureConfig::bCreateFoliage' has a wrong offset!");

// ScriptStruct Stalker2.ZoomMarkerSettings
// 0x0010 (0x0010 - 0x0000)
struct FZoomMarkerSettings final
{
public:
	int32                                         MaxZoomLevelToShow;                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinZoomLevelToShow;                                // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxZoomLevelToShowHab;                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinZoomLevelToShowHub;                             // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoomMarkerSettings) == 0x000004, "Wrong alignment on FZoomMarkerSettings");
static_assert(sizeof(FZoomMarkerSettings) == 0x000010, "Wrong size on FZoomMarkerSettings");
static_assert(offsetof(FZoomMarkerSettings, MaxZoomLevelToShow) == 0x000000, "Member 'FZoomMarkerSettings::MaxZoomLevelToShow' has a wrong offset!");
static_assert(offsetof(FZoomMarkerSettings, MinZoomLevelToShow) == 0x000004, "Member 'FZoomMarkerSettings::MinZoomLevelToShow' has a wrong offset!");
static_assert(offsetof(FZoomMarkerSettings, MaxZoomLevelToShowHab) == 0x000008, "Member 'FZoomMarkerSettings::MaxZoomLevelToShowHab' has a wrong offset!");
static_assert(offsetof(FZoomMarkerSettings, MinZoomLevelToShowHub) == 0x00000C, "Member 'FZoomMarkerSettings::MinZoomLevelToShowHub' has a wrong offset!");

// ScriptStruct Stalker2.StrandStaticMeshComponent
// 0x0068 (0x0068 - 0x0000)
struct FStrandStaticMeshComponent final
{
public:
	struct FVector                                WorldPos;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               WorldRotation;                                     // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RelativeScale;                                     // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStrandStaticMeshComponent) == 0x000008, "Wrong alignment on FStrandStaticMeshComponent");
static_assert(sizeof(FStrandStaticMeshComponent) == 0x000068, "Wrong size on FStrandStaticMeshComponent");
static_assert(offsetof(FStrandStaticMeshComponent, WorldPos) == 0x000000, "Member 'FStrandStaticMeshComponent::WorldPos' has a wrong offset!");
static_assert(offsetof(FStrandStaticMeshComponent, StaticMesh) == 0x000018, "Member 'FStrandStaticMeshComponent::StaticMesh' has a wrong offset!");
static_assert(offsetof(FStrandStaticMeshComponent, RelativeRotation) == 0x000020, "Member 'FStrandStaticMeshComponent::RelativeRotation' has a wrong offset!");
static_assert(offsetof(FStrandStaticMeshComponent, WorldRotation) == 0x000038, "Member 'FStrandStaticMeshComponent::WorldRotation' has a wrong offset!");
static_assert(offsetof(FStrandStaticMeshComponent, RelativeScale) == 0x000050, "Member 'FStrandStaticMeshComponent::RelativeScale' has a wrong offset!");

// ScriptStruct Stalker2.MoveSettings
// 0x0008 (0x0008 - 0x0000)
struct FMoveSettings final
{
public:
	float                                         SpeedMapZoom;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoveSettings) == 0x000004, "Wrong alignment on FMoveSettings");
static_assert(sizeof(FMoveSettings) == 0x000008, "Wrong size on FMoveSettings");
static_assert(offsetof(FMoveSettings, SpeedMapZoom) == 0x000000, "Member 'FMoveSettings::SpeedMapZoom' has a wrong offset!");
static_assert(offsetof(FMoveSettings, Speed) == 0x000004, "Member 'FMoveSettings::Speed' has a wrong offset!");

// ScriptStruct Stalker2.ZoomLevelSettings
// 0x000C (0x000C - 0x0000)
struct FZoomLevelSettings final
{
public:
	float                                         MapZoom;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMoveSettings                          MoveSettings;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoomLevelSettings) == 0x000004, "Wrong alignment on FZoomLevelSettings");
static_assert(sizeof(FZoomLevelSettings) == 0x00000C, "Wrong size on FZoomLevelSettings");
static_assert(offsetof(FZoomLevelSettings, MapZoom) == 0x000000, "Member 'FZoomLevelSettings::MapZoom' has a wrong offset!");
static_assert(offsetof(FZoomLevelSettings, MoveSettings) == 0x000004, "Member 'FZoomLevelSettings::MoveSettings' has a wrong offset!");

// ScriptStruct Stalker2.TeleportData
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FTeleportData final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeleportData) == 0x000010, "Wrong alignment on FTeleportData");
static_assert(sizeof(FTeleportData) == 0x000080, "Wrong size on FTeleportData");

// ScriptStruct Stalker2.MarkerIconPair
// 0x0010 (0x0010 - 0x0000)
struct FMarkerIconPair final
{
public:
	class UTexture2D*                             Active;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Innactive;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarkerIconPair) == 0x000008, "Wrong alignment on FMarkerIconPair");
static_assert(sizeof(FMarkerIconPair) == 0x000010, "Wrong size on FMarkerIconPair");
static_assert(offsetof(FMarkerIconPair, Active) == 0x000000, "Member 'FMarkerIconPair::Active' has a wrong offset!");
static_assert(offsetof(FMarkerIconPair, Innactive) == 0x000008, "Member 'FMarkerIconPair::Innactive' has a wrong offset!");

// ScriptStruct Stalker2.MarkerStateIconsData
// 0x0028 (0x0028 - 0x0000)
struct FMarkerStateIconsData final
{
public:
	class FName                                   ColorStyle;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarkerIconPair                        Compass;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMarkerIconPair                        Map;                                               // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarkerStateIconsData) == 0x000008, "Wrong alignment on FMarkerStateIconsData");
static_assert(sizeof(FMarkerStateIconsData) == 0x000028, "Wrong size on FMarkerStateIconsData");
static_assert(offsetof(FMarkerStateIconsData, ColorStyle) == 0x000000, "Member 'FMarkerStateIconsData::ColorStyle' has a wrong offset!");
static_assert(offsetof(FMarkerStateIconsData, Compass) == 0x000008, "Member 'FMarkerStateIconsData::Compass' has a wrong offset!");
static_assert(offsetof(FMarkerStateIconsData, Map) == 0x000018, "Member 'FMarkerStateIconsData::Map' has a wrong offset!");

// ScriptStruct Stalker2.StreamingDistanceOverrideVolumeState
// 0x0050 (0x0050 - 0x0000)
struct FStreamingDistanceOverrideVolumeState final
{
public:
	class AStreamingDistanceOverridingVolume*     Volume;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x48];                                       // 0x0008(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStreamingDistanceOverrideVolumeState) == 0x000008, "Wrong alignment on FStreamingDistanceOverrideVolumeState");
static_assert(sizeof(FStreamingDistanceOverrideVolumeState) == 0x000050, "Wrong size on FStreamingDistanceOverrideVolumeState");
static_assert(offsetof(FStreamingDistanceOverrideVolumeState, Volume) == 0x000000, "Member 'FStreamingDistanceOverrideVolumeState::Volume' has a wrong offset!");

// ScriptStruct Stalker2.MarkerIconData
// 0x0050 (0x0058 - 0x0008)
struct FMarkerIconData final : public FTableRowBase
{
public:
	TMap<EMarkerState, struct FMarkerStateIconsData> MarkerStateIcons;                               // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarkerIconData) == 0x000008, "Wrong alignment on FMarkerIconData");
static_assert(sizeof(FMarkerIconData) == 0x000058, "Wrong size on FMarkerIconData");
static_assert(offsetof(FMarkerIconData, MarkerStateIcons) == 0x000008, "Member 'FMarkerIconData::MarkerStateIcons' has a wrong offset!");

// ScriptStruct Stalker2.ZoomInterval
// 0x0008 (0x0008 - 0x0000)
struct FZoomInterval final
{
public:
	int32                                         MinZoomLevel;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxZoomLevel;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoomInterval) == 0x000004, "Wrong alignment on FZoomInterval");
static_assert(sizeof(FZoomInterval) == 0x000008, "Wrong size on FZoomInterval");
static_assert(offsetof(FZoomInterval, MinZoomLevel) == 0x000000, "Member 'FZoomInterval::MinZoomLevel' has a wrong offset!");
static_assert(offsetof(FZoomInterval, MaxZoomLevel) == 0x000004, "Member 'FZoomInterval::MaxZoomLevel' has a wrong offset!");

// ScriptStruct Stalker2.SplinePointMeshData
// 0x0068 (0x0068 - 0x0000)
struct FSplinePointMeshData final
{
public:
	class UStaticMesh*                            StrandStaticMesh;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SeparatorStaticMesh;                               // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrefabAsset*                           PrefabStrandMesh;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrefabAsset*                           PrefabSeparatorMesh;                               // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x48];                                      // 0x0020(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSplinePointMeshData) == 0x000008, "Wrong alignment on FSplinePointMeshData");
static_assert(sizeof(FSplinePointMeshData) == 0x000068, "Wrong size on FSplinePointMeshData");
static_assert(offsetof(FSplinePointMeshData, StrandStaticMesh) == 0x000000, "Member 'FSplinePointMeshData::StrandStaticMesh' has a wrong offset!");
static_assert(offsetof(FSplinePointMeshData, SeparatorStaticMesh) == 0x000008, "Member 'FSplinePointMeshData::SeparatorStaticMesh' has a wrong offset!");
static_assert(offsetof(FSplinePointMeshData, PrefabStrandMesh) == 0x000010, "Member 'FSplinePointMeshData::PrefabStrandMesh' has a wrong offset!");
static_assert(offsetof(FSplinePointMeshData, PrefabSeparatorMesh) == 0x000018, "Member 'FSplinePointMeshData::PrefabSeparatorMesh' has a wrong offset!");

// ScriptStruct Stalker2.MapTypeSettings
// 0x001C (0x001C - 0x0000)
struct FMapTypeSettings final
{
public:
	bool                                          bIsMapType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FZoomInterval                          ZoomInterval;                                      // 0x0004(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FZoomInterval                          TrackedZoomInterval;                               // 0x000C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ZOrder;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportHubFolding;                                // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapTypeSettings) == 0x000004, "Wrong alignment on FMapTypeSettings");
static_assert(sizeof(FMapTypeSettings) == 0x00001C, "Wrong size on FMapTypeSettings");
static_assert(offsetof(FMapTypeSettings, bIsMapType) == 0x000000, "Member 'FMapTypeSettings::bIsMapType' has a wrong offset!");
static_assert(offsetof(FMapTypeSettings, ZoomInterval) == 0x000004, "Member 'FMapTypeSettings::ZoomInterval' has a wrong offset!");
static_assert(offsetof(FMapTypeSettings, TrackedZoomInterval) == 0x00000C, "Member 'FMapTypeSettings::TrackedZoomInterval' has a wrong offset!");
static_assert(offsetof(FMapTypeSettings, ZOrder) == 0x000014, "Member 'FMapTypeSettings::ZOrder' has a wrong offset!");
static_assert(offsetof(FMapTypeSettings, bSupportHubFolding) == 0x000018, "Member 'FMapTypeSettings::bSupportHubFolding' has a wrong offset!");

// ScriptStruct Stalker2.CompassTypeSettings
// 0x0008 (0x0008 - 0x0000)
struct FCompassTypeSettings final
{
public:
	bool                                          bIsCompassType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibleIfTrack;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompassPosition                              CompassPosition;                                   // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ZOrder;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompassTypeSettings) == 0x000004, "Wrong alignment on FCompassTypeSettings");
static_assert(sizeof(FCompassTypeSettings) == 0x000008, "Wrong size on FCompassTypeSettings");
static_assert(offsetof(FCompassTypeSettings, bIsCompassType) == 0x000000, "Member 'FCompassTypeSettings::bIsCompassType' has a wrong offset!");
static_assert(offsetof(FCompassTypeSettings, bVisibleIfTrack) == 0x000001, "Member 'FCompassTypeSettings::bVisibleIfTrack' has a wrong offset!");
static_assert(offsetof(FCompassTypeSettings, CompassPosition) == 0x000002, "Member 'FCompassTypeSettings::CompassPosition' has a wrong offset!");
static_assert(offsetof(FCompassTypeSettings, ZOrder) == 0x000004, "Member 'FCompassTypeSettings::ZOrder' has a wrong offset!");

// ScriptStruct Stalker2.StructItemGeneratorElementCountedPart
// 0x0008 (0x0008 - 0x0000)
struct FStructItemGeneratorElementCountedPart
{
public:
	int32                                         MinCount;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStructItemGeneratorElementCountedPart) == 0x000004, "Wrong alignment on FStructItemGeneratorElementCountedPart");
static_assert(sizeof(FStructItemGeneratorElementCountedPart) == 0x000008, "Wrong size on FStructItemGeneratorElementCountedPart");
static_assert(offsetof(FStructItemGeneratorElementCountedPart, MinCount) == 0x000000, "Member 'FStructItemGeneratorElementCountedPart::MinCount' has a wrong offset!");
static_assert(offsetof(FStructItemGeneratorElementCountedPart, MaxCount) == 0x000004, "Member 'FStructItemGeneratorElementCountedPart::MaxCount' has a wrong offset!");

// ScriptStruct Stalker2.StructItemGeneratorSingleElement
// 0x0068 (0x0070 - 0x0008)
struct alignas(0x08) FStructItemGeneratorSingleElement final : public FStructItemGeneratorElementCountedPart
{
public:
	uint8                                         Pad_8[0x4];                                        // 0x0008(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Chance;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDurability;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDurability;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponGenerationFlags                        WeaponGenerationFlags;                             // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x53];                                      // 0x001D(0x0053)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStructItemGeneratorSingleElement) == 0x000008, "Wrong alignment on FStructItemGeneratorSingleElement");
static_assert(sizeof(FStructItemGeneratorSingleElement) == 0x000070, "Wrong size on FStructItemGeneratorSingleElement");
static_assert(offsetof(FStructItemGeneratorSingleElement, Chance) == 0x00000C, "Member 'FStructItemGeneratorSingleElement::Chance' has a wrong offset!");
static_assert(offsetof(FStructItemGeneratorSingleElement, Weight) == 0x000010, "Member 'FStructItemGeneratorSingleElement::Weight' has a wrong offset!");
static_assert(offsetof(FStructItemGeneratorSingleElement, MinDurability) == 0x000014, "Member 'FStructItemGeneratorSingleElement::MinDurability' has a wrong offset!");
static_assert(offsetof(FStructItemGeneratorSingleElement, MaxDurability) == 0x000018, "Member 'FStructItemGeneratorSingleElement::MaxDurability' has a wrong offset!");
static_assert(offsetof(FStructItemGeneratorSingleElement, WeaponGenerationFlags) == 0x00001C, "Member 'FStructItemGeneratorSingleElement::WeaponGenerationFlags' has a wrong offset!");

// ScriptStruct Stalker2.StructItemGenerationCategory
// 0x0058 (0x0058 - 0x0000)
struct FStructItemGenerationCategory final
{
public:
	EItemGenerationCategory                       Category;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStructItemGeneratorSingleElement> PossibleItems;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAllowSameCategoryGeneration;                      // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3F];                                      // 0x0019(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStructItemGenerationCategory) == 0x000008, "Wrong alignment on FStructItemGenerationCategory");
static_assert(sizeof(FStructItemGenerationCategory) == 0x000058, "Wrong size on FStructItemGenerationCategory");
static_assert(offsetof(FStructItemGenerationCategory, Category) == 0x000000, "Member 'FStructItemGenerationCategory::Category' has a wrong offset!");
static_assert(offsetof(FStructItemGenerationCategory, PossibleItems) == 0x000008, "Member 'FStructItemGenerationCategory::PossibleItems' has a wrong offset!");
static_assert(offsetof(FStructItemGenerationCategory, bAllowSameCategoryGeneration) == 0x000018, "Member 'FStructItemGenerationCategory::bAllowSameCategoryGeneration' has a wrong offset!");

// ScriptStruct Stalker2.MarkerIconSettings
// 0x0020 (0x0020 - 0x0000)
struct FMarkerIconSettings final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             TextureTracked;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        RelativeScale;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColorSID;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarkerIconSettings) == 0x000008, "Wrong alignment on FMarkerIconSettings");
static_assert(sizeof(FMarkerIconSettings) == 0x000020, "Wrong size on FMarkerIconSettings");
static_assert(offsetof(FMarkerIconSettings, Texture) == 0x000000, "Member 'FMarkerIconSettings::Texture' has a wrong offset!");
static_assert(offsetof(FMarkerIconSettings, TextureTracked) == 0x000008, "Member 'FMarkerIconSettings::TextureTracked' has a wrong offset!");
static_assert(offsetof(FMarkerIconSettings, RelativeScale) == 0x000010, "Member 'FMarkerIconSettings::RelativeScale' has a wrong offset!");
static_assert(offsetof(FMarkerIconSettings, ColorSID) == 0x000018, "Member 'FMarkerIconSettings::ColorSID' has a wrong offset!");

// ScriptStruct Stalker2.MarkerTypeSettings
// 0x0048 (0x0048 - 0x0000)
struct FMarkerTypeSettings final
{
public:
	struct FMarkerIconSettings                    IconSettings;                                      // 0x0000(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTrackable;                                        // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHaveDiscoveredState;                              // 0x0021(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCompassTypeSettings                   CompassTypeSettings;                               // 0x0024(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FMapTypeSettings                       MapTypeSettings;                                   // 0x002C(0x001C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarkerTypeSettings) == 0x000008, "Wrong alignment on FMarkerTypeSettings");
static_assert(sizeof(FMarkerTypeSettings) == 0x000048, "Wrong size on FMarkerTypeSettings");
static_assert(offsetof(FMarkerTypeSettings, IconSettings) == 0x000000, "Member 'FMarkerTypeSettings::IconSettings' has a wrong offset!");
static_assert(offsetof(FMarkerTypeSettings, bTrackable) == 0x000020, "Member 'FMarkerTypeSettings::bTrackable' has a wrong offset!");
static_assert(offsetof(FMarkerTypeSettings, bHaveDiscoveredState) == 0x000021, "Member 'FMarkerTypeSettings::bHaveDiscoveredState' has a wrong offset!");
static_assert(offsetof(FMarkerTypeSettings, CompassTypeSettings) == 0x000024, "Member 'FMarkerTypeSettings::CompassTypeSettings' has a wrong offset!");
static_assert(offsetof(FMarkerTypeSettings, MapTypeSettings) == 0x00002C, "Member 'FMarkerTypeSettings::MapTypeSettings' has a wrong offset!");

// ScriptStruct Stalker2.GUIDIndex
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FGUIDIndex final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGUIDIndex) == 0x000004, "Wrong alignment on FGUIDIndex");
static_assert(sizeof(FGUIDIndex) == 0x000004, "Wrong size on FGUIDIndex");

// ScriptStruct Stalker2.TextProperties
// 0x0014 (0x0014 - 0x0000)
struct FTextProperties final
{
public:
	EHorizontalAlignment                          TextAlignment;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                TextMargin;                                        // 0x0004(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextProperties) == 0x000004, "Wrong alignment on FTextProperties");
static_assert(sizeof(FTextProperties) == 0x000014, "Wrong size on FTextProperties");
static_assert(offsetof(FTextProperties, TextAlignment) == 0x000000, "Member 'FTextProperties::TextAlignment' has a wrong offset!");
static_assert(offsetof(FTextProperties, TextMargin) == 0x000004, "Member 'FTextProperties::TextMargin' has a wrong offset!");

// ScriptStruct Stalker2.SlotScaleSettings
// 0x0014 (0x0014 - 0x0000)
struct FSlotScaleSettings final
{
public:
	struct FMargin                                Padding;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlotScaleSettings) == 0x000004, "Wrong alignment on FSlotScaleSettings");
static_assert(sizeof(FSlotScaleSettings) == 0x000014, "Wrong size on FSlotScaleSettings");
static_assert(offsetof(FSlotScaleSettings, Padding) == 0x000000, "Member 'FSlotScaleSettings::Padding' has a wrong offset!");
static_assert(offsetof(FSlotScaleSettings, HorizontalAlignment) == 0x000010, "Member 'FSlotScaleSettings::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(FSlotScaleSettings, VerticalAlignment) == 0x000011, "Member 'FSlotScaleSettings::VerticalAlignment' has a wrong offset!");

// ScriptStruct Stalker2.StructConditionalGeneration
// 0x0030 (0x0030 - 0x0000)
struct FStructConditionalGeneration final
{
public:
	double                                        RefreshGameTime;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ERank>                                 PlayerRanks;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EGameDifficulty>                       Difficulties;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReputationThreshold;                               // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStructConditionalGeneration) == 0x000008, "Wrong alignment on FStructConditionalGeneration");
static_assert(sizeof(FStructConditionalGeneration) == 0x000030, "Wrong size on FStructConditionalGeneration");
static_assert(offsetof(FStructConditionalGeneration, RefreshGameTime) == 0x000000, "Member 'FStructConditionalGeneration::RefreshGameTime' has a wrong offset!");
static_assert(offsetof(FStructConditionalGeneration, PlayerRanks) == 0x000008, "Member 'FStructConditionalGeneration::PlayerRanks' has a wrong offset!");
static_assert(offsetof(FStructConditionalGeneration, Difficulties) == 0x000018, "Member 'FStructConditionalGeneration::Difficulties' has a wrong offset!");
static_assert(offsetof(FStructConditionalGeneration, ReputationThreshold) == 0x000028, "Member 'FStructConditionalGeneration::ReputationThreshold' has a wrong offset!");

// ScriptStruct Stalker2.InitialCollectionSize
// 0x0048 (0x0048 - 0x0000)
struct FInitialCollectionSize final
{
public:
	int32                                         AgentView;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AgentModel;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnomalyView;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnomalyModel;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArtifactView;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileView;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AIComponent;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AkComponent;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AkLateReverbComponent;                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AkRoomComponent;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AkSurfaceReflectorSetComponent;                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemContainer;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestructibleView;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestructibleModel;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WetnessComponent;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlashlightComponent;                               // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContextualActionModel;                             // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuestNode;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInitialCollectionSize) == 0x000004, "Wrong alignment on FInitialCollectionSize");
static_assert(sizeof(FInitialCollectionSize) == 0x000048, "Wrong size on FInitialCollectionSize");
static_assert(offsetof(FInitialCollectionSize, AgentView) == 0x000000, "Member 'FInitialCollectionSize::AgentView' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, AgentModel) == 0x000004, "Member 'FInitialCollectionSize::AgentModel' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, AnomalyView) == 0x000008, "Member 'FInitialCollectionSize::AnomalyView' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, AnomalyModel) == 0x00000C, "Member 'FInitialCollectionSize::AnomalyModel' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, ArtifactView) == 0x000010, "Member 'FInitialCollectionSize::ArtifactView' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, ProjectileView) == 0x000014, "Member 'FInitialCollectionSize::ProjectileView' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, AIComponent) == 0x000018, "Member 'FInitialCollectionSize::AIComponent' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, AkComponent) == 0x00001C, "Member 'FInitialCollectionSize::AkComponent' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, AkLateReverbComponent) == 0x000020, "Member 'FInitialCollectionSize::AkLateReverbComponent' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, AkRoomComponent) == 0x000024, "Member 'FInitialCollectionSize::AkRoomComponent' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, AkSurfaceReflectorSetComponent) == 0x000028, "Member 'FInitialCollectionSize::AkSurfaceReflectorSetComponent' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, ItemContainer) == 0x00002C, "Member 'FInitialCollectionSize::ItemContainer' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, DestructibleView) == 0x000030, "Member 'FInitialCollectionSize::DestructibleView' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, DestructibleModel) == 0x000034, "Member 'FInitialCollectionSize::DestructibleModel' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, WetnessComponent) == 0x000038, "Member 'FInitialCollectionSize::WetnessComponent' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, FlashlightComponent) == 0x00003C, "Member 'FInitialCollectionSize::FlashlightComponent' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, ContextualActionModel) == 0x000040, "Member 'FInitialCollectionSize::ContextualActionModel' has a wrong offset!");
static_assert(offsetof(FInitialCollectionSize, QuestNode) == 0x000044, "Member 'FInitialCollectionSize::QuestNode' has a wrong offset!");

// ScriptStruct Stalker2.MeshCategory
// 0x0018 (0x0018 - 0x0000)
struct FMeshCategory final
{
public:
	class FName                                   MeshCategory;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMeshesData>                    MeshesData;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshCategory) == 0x000008, "Wrong alignment on FMeshCategory");
static_assert(sizeof(FMeshCategory) == 0x000018, "Wrong size on FMeshCategory");
static_assert(offsetof(FMeshCategory, MeshCategory) == 0x000000, "Member 'FMeshCategory::MeshCategory' has a wrong offset!");
static_assert(offsetof(FMeshCategory, MeshesData) == 0x000008, "Member 'FMeshCategory::MeshesData' has a wrong offset!");

// ScriptStruct Stalker2.MeshSoundPlacerDataRow
// 0x0058 (0x0060 - 0x0008)
struct FMeshSoundPlacerDataRow final : public FTableRowBase
{
public:
	float                                         RaycastSphereRadius;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RubberBandDistanceAtWalk;                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RubberBandDistanceAtRun;                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RubberBandDistanceAtSprint;                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RubberBandSpeed;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAkAudioEvent>           StopAkEvent;                                       // 0x0020(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMeshCategory>                  MeshCategories;                                    // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshSoundPlacerDataRow) == 0x000008, "Wrong alignment on FMeshSoundPlacerDataRow");
static_assert(sizeof(FMeshSoundPlacerDataRow) == 0x000060, "Wrong size on FMeshSoundPlacerDataRow");
static_assert(offsetof(FMeshSoundPlacerDataRow, RaycastSphereRadius) == 0x000008, "Member 'FMeshSoundPlacerDataRow::RaycastSphereRadius' has a wrong offset!");
static_assert(offsetof(FMeshSoundPlacerDataRow, RubberBandDistanceAtWalk) == 0x00000C, "Member 'FMeshSoundPlacerDataRow::RubberBandDistanceAtWalk' has a wrong offset!");
static_assert(offsetof(FMeshSoundPlacerDataRow, RubberBandDistanceAtRun) == 0x000010, "Member 'FMeshSoundPlacerDataRow::RubberBandDistanceAtRun' has a wrong offset!");
static_assert(offsetof(FMeshSoundPlacerDataRow, RubberBandDistanceAtSprint) == 0x000014, "Member 'FMeshSoundPlacerDataRow::RubberBandDistanceAtSprint' has a wrong offset!");
static_assert(offsetof(FMeshSoundPlacerDataRow, RubberBandSpeed) == 0x000018, "Member 'FMeshSoundPlacerDataRow::RubberBandSpeed' has a wrong offset!");
static_assert(offsetof(FMeshSoundPlacerDataRow, StopAkEvent) == 0x000020, "Member 'FMeshSoundPlacerDataRow::StopAkEvent' has a wrong offset!");
static_assert(offsetof(FMeshSoundPlacerDataRow, MeshCategories) == 0x000050, "Member 'FMeshSoundPlacerDataRow::MeshCategories' has a wrong offset!");

// ScriptStruct Stalker2.ViewOpenSettings
// 0x0038 (0x0038 - 0x0000)
struct FViewOpenSettings final
{
public:
	bool                                          bShouldEffectCursorOnShow;                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShoudShowMouseCursor;                             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShoudIdleAnimation;                               // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShoudIgnoreInputOnPause;                          // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShoudClearInputOnClose;                           // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShoudSendOpenUpdateEvent;                         // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShoudCheckOpenView;                               // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShoudIgnoreCheckOpenView;                         // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShoudIgnoreLowPriority;                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNewerCloseOtherViews;                             // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECloseType                                    CloseType;                                         // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EWidgetNameEx>                         WidgetsToHideThisWhenOpen;                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<EWidgetNameEx>                         CloseWidgetNames;                                  // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         PriorityZOrder;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeRestoredAfterPause;                          // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FViewOpenSettings) == 0x000008, "Wrong alignment on FViewOpenSettings");
static_assert(sizeof(FViewOpenSettings) == 0x000038, "Wrong size on FViewOpenSettings");
static_assert(offsetof(FViewOpenSettings, bShouldEffectCursorOnShow) == 0x000000, "Member 'FViewOpenSettings::bShouldEffectCursorOnShow' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, bShoudShowMouseCursor) == 0x000001, "Member 'FViewOpenSettings::bShoudShowMouseCursor' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, bShoudIdleAnimation) == 0x000002, "Member 'FViewOpenSettings::bShoudIdleAnimation' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, bShoudIgnoreInputOnPause) == 0x000003, "Member 'FViewOpenSettings::bShoudIgnoreInputOnPause' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, bShoudClearInputOnClose) == 0x000004, "Member 'FViewOpenSettings::bShoudClearInputOnClose' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, bShoudSendOpenUpdateEvent) == 0x000005, "Member 'FViewOpenSettings::bShoudSendOpenUpdateEvent' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, bShoudCheckOpenView) == 0x000006, "Member 'FViewOpenSettings::bShoudCheckOpenView' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, bShoudIgnoreCheckOpenView) == 0x000007, "Member 'FViewOpenSettings::bShoudIgnoreCheckOpenView' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, bShoudIgnoreLowPriority) == 0x000008, "Member 'FViewOpenSettings::bShoudIgnoreLowPriority' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, bNewerCloseOtherViews) == 0x000009, "Member 'FViewOpenSettings::bNewerCloseOtherViews' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, CloseType) == 0x00000A, "Member 'FViewOpenSettings::CloseType' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, WidgetsToHideThisWhenOpen) == 0x000010, "Member 'FViewOpenSettings::WidgetsToHideThisWhenOpen' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, CloseWidgetNames) == 0x000020, "Member 'FViewOpenSettings::CloseWidgetNames' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, PriorityZOrder) == 0x000030, "Member 'FViewOpenSettings::PriorityZOrder' has a wrong offset!");
static_assert(offsetof(FViewOpenSettings, bCanBeRestoredAfterPause) == 0x000034, "Member 'FViewOpenSettings::bCanBeRestoredAfterPause' has a wrong offset!");

// ScriptStruct Stalker2.DoubleLineSettings
// 0x0020 (0x0020 - 0x0000)
struct FDoubleLineSettings final
{
public:
	class FString                                 FindTag;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CorrectTag;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDoubleLineSettings) == 0x000008, "Wrong alignment on FDoubleLineSettings");
static_assert(sizeof(FDoubleLineSettings) == 0x000020, "Wrong size on FDoubleLineSettings");
static_assert(offsetof(FDoubleLineSettings, FindTag) == 0x000000, "Member 'FDoubleLineSettings::FindTag' has a wrong offset!");
static_assert(offsetof(FDoubleLineSettings, CorrectTag) == 0x000010, "Member 'FDoubleLineSettings::CorrectTag' has a wrong offset!");

// ScriptStruct Stalker2.ModioLegendData
// 0x0010 (0x0010 - 0x0000)
struct FModioLegendData final
{
public:
	class UModioLegendModel*                      BrowseShortcutsModel;                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModioLegendModel*                      DetailsShortcutsModel;                             // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModioLegendData) == 0x000008, "Wrong alignment on FModioLegendData");
static_assert(sizeof(FModioLegendData) == 0x000010, "Wrong size on FModioLegendData");
static_assert(offsetof(FModioLegendData, BrowseShortcutsModel) == 0x000000, "Member 'FModioLegendData::BrowseShortcutsModel' has a wrong offset!");
static_assert(offsetof(FModioLegendData, DetailsShortcutsModel) == 0x000008, "Member 'FModioLegendData::DetailsShortcutsModel' has a wrong offset!");

// ScriptStruct Stalker2.GroupUID
// 0x0000 (0x0004 - 0x0004)
struct FGroupUID final : public FUID
{
};
static_assert(alignof(FGroupUID) == 0x000004, "Wrong alignment on FGroupUID");
static_assert(sizeof(FGroupUID) == 0x000004, "Wrong size on FGroupUID");

// ScriptStruct Stalker2.MontageSection
// 0x0010 (0x0010 - 0x0000)
struct FMontageSection final
{
public:
	class FString                                 Value;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMontageSection) == 0x000008, "Wrong alignment on FMontageSection");
static_assert(sizeof(FMontageSection) == 0x000010, "Wrong size on FMontageSection");
static_assert(offsetof(FMontageSection, Value) == 0x000000, "Member 'FMontageSection::Value' has a wrong offset!");

// ScriptStruct Stalker2.MovementParams
// 0x0058 (0x0058 - 0x0000)
struct FMovementParams final
{
public:
	float                                         WalkSpeed;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeed;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchSpeed;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowCrouchSpeed;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintSpeed;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbSpeedCoef;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpSpeedCoef;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimpSpeedCoef;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkDiagonalBackCoef;                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunDiagonalBackCoef;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkBackCoef;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunBackCoef;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveBackCrouchCoef;                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveBackLowCrouchCoef;                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControlCoef;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkTransitionCoef;                                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseTurnRate;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLookUpRate;                                    // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlowdownValue;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaggerAngle;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDash;                                          // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovementParams) == 0x000004, "Wrong alignment on FMovementParams");
static_assert(sizeof(FMovementParams) == 0x000058, "Wrong size on FMovementParams");
static_assert(offsetof(FMovementParams, WalkSpeed) == 0x000000, "Member 'FMovementParams::WalkSpeed' has a wrong offset!");
static_assert(offsetof(FMovementParams, RunSpeed) == 0x000004, "Member 'FMovementParams::RunSpeed' has a wrong offset!");
static_assert(offsetof(FMovementParams, CrouchSpeed) == 0x000008, "Member 'FMovementParams::CrouchSpeed' has a wrong offset!");
static_assert(offsetof(FMovementParams, LowCrouchSpeed) == 0x00000C, "Member 'FMovementParams::LowCrouchSpeed' has a wrong offset!");
static_assert(offsetof(FMovementParams, SprintSpeed) == 0x000010, "Member 'FMovementParams::SprintSpeed' has a wrong offset!");
static_assert(offsetof(FMovementParams, ClimbSpeedCoef) == 0x000014, "Member 'FMovementParams::ClimbSpeedCoef' has a wrong offset!");
static_assert(offsetof(FMovementParams, JumpSpeedCoef) == 0x000018, "Member 'FMovementParams::JumpSpeedCoef' has a wrong offset!");
static_assert(offsetof(FMovementParams, LimpSpeedCoef) == 0x00001C, "Member 'FMovementParams::LimpSpeedCoef' has a wrong offset!");
static_assert(offsetof(FMovementParams, WalkDiagonalBackCoef) == 0x000020, "Member 'FMovementParams::WalkDiagonalBackCoef' has a wrong offset!");
static_assert(offsetof(FMovementParams, RunDiagonalBackCoef) == 0x000024, "Member 'FMovementParams::RunDiagonalBackCoef' has a wrong offset!");
static_assert(offsetof(FMovementParams, WalkBackCoef) == 0x000028, "Member 'FMovementParams::WalkBackCoef' has a wrong offset!");
static_assert(offsetof(FMovementParams, RunBackCoef) == 0x00002C, "Member 'FMovementParams::RunBackCoef' has a wrong offset!");
static_assert(offsetof(FMovementParams, MoveBackCrouchCoef) == 0x000030, "Member 'FMovementParams::MoveBackCrouchCoef' has a wrong offset!");
static_assert(offsetof(FMovementParams, MoveBackLowCrouchCoef) == 0x000034, "Member 'FMovementParams::MoveBackLowCrouchCoef' has a wrong offset!");
static_assert(offsetof(FMovementParams, AirControlCoef) == 0x000038, "Member 'FMovementParams::AirControlCoef' has a wrong offset!");
static_assert(offsetof(FMovementParams, WalkTransitionCoef) == 0x00003C, "Member 'FMovementParams::WalkTransitionCoef' has a wrong offset!");
static_assert(offsetof(FMovementParams, BaseTurnRate) == 0x000040, "Member 'FMovementParams::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(FMovementParams, BaseLookUpRate) == 0x000044, "Member 'FMovementParams::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(FMovementParams, MaxSlowdownValue) == 0x000048, "Member 'FMovementParams::MaxSlowdownValue' has a wrong offset!");
static_assert(offsetof(FMovementParams, StaggerAngle) == 0x00004C, "Member 'FMovementParams::StaggerAngle' has a wrong offset!");
static_assert(offsetof(FMovementParams, bCanDash) == 0x000050, "Member 'FMovementParams::bCanDash' has a wrong offset!");

// ScriptStruct Stalker2.ThreatPointerSettings
// 0x0020 (0x0020 - 0x0000)
struct FThreatPointerSettings final
{
public:
	float                                         ThreatIndicatorMoveRadius;                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpacityChangingSpeed;                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatLevelChangingSpeed;                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatIndicatorLevelMin;                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatIndicatorLevelMax;                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatThreatPointerRotationSpeed;                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlertAnimationSpeed;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlertAnimationNumberLoops;                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FThreatPointerSettings) == 0x000004, "Wrong alignment on FThreatPointerSettings");
static_assert(sizeof(FThreatPointerSettings) == 0x000020, "Wrong size on FThreatPointerSettings");
static_assert(offsetof(FThreatPointerSettings, ThreatIndicatorMoveRadius) == 0x000000, "Member 'FThreatPointerSettings::ThreatIndicatorMoveRadius' has a wrong offset!");
static_assert(offsetof(FThreatPointerSettings, OpacityChangingSpeed) == 0x000004, "Member 'FThreatPointerSettings::OpacityChangingSpeed' has a wrong offset!");
static_assert(offsetof(FThreatPointerSettings, ThreatLevelChangingSpeed) == 0x000008, "Member 'FThreatPointerSettings::ThreatLevelChangingSpeed' has a wrong offset!");
static_assert(offsetof(FThreatPointerSettings, ThreatIndicatorLevelMin) == 0x00000C, "Member 'FThreatPointerSettings::ThreatIndicatorLevelMin' has a wrong offset!");
static_assert(offsetof(FThreatPointerSettings, ThreatIndicatorLevelMax) == 0x000010, "Member 'FThreatPointerSettings::ThreatIndicatorLevelMax' has a wrong offset!");
static_assert(offsetof(FThreatPointerSettings, ThreatThreatPointerRotationSpeed) == 0x000014, "Member 'FThreatPointerSettings::ThreatThreatPointerRotationSpeed' has a wrong offset!");
static_assert(offsetof(FThreatPointerSettings, AlertAnimationSpeed) == 0x000018, "Member 'FThreatPointerSettings::AlertAnimationSpeed' has a wrong offset!");
static_assert(offsetof(FThreatPointerSettings, AlertAnimationNumberLoops) == 0x00001C, "Member 'FThreatPointerSettings::AlertAnimationNumberLoops' has a wrong offset!");

// ScriptStruct Stalker2.VelocityDebug
// 0x0010 (0x0010 - 0x0000)
struct FVelocityDebug final
{
public:
	double                                        LinearVelocity;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        AngularVelocity;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVelocityDebug) == 0x000008, "Wrong alignment on FVelocityDebug");
static_assert(sizeof(FVelocityDebug) == 0x000010, "Wrong size on FVelocityDebug");
static_assert(offsetof(FVelocityDebug, LinearVelocity) == 0x000000, "Member 'FVelocityDebug::LinearVelocity' has a wrong offset!");
static_assert(offsetof(FVelocityDebug, AngularVelocity) == 0x000008, "Member 'FVelocityDebug::AngularVelocity' has a wrong offset!");

// ScriptStruct Stalker2.MultiClickInteractionData
// 0x0010 (0x0028 - 0x0018)
struct FMultiClickInteractionData final : public FInteractionData
{
public:
	float                                         ClickPercentageIncrease;                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentageDecrease;                                // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotDecrease;                                    // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMultiClickInteractionData) == 0x000008, "Wrong alignment on FMultiClickInteractionData");
static_assert(sizeof(FMultiClickInteractionData) == 0x000028, "Wrong size on FMultiClickInteractionData");
static_assert(offsetof(FMultiClickInteractionData, ClickPercentageIncrease) == 0x000018, "Member 'FMultiClickInteractionData::ClickPercentageIncrease' has a wrong offset!");
static_assert(offsetof(FMultiClickInteractionData, PercentageDecrease) == 0x00001C, "Member 'FMultiClickInteractionData::PercentageDecrease' has a wrong offset!");
static_assert(offsetof(FMultiClickInteractionData, bDoNotDecrease) == 0x000020, "Member 'FMultiClickInteractionData::bDoNotDecrease' has a wrong offset!");

// ScriptStruct Stalker2.BackgroundSettings
// 0x0008 (0x0008 - 0x0000)
struct FBackgroundSettings final
{
public:
	class UTexture2D*                             Icon;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBackgroundSettings) == 0x000008, "Wrong alignment on FBackgroundSettings");
static_assert(sizeof(FBackgroundSettings) == 0x000008, "Wrong size on FBackgroundSettings");
static_assert(offsetof(FBackgroundSettings, Icon) == 0x000000, "Member 'FBackgroundSettings::Icon' has a wrong offset!");

// ScriptStruct Stalker2.ParticleDaytimePrototype
// 0x0008 (0x0010 - 0x0008)
struct FParticleDaytimePrototype final : public FParticleConditionPrototype
{
public:
	float                                         SpawnTime;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DespawnTime;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleDaytimePrototype) == 0x000008, "Wrong alignment on FParticleDaytimePrototype");
static_assert(sizeof(FParticleDaytimePrototype) == 0x000010, "Wrong size on FParticleDaytimePrototype");
static_assert(offsetof(FParticleDaytimePrototype, SpawnTime) == 0x000008, "Member 'FParticleDaytimePrototype::SpawnTime' has a wrong offset!");
static_assert(offsetof(FParticleDaytimePrototype, DespawnTime) == 0x00000C, "Member 'FParticleDaytimePrototype::DespawnTime' has a wrong offset!");

// ScriptStruct Stalker2.ParticleGunshotPrototype
// 0x0008 (0x0010 - 0x0008)
struct FParticleGunshotPrototype final : public FEnvironmentParticlePrototype
{
public:
	float                                         GunshotDistance;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParticleGunshotPrototype) == 0x000008, "Wrong alignment on FParticleGunshotPrototype");
static_assert(sizeof(FParticleGunshotPrototype) == 0x000010, "Wrong size on FParticleGunshotPrototype");
static_assert(offsetof(FParticleGunshotPrototype, GunshotDistance) == 0x000008, "Member 'FParticleGunshotPrototype::GunshotDistance' has a wrong offset!");

// ScriptStruct Stalker2.ParticleRainIntensityPrototype
// 0x0008 (0x0010 - 0x0008)
struct FParticleRainIntensityPrototype final : public FParticleConditionPrototype
{
public:
	struct FFloatInterval                         AllowedRainIntensityInterval;                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleRainIntensityPrototype) == 0x000008, "Wrong alignment on FParticleRainIntensityPrototype");
static_assert(sizeof(FParticleRainIntensityPrototype) == 0x000010, "Wrong size on FParticleRainIntensityPrototype");
static_assert(offsetof(FParticleRainIntensityPrototype, AllowedRainIntensityInterval) == 0x000008, "Member 'FParticleRainIntensityPrototype::AllowedRainIntensityInterval' has a wrong offset!");

// ScriptStruct Stalker2.SlotFilterSettings
// 0x0010 (0x0010 - 0x0000)
struct FSlotFilterSettings final
{
public:
	class FName                                   FilterIconStyleIdEnable;                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FilterIconStyleIdDisable;                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlotFilterSettings) == 0x000004, "Wrong alignment on FSlotFilterSettings");
static_assert(sizeof(FSlotFilterSettings) == 0x000010, "Wrong size on FSlotFilterSettings");
static_assert(offsetof(FSlotFilterSettings, FilterIconStyleIdEnable) == 0x000000, "Member 'FSlotFilterSettings::FilterIconStyleIdEnable' has a wrong offset!");
static_assert(offsetof(FSlotFilterSettings, FilterIconStyleIdDisable) == 0x000008, "Member 'FSlotFilterSettings::FilterIconStyleIdDisable' has a wrong offset!");

// ScriptStruct Stalker2.QuestStatusSettings
// 0x0020 (0x0020 - 0x0000)
struct FQuestStatusSettings final
{
public:
	struct FLinearColor                           Collor;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LocalisationSid;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestStatusSettings) == 0x000008, "Wrong alignment on FQuestStatusSettings");
static_assert(sizeof(FQuestStatusSettings) == 0x000020, "Wrong size on FQuestStatusSettings");
static_assert(offsetof(FQuestStatusSettings, Collor) == 0x000000, "Member 'FQuestStatusSettings::Collor' has a wrong offset!");
static_assert(offsetof(FQuestStatusSettings, LocalisationSid) == 0x000010, "Member 'FQuestStatusSettings::LocalisationSid' has a wrong offset!");

// ScriptStruct Stalker2.TaskStatusSettings
// 0x0020 (0x0020 - 0x0000)
struct FTaskStatusSettings final
{
public:
	struct FLinearColor                           Collor;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTaskStatusSettings) == 0x000008, "Wrong alignment on FTaskStatusSettings");
static_assert(sizeof(FTaskStatusSettings) == 0x000020, "Wrong size on FTaskStatusSettings");
static_assert(offsetof(FTaskStatusSettings, Collor) == 0x000000, "Member 'FTaskStatusSettings::Collor' has a wrong offset!");
static_assert(offsetof(FTaskStatusSettings, Icon) == 0x000010, "Member 'FTaskStatusSettings::Icon' has a wrong offset!");

// ScriptStruct Stalker2.UpgradeFilterSettings
// 0x0002 (0x0002 - 0x0000)
struct FUpgradeFilterSettings final
{
public:
	bool                                          bEnableFilter;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventoryEquipmentSlot                       Filter;                                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUpgradeFilterSettings) == 0x000001, "Wrong alignment on FUpgradeFilterSettings");
static_assert(sizeof(FUpgradeFilterSettings) == 0x000002, "Wrong size on FUpgradeFilterSettings");
static_assert(offsetof(FUpgradeFilterSettings, bEnableFilter) == 0x000000, "Member 'FUpgradeFilterSettings::bEnableFilter' has a wrong offset!");
static_assert(offsetof(FUpgradeFilterSettings, Filter) == 0x000001, "Member 'FUpgradeFilterSettings::Filter' has a wrong offset!");

// ScriptStruct Stalker2.PhysicsObjectCollection
// 0x0030 (0x0098 - 0x0068)
struct FPhysicsObjectCollection final : public FBaseTickAggregationCollection
{
public:
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPhysicsObjectCollection) == 0x000008, "Wrong alignment on FPhysicsObjectCollection");
static_assert(sizeof(FPhysicsObjectCollection) == 0x000098, "Wrong size on FPhysicsObjectCollection");

// ScriptStruct Stalker2.SimpleMovingAnimations
// 0x0040 (0x0040 - 0x0000)
struct FSimpleMovingAnimations final
{
public:
	class UAnimSequence*                          Forward;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Backward;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Left;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Right;                                             // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ForwardLeft;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ForwardRight;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BackwardLeft;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BackwardRight;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleMovingAnimations) == 0x000008, "Wrong alignment on FSimpleMovingAnimations");
static_assert(sizeof(FSimpleMovingAnimations) == 0x000040, "Wrong size on FSimpleMovingAnimations");
static_assert(offsetof(FSimpleMovingAnimations, Forward) == 0x000000, "Member 'FSimpleMovingAnimations::Forward' has a wrong offset!");
static_assert(offsetof(FSimpleMovingAnimations, Backward) == 0x000008, "Member 'FSimpleMovingAnimations::Backward' has a wrong offset!");
static_assert(offsetof(FSimpleMovingAnimations, Left) == 0x000010, "Member 'FSimpleMovingAnimations::Left' has a wrong offset!");
static_assert(offsetof(FSimpleMovingAnimations, Right) == 0x000018, "Member 'FSimpleMovingAnimations::Right' has a wrong offset!");
static_assert(offsetof(FSimpleMovingAnimations, ForwardLeft) == 0x000020, "Member 'FSimpleMovingAnimations::ForwardLeft' has a wrong offset!");
static_assert(offsetof(FSimpleMovingAnimations, ForwardRight) == 0x000028, "Member 'FSimpleMovingAnimations::ForwardRight' has a wrong offset!");
static_assert(offsetof(FSimpleMovingAnimations, BackwardLeft) == 0x000030, "Member 'FSimpleMovingAnimations::BackwardLeft' has a wrong offset!");
static_assert(offsetof(FSimpleMovingAnimations, BackwardRight) == 0x000038, "Member 'FSimpleMovingAnimations::BackwardRight' has a wrong offset!");

// ScriptStruct Stalker2.PlayerInternalAnimations
// 0x00B8 (0x00B8 - 0x0000)
struct FPlayerInternalAnimations final
{
public:
	class UAnimMontage*                           PickingUpItem;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           JumpLand;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           JumpLandLowCrouch;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FailedLanding;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ToggleFlashlightStand;                             // 0x0020(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ToggleFlashlightLowCrouch;                         // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EnterRagdollCurve;                                 // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEquipUnequipAnimations                EquipUnequip;                                      // 0x0038(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FEquipUnequipAnimations                RemoveReturnLeftHand;                              // 0x0050(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EAgentType, class UAnimMontage*>         DragWeaponByNPC;                                   // 0x0068(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInternalAnimations) == 0x000008, "Wrong alignment on FPlayerInternalAnimations");
static_assert(sizeof(FPlayerInternalAnimations) == 0x0000B8, "Wrong size on FPlayerInternalAnimations");
static_assert(offsetof(FPlayerInternalAnimations, PickingUpItem) == 0x000000, "Member 'FPlayerInternalAnimations::PickingUpItem' has a wrong offset!");
static_assert(offsetof(FPlayerInternalAnimations, JumpLand) == 0x000008, "Member 'FPlayerInternalAnimations::JumpLand' has a wrong offset!");
static_assert(offsetof(FPlayerInternalAnimations, JumpLandLowCrouch) == 0x000010, "Member 'FPlayerInternalAnimations::JumpLandLowCrouch' has a wrong offset!");
static_assert(offsetof(FPlayerInternalAnimations, FailedLanding) == 0x000018, "Member 'FPlayerInternalAnimations::FailedLanding' has a wrong offset!");
static_assert(offsetof(FPlayerInternalAnimations, ToggleFlashlightStand) == 0x000020, "Member 'FPlayerInternalAnimations::ToggleFlashlightStand' has a wrong offset!");
static_assert(offsetof(FPlayerInternalAnimations, ToggleFlashlightLowCrouch) == 0x000028, "Member 'FPlayerInternalAnimations::ToggleFlashlightLowCrouch' has a wrong offset!");
static_assert(offsetof(FPlayerInternalAnimations, EnterRagdollCurve) == 0x000030, "Member 'FPlayerInternalAnimations::EnterRagdollCurve' has a wrong offset!");
static_assert(offsetof(FPlayerInternalAnimations, EquipUnequip) == 0x000038, "Member 'FPlayerInternalAnimations::EquipUnequip' has a wrong offset!");
static_assert(offsetof(FPlayerInternalAnimations, RemoveReturnLeftHand) == 0x000050, "Member 'FPlayerInternalAnimations::RemoveReturnLeftHand' has a wrong offset!");
static_assert(offsetof(FPlayerInternalAnimations, DragWeaponByNPC) == 0x000068, "Member 'FPlayerInternalAnimations::DragWeaponByNPC' has a wrong offset!");

// ScriptStruct Stalker2.PlayerFirearmInternalAnimations
// 0x02B8 (0x02B8 - 0x0000)
struct FPlayerFirearmInternalAnimations final
{
public:
	struct FCharacterWeaponAnimations             ShootingInHip;                                     // 0x0000(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             ShootingInAim;                                     // 0x0020(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EAnimationShootingTypes, struct FCharacterWeaponAnimations> Shooting;                       // 0x0040(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FCharacterWeaponAnimations> ShootingWithScope;                          // 0x0090(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FString, struct FAttachDetachAnimations> AttachingBySID;                              // 0x00E0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FCharacterWeaponAnimations>     Jamming;                                           // 0x0130(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FCharacterWeaponAnimations> UniqueAttachJamming;                        // 0x0140(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMagazineReloadAnimations> Reloading;                                   // 0x0190(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMagazineReloadAnimations> OneHandReloading;                            // 0x01E0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCharacterWeaponAnimations             MeleeAnimation;                                    // 0x0230(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EAnimSwitchFireTypeMode, struct FChangeFireTypeAnimations> SwitchFireType;                  // 0x0250(0x0050)(Edit, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PickUpItem;                                        // 0x02A0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CharacterHipIdleSequence;                          // 0x02A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WeaponHipIdleSequence;                             // 0x02B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerFirearmInternalAnimations) == 0x000008, "Wrong alignment on FPlayerFirearmInternalAnimations");
static_assert(sizeof(FPlayerFirearmInternalAnimations) == 0x0002B8, "Wrong size on FPlayerFirearmInternalAnimations");
static_assert(offsetof(FPlayerFirearmInternalAnimations, ShootingInHip) == 0x000000, "Member 'FPlayerFirearmInternalAnimations::ShootingInHip' has a wrong offset!");
static_assert(offsetof(FPlayerFirearmInternalAnimations, ShootingInAim) == 0x000020, "Member 'FPlayerFirearmInternalAnimations::ShootingInAim' has a wrong offset!");
static_assert(offsetof(FPlayerFirearmInternalAnimations, Shooting) == 0x000040, "Member 'FPlayerFirearmInternalAnimations::Shooting' has a wrong offset!");
static_assert(offsetof(FPlayerFirearmInternalAnimations, ShootingWithScope) == 0x000090, "Member 'FPlayerFirearmInternalAnimations::ShootingWithScope' has a wrong offset!");
static_assert(offsetof(FPlayerFirearmInternalAnimations, AttachingBySID) == 0x0000E0, "Member 'FPlayerFirearmInternalAnimations::AttachingBySID' has a wrong offset!");
static_assert(offsetof(FPlayerFirearmInternalAnimations, Jamming) == 0x000130, "Member 'FPlayerFirearmInternalAnimations::Jamming' has a wrong offset!");
static_assert(offsetof(FPlayerFirearmInternalAnimations, UniqueAttachJamming) == 0x000140, "Member 'FPlayerFirearmInternalAnimations::UniqueAttachJamming' has a wrong offset!");
static_assert(offsetof(FPlayerFirearmInternalAnimations, Reloading) == 0x000190, "Member 'FPlayerFirearmInternalAnimations::Reloading' has a wrong offset!");
static_assert(offsetof(FPlayerFirearmInternalAnimations, OneHandReloading) == 0x0001E0, "Member 'FPlayerFirearmInternalAnimations::OneHandReloading' has a wrong offset!");
static_assert(offsetof(FPlayerFirearmInternalAnimations, MeleeAnimation) == 0x000230, "Member 'FPlayerFirearmInternalAnimations::MeleeAnimation' has a wrong offset!");
static_assert(offsetof(FPlayerFirearmInternalAnimations, SwitchFireType) == 0x000250, "Member 'FPlayerFirearmInternalAnimations::SwitchFireType' has a wrong offset!");
static_assert(offsetof(FPlayerFirearmInternalAnimations, PickUpItem) == 0x0002A0, "Member 'FPlayerFirearmInternalAnimations::PickUpItem' has a wrong offset!");
static_assert(offsetof(FPlayerFirearmInternalAnimations, CharacterHipIdleSequence) == 0x0002A8, "Member 'FPlayerFirearmInternalAnimations::CharacterHipIdleSequence' has a wrong offset!");
static_assert(offsetof(FPlayerFirearmInternalAnimations, WeaponHipIdleSequence) == 0x0002B0, "Member 'FPlayerFirearmInternalAnimations::WeaponHipIdleSequence' has a wrong offset!");

// ScriptStruct Stalker2.PlayerThrowableItemInternalAnimations
// 0x00C0 (0x00C0 - 0x0000)
struct FPlayerThrowableItemInternalAnimations final
{
public:
	TMap<EAnimationThrowingType, struct FCharacterWeaponAnimations> Throw;                           // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EAnimationThrowingType, struct FCharacterWeaponAnimations> CancelThrow;                     // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StrongThrowForceCurve;                             // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            LightThrowForceCurve;                              // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           StrongThrowDirectionOffsetCurve;                   // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           LightThrowDirectionOffsetCurve;                    // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerThrowableItemInternalAnimations) == 0x000008, "Wrong alignment on FPlayerThrowableItemInternalAnimations");
static_assert(sizeof(FPlayerThrowableItemInternalAnimations) == 0x0000C0, "Wrong size on FPlayerThrowableItemInternalAnimations");
static_assert(offsetof(FPlayerThrowableItemInternalAnimations, Throw) == 0x000000, "Member 'FPlayerThrowableItemInternalAnimations::Throw' has a wrong offset!");
static_assert(offsetof(FPlayerThrowableItemInternalAnimations, CancelThrow) == 0x000050, "Member 'FPlayerThrowableItemInternalAnimations::CancelThrow' has a wrong offset!");
static_assert(offsetof(FPlayerThrowableItemInternalAnimations, StrongThrowForceCurve) == 0x0000A0, "Member 'FPlayerThrowableItemInternalAnimations::StrongThrowForceCurve' has a wrong offset!");
static_assert(offsetof(FPlayerThrowableItemInternalAnimations, LightThrowForceCurve) == 0x0000A8, "Member 'FPlayerThrowableItemInternalAnimations::LightThrowForceCurve' has a wrong offset!");
static_assert(offsetof(FPlayerThrowableItemInternalAnimations, StrongThrowDirectionOffsetCurve) == 0x0000B0, "Member 'FPlayerThrowableItemInternalAnimations::StrongThrowDirectionOffsetCurve' has a wrong offset!");
static_assert(offsetof(FPlayerThrowableItemInternalAnimations, LightThrowDirectionOffsetCurve) == 0x0000B8, "Member 'FPlayerThrowableItemInternalAnimations::LightThrowDirectionOffsetCurve' has a wrong offset!");

// ScriptStruct Stalker2.InteractableAnimations
// 0x0018 (0x0018 - 0x0000)
struct FInteractableAnimations final
{
public:
	class UAnimMontage*                           Item;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Character;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterWithDetector;                             // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractableAnimations) == 0x000008, "Wrong alignment on FInteractableAnimations");
static_assert(sizeof(FInteractableAnimations) == 0x000018, "Wrong size on FInteractableAnimations");
static_assert(offsetof(FInteractableAnimations, Item) == 0x000000, "Member 'FInteractableAnimations::Item' has a wrong offset!");
static_assert(offsetof(FInteractableAnimations, Character) == 0x000008, "Member 'FInteractableAnimations::Character' has a wrong offset!");
static_assert(offsetof(FInteractableAnimations, CharacterWithDetector) == 0x000010, "Member 'FInteractableAnimations::CharacterWithDetector' has a wrong offset!");

// ScriptStruct Stalker2.PlayerDialogAnimations
// 0x0050 (0x0050 - 0x0000)
struct FPlayerDialogAnimations final
{
public:
	TMap<EDialogAnimationType, class UAnimSequenceBase*> DialogAnimations;                           // 0x0000(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDialogAnimations) == 0x000008, "Wrong alignment on FPlayerDialogAnimations");
static_assert(sizeof(FPlayerDialogAnimations) == 0x000050, "Wrong size on FPlayerDialogAnimations");
static_assert(offsetof(FPlayerDialogAnimations, DialogAnimations) == 0x000000, "Member 'FPlayerDialogAnimations::DialogAnimations' has a wrong offset!");

// ScriptStruct Stalker2.AnimInteractableData
// 0x0028 (0x0028 - 0x0000)
struct FAnimInteractableData final
{
public:
	struct FVector                                InteractionDirection;                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionDistance;                               // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLerpToInteractable;                         // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LerpSpeedMultiplier;                               // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLerpIn3D;                                   // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldToggleFOV;                                  // 0x0025(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionEnabled                             CollisionType;                                     // 0x0026(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimInteractableData) == 0x000008, "Wrong alignment on FAnimInteractableData");
static_assert(sizeof(FAnimInteractableData) == 0x000028, "Wrong size on FAnimInteractableData");
static_assert(offsetof(FAnimInteractableData, InteractionDirection) == 0x000000, "Member 'FAnimInteractableData::InteractionDirection' has a wrong offset!");
static_assert(offsetof(FAnimInteractableData, InteractionDistance) == 0x000018, "Member 'FAnimInteractableData::InteractionDistance' has a wrong offset!");
static_assert(offsetof(FAnimInteractableData, bShouldLerpToInteractable) == 0x00001C, "Member 'FAnimInteractableData::bShouldLerpToInteractable' has a wrong offset!");
static_assert(offsetof(FAnimInteractableData, LerpSpeedMultiplier) == 0x000020, "Member 'FAnimInteractableData::LerpSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FAnimInteractableData, bShouldLerpIn3D) == 0x000024, "Member 'FAnimInteractableData::bShouldLerpIn3D' has a wrong offset!");
static_assert(offsetof(FAnimInteractableData, bShouldToggleFOV) == 0x000025, "Member 'FAnimInteractableData::bShouldToggleFOV' has a wrong offset!");
static_assert(offsetof(FAnimInteractableData, CollisionType) == 0x000026, "Member 'FAnimInteractableData::CollisionType' has a wrong offset!");

// ScriptStruct Stalker2.PoseSearchLocomotionAnimCollectionData
// 0x0030 (0x0030 - 0x0000)
struct FPoseSearchLocomotionAnimCollectionData final
{
public:
	class UPoseSearchSearchableAsset*             Searchable;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseSearchSearchableAsset*             SearchableRelaxState;                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseSearchLocomotionDescriptor*        Descriptor;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseSearchLocomotionDescriptor*        DescriptorRelaxState;                              // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPoseSearchMovementTagConfigs          MovementTagConfigs;                                // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoseSearchLocomotionAnimCollectionData) == 0x000008, "Wrong alignment on FPoseSearchLocomotionAnimCollectionData");
static_assert(sizeof(FPoseSearchLocomotionAnimCollectionData) == 0x000030, "Wrong size on FPoseSearchLocomotionAnimCollectionData");
static_assert(offsetof(FPoseSearchLocomotionAnimCollectionData, Searchable) == 0x000000, "Member 'FPoseSearchLocomotionAnimCollectionData::Searchable' has a wrong offset!");
static_assert(offsetof(FPoseSearchLocomotionAnimCollectionData, SearchableRelaxState) == 0x000008, "Member 'FPoseSearchLocomotionAnimCollectionData::SearchableRelaxState' has a wrong offset!");
static_assert(offsetof(FPoseSearchLocomotionAnimCollectionData, Descriptor) == 0x000010, "Member 'FPoseSearchLocomotionAnimCollectionData::Descriptor' has a wrong offset!");
static_assert(offsetof(FPoseSearchLocomotionAnimCollectionData, DescriptorRelaxState) == 0x000018, "Member 'FPoseSearchLocomotionAnimCollectionData::DescriptorRelaxState' has a wrong offset!");
static_assert(offsetof(FPoseSearchLocomotionAnimCollectionData, MovementTagConfigs) == 0x000020, "Member 'FPoseSearchLocomotionAnimCollectionData::MovementTagConfigs' has a wrong offset!");

// ScriptStruct Stalker2.ProjectileImpactFXData
// 0x0228 (0x0228 - 0x0000)
struct FProjectileImpactFXData final
{
public:
	class AAgent*                                 HitAgent;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x220];                                      // 0x0008(0x0220)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileImpactFXData) == 0x000008, "Wrong alignment on FProjectileImpactFXData");
static_assert(sizeof(FProjectileImpactFXData) == 0x000228, "Wrong size on FProjectileImpactFXData");
static_assert(offsetof(FProjectileImpactFXData, HitAgent) == 0x000000, "Member 'FProjectileImpactFXData::HitAgent' has a wrong offset!");

// ScriptStruct Stalker2.PsySpawnStruct
// 0x0130 (0x0130 - 0x0000)
struct alignas(0x10) FPsySpawnStruct final
{
public:
	uint8                                         Pad_0[0x2C];                                       // 0x0000(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        GameGraphMinComponentVerticesCount;                // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CurrentPsyPrototypeClass;                          // 0x0030(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0xD0];                                      // 0x0060(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPsySpawnStruct) == 0x000010, "Wrong alignment on FPsySpawnStruct");
static_assert(sizeof(FPsySpawnStruct) == 0x000130, "Wrong size on FPsySpawnStruct");
static_assert(offsetof(FPsySpawnStruct, GameGraphMinComponentVerticesCount) == 0x00002C, "Member 'FPsySpawnStruct::GameGraphMinComponentVerticesCount' has a wrong offset!");
static_assert(offsetof(FPsySpawnStruct, CurrentPsyPrototypeClass) == 0x000030, "Member 'FPsySpawnStruct::CurrentPsyPrototypeClass' has a wrong offset!");

// ScriptStruct Stalker2.RazerChromaDamageSettings
// 0x0030 (0x0030 - 0x0000)
struct FRazerChromaDamageSettings final
{
public:
	struct FRazerChromaEvent                      Event;                                             // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         DamageThreshold;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EDamageSource>                         DamageSources;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRazerChromaDamageSettings) == 0x000008, "Wrong alignment on FRazerChromaDamageSettings");
static_assert(sizeof(FRazerChromaDamageSettings) == 0x000030, "Wrong size on FRazerChromaDamageSettings");
static_assert(offsetof(FRazerChromaDamageSettings, Event) == 0x000000, "Member 'FRazerChromaDamageSettings::Event' has a wrong offset!");
static_assert(offsetof(FRazerChromaDamageSettings, DamageThreshold) == 0x000018, "Member 'FRazerChromaDamageSettings::DamageThreshold' has a wrong offset!");
static_assert(offsetof(FRazerChromaDamageSettings, DamageSources) == 0x000020, "Member 'FRazerChromaDamageSettings::DamageSources' has a wrong offset!");

// ScriptStruct Stalker2.RazerSensaDamageSettings
// 0x0098 (0x0098 - 0x0000)
struct FRazerSensaDamageSettings final
{
public:
	struct FRazerSensaEvent                       NearLeftEvent;                                     // 0x0000(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FRazerSensaEvent                       FarLeftEvent;                                      // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FRazerSensaEvent                       NearFrontEvent;                                    // 0x0020(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FRazerSensaEvent                       FarFrontEvent;                                     // 0x0030(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FRazerSensaEvent                       NearRightEvent;                                    // 0x0040(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FRazerSensaEvent                       FarRightEvent;                                     // 0x0050(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FRazerSensaEvent                       NearBackEvent;                                     // 0x0060(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FRazerSensaEvent                       FarBackEvent;                                      // 0x0070(0x0010)(Edit, NativeAccessSpecifierPublic)
	float                                         DamageThreshold;                                   // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarThreshold;                                      // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EDamageSource>                         DamageSources;                                     // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRazerSensaDamageSettings) == 0x000008, "Wrong alignment on FRazerSensaDamageSettings");
static_assert(sizeof(FRazerSensaDamageSettings) == 0x000098, "Wrong size on FRazerSensaDamageSettings");
static_assert(offsetof(FRazerSensaDamageSettings, NearLeftEvent) == 0x000000, "Member 'FRazerSensaDamageSettings::NearLeftEvent' has a wrong offset!");
static_assert(offsetof(FRazerSensaDamageSettings, FarLeftEvent) == 0x000010, "Member 'FRazerSensaDamageSettings::FarLeftEvent' has a wrong offset!");
static_assert(offsetof(FRazerSensaDamageSettings, NearFrontEvent) == 0x000020, "Member 'FRazerSensaDamageSettings::NearFrontEvent' has a wrong offset!");
static_assert(offsetof(FRazerSensaDamageSettings, FarFrontEvent) == 0x000030, "Member 'FRazerSensaDamageSettings::FarFrontEvent' has a wrong offset!");
static_assert(offsetof(FRazerSensaDamageSettings, NearRightEvent) == 0x000040, "Member 'FRazerSensaDamageSettings::NearRightEvent' has a wrong offset!");
static_assert(offsetof(FRazerSensaDamageSettings, FarRightEvent) == 0x000050, "Member 'FRazerSensaDamageSettings::FarRightEvent' has a wrong offset!");
static_assert(offsetof(FRazerSensaDamageSettings, NearBackEvent) == 0x000060, "Member 'FRazerSensaDamageSettings::NearBackEvent' has a wrong offset!");
static_assert(offsetof(FRazerSensaDamageSettings, FarBackEvent) == 0x000070, "Member 'FRazerSensaDamageSettings::FarBackEvent' has a wrong offset!");
static_assert(offsetof(FRazerSensaDamageSettings, DamageThreshold) == 0x000080, "Member 'FRazerSensaDamageSettings::DamageThreshold' has a wrong offset!");
static_assert(offsetof(FRazerSensaDamageSettings, FarThreshold) == 0x000084, "Member 'FRazerSensaDamageSettings::FarThreshold' has a wrong offset!");
static_assert(offsetof(FRazerSensaDamageSettings, DamageSources) == 0x000088, "Member 'FRazerSensaDamageSettings::DamageSources' has a wrong offset!");

// ScriptStruct Stalker2.BuckRecoilKeys
// 0x0010 (0x0010 - 0x0000)
struct FBuckRecoilKeys final
{
public:
	TArray<struct FRecoilKeys>                    BuckRecoilKeys;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuckRecoilKeys) == 0x000008, "Wrong alignment on FBuckRecoilKeys");
static_assert(sizeof(FBuckRecoilKeys) == 0x000010, "Wrong size on FBuckRecoilKeys");
static_assert(offsetof(FBuckRecoilKeys, BuckRecoilKeys) == 0x000000, "Member 'FBuckRecoilKeys::BuckRecoilKeys' has a wrong offset!");

// ScriptStruct Stalker2.RichWidgetRow
// 0x0008 (0x0010 - 0x0008)
struct FRichWidgetRow final : public FTableRowBase
{
public:
	TSubclassOf<class UUserWidget>                WidgetToDisplay;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRichWidgetRow) == 0x000008, "Wrong alignment on FRichWidgetRow");
static_assert(sizeof(FRichWidgetRow) == 0x000010, "Wrong size on FRichWidgetRow");
static_assert(offsetof(FRichWidgetRow, WidgetToDisplay) == 0x000008, "Member 'FRichWidgetRow::WidgetToDisplay' has a wrong offset!");

// ScriptStruct Stalker2.ScarPhaseData
// 0x0058 (0x0058 - 0x0000)
struct FScarPhaseData final
{
public:
	TArray<struct FEffectPrototypeSID>            EffectsToApply;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEffectPrototypeSID>            EffectsToRemove;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAbilityPrototypeSID>           AbilitiesToGive;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhaseHPThreshold;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScarPhaseData) == 0x000008, "Wrong alignment on FScarPhaseData");
static_assert(sizeof(FScarPhaseData) == 0x000058, "Wrong size on FScarPhaseData");
static_assert(offsetof(FScarPhaseData, EffectsToApply) == 0x000000, "Member 'FScarPhaseData::EffectsToApply' has a wrong offset!");
static_assert(offsetof(FScarPhaseData, EffectsToRemove) == 0x000010, "Member 'FScarPhaseData::EffectsToRemove' has a wrong offset!");
static_assert(offsetof(FScarPhaseData, AbilitiesToGive) == 0x000020, "Member 'FScarPhaseData::AbilitiesToGive' has a wrong offset!");
static_assert(offsetof(FScarPhaseData, PhaseHPThreshold) == 0x000050, "Member 'FScarPhaseData::PhaseHPThreshold' has a wrong offset!");

// ScriptStruct Stalker2.FloatValueLocalisationPair
// 0x0020 (0x0020 - 0x0000)
struct FFloatValueLocalisationPair final
{
public:
	float                                         PercentValue;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Loc10N;                                            // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatValueLocalisationPair) == 0x000008, "Wrong alignment on FFloatValueLocalisationPair");
static_assert(sizeof(FFloatValueLocalisationPair) == 0x000020, "Wrong size on FFloatValueLocalisationPair");
static_assert(offsetof(FFloatValueLocalisationPair, PercentValue) == 0x000000, "Member 'FFloatValueLocalisationPair::PercentValue' has a wrong offset!");
static_assert(offsetof(FFloatValueLocalisationPair, Loc10N) == 0x000008, "Member 'FFloatValueLocalisationPair::Loc10N' has a wrong offset!");

// ScriptStruct Stalker2.DialogAnswersStyles
// 0x0380 (0x0380 - 0x0000)
struct FDialogAnswersStyles final
{
public:
	class FString                                 AnswerDisabled;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerDefault;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerDefaultHovered;                              // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerDefaultRead;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerDefaultHoveredRead;                          // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerQuest;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerQuestHovered;                                // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerQuestRead;                                   // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerQuestHoveredRead;                            // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerWithDangerAction;                            // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerWithDangerActionHovered;                     // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerWithGetAction;                               // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerWithGetActionHovered;                        // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerWithGiveAction;                              // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnswerWithGiveActionHovered;                       // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionDisabled;                                    // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionDefault;                                     // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionDefaultHovered;                              // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionQuest;                                       // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionQuestHovered;                                // 0x0130(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionDanger;                                      // 0x0140(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionDangerHovered;                               // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionGet;                                         // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionGetHovered;                                  // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionGive;                                        // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionGiveHovered;                                 // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundDisabled;                                // 0x01A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundDefault;                                 // 0x01B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundDefaultHovered;                          // 0x01C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundDefaultRead;                             // 0x01D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundDefaultHoveredRead;                      // 0x01E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundQuest;                                   // 0x01F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundQuestHovered;                            // 0x0200(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundQuestRead;                               // 0x0210(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundQuestHoveredRead;                        // 0x0220(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundDanger;                                  // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundDangerHovered;                           // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundGet;                                     // 0x0250(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundGetHovered;                              // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundGive;                                    // 0x0270(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundGiveHovered;                             // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconDisabled;                                      // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconDefault;                                       // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconDefaultHovered;                                // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconDefaultRead;                                   // 0x02C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconDefaultHoveredRead;                            // 0x02D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconQuest;                                         // 0x02E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconQuestHovered;                                  // 0x02F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconQuestRead;                                     // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconQuestHoveredRead;                              // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconDanger;                                        // 0x0320(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconDangerHovered;                                 // 0x0330(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconGet;                                           // 0x0340(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconGetHovered;                                    // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconGive;                                          // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconGiveHovered;                                   // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDialogAnswersStyles) == 0x000008, "Wrong alignment on FDialogAnswersStyles");
static_assert(sizeof(FDialogAnswersStyles) == 0x000380, "Wrong size on FDialogAnswersStyles");
static_assert(offsetof(FDialogAnswersStyles, AnswerDisabled) == 0x000000, "Member 'FDialogAnswersStyles::AnswerDisabled' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerDefault) == 0x000010, "Member 'FDialogAnswersStyles::AnswerDefault' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerDefaultHovered) == 0x000020, "Member 'FDialogAnswersStyles::AnswerDefaultHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerDefaultRead) == 0x000030, "Member 'FDialogAnswersStyles::AnswerDefaultRead' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerDefaultHoveredRead) == 0x000040, "Member 'FDialogAnswersStyles::AnswerDefaultHoveredRead' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerQuest) == 0x000050, "Member 'FDialogAnswersStyles::AnswerQuest' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerQuestHovered) == 0x000060, "Member 'FDialogAnswersStyles::AnswerQuestHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerQuestRead) == 0x000070, "Member 'FDialogAnswersStyles::AnswerQuestRead' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerQuestHoveredRead) == 0x000080, "Member 'FDialogAnswersStyles::AnswerQuestHoveredRead' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerWithDangerAction) == 0x000090, "Member 'FDialogAnswersStyles::AnswerWithDangerAction' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerWithDangerActionHovered) == 0x0000A0, "Member 'FDialogAnswersStyles::AnswerWithDangerActionHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerWithGetAction) == 0x0000B0, "Member 'FDialogAnswersStyles::AnswerWithGetAction' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerWithGetActionHovered) == 0x0000C0, "Member 'FDialogAnswersStyles::AnswerWithGetActionHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerWithGiveAction) == 0x0000D0, "Member 'FDialogAnswersStyles::AnswerWithGiveAction' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, AnswerWithGiveActionHovered) == 0x0000E0, "Member 'FDialogAnswersStyles::AnswerWithGiveActionHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, ActionDisabled) == 0x0000F0, "Member 'FDialogAnswersStyles::ActionDisabled' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, ActionDefault) == 0x000100, "Member 'FDialogAnswersStyles::ActionDefault' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, ActionDefaultHovered) == 0x000110, "Member 'FDialogAnswersStyles::ActionDefaultHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, ActionQuest) == 0x000120, "Member 'FDialogAnswersStyles::ActionQuest' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, ActionQuestHovered) == 0x000130, "Member 'FDialogAnswersStyles::ActionQuestHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, ActionDanger) == 0x000140, "Member 'FDialogAnswersStyles::ActionDanger' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, ActionDangerHovered) == 0x000150, "Member 'FDialogAnswersStyles::ActionDangerHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, ActionGet) == 0x000160, "Member 'FDialogAnswersStyles::ActionGet' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, ActionGetHovered) == 0x000170, "Member 'FDialogAnswersStyles::ActionGetHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, ActionGive) == 0x000180, "Member 'FDialogAnswersStyles::ActionGive' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, ActionGiveHovered) == 0x000190, "Member 'FDialogAnswersStyles::ActionGiveHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundDisabled) == 0x0001A0, "Member 'FDialogAnswersStyles::BackgroundDisabled' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundDefault) == 0x0001B0, "Member 'FDialogAnswersStyles::BackgroundDefault' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundDefaultHovered) == 0x0001C0, "Member 'FDialogAnswersStyles::BackgroundDefaultHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundDefaultRead) == 0x0001D0, "Member 'FDialogAnswersStyles::BackgroundDefaultRead' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundDefaultHoveredRead) == 0x0001E0, "Member 'FDialogAnswersStyles::BackgroundDefaultHoveredRead' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundQuest) == 0x0001F0, "Member 'FDialogAnswersStyles::BackgroundQuest' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundQuestHovered) == 0x000200, "Member 'FDialogAnswersStyles::BackgroundQuestHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundQuestRead) == 0x000210, "Member 'FDialogAnswersStyles::BackgroundQuestRead' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundQuestHoveredRead) == 0x000220, "Member 'FDialogAnswersStyles::BackgroundQuestHoveredRead' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundDanger) == 0x000230, "Member 'FDialogAnswersStyles::BackgroundDanger' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundDangerHovered) == 0x000240, "Member 'FDialogAnswersStyles::BackgroundDangerHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundGet) == 0x000250, "Member 'FDialogAnswersStyles::BackgroundGet' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundGetHovered) == 0x000260, "Member 'FDialogAnswersStyles::BackgroundGetHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundGive) == 0x000270, "Member 'FDialogAnswersStyles::BackgroundGive' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, BackgroundGiveHovered) == 0x000280, "Member 'FDialogAnswersStyles::BackgroundGiveHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconDisabled) == 0x000290, "Member 'FDialogAnswersStyles::IconDisabled' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconDefault) == 0x0002A0, "Member 'FDialogAnswersStyles::IconDefault' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconDefaultHovered) == 0x0002B0, "Member 'FDialogAnswersStyles::IconDefaultHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconDefaultRead) == 0x0002C0, "Member 'FDialogAnswersStyles::IconDefaultRead' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconDefaultHoveredRead) == 0x0002D0, "Member 'FDialogAnswersStyles::IconDefaultHoveredRead' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconQuest) == 0x0002E0, "Member 'FDialogAnswersStyles::IconQuest' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconQuestHovered) == 0x0002F0, "Member 'FDialogAnswersStyles::IconQuestHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconQuestRead) == 0x000300, "Member 'FDialogAnswersStyles::IconQuestRead' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconQuestHoveredRead) == 0x000310, "Member 'FDialogAnswersStyles::IconQuestHoveredRead' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconDanger) == 0x000320, "Member 'FDialogAnswersStyles::IconDanger' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconDangerHovered) == 0x000330, "Member 'FDialogAnswersStyles::IconDangerHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconGet) == 0x000340, "Member 'FDialogAnswersStyles::IconGet' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconGetHovered) == 0x000350, "Member 'FDialogAnswersStyles::IconGetHovered' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconGive) == 0x000360, "Member 'FDialogAnswersStyles::IconGive' has a wrong offset!");
static_assert(offsetof(FDialogAnswersStyles, IconGiveHovered) == 0x000370, "Member 'FDialogAnswersStyles::IconGiveHovered' has a wrong offset!");

// ScriptStruct Stalker2.DialogFolderInfo
// 0x0030 (0x0030 - 0x0000)
struct FDialogFolderInfo final
{
public:
	class FText                                   FolderName;                                        // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	TArray<struct FDialogAnswerInfo>              Answers;                                           // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FUID                                   MemberUID;                                         // 0x0028(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogFolderInfo) == 0x000008, "Wrong alignment on FDialogFolderInfo");
static_assert(sizeof(FDialogFolderInfo) == 0x000030, "Wrong size on FDialogFolderInfo");
static_assert(offsetof(FDialogFolderInfo, FolderName) == 0x000000, "Member 'FDialogFolderInfo::FolderName' has a wrong offset!");
static_assert(offsetof(FDialogFolderInfo, Answers) == 0x000018, "Member 'FDialogFolderInfo::Answers' has a wrong offset!");
static_assert(offsetof(FDialogFolderInfo, MemberUID) == 0x000028, "Member 'FDialogFolderInfo::MemberUID' has a wrong offset!");

// ScriptStruct Stalker2.SignalToReceive
// 0x0050 (0x0050 - 0x0000)
struct FSignalToReceive final
{
public:
	struct FGSCComponentReference                 SenderComponentRef;                                // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSignalToReceive) == 0x000008, "Wrong alignment on FSignalToReceive");
static_assert(sizeof(FSignalToReceive) == 0x000050, "Wrong size on FSignalToReceive");
static_assert(offsetof(FSignalToReceive, SenderComponentRef) == 0x000000, "Member 'FSignalToReceive::SenderComponentRef' has a wrong offset!");

// ScriptStruct Stalker2.SingleClickInteractionData
// 0x0000 (0x0018 - 0x0018)
struct FSingleClickInteractionData final : public FInteractionData
{
};
static_assert(alignof(FSingleClickInteractionData) == 0x000008, "Wrong alignment on FSingleClickInteractionData");
static_assert(sizeof(FSingleClickInteractionData) == 0x000018, "Wrong size on FSingleClickInteractionData");

// ScriptStruct Stalker2.SmartCoverWeaponTypeData
// 0x0050 (0x0050 - 0x0000)
struct FSmartCoverWeaponTypeData final
{
public:
	TMap<ESmartCoverType, struct FSmartCoverPerCoverTypeData> AnimationsData;                        // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSmartCoverWeaponTypeData) == 0x000008, "Wrong alignment on FSmartCoverWeaponTypeData");
static_assert(sizeof(FSmartCoverWeaponTypeData) == 0x000050, "Wrong size on FSmartCoverWeaponTypeData");
static_assert(offsetof(FSmartCoverWeaponTypeData, AnimationsData) == 0x000000, "Member 'FSmartCoverWeaponTypeData::AnimationsData' has a wrong offset!");

// ScriptStruct Stalker2.SmartCoverAnimCollectionData
// 0x0050 (0x0050 - 0x0000)
struct FSmartCoverAnimCollectionData final
{
public:
	TMap<EWeaponType, struct FSmartCoverWeaponTypeData> WeaponTypeAnimationsData;                    // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSmartCoverAnimCollectionData) == 0x000008, "Wrong alignment on FSmartCoverAnimCollectionData");
static_assert(sizeof(FSmartCoverAnimCollectionData) == 0x000050, "Wrong size on FSmartCoverAnimCollectionData");
static_assert(offsetof(FSmartCoverAnimCollectionData, WeaponTypeAnimationsData) == 0x000000, "Member 'FSmartCoverAnimCollectionData::WeaponTypeAnimationsData' has a wrong offset!");

// ScriptStruct Stalker2.FactionRestrictions
// 0x0068 (0x0068 - 0x0000)
struct FFactionRestrictions final
{
public:
	struct FFactionSelector                       Faction;                                           // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	ESpaceRestrictionType                         RestrictionType;                                   // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFactionRestrictions) == 0x000008, "Wrong alignment on FFactionRestrictions");
static_assert(sizeof(FFactionRestrictions) == 0x000068, "Wrong size on FFactionRestrictions");
static_assert(offsetof(FFactionRestrictions, Faction) == 0x000000, "Member 'FFactionRestrictions::Faction' has a wrong offset!");
static_assert(offsetof(FFactionRestrictions, RestrictionType) == 0x000060, "Member 'FFactionRestrictions::RestrictionType' has a wrong offset!");

// ScriptStruct Stalker2.AgentDomainRestrictions
// 0x0002 (0x0002 - 0x0000)
struct FAgentDomainRestrictions final
{
public:
	EAgentDomain                                  AgentDomain;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpaceRestrictionType                         RestrictionType;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAgentDomainRestrictions) == 0x000001, "Wrong alignment on FAgentDomainRestrictions");
static_assert(sizeof(FAgentDomainRestrictions) == 0x000002, "Wrong size on FAgentDomainRestrictions");
static_assert(offsetof(FAgentDomainRestrictions, AgentDomain) == 0x000000, "Member 'FAgentDomainRestrictions::AgentDomain' has a wrong offset!");
static_assert(offsetof(FAgentDomainRestrictions, RestrictionType) == 0x000001, "Member 'FAgentDomainRestrictions::RestrictionType' has a wrong offset!");

// ScriptStruct Stalker2.DefaultRestrictions
// 0x0028 (0x0028 - 0x0000)
struct FDefaultRestrictions final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDuringEmission;                             // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpaceRestrictionType                         GlobalRestriction;                                 // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAgentDomainRestrictions>       AgentDomainRestrictions;                           // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFactionRestrictions>           FactionRestrictions;                               // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefaultRestrictions) == 0x000008, "Wrong alignment on FDefaultRestrictions");
static_assert(sizeof(FDefaultRestrictions) == 0x000028, "Wrong size on FDefaultRestrictions");
static_assert(offsetof(FDefaultRestrictions, bEnabled) == 0x000000, "Member 'FDefaultRestrictions::bEnabled' has a wrong offset!");
static_assert(offsetof(FDefaultRestrictions, bIgnoreDuringEmission) == 0x000001, "Member 'FDefaultRestrictions::bIgnoreDuringEmission' has a wrong offset!");
static_assert(offsetof(FDefaultRestrictions, GlobalRestriction) == 0x000002, "Member 'FDefaultRestrictions::GlobalRestriction' has a wrong offset!");
static_assert(offsetof(FDefaultRestrictions, AgentDomainRestrictions) == 0x000008, "Member 'FDefaultRestrictions::AgentDomainRestrictions' has a wrong offset!");
static_assert(offsetof(FDefaultRestrictions, FactionRestrictions) == 0x000018, "Member 'FDefaultRestrictions::FactionRestrictions' has a wrong offset!");

// ScriptStruct Stalker2.StaticEnvironmentParticleDataRow
// 0x0110 (0x0118 - 0x0008)
struct FStaticEnvironmentParticleDataRow final : public FTableRowBase
{
public:
	EStaticParticleType                           ParticleType;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class UNiagaraParameterProvider>> Providers;                                    // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FParticleIndoorSpawnPrototype          IndoorSpawnPrototype;                              // 0x0060(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParticleWeatherPrototype              WeatherTypePrototype;                              // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParticleLairPrototype                 LairPrototype;                                     // 0x00A8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParticleDistancePrototype             PlayerDistancePrototype;                           // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParticleDaytimePrototype              DaytimePrototype;                                  // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParticleRainIntensityPrototype        RainIntensityPrototype;                            // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParticleWindIntensityPrototype        WindIntensityPrototype;                            // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UNiagaraSystem>>  NiagaraSystems;                                    // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStaticEnvironmentParticleDataRow) == 0x000008, "Wrong alignment on FStaticEnvironmentParticleDataRow");
static_assert(sizeof(FStaticEnvironmentParticleDataRow) == 0x000118, "Wrong size on FStaticEnvironmentParticleDataRow");
static_assert(offsetof(FStaticEnvironmentParticleDataRow, ParticleType) == 0x000008, "Member 'FStaticEnvironmentParticleDataRow::ParticleType' has a wrong offset!");
static_assert(offsetof(FStaticEnvironmentParticleDataRow, Providers) == 0x000010, "Member 'FStaticEnvironmentParticleDataRow::Providers' has a wrong offset!");
static_assert(offsetof(FStaticEnvironmentParticleDataRow, IndoorSpawnPrototype) == 0x000060, "Member 'FStaticEnvironmentParticleDataRow::IndoorSpawnPrototype' has a wrong offset!");
static_assert(offsetof(FStaticEnvironmentParticleDataRow, WeatherTypePrototype) == 0x000090, "Member 'FStaticEnvironmentParticleDataRow::WeatherTypePrototype' has a wrong offset!");
static_assert(offsetof(FStaticEnvironmentParticleDataRow, LairPrototype) == 0x0000A8, "Member 'FStaticEnvironmentParticleDataRow::LairPrototype' has a wrong offset!");
static_assert(offsetof(FStaticEnvironmentParticleDataRow, PlayerDistancePrototype) == 0x0000C8, "Member 'FStaticEnvironmentParticleDataRow::PlayerDistancePrototype' has a wrong offset!");
static_assert(offsetof(FStaticEnvironmentParticleDataRow, DaytimePrototype) == 0x0000D8, "Member 'FStaticEnvironmentParticleDataRow::DaytimePrototype' has a wrong offset!");
static_assert(offsetof(FStaticEnvironmentParticleDataRow, RainIntensityPrototype) == 0x0000E8, "Member 'FStaticEnvironmentParticleDataRow::RainIntensityPrototype' has a wrong offset!");
static_assert(offsetof(FStaticEnvironmentParticleDataRow, WindIntensityPrototype) == 0x0000F8, "Member 'FStaticEnvironmentParticleDataRow::WindIntensityPrototype' has a wrong offset!");
static_assert(offsetof(FStaticEnvironmentParticleDataRow, NiagaraSystems) == 0x000108, "Member 'FStaticEnvironmentParticleDataRow::NiagaraSystems' has a wrong offset!");

// ScriptStruct Stalker2.StatStates
// 0x000C (0x000C - 0x0000)
struct FStatStates final
{
public:
	float                                         Weak;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Medium;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strong;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatStates) == 0x000004, "Wrong alignment on FStatStates");
static_assert(sizeof(FStatStates) == 0x00000C, "Wrong size on FStatStates");
static_assert(offsetof(FStatStates, Weak) == 0x000000, "Member 'FStatStates::Weak' has a wrong offset!");
static_assert(offsetof(FStatStates, Medium) == 0x000004, "Member 'FStatStates::Medium' has a wrong offset!");
static_assert(offsetof(FStatStates, Strong) == 0x000008, "Member 'FStatStates::Strong' has a wrong offset!");

// ScriptStruct Stalker2.StealthParams
// 0x0024 (0x0024 - 0x0000)
struct FStealthParams final
{
public:
	float                                         FlashLightCoef;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibilitySizeFactor;                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibilityCrouchCoef;                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibilityJumpCoef;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibilityObstacleHeadCoef;                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibilityObstacleBodyCoef;                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseObstacleCoef;                                 // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseCrouchCoef;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseJumpCoef;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStealthParams) == 0x000004, "Wrong alignment on FStealthParams");
static_assert(sizeof(FStealthParams) == 0x000024, "Wrong size on FStealthParams");
static_assert(offsetof(FStealthParams, FlashLightCoef) == 0x000000, "Member 'FStealthParams::FlashLightCoef' has a wrong offset!");
static_assert(offsetof(FStealthParams, VisibilitySizeFactor) == 0x000004, "Member 'FStealthParams::VisibilitySizeFactor' has a wrong offset!");
static_assert(offsetof(FStealthParams, VisibilityCrouchCoef) == 0x000008, "Member 'FStealthParams::VisibilityCrouchCoef' has a wrong offset!");
static_assert(offsetof(FStealthParams, VisibilityJumpCoef) == 0x00000C, "Member 'FStealthParams::VisibilityJumpCoef' has a wrong offset!");
static_assert(offsetof(FStealthParams, VisibilityObstacleHeadCoef) == 0x000010, "Member 'FStealthParams::VisibilityObstacleHeadCoef' has a wrong offset!");
static_assert(offsetof(FStealthParams, VisibilityObstacleBodyCoef) == 0x000014, "Member 'FStealthParams::VisibilityObstacleBodyCoef' has a wrong offset!");
static_assert(offsetof(FStealthParams, NoiseObstacleCoef) == 0x000018, "Member 'FStealthParams::NoiseObstacleCoef' has a wrong offset!");
static_assert(offsetof(FStealthParams, NoiseCrouchCoef) == 0x00001C, "Member 'FStealthParams::NoiseCrouchCoef' has a wrong offset!");
static_assert(offsetof(FStealthParams, NoiseJumpCoef) == 0x000020, "Member 'FStealthParams::NoiseJumpCoef' has a wrong offset!");

// ScriptStruct Stalker2.StrandSplineComponent
// 0x00B0 (0x00B0 - 0x0000)
struct FStrandSplineComponent final
{
public:
	struct FVector                                WorldPos;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartPos;                                          // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartTangent;                                      // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPos;                                            // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTangent;                                        // 0x0068(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0080(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RelativeScale;                                     // 0x0098(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStrandSplineComponent) == 0x000008, "Wrong alignment on FStrandSplineComponent");
static_assert(sizeof(FStrandSplineComponent) == 0x0000B0, "Wrong size on FStrandSplineComponent");
static_assert(offsetof(FStrandSplineComponent, WorldPos) == 0x000000, "Member 'FStrandSplineComponent::WorldPos' has a wrong offset!");
static_assert(offsetof(FStrandSplineComponent, StaticMesh) == 0x000018, "Member 'FStrandSplineComponent::StaticMesh' has a wrong offset!");
static_assert(offsetof(FStrandSplineComponent, StartPos) == 0x000020, "Member 'FStrandSplineComponent::StartPos' has a wrong offset!");
static_assert(offsetof(FStrandSplineComponent, StartTangent) == 0x000038, "Member 'FStrandSplineComponent::StartTangent' has a wrong offset!");
static_assert(offsetof(FStrandSplineComponent, EndPos) == 0x000050, "Member 'FStrandSplineComponent::EndPos' has a wrong offset!");
static_assert(offsetof(FStrandSplineComponent, EndTangent) == 0x000068, "Member 'FStrandSplineComponent::EndTangent' has a wrong offset!");
static_assert(offsetof(FStrandSplineComponent, Rotation) == 0x000080, "Member 'FStrandSplineComponent::Rotation' has a wrong offset!");
static_assert(offsetof(FStrandSplineComponent, RelativeScale) == 0x000098, "Member 'FStrandSplineComponent::RelativeScale' has a wrong offset!");

// ScriptStruct Stalker2.StrandFinalData
// 0x0020 (0x0020 - 0x0000)
struct FStrandFinalData final
{
public:
	TArray<struct FStrandSplineComponent>         SplineComponentsData;                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FStrandStaticMeshComponent>     StaticMeshComponentsData;                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStrandFinalData) == 0x000008, "Wrong alignment on FStrandFinalData");
static_assert(sizeof(FStrandFinalData) == 0x000020, "Wrong size on FStrandFinalData");
static_assert(offsetof(FStrandFinalData, SplineComponentsData) == 0x000000, "Member 'FStrandFinalData::SplineComponentsData' has a wrong offset!");
static_assert(offsetof(FStrandFinalData, StaticMeshComponentsData) == 0x000010, "Member 'FStrandFinalData::StaticMeshComponentsData' has a wrong offset!");

// ScriptStruct Stalker2.StreamingDistanceOverrideTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FStreamingDistanceOverrideTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStreamingDistanceOverrideTickFunction) == 0x000008, "Wrong alignment on FStreamingDistanceOverrideTickFunction");
static_assert(sizeof(FStreamingDistanceOverrideTickFunction) == 0x000030, "Wrong size on FStreamingDistanceOverrideTickFunction");

// ScriptStruct Stalker2.NotificationModel
// 0x0078 (0x0078 - 0x0000)
struct FNotificationModel final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHintType                                     HintType;                                          // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemsRemoved;                                     // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionSystemNotificationsType           Type;                                              // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AudiologChainPrototypeID;                          // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AudiologDuration;                                  // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x14];                                      // 0x0064(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNotificationModel) == 0x000008, "Wrong alignment on FNotificationModel");
static_assert(sizeof(FNotificationModel) == 0x000078, "Wrong size on FNotificationModel");
static_assert(offsetof(FNotificationModel, Title) == 0x000000, "Member 'FNotificationModel::Title' has a wrong offset!");
static_assert(offsetof(FNotificationModel, Description) == 0x000018, "Member 'FNotificationModel::Description' has a wrong offset!");
static_assert(offsetof(FNotificationModel, Count) == 0x000030, "Member 'FNotificationModel::Count' has a wrong offset!");
static_assert(offsetof(FNotificationModel, HintType) == 0x000034, "Member 'FNotificationModel::HintType' has a wrong offset!");
static_assert(offsetof(FNotificationModel, bItemsRemoved) == 0x000035, "Member 'FNotificationModel::bItemsRemoved' has a wrong offset!");
static_assert(offsetof(FNotificationModel, Type) == 0x000036, "Member 'FNotificationModel::Type' has a wrong offset!");
static_assert(offsetof(FNotificationModel, Location) == 0x000038, "Member 'FNotificationModel::Location' has a wrong offset!");
static_assert(offsetof(FNotificationModel, AudiologChainPrototypeID) == 0x000050, "Member 'FNotificationModel::AudiologChainPrototypeID' has a wrong offset!");
static_assert(offsetof(FNotificationModel, AudiologDuration) == 0x000060, "Member 'FNotificationModel::AudiologDuration' has a wrong offset!");

// ScriptStruct Stalker2.TeleportParams
// 0x0003 (0x0003 - 0x0000)
struct FTeleportParams final
{
public:
	uint8                                         Pad_0[0x3];                                        // 0x0000(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeleportParams) == 0x000001, "Wrong alignment on FTeleportParams");
static_assert(sizeof(FTeleportParams) == 0x000003, "Wrong size on FTeleportParams");

// ScriptStruct Stalker2.TextSettings
// 0x03C0 (0x03C0 - 0x0000)
struct FTextSettings final
{
public:
	class FName                                   FontStyleId;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFontColor;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTextBlockStyle                        FontStyle;                                         // 0x0010(0x03A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETextJustify                                  Justification;                                     // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoWrap;                                         // 0x03B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B2[0x2];                                      // 0x03B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WrappingTextAt;                                    // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextTransformPolicy                          TextTransformPolicy;                               // 0x03B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineHeightPercentage;                              // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextSettings) == 0x000010, "Wrong alignment on FTextSettings");
static_assert(sizeof(FTextSettings) == 0x0003C0, "Wrong size on FTextSettings");
static_assert(offsetof(FTextSettings, FontStyleId) == 0x000000, "Member 'FTextSettings::FontStyleId' has a wrong offset!");
static_assert(offsetof(FTextSettings, bUseFontColor) == 0x000008, "Member 'FTextSettings::bUseFontColor' has a wrong offset!");
static_assert(offsetof(FTextSettings, FontStyle) == 0x000010, "Member 'FTextSettings::FontStyle' has a wrong offset!");
static_assert(offsetof(FTextSettings, Justification) == 0x0003B0, "Member 'FTextSettings::Justification' has a wrong offset!");
static_assert(offsetof(FTextSettings, bAutoWrap) == 0x0003B1, "Member 'FTextSettings::bAutoWrap' has a wrong offset!");
static_assert(offsetof(FTextSettings, WrappingTextAt) == 0x0003B4, "Member 'FTextSettings::WrappingTextAt' has a wrong offset!");
static_assert(offsetof(FTextSettings, TextTransformPolicy) == 0x0003B8, "Member 'FTextSettings::TextTransformPolicy' has a wrong offset!");
static_assert(offsetof(FTextSettings, LineHeightPercentage) == 0x0003BC, "Member 'FTextSettings::LineHeightPercentage' has a wrong offset!");

// ScriptStruct Stalker2.TimeBudget
// 0x0030 (0x0030 - 0x0000)
struct FTimeBudget final
{
public:
	int32                                         AgentView;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AgentModel;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnomalyView;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnomalyModel;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArtifactView;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemContainer;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestructibleView;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestructibleModel;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WetnessComponent;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlashlightComponent;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContextualActionModel;                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuestNode;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTimeBudget) == 0x000004, "Wrong alignment on FTimeBudget");
static_assert(sizeof(FTimeBudget) == 0x000030, "Wrong size on FTimeBudget");
static_assert(offsetof(FTimeBudget, AgentView) == 0x000000, "Member 'FTimeBudget::AgentView' has a wrong offset!");
static_assert(offsetof(FTimeBudget, AgentModel) == 0x000004, "Member 'FTimeBudget::AgentModel' has a wrong offset!");
static_assert(offsetof(FTimeBudget, AnomalyView) == 0x000008, "Member 'FTimeBudget::AnomalyView' has a wrong offset!");
static_assert(offsetof(FTimeBudget, AnomalyModel) == 0x00000C, "Member 'FTimeBudget::AnomalyModel' has a wrong offset!");
static_assert(offsetof(FTimeBudget, ArtifactView) == 0x000010, "Member 'FTimeBudget::ArtifactView' has a wrong offset!");
static_assert(offsetof(FTimeBudget, ItemContainer) == 0x000014, "Member 'FTimeBudget::ItemContainer' has a wrong offset!");
static_assert(offsetof(FTimeBudget, DestructibleView) == 0x000018, "Member 'FTimeBudget::DestructibleView' has a wrong offset!");
static_assert(offsetof(FTimeBudget, DestructibleModel) == 0x00001C, "Member 'FTimeBudget::DestructibleModel' has a wrong offset!");
static_assert(offsetof(FTimeBudget, WetnessComponent) == 0x000020, "Member 'FTimeBudget::WetnessComponent' has a wrong offset!");
static_assert(offsetof(FTimeBudget, FlashlightComponent) == 0x000024, "Member 'FTimeBudget::FlashlightComponent' has a wrong offset!");
static_assert(offsetof(FTimeBudget, ContextualActionModel) == 0x000028, "Member 'FTimeBudget::ContextualActionModel' has a wrong offset!");
static_assert(offsetof(FTimeBudget, QuestNode) == 0x00002C, "Member 'FTimeBudget::QuestNode' has a wrong offset!");

// ScriptStruct Stalker2.TopazScannerVFX
// 0x00A0 (0x00A0 - 0x0000)
struct FTopazScannerVFX final
{
public:
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EnableTime;                                        // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DisableTime;                                       // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UNiagaraComponent>       NiagaraComponent;                                  // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ATopazScanner>           OwnerScanner;                                      // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x18];                                      // 0x0088(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTopazScannerVFX) == 0x000010, "Wrong alignment on FTopazScannerVFX");
static_assert(sizeof(FTopazScannerVFX) == 0x0000A0, "Wrong size on FTopazScannerVFX");
static_assert(offsetof(FTopazScannerVFX, NiagaraSystem) == 0x000000, "Member 'FTopazScannerVFX::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(FTopazScannerVFX, SpawnTransform) == 0x000010, "Member 'FTopazScannerVFX::SpawnTransform' has a wrong offset!");
static_assert(offsetof(FTopazScannerVFX, EnableTime) == 0x000070, "Member 'FTopazScannerVFX::EnableTime' has a wrong offset!");
static_assert(offsetof(FTopazScannerVFX, DisableTime) == 0x000074, "Member 'FTopazScannerVFX::DisableTime' has a wrong offset!");
static_assert(offsetof(FTopazScannerVFX, NiagaraComponent) == 0x000078, "Member 'FTopazScannerVFX::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(FTopazScannerVFX, OwnerScanner) == 0x000080, "Member 'FTopazScannerVFX::OwnerScanner' has a wrong offset!");

// ScriptStruct Stalker2.ItemContainerUID
// 0x0000 (0x0004 - 0x0004)
struct FItemContainerUID final : public FUID
{
};
static_assert(alignof(FItemContainerUID) == 0x000004, "Wrong alignment on FItemContainerUID");
static_assert(sizeof(FItemContainerUID) == 0x000004, "Wrong size on FItemContainerUID");

// ScriptStruct Stalker2.GSC_WidgetStyle
// 0x0010 (0x0018 - 0x0008)
struct FGSC_WidgetStyle final : public FTableRowBase
{
public:
	struct FLinearColor                           Colour;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGSC_WidgetStyle) == 0x000008, "Wrong alignment on FGSC_WidgetStyle");
static_assert(sizeof(FGSC_WidgetStyle) == 0x000018, "Wrong size on FGSC_WidgetStyle");
static_assert(offsetof(FGSC_WidgetStyle, Colour) == 0x000008, "Member 'FGSC_WidgetStyle::Colour' has a wrong offset!");

// ScriptStruct Stalker2.Upgrade
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FUpgrade final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUpgrade) == 0x000008, "Wrong alignment on FUpgrade");
static_assert(sizeof(FUpgrade) == 0x000058, "Wrong size on FUpgrade");

// ScriptStruct Stalker2.OverlapVolumeEffect
// 0x0050 (0x0050 - 0x0000)
struct FOverlapVolumeEffect final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrototypeSID                          EffectPrototype;                                   // 0x0008(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AddOnBeginOverlap : 1;                             // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         RemoveOnEndOverlap : 1;                            // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IgnorePlayer : 1;                                  // 0x0048(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IgnoreAI : 1;                                      // 0x0048(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOverlapVolumeEffect) == 0x000008, "Wrong alignment on FOverlapVolumeEffect");
static_assert(sizeof(FOverlapVolumeEffect) == 0x000050, "Wrong size on FOverlapVolumeEffect");
static_assert(offsetof(FOverlapVolumeEffect, EffectPrototype) == 0x000008, "Member 'FOverlapVolumeEffect::EffectPrototype' has a wrong offset!");

// ScriptStruct Stalker2.WLSplinePointTiming
// 0x0001 (0x0001 - 0x0000)
struct FWLSplinePointTiming final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWLSplinePointTiming) == 0x000001, "Wrong alignment on FWLSplinePointTiming");
static_assert(sizeof(FWLSplinePointTiming) == 0x000001, "Wrong size on FWLSplinePointTiming");

// ScriptStruct Stalker2.WanderingLightInstanceData
// 0x0040 (0x0040 - 0x0000)
struct FWanderingLightInstanceData final
{
public:
	struct FVector                                BaseLocation;                                      // 0x0000(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveVector                     HorizontalMovementCurve;                           // 0x0018(0x0018)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalMovementDuration;                        // 0x0030(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalMovementDenom;                           // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseVerticalOffset;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCircularMovement;                                 // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWanderingLightInstanceData) == 0x000008, "Wrong alignment on FWanderingLightInstanceData");
static_assert(sizeof(FWanderingLightInstanceData) == 0x000040, "Wrong size on FWanderingLightInstanceData");
static_assert(offsetof(FWanderingLightInstanceData, BaseLocation) == 0x000000, "Member 'FWanderingLightInstanceData::BaseLocation' has a wrong offset!");
static_assert(offsetof(FWanderingLightInstanceData, HorizontalMovementCurve) == 0x000018, "Member 'FWanderingLightInstanceData::HorizontalMovementCurve' has a wrong offset!");
static_assert(offsetof(FWanderingLightInstanceData, HorizontalMovementDuration) == 0x000030, "Member 'FWanderingLightInstanceData::HorizontalMovementDuration' has a wrong offset!");
static_assert(offsetof(FWanderingLightInstanceData, HorizontalMovementDenom) == 0x000034, "Member 'FWanderingLightInstanceData::HorizontalMovementDenom' has a wrong offset!");
static_assert(offsetof(FWanderingLightInstanceData, BaseVerticalOffset) == 0x000038, "Member 'FWanderingLightInstanceData::BaseVerticalOffset' has a wrong offset!");
static_assert(offsetof(FWanderingLightInstanceData, bCircularMovement) == 0x00003C, "Member 'FWanderingLightInstanceData::bCircularMovement' has a wrong offset!");

// ScriptStruct Stalker2.WLCylinderShapeParams
// 0x0028 (0x0028 - 0x0000)
struct FWLCylinderShapeParams final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZMin;                                              // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZMax;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWLCylinderShapeParams) == 0x000008, "Wrong alignment on FWLCylinderShapeParams");
static_assert(sizeof(FWLCylinderShapeParams) == 0x000028, "Wrong size on FWLCylinderShapeParams");
static_assert(offsetof(FWLCylinderShapeParams, Location) == 0x000000, "Member 'FWLCylinderShapeParams::Location' has a wrong offset!");
static_assert(offsetof(FWLCylinderShapeParams, Radius) == 0x000018, "Member 'FWLCylinderShapeParams::Radius' has a wrong offset!");
static_assert(offsetof(FWLCylinderShapeParams, ZMin) == 0x00001C, "Member 'FWLCylinderShapeParams::ZMin' has a wrong offset!");
static_assert(offsetof(FWLCylinderShapeParams, ZMax) == 0x000020, "Member 'FWLCylinderShapeParams::ZMax' has a wrong offset!");

// ScriptStruct Stalker2.WaterSurfaceObstructionResult
// 0x0010 (0x0010 - 0x0000)
struct FWaterSurfaceObstructionResult final
{
public:
	bool                                          bObstructed;                                       // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DistanceToWater;                                   // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaterSurfaceObstructionResult) == 0x000008, "Wrong alignment on FWaterSurfaceObstructionResult");
static_assert(sizeof(FWaterSurfaceObstructionResult) == 0x000010, "Wrong size on FWaterSurfaceObstructionResult");
static_assert(offsetof(FWaterSurfaceObstructionResult, bObstructed) == 0x000000, "Member 'FWaterSurfaceObstructionResult::bObstructed' has a wrong offset!");
static_assert(offsetof(FWaterSurfaceObstructionResult, DistanceToWater) == 0x000008, "Member 'FWaterSurfaceObstructionResult::DistanceToWater' has a wrong offset!");

// ScriptStruct Stalker2.DragDeadBodyAnimations
// 0x0010 (0x0010 - 0x0000)
struct FDragDeadBodyAnimations final
{
public:
	class UAnimMontage*                           PickUpBodyFaceUp;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DropBody;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragDeadBodyAnimations) == 0x000008, "Wrong alignment on FDragDeadBodyAnimations");
static_assert(sizeof(FDragDeadBodyAnimations) == 0x000010, "Wrong size on FDragDeadBodyAnimations");
static_assert(offsetof(FDragDeadBodyAnimations, PickUpBodyFaceUp) == 0x000000, "Member 'FDragDeadBodyAnimations::PickUpBodyFaceUp' has a wrong offset!");
static_assert(offsetof(FDragDeadBodyAnimations, DropBody) == 0x000008, "Member 'FDragDeadBodyAnimations::DropBody' has a wrong offset!");

// ScriptStruct Stalker2.CharacterDetectorAnimations
// 0x0068 (0x0068 - 0x0000)
struct FCharacterDetectorAnimations final
{
public:
	class UAnimMontage*                           Character;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FCharacterWeaponAnimations> CharacterWithWeapon;                              // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Detector;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Weapon;                                            // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDetectorAnimations) == 0x000008, "Wrong alignment on FCharacterDetectorAnimations");
static_assert(sizeof(FCharacterDetectorAnimations) == 0x000068, "Wrong size on FCharacterDetectorAnimations");
static_assert(offsetof(FCharacterDetectorAnimations, Character) == 0x000000, "Member 'FCharacterDetectorAnimations::Character' has a wrong offset!");
static_assert(offsetof(FCharacterDetectorAnimations, CharacterWithWeapon) == 0x000008, "Member 'FCharacterDetectorAnimations::CharacterWithWeapon' has a wrong offset!");
static_assert(offsetof(FCharacterDetectorAnimations, Detector) == 0x000058, "Member 'FCharacterDetectorAnimations::Detector' has a wrong offset!");
static_assert(offsetof(FCharacterDetectorAnimations, Weapon) == 0x000060, "Member 'FCharacterDetectorAnimations::Weapon' has a wrong offset!");

// ScriptStruct Stalker2.CharacterDetectorFailedLandingAnimations
// 0x0050 (0x0050 - 0x0000)
struct FCharacterDetectorFailedLandingAnimations final
{
public:
	TMap<EMainHandEquipmentType, class UAnimMontage*> FailedLanding;                                 // 0x0000(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDetectorFailedLandingAnimations) == 0x000008, "Wrong alignment on FCharacterDetectorFailedLandingAnimations");
static_assert(sizeof(FCharacterDetectorFailedLandingAnimations) == 0x000050, "Wrong size on FCharacterDetectorFailedLandingAnimations");
static_assert(offsetof(FCharacterDetectorFailedLandingAnimations, FailedLanding) == 0x000000, "Member 'FCharacterDetectorFailedLandingAnimations::FailedLanding' has a wrong offset!");

// ScriptStruct Stalker2.AttachMeshesData
// 0x0010 (0x0010 - 0x0000)
struct FAttachMeshesData final
{
public:
	TArray<class UMeshComponent*>                 ArrayMeshes;                                       // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttachMeshesData) == 0x000008, "Wrong alignment on FAttachMeshesData");
static_assert(sizeof(FAttachMeshesData) == 0x000010, "Wrong size on FAttachMeshesData");
static_assert(offsetof(FAttachMeshesData, ArrayMeshes) == 0x000000, "Member 'FAttachMeshesData::ArrayMeshes' has a wrong offset!");

// ScriptStruct Stalker2.WeaponAttachMeshesData
// 0x0080 (0x0080 - 0x0000)
struct FWeaponAttachMeshesData final
{
public:
	TMap<EAttachType, struct FAttachMeshesData>   AttachMeshesMap;                                   // 0x0000(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMeshComponent*>                 BulletMeshes;                                      // 0x0050(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAttachedMagazineStruct>        MagazineMeshes;                                    // 0x0060(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMeshComponent*>                 WeaponStaticMeshParts;                             // 0x0070(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAttachMeshesData) == 0x000008, "Wrong alignment on FWeaponAttachMeshesData");
static_assert(sizeof(FWeaponAttachMeshesData) == 0x000080, "Wrong size on FWeaponAttachMeshesData");
static_assert(offsetof(FWeaponAttachMeshesData, AttachMeshesMap) == 0x000000, "Member 'FWeaponAttachMeshesData::AttachMeshesMap' has a wrong offset!");
static_assert(offsetof(FWeaponAttachMeshesData, BulletMeshes) == 0x000050, "Member 'FWeaponAttachMeshesData::BulletMeshes' has a wrong offset!");
static_assert(offsetof(FWeaponAttachMeshesData, MagazineMeshes) == 0x000060, "Member 'FWeaponAttachMeshesData::MagazineMeshes' has a wrong offset!");
static_assert(offsetof(FWeaponAttachMeshesData, WeaponStaticMeshParts) == 0x000070, "Member 'FWeaponAttachMeshesData::WeaponStaticMeshParts' has a wrong offset!");

// ScriptStruct Stalker2.Wind
// 0x0070 (0x0070 - 0x0000)
struct FWind final
{
public:
	struct FVector2D                              FoliageWindDirection;                              // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FoliageWindIntensity;                              // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              PreviousFoliageWindDirection;                      // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PreviousFoliageWindIntensity;                      // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Intensity;                                         // 0x002C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WindDirectionChangeIntensity;                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLockedDirection;                                  // 0x0034(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Direction;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              TargetDirection;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              PreviousDirection;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWind) == 0x000008, "Wrong alignment on FWind");
static_assert(sizeof(FWind) == 0x000070, "Wrong size on FWind");
static_assert(offsetof(FWind, FoliageWindDirection) == 0x000000, "Member 'FWind::FoliageWindDirection' has a wrong offset!");
static_assert(offsetof(FWind, FoliageWindIntensity) == 0x000010, "Member 'FWind::FoliageWindIntensity' has a wrong offset!");
static_assert(offsetof(FWind, PreviousFoliageWindDirection) == 0x000018, "Member 'FWind::PreviousFoliageWindDirection' has a wrong offset!");
static_assert(offsetof(FWind, PreviousFoliageWindIntensity) == 0x000028, "Member 'FWind::PreviousFoliageWindIntensity' has a wrong offset!");
static_assert(offsetof(FWind, Intensity) == 0x00002C, "Member 'FWind::Intensity' has a wrong offset!");
static_assert(offsetof(FWind, WindDirectionChangeIntensity) == 0x000030, "Member 'FWind::WindDirectionChangeIntensity' has a wrong offset!");
static_assert(offsetof(FWind, bLockedDirection) == 0x000034, "Member 'FWind::bLockedDirection' has a wrong offset!");
static_assert(offsetof(FWind, Direction) == 0x000038, "Member 'FWind::Direction' has a wrong offset!");
static_assert(offsetof(FWind, TargetDirection) == 0x000048, "Member 'FWind::TargetDirection' has a wrong offset!");
static_assert(offsetof(FWind, PreviousDirection) == 0x000058, "Member 'FWind::PreviousDirection' has a wrong offset!");

// ScriptStruct Stalker2.WetnessComponentCollection
// 0x0030 (0x0098 - 0x0068)
struct FWetnessComponentCollection final : public FBaseTickAggregationCollection
{
public:
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWetnessComponentCollection) == 0x000008, "Wrong alignment on FWetnessComponentCollection");
static_assert(sizeof(FWetnessComponentCollection) == 0x000098, "Wrong size on FWetnessComponentCollection");

// ScriptStruct Stalker2.DisplaySettings
// 0x0020 (0x0020 - 0x0000)
struct FDisplaySettings final
{
public:
	class FName                                   TitleBackgroundStyleId;                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TitleBorderLineStyleId;                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InsideMarkerStyleId;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerBackgroundStyleId;                           // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDisplaySettings) == 0x000004, "Wrong alignment on FDisplaySettings");
static_assert(sizeof(FDisplaySettings) == 0x000020, "Wrong size on FDisplaySettings");
static_assert(offsetof(FDisplaySettings, TitleBackgroundStyleId) == 0x000000, "Member 'FDisplaySettings::TitleBackgroundStyleId' has a wrong offset!");
static_assert(offsetof(FDisplaySettings, TitleBorderLineStyleId) == 0x000008, "Member 'FDisplaySettings::TitleBorderLineStyleId' has a wrong offset!");
static_assert(offsetof(FDisplaySettings, InsideMarkerStyleId) == 0x000010, "Member 'FDisplaySettings::InsideMarkerStyleId' has a wrong offset!");
static_assert(offsetof(FDisplaySettings, MarkerBackgroundStyleId) == 0x000018, "Member 'FDisplaySettings::MarkerBackgroundStyleId' has a wrong offset!");

}

