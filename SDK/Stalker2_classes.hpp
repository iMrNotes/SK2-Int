#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Stalker2

#include "Basic.hpp"

#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Stalker2_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AkAudio_structs.hpp"
#include "AkAudio_classes.hpp"
#include "NiagaraAnimNotifies_classes.hpp"
#include "PoseSearch_classes.hpp"
#include "EnhancedInput_classes.hpp"
#include "MovieScene_structs.hpp"
#include "Niagara_classes.hpp"
#include "CinematicKeyFrameTracks_structs.hpp"
#include "AIModule_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "PhysicsCore_classes.hpp"
#include "SlateCore_structs.hpp"
#include "CommonUI_classes.hpp"
#include "ModioUI_classes.hpp"
#include "MotionWarping_classes.hpp"
#include "SectorSelector_classes.hpp"


namespace SDK
{

// Class Stalker2.WidgetBase
// 0x0000 (0x0278 - 0x0278)
class UWidgetBase : public UUserWidget
{
public:
	void UpdateWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetBase">();
	}
	static class UWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetBase>();
	}
};
static_assert(alignof(UWidgetBase) == 0x000008, "Wrong alignment on UWidgetBase");
static_assert(sizeof(UWidgetBase) == 0x000278, "Wrong size on UWidgetBase");

// Class Stalker2.GuidActorComponent
// 0x0018 (0x00B8 - 0x00A0)
class UGuidActorComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidActorComponent">();
	}
	static class UGuidActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuidActorComponent>();
	}
};
static_assert(alignof(UGuidActorComponent) == 0x000008, "Wrong alignment on UGuidActorComponent");
static_assert(sizeof(UGuidActorComponent) == 0x0000B8, "Wrong size on UGuidActorComponent");
static_assert(offsetof(UGuidActorComponent, Guid) == 0x0000A8, "Member 'UGuidActorComponent::Guid' has a wrong offset!");

// Class Stalker2.UIDActorComponent
// 0x0000 (0x00B8 - 0x00B8)
class UUIDActorComponent : public UGuidActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActorComponent">();
	}
	static class UUIDActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDActorComponent>();
	}
};
static_assert(alignof(UUIDActorComponent) == 0x000008, "Wrong alignment on UUIDActorComponent");
static_assert(sizeof(UUIDActorComponent) == 0x0000B8, "Wrong size on UUIDActorComponent");

// Class Stalker2.InteractionComponent
// 0x0110 (0x01C8 - 0x00B8)
class UInteractionComponent : public UUIDActorComponent
{
public:
	FMulticastSparseDelegateProperty_             OnStartQuestNode;                                  // 0x00B8(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnFinishQuestNode;                                 // 0x00B9(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnExcludeQuestNode;                                // 0x00BA(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnInteractedEvent;                                 // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEndInteractedEvent;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnNotifyInteractEvent;                             // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   InteractionSocketName;                             // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x40];                                      // 0x00F8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsInteractionActive;                              // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldReleaseTargetOnInteraction;                 // 0x0139(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRightHandBusy;                                    // 0x013A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeftHandBusy;                                     // 0x013B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsConeInteraction;                                // 0x013C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowInactive;                                     // 0x013D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelfActivating;                                   // 0x013E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F[0x1];                                      // 0x013F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinInteractionRadius;                              // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxInteractionRadius;                              // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ConeTipOffset;                                     // 0x0148(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractionHeight;                                 // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractionPointHeightOffset;                      // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ConeDirection;                                     // 0x0168(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConeHeight;                                        // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConeAngle;                                         // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableAnimCollection*            InteractableAnimCollection;                        // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Offset;                                            // 0x0190(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowInteractionDot;                               // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x1F];                                     // 0x01A9(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInteractionActive(const bool bActive);
	void SetInteractionDistance(const float MinDistance, const float MaxDistance);
	void SetSelfActivating(const bool bNewValue);
	void SetShowInactive(const bool bShow);

	bool HasItemRequirement() const;
	bool HasRelatedQuest() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionComponent">();
	}
	static class UInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionComponent>();
	}
};
static_assert(alignof(UInteractionComponent) == 0x000008, "Wrong alignment on UInteractionComponent");
static_assert(sizeof(UInteractionComponent) == 0x0001C8, "Wrong size on UInteractionComponent");
static_assert(offsetof(UInteractionComponent, OnStartQuestNode) == 0x0000B8, "Member 'UInteractionComponent::OnStartQuestNode' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnFinishQuestNode) == 0x0000B9, "Member 'UInteractionComponent::OnFinishQuestNode' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnExcludeQuestNode) == 0x0000BA, "Member 'UInteractionComponent::OnExcludeQuestNode' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnInteractedEvent) == 0x0000C0, "Member 'UInteractionComponent::OnInteractedEvent' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnEndInteractedEvent) == 0x0000D0, "Member 'UInteractionComponent::OnEndInteractedEvent' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnNotifyInteractEvent) == 0x0000E0, "Member 'UInteractionComponent::OnNotifyInteractEvent' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, InteractionSocketName) == 0x0000F0, "Member 'UInteractionComponent::InteractionSocketName' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bIsInteractionActive) == 0x000138, "Member 'UInteractionComponent::bIsInteractionActive' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bShouldReleaseTargetOnInteraction) == 0x000139, "Member 'UInteractionComponent::bShouldReleaseTargetOnInteraction' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bRightHandBusy) == 0x00013A, "Member 'UInteractionComponent::bRightHandBusy' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bLeftHandBusy) == 0x00013B, "Member 'UInteractionComponent::bLeftHandBusy' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bIsConeInteraction) == 0x00013C, "Member 'UInteractionComponent::bIsConeInteraction' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bShowInactive) == 0x00013D, "Member 'UInteractionComponent::bShowInactive' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bSelfActivating) == 0x00013E, "Member 'UInteractionComponent::bSelfActivating' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, MinInteractionRadius) == 0x000140, "Member 'UInteractionComponent::MinInteractionRadius' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, MaxInteractionRadius) == 0x000144, "Member 'UInteractionComponent::MaxInteractionRadius' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, ConeTipOffset) == 0x000148, "Member 'UInteractionComponent::ConeTipOffset' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, InteractionHeight) == 0x000160, "Member 'UInteractionComponent::InteractionHeight' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, InteractionPointHeightOffset) == 0x000164, "Member 'UInteractionComponent::InteractionPointHeightOffset' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, ConeDirection) == 0x000168, "Member 'UInteractionComponent::ConeDirection' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, ConeHeight) == 0x000180, "Member 'UInteractionComponent::ConeHeight' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, ConeAngle) == 0x000184, "Member 'UInteractionComponent::ConeAngle' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, InteractableAnimCollection) == 0x000188, "Member 'UInteractionComponent::InteractableAnimCollection' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, Offset) == 0x000190, "Member 'UInteractionComponent::Offset' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bShowInteractionDot) == 0x0001A8, "Member 'UInteractionComponent::bShowInteractionDot' has a wrong offset!");

// Class Stalker2.ChildViewBase
// 0x0000 (0x0278 - 0x0278)
class UChildViewBase : public UWidgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChildViewBase">();
	}
	static class UChildViewBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChildViewBase>();
	}
};
static_assert(alignof(UChildViewBase) == 0x000008, "Wrong alignment on UChildViewBase");
static_assert(sizeof(UChildViewBase) == 0x000278, "Wrong size on UChildViewBase");

// Class Stalker2.MenuSubViewBase
// 0x0058 (0x02D0 - 0x0278)
class UMenuSubViewBase : public UChildViewBase
{
public:
	class UTextWidget*                            PauseText;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           ButtonPanel;                                       // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuButtonModel*                       MenuButtonModel;                                   // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DefaultSelectedIndex;                              // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTextProperties                        TextProperties;                                    // 0x0294(0x0014)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         SpaceBetweenOptions;                               // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UScrollBox*                             ScrollBox;                                         // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMenuButtonBase*>                MenuOptionsHolder;                                 // 0x02B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UMenuButtonBase*                        SelectedButton;                                    // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SelectOptionWidget(class UMenuButtonBase* ButtonWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuSubViewBase">();
	}
	static class UMenuSubViewBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuSubViewBase>();
	}
};
static_assert(alignof(UMenuSubViewBase) == 0x000008, "Wrong alignment on UMenuSubViewBase");
static_assert(sizeof(UMenuSubViewBase) == 0x0002D0, "Wrong size on UMenuSubViewBase");
static_assert(offsetof(UMenuSubViewBase, PauseText) == 0x000278, "Member 'UMenuSubViewBase::PauseText' has a wrong offset!");
static_assert(offsetof(UMenuSubViewBase, ButtonPanel) == 0x000280, "Member 'UMenuSubViewBase::ButtonPanel' has a wrong offset!");
static_assert(offsetof(UMenuSubViewBase, MenuButtonModel) == 0x000288, "Member 'UMenuSubViewBase::MenuButtonModel' has a wrong offset!");
static_assert(offsetof(UMenuSubViewBase, DefaultSelectedIndex) == 0x000290, "Member 'UMenuSubViewBase::DefaultSelectedIndex' has a wrong offset!");
static_assert(offsetof(UMenuSubViewBase, TextProperties) == 0x000294, "Member 'UMenuSubViewBase::TextProperties' has a wrong offset!");
static_assert(offsetof(UMenuSubViewBase, SpaceBetweenOptions) == 0x0002A8, "Member 'UMenuSubViewBase::SpaceBetweenOptions' has a wrong offset!");
static_assert(offsetof(UMenuSubViewBase, ScrollBox) == 0x0002B0, "Member 'UMenuSubViewBase::ScrollBox' has a wrong offset!");
static_assert(offsetof(UMenuSubViewBase, MenuOptionsHolder) == 0x0002B8, "Member 'UMenuSubViewBase::MenuOptionsHolder' has a wrong offset!");
static_assert(offsetof(UMenuSubViewBase, SelectedButton) == 0x0002C8, "Member 'UMenuSubViewBase::SelectedButton' has a wrong offset!");

// Class Stalker2.SettingsMenuSubView
// 0x0020 (0x02F0 - 0x02D0)
class USettingsMenuSubView final : public UMenuSubViewBase
{
public:
	class USettingsView*                          SettingsView;                                      // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMenuButtonModel*                       ElementButtonHoveredMenuButtonModel;               // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMenuButtonModel*                       SubCategoryMenuButtonModel;                        // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsMenuSubView">();
	}
	static class USettingsMenuSubView* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsMenuSubView>();
	}
};
static_assert(alignof(USettingsMenuSubView) == 0x000008, "Wrong alignment on USettingsMenuSubView");
static_assert(sizeof(USettingsMenuSubView) == 0x0002F0, "Wrong size on USettingsMenuSubView");
static_assert(offsetof(USettingsMenuSubView, SettingsView) == 0x0002D0, "Member 'USettingsMenuSubView::SettingsView' has a wrong offset!");
static_assert(offsetof(USettingsMenuSubView, ElementButtonHoveredMenuButtonModel) == 0x0002D8, "Member 'USettingsMenuSubView::ElementButtonHoveredMenuButtonModel' has a wrong offset!");
static_assert(offsetof(USettingsMenuSubView, SubCategoryMenuButtonModel) == 0x0002E0, "Member 'USettingsMenuSubView::SubCategoryMenuButtonModel' has a wrong offset!");

// Class Stalker2.BaseManager
// 0x0050 (0x0078 - 0x0028)
class UBaseManager : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseManager">();
	}
	static class UBaseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseManager>();
	}
};
static_assert(alignof(UBaseManager) == 0x000008, "Wrong alignment on UBaseManager");
static_assert(sizeof(UBaseManager) == 0x000078, "Wrong size on UBaseManager");

// Class Stalker2.BaseTickableManager
// 0x0030 (0x00A8 - 0x0078)
class UBaseTickableManager : public UBaseManager
{
public:
	uint8                                         Pad_78[0x30];                                      // 0x0078(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseTickableManager">();
	}
	static class UBaseTickableManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseTickableManager>();
	}
};
static_assert(alignof(UBaseTickableManager) == 0x000008, "Wrong alignment on UBaseTickableManager");
static_assert(sizeof(UBaseTickableManager) == 0x0000A8, "Wrong size on UBaseTickableManager");

// Class Stalker2.BaseConsoleManager
// 0x0000 (0x00A8 - 0x00A8)
class UBaseConsoleManager : public UBaseTickableManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseConsoleManager">();
	}
	static class UBaseConsoleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseConsoleManager>();
	}
};
static_assert(alignof(UBaseConsoleManager) == 0x000008, "Wrong alignment on UBaseConsoleManager");
static_assert(sizeof(UBaseConsoleManager) == 0x0000A8, "Wrong size on UBaseConsoleManager");

// Class Stalker2.CustomConsoleManagerAchievements
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerAchievements final : public UBaseConsoleManager
{
public:
	void XAchievementsAddProgress(const class FString& Name_0, const int32 Value);
	void XAchievementsProcessFinishCampaign();
	void XAchievementsResetAll();
	void XAchievementsUpdateDebugAchievement(const int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerAchievements">();
	}
	static class UCustomConsoleManagerAchievements* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerAchievements>();
	}
};
static_assert(alignof(UCustomConsoleManagerAchievements) == 0x000008, "Wrong alignment on UCustomConsoleManagerAchievements");
static_assert(sizeof(UCustomConsoleManagerAchievements) == 0x0000A8, "Wrong size on UCustomConsoleManagerAchievements");

// Class Stalker2.AnimNotifyBase
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyBase : public UAnimNotify
{
public:
	ENotifyTriggerType                            NotifyTriggerType;                                 // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyBase">();
	}
	static class UAnimNotifyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyBase>();
	}
};
static_assert(alignof(UAnimNotifyBase) == 0x000008, "Wrong alignment on UAnimNotifyBase");
static_assert(sizeof(UAnimNotifyBase) == 0x000040, "Wrong size on UAnimNotifyBase");
static_assert(offsetof(UAnimNotifyBase, NotifyTriggerType) == 0x000038, "Member 'UAnimNotifyBase::NotifyTriggerType' has a wrong offset!");

// Class Stalker2.AnimNotify_DetachItemContextualAction
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify_DetachItemContextualAction final : public UAnimNotifyBase
{
public:
	TArray<struct FContextualItemDetachment>      ContextualItemAttachments;                         // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DetachItemContextualAction">();
	}
	static class UAnimNotify_DetachItemContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DetachItemContextualAction>();
	}
};
static_assert(alignof(UAnimNotify_DetachItemContextualAction) == 0x000008, "Wrong alignment on UAnimNotify_DetachItemContextualAction");
static_assert(sizeof(UAnimNotify_DetachItemContextualAction) == 0x000050, "Wrong size on UAnimNotify_DetachItemContextualAction");
static_assert(offsetof(UAnimNotify_DetachItemContextualAction, ContextualItemAttachments) == 0x000040, "Member 'UAnimNotify_DetachItemContextualAction::ContextualItemAttachments' has a wrong offset!");

// Class Stalker2.AbstractProgressBar
// 0x0010 (0x0288 - 0x0278)
class UAbstractProgressBar : public UWidgetBase
{
public:
	bool                                          bEnableStyleManager;                               // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressValue;                                     // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressStyleId;                                   // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetProgressValue(float InProgress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbstractProgressBar">();
	}
	static class UAbstractProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbstractProgressBar>();
	}
};
static_assert(alignof(UAbstractProgressBar) == 0x000008, "Wrong alignment on UAbstractProgressBar");
static_assert(sizeof(UAbstractProgressBar) == 0x000288, "Wrong size on UAbstractProgressBar");
static_assert(offsetof(UAbstractProgressBar, bEnableStyleManager) == 0x000278, "Member 'UAbstractProgressBar::bEnableStyleManager' has a wrong offset!");
static_assert(offsetof(UAbstractProgressBar, ProgressValue) == 0x00027C, "Member 'UAbstractProgressBar::ProgressValue' has a wrong offset!");
static_assert(offsetof(UAbstractProgressBar, ProgressStyleId) == 0x000280, "Member 'UAbstractProgressBar::ProgressStyleId' has a wrong offset!");

// Class Stalker2.SettingsPage
// 0x0018 (0x0290 - 0x0278)
class USettingsPage : public UWidgetBase
{
public:
	class UScrollBox*                             OptionsContainer;                                  // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESettingCategoryType                          Category;                                          // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0xF];                                      // 0x0281(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsPage">();
	}
	static class USettingsPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsPage>();
	}
};
static_assert(alignof(USettingsPage) == 0x000008, "Wrong alignment on USettingsPage");
static_assert(sizeof(USettingsPage) == 0x000290, "Wrong size on USettingsPage");
static_assert(offsetof(USettingsPage, OptionsContainer) == 0x000278, "Member 'USettingsPage::OptionsContainer' has a wrong offset!");
static_assert(offsetof(USettingsPage, Category) == 0x000280, "Member 'USettingsPage::Category' has a wrong offset!");

// Class Stalker2.InputProcessingUnit
// 0x0018 (0x0040 - 0x0028)
class UInputProcessingUnit : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInputBufferIPUStruct>          InputBuffer;                                       // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputProcessingUnit">();
	}
	static class UInputProcessingUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputProcessingUnit>();
	}
};
static_assert(alignof(UInputProcessingUnit) == 0x000008, "Wrong alignment on UInputProcessingUnit");
static_assert(sizeof(UInputProcessingUnit) == 0x000040, "Wrong size on UInputProcessingUnit");
static_assert(offsetof(UInputProcessingUnit, InputBuffer) == 0x000030, "Member 'UInputProcessingUnit::InputBuffer' has a wrong offset!");

// Class Stalker2.BehaviorBasedIPU
// 0x0018 (0x0058 - 0x0040)
class UBehaviorBasedIPU : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviorBasedIPU">();
	}
	static class UBehaviorBasedIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviorBasedIPU>();
	}
};
static_assert(alignof(UBehaviorBasedIPU) == 0x000008, "Wrong alignment on UBehaviorBasedIPU");
static_assert(sizeof(UBehaviorBasedIPU) == 0x000058, "Wrong size on UBehaviorBasedIPU");

// Class Stalker2.LadderSprintIPU
// 0x0000 (0x0058 - 0x0058)
class ULadderSprintIPU final : public UBehaviorBasedIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderSprintIPU">();
	}
	static class ULadderSprintIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULadderSprintIPU>();
	}
};
static_assert(alignof(ULadderSprintIPU) == 0x000008, "Wrong alignment on ULadderSprintIPU");
static_assert(sizeof(ULadderSprintIPU) == 0x000058, "Wrong size on ULadderSprintIPU");

// Class Stalker2.AccessibilitySettingsWidget
// 0x0008 (0x0298 - 0x0290)
class UAccessibilitySettingsWidget final : public USettingsPage
{
public:
	class USettingElementSwitcher*                ColorBlindness;                                    // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AccessibilitySettingsWidget">();
	}
	static class UAccessibilitySettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAccessibilitySettingsWidget>();
	}
};
static_assert(alignof(UAccessibilitySettingsWidget) == 0x000008, "Wrong alignment on UAccessibilitySettingsWidget");
static_assert(sizeof(UAccessibilitySettingsWidget) == 0x000298, "Wrong size on UAccessibilitySettingsWidget");
static_assert(offsetof(UAccessibilitySettingsWidget, ColorBlindness) == 0x000290, "Member 'UAccessibilitySettingsWidget::ColorBlindness' has a wrong offset!");

// Class Stalker2.AnimInstanceBase
// 0x0090 (0x0400 - 0x0370)
class UAnimInstanceBase : public UAnimInstance
{
public:
	uint8                                         Pad_368[0x30];                                     // 0x0368(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AObj>                    Owner;                                             // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class USkeletalMeshComponent>  SkeletalMeshComponent;                             // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          DummyAnimation;                                    // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 DummyBlueprint;                                    // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x48];                                     // 0x03B8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceBase">();
	}
	static class UAnimInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceBase>();
	}
};
static_assert(alignof(UAnimInstanceBase) == 0x000010, "Wrong alignment on UAnimInstanceBase");
static_assert(sizeof(UAnimInstanceBase) == 0x000400, "Wrong size on UAnimInstanceBase");
static_assert(offsetof(UAnimInstanceBase, Owner) == 0x000398, "Member 'UAnimInstanceBase::Owner' has a wrong offset!");
static_assert(offsetof(UAnimInstanceBase, SkeletalMeshComponent) == 0x0003A0, "Member 'UAnimInstanceBase::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UAnimInstanceBase, DummyAnimation) == 0x0003A8, "Member 'UAnimInstanceBase::DummyAnimation' has a wrong offset!");
static_assert(offsetof(UAnimInstanceBase, DummyBlueprint) == 0x0003B0, "Member 'UAnimInstanceBase::DummyBlueprint' has a wrong offset!");

// Class Stalker2.AnimInstanceCodelock
// 0x0010 (0x0410 - 0x0400)
class UAnimInstanceCodelock final : public UAnimInstanceBase
{
public:
	class UPlayerCodelockAnimCollection*          CodelockAnimCollection;                            // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceCodelock">();
	}
	static class UAnimInstanceCodelock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceCodelock>();
	}
};
static_assert(alignof(UAnimInstanceCodelock) == 0x000010, "Wrong alignment on UAnimInstanceCodelock");
static_assert(sizeof(UAnimInstanceCodelock) == 0x000410, "Wrong size on UAnimInstanceCodelock");
static_assert(offsetof(UAnimInstanceCodelock, CodelockAnimCollection) == 0x000400, "Member 'UAnimInstanceCodelock::CodelockAnimCollection' has a wrong offset!");

// Class Stalker2.RightClickMenuItemWidget
// 0x00B0 (0x0328 - 0x0278)
class URightClickMenuItemWidget final : public UUserWidget
{
public:
	class UButton*                                ButtonClick;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            Label;                                             // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 UnhoveredBackground;                               // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 HoveredBackground;                                 // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           TextColorHovered;                                  // 0x0298(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           TextColorUnhovered;                                // 0x02A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                MenuItemWidgetClass;                               // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x68];                                     // 0x02C0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonClick();
	void OnButtonHovered();
	void OnButtonUnHovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RightClickMenuItemWidget">();
	}
	static class URightClickMenuItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URightClickMenuItemWidget>();
	}
};
static_assert(alignof(URightClickMenuItemWidget) == 0x000008, "Wrong alignment on URightClickMenuItemWidget");
static_assert(sizeof(URightClickMenuItemWidget) == 0x000328, "Wrong size on URightClickMenuItemWidget");
static_assert(offsetof(URightClickMenuItemWidget, ButtonClick) == 0x000278, "Member 'URightClickMenuItemWidget::ButtonClick' has a wrong offset!");
static_assert(offsetof(URightClickMenuItemWidget, Label) == 0x000280, "Member 'URightClickMenuItemWidget::Label' has a wrong offset!");
static_assert(offsetof(URightClickMenuItemWidget, UnhoveredBackground) == 0x000288, "Member 'URightClickMenuItemWidget::UnhoveredBackground' has a wrong offset!");
static_assert(offsetof(URightClickMenuItemWidget, HoveredBackground) == 0x000290, "Member 'URightClickMenuItemWidget::HoveredBackground' has a wrong offset!");
static_assert(offsetof(URightClickMenuItemWidget, TextColorHovered) == 0x000298, "Member 'URightClickMenuItemWidget::TextColorHovered' has a wrong offset!");
static_assert(offsetof(URightClickMenuItemWidget, TextColorUnhovered) == 0x0002A8, "Member 'URightClickMenuItemWidget::TextColorUnhovered' has a wrong offset!");
static_assert(offsetof(URightClickMenuItemWidget, MenuItemWidgetClass) == 0x0002B8, "Member 'URightClickMenuItemWidget::MenuItemWidgetClass' has a wrong offset!");

// Class Stalker2.AnimNotify_LookAt
// 0x00E8 (0x0128 - 0x0040)
class UAnimNotify_LookAt final : public UAnimNotifyBase
{
public:
	ELookAtAction                                 LookAtAction;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELookAtOwnerState                             LookAtOwnerState;                                  // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttractionPointType                          AttractionPointType;                               // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtPlayer;                                     // 0x0043(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LookAtPlaceholderQuestGuid;                        // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LookAtActorFName;                                  // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactionTime;                                      // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EApplyRestrictionType                         ApplyRestrictionType;                              // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ERotationPartType, struct FBodyPartRestriction> HorizontalRestrictions;                     // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TMap<ERotationPartType, struct FBodyPartRestriction> VerticalRestrictions;                       // 0x00D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_LookAt">();
	}
	static class UAnimNotify_LookAt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_LookAt>();
	}
};
static_assert(alignof(UAnimNotify_LookAt) == 0x000008, "Wrong alignment on UAnimNotify_LookAt");
static_assert(sizeof(UAnimNotify_LookAt) == 0x000128, "Wrong size on UAnimNotify_LookAt");
static_assert(offsetof(UAnimNotify_LookAt, LookAtAction) == 0x000040, "Member 'UAnimNotify_LookAt::LookAtAction' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LookAt, LookAtOwnerState) == 0x000041, "Member 'UAnimNotify_LookAt::LookAtOwnerState' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LookAt, AttractionPointType) == 0x000042, "Member 'UAnimNotify_LookAt::AttractionPointType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LookAt, bLookAtPlayer) == 0x000043, "Member 'UAnimNotify_LookAt::bLookAtPlayer' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LookAt, LookAtPlaceholderQuestGuid) == 0x000044, "Member 'UAnimNotify_LookAt::LookAtPlaceholderQuestGuid' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LookAt, LookAtActorFName) == 0x00004C, "Member 'UAnimNotify_LookAt::LookAtActorFName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LookAt, TargetLocation) == 0x000058, "Member 'UAnimNotify_LookAt::TargetLocation' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LookAt, BoneName) == 0x000070, "Member 'UAnimNotify_LookAt::BoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LookAt, ReactionTime) == 0x000078, "Member 'UAnimNotify_LookAt::ReactionTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LookAt, Priority) == 0x00007C, "Member 'UAnimNotify_LookAt::Priority' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LookAt, CollisionChannel) == 0x000080, "Member 'UAnimNotify_LookAt::CollisionChannel' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LookAt, ApplyRestrictionType) == 0x000081, "Member 'UAnimNotify_LookAt::ApplyRestrictionType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LookAt, HorizontalRestrictions) == 0x000088, "Member 'UAnimNotify_LookAt::HorizontalRestrictions' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LookAt, VerticalRestrictions) == 0x0000D8, "Member 'UAnimNotify_LookAt::VerticalRestrictions' has a wrong offset!");

// Class Stalker2.TickBudgetSettings
// 0x0078 (0x00B0 - 0x0038)
class UTickBudgetSettings final : public UDeveloperSettings
{
public:
	struct FTimeBudget                            TimeBudget;                                        // 0x0038(0x0030)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FInitialCollectionSize                 InitialCollectionSize;                             // 0x0068(0x0048)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TickBudgetSettings">();
	}
	static class UTickBudgetSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTickBudgetSettings>();
	}
};
static_assert(alignof(UTickBudgetSettings) == 0x000008, "Wrong alignment on UTickBudgetSettings");
static_assert(sizeof(UTickBudgetSettings) == 0x0000B0, "Wrong size on UTickBudgetSettings");
static_assert(offsetof(UTickBudgetSettings, TimeBudget) == 0x000038, "Member 'UTickBudgetSettings::TimeBudget' has a wrong offset!");
static_assert(offsetof(UTickBudgetSettings, InitialCollectionSize) == 0x000068, "Member 'UTickBudgetSettings::InitialCollectionSize' has a wrong offset!");

// Class Stalker2.AchievementManager
// 0x00C0 (0x0138 - 0x0078)
class UAchievementManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FUserAchievements> UsersToProgress;                                   // 0x0080(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FUserAchievements                      DefaultUserAchievements;                           // 0x00D0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementManager">();
	}
	static class UAchievementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementManager>();
	}
};
static_assert(alignof(UAchievementManager) == 0x000008, "Wrong alignment on UAchievementManager");
static_assert(sizeof(UAchievementManager) == 0x000138, "Wrong size on UAchievementManager");
static_assert(offsetof(UAchievementManager, UsersToProgress) == 0x000080, "Member 'UAchievementManager::UsersToProgress' has a wrong offset!");
static_assert(offsetof(UAchievementManager, DefaultUserAchievements) == 0x0000D0, "Member 'UAchievementManager::DefaultUserAchievements' has a wrong offset!");

// Class Stalker2.AchievementTracker
// 0x0010 (0x0038 - 0x0028)
class UAchievementTracker : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker">();
	}
	static class UAchievementTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker>();
	}
};
static_assert(alignof(UAchievementTracker) == 0x000008, "Wrong alignment on UAchievementTracker");
static_assert(sizeof(UAchievementTracker) == 0x000038, "Wrong size on UAchievementTracker");

// Class Stalker2.LastSaveTimeMenuWidget
// 0x0018 (0x0290 - 0x0278)
class ULastSaveTimeMenuWidget final : public UWidgetBase
{
public:
	class UTextWidget*                            Timestamp;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DateFormat;                                        // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LastSaveTimeMenuWidget">();
	}
	static class ULastSaveTimeMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULastSaveTimeMenuWidget>();
	}
};
static_assert(alignof(ULastSaveTimeMenuWidget) == 0x000008, "Wrong alignment on ULastSaveTimeMenuWidget");
static_assert(sizeof(ULastSaveTimeMenuWidget) == 0x000290, "Wrong size on ULastSaveTimeMenuWidget");
static_assert(offsetof(ULastSaveTimeMenuWidget, Timestamp) == 0x000278, "Member 'ULastSaveTimeMenuWidget::Timestamp' has a wrong offset!");
static_assert(offsetof(ULastSaveTimeMenuWidget, DateFormat) == 0x000280, "Member 'ULastSaveTimeMenuWidget::DateFormat' has a wrong offset!");

// Class Stalker2.AchievementTracker_Debug
// 0x0008 (0x0040 - 0x0038)
class UAchievementTracker_Debug final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_Debug">();
	}
	static class UAchievementTracker_Debug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_Debug>();
	}
};
static_assert(alignof(UAchievementTracker_Debug) == 0x000008, "Wrong alignment on UAchievementTracker_Debug");
static_assert(sizeof(UAchievementTracker_Debug) == 0x000040, "Wrong size on UAchievementTracker_Debug");

// Class Stalker2.RazerChromaCinematicEventTracker
// 0x0058 (0x0080 - 0x0028)
class URazerChromaCinematicEventTracker final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class URazerChromaSubsystem*                  Subsystem;                                         // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RazerChromaCinematicEventTracker">();
	}
	static class URazerChromaCinematicEventTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<URazerChromaCinematicEventTracker>();
	}
};
static_assert(alignof(URazerChromaCinematicEventTracker) == 0x000008, "Wrong alignment on URazerChromaCinematicEventTracker");
static_assert(sizeof(URazerChromaCinematicEventTracker) == 0x000080, "Wrong size on URazerChromaCinematicEventTracker");
static_assert(offsetof(URazerChromaCinematicEventTracker, Subsystem) == 0x000078, "Member 'URazerChromaCinematicEventTracker::Subsystem' has a wrong offset!");

// Class Stalker2.AnimInstanceHumanFirearm
// 0x0290 (0x0690 - 0x0400)
class UAnimInstanceHumanFirearm final : public UAnimInstanceBase
{
public:
	class UHumanFirearmAnimCollection*            WeaponAnimCollection;                              // 0x0400(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        WeaponAnimCollectionAsset;                         // 0x0408(0x0020)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHumanFirearmAnimCollection*            ZombieWeaponAnimCollection;                        // 0x0428(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        ZombieWeaponAnimCollectionAsset;                   // 0x0430(0x0020)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimHumanWeaponConfig                 WeaponConfig;                                      // 0x0450(0x0020)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimHumanWeaponConfig                 RelaxedWeaponConfig;                               // 0x0470(0x0020)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimHumanAimingData                   AimingData;                                        // 0x0490(0x0001)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_491[0xF];                                      // 0x0491(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimPoseSearchLocomotionData          PoseSearchLocomotionData;                          // 0x04A0(0x01D0)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsZombie;                                         // 0x0670(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsingSmartCoverAnimPose;                          // 0x0671(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESmartCoverType                               SmartCoverType;                                    // 0x0672(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_673[0x1D];                                     // 0x0673(0x001D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceHumanFirearm">();
	}
	static class UAnimInstanceHumanFirearm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceHumanFirearm>();
	}
};
static_assert(alignof(UAnimInstanceHumanFirearm) == 0x000010, "Wrong alignment on UAnimInstanceHumanFirearm");
static_assert(sizeof(UAnimInstanceHumanFirearm) == 0x000690, "Wrong size on UAnimInstanceHumanFirearm");
static_assert(offsetof(UAnimInstanceHumanFirearm, WeaponAnimCollection) == 0x000400, "Member 'UAnimInstanceHumanFirearm::WeaponAnimCollection' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHumanFirearm, WeaponAnimCollectionAsset) == 0x000408, "Member 'UAnimInstanceHumanFirearm::WeaponAnimCollectionAsset' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHumanFirearm, ZombieWeaponAnimCollection) == 0x000428, "Member 'UAnimInstanceHumanFirearm::ZombieWeaponAnimCollection' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHumanFirearm, ZombieWeaponAnimCollectionAsset) == 0x000430, "Member 'UAnimInstanceHumanFirearm::ZombieWeaponAnimCollectionAsset' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHumanFirearm, WeaponConfig) == 0x000450, "Member 'UAnimInstanceHumanFirearm::WeaponConfig' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHumanFirearm, RelaxedWeaponConfig) == 0x000470, "Member 'UAnimInstanceHumanFirearm::RelaxedWeaponConfig' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHumanFirearm, AimingData) == 0x000490, "Member 'UAnimInstanceHumanFirearm::AimingData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHumanFirearm, PoseSearchLocomotionData) == 0x0004A0, "Member 'UAnimInstanceHumanFirearm::PoseSearchLocomotionData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHumanFirearm, bIsZombie) == 0x000670, "Member 'UAnimInstanceHumanFirearm::bIsZombie' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHumanFirearm, bUsingSmartCoverAnimPose) == 0x000671, "Member 'UAnimInstanceHumanFirearm::bUsingSmartCoverAnimPose' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHumanFirearm, SmartCoverType) == 0x000672, "Member 'UAnimInstanceHumanFirearm::SmartCoverType' has a wrong offset!");

// Class Stalker2.AchievementTrigger
// 0x0018 (0x02B0 - 0x0298)
class AAchievementTrigger final : public AActor
{
public:
	class UBoxComponent*                          TriggerArea;                                       // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AchievementSID;                                    // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTrigger">();
	}
	static class AAchievementTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAchievementTrigger>();
	}
};
static_assert(alignof(AAchievementTrigger) == 0x000008, "Wrong alignment on AAchievementTrigger");
static_assert(sizeof(AAchievementTrigger) == 0x0002B0, "Wrong size on AAchievementTrigger");
static_assert(offsetof(AAchievementTrigger, TriggerArea) == 0x000298, "Member 'AAchievementTrigger::TriggerArea' has a wrong offset!");
static_assert(offsetof(AAchievementTrigger, AchievementSID) == 0x0002A0, "Member 'AAchievementTrigger::AchievementSID' has a wrong offset!");

// Class Stalker2.ActionBlockerConditionBase
// 0x0000 (0x0028 - 0x0028)
class UActionBlockerConditionBase : public UObject
{
public:
	bool CanTrigger() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionBlockerConditionBase">();
	}
	static class UActionBlockerConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionBlockerConditionBase>();
	}
};
static_assert(alignof(UActionBlockerConditionBase) == 0x000008, "Wrong alignment on UActionBlockerConditionBase");
static_assert(sizeof(UActionBlockerConditionBase) == 0x000028, "Wrong size on UActionBlockerConditionBase");

// Class Stalker2.LookAtRestrictionsDataAsset
// 0x0088 (0x00B8 - 0x0030)
class ULookAtRestrictionsDataAsset final : public UDataAsset
{
public:
	struct FRestrictionsMap                       DefaultRestrictions;                               // 0x0030(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TMap<ELookAtOwnerState, struct FRestrictionsMap> Restrictions;                                   // 0x0068(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtRestrictionsDataAsset">();
	}
	static class ULookAtRestrictionsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtRestrictionsDataAsset>();
	}
};
static_assert(alignof(ULookAtRestrictionsDataAsset) == 0x000008, "Wrong alignment on ULookAtRestrictionsDataAsset");
static_assert(sizeof(ULookAtRestrictionsDataAsset) == 0x0000B8, "Wrong size on ULookAtRestrictionsDataAsset");
static_assert(offsetof(ULookAtRestrictionsDataAsset, DefaultRestrictions) == 0x000030, "Member 'ULookAtRestrictionsDataAsset::DefaultRestrictions' has a wrong offset!");
static_assert(offsetof(ULookAtRestrictionsDataAsset, Restrictions) == 0x000068, "Member 'ULookAtRestrictionsDataAsset::Restrictions' has a wrong offset!");

// Class Stalker2.PsyNPCComponent
// 0x0038 (0x00D8 - 0x00A0)
class UPsyNPCComponent final : public UActorComponent
{
public:
	class UCurveFloat*                            DissolveCurve;                                     // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            GroomCurve;                                        // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DissolveTime;                                      // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0x24];                                      // 0x00B4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsyNPCComponent">();
	}
	static class UPsyNPCComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsyNPCComponent>();
	}
};
static_assert(alignof(UPsyNPCComponent) == 0x000008, "Wrong alignment on UPsyNPCComponent");
static_assert(sizeof(UPsyNPCComponent) == 0x0000D8, "Wrong size on UPsyNPCComponent");
static_assert(offsetof(UPsyNPCComponent, DissolveCurve) == 0x0000A0, "Member 'UPsyNPCComponent::DissolveCurve' has a wrong offset!");
static_assert(offsetof(UPsyNPCComponent, GroomCurve) == 0x0000A8, "Member 'UPsyNPCComponent::GroomCurve' has a wrong offset!");
static_assert(offsetof(UPsyNPCComponent, DissolveTime) == 0x0000B0, "Member 'UPsyNPCComponent::DissolveTime' has a wrong offset!");

// Class Stalker2.ActionMimicButton
// 0x0038 (0x02B0 - 0x0278)
class UActionMimicButton : public UWidgetBase
{
public:
	bool                                          bInitializeAutomatically;                          // 0x0278(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActionMimicSettings                   MimicSettings;                                     // 0x027C(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                ButtonElement;                                     // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputAction;                                       // 0x0298(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputTrigger*                          InputTrigger;                                      // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMouseButtonPressed();
	void OnMouseButtonReleased();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionMimicButton">();
	}
	static class UActionMimicButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionMimicButton>();
	}
};
static_assert(alignof(UActionMimicButton) == 0x000008, "Wrong alignment on UActionMimicButton");
static_assert(sizeof(UActionMimicButton) == 0x0002B0, "Wrong size on UActionMimicButton");
static_assert(offsetof(UActionMimicButton, bInitializeAutomatically) == 0x000278, "Member 'UActionMimicButton::bInitializeAutomatically' has a wrong offset!");
static_assert(offsetof(UActionMimicButton, MimicSettings) == 0x00027C, "Member 'UActionMimicButton::MimicSettings' has a wrong offset!");
static_assert(offsetof(UActionMimicButton, ButtonElement) == 0x000290, "Member 'UActionMimicButton::ButtonElement' has a wrong offset!");
static_assert(offsetof(UActionMimicButton, InputAction) == 0x000298, "Member 'UActionMimicButton::InputAction' has a wrong offset!");
static_assert(offsetof(UActionMimicButton, InputTrigger) == 0x0002A0, "Member 'UActionMimicButton::InputTrigger' has a wrong offset!");

// Class Stalker2.LeanRightIPU
// 0x0000 (0x0058 - 0x0058)
class ULeanRightIPU final : public UBehaviorBasedIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeanRightIPU">();
	}
	static class ULeanRightIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeanRightIPU>();
	}
};
static_assert(alignof(ULeanRightIPU) == 0x000008, "Wrong alignment on ULeanRightIPU");
static_assert(sizeof(ULeanRightIPU) == 0x000058, "Wrong size on ULeanRightIPU");

// Class Stalker2.ActorEyesCameraActor
// 0x0020 (0x0A00 - 0x09E0)
class AActorEyesCameraActor final : public ACameraActor
{
public:
	uint8                                         Pad_9E0[0x20];                                     // 0x09E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorEyesCameraActor">();
	}
	static class AActorEyesCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActorEyesCameraActor>();
	}
};
static_assert(alignof(AActorEyesCameraActor) == 0x000010, "Wrong alignment on AActorEyesCameraActor");
static_assert(sizeof(AActorEyesCameraActor) == 0x000A00, "Wrong size on AActorEyesCameraActor");

// Class Stalker2.SettingElement
// 0x1B08 (0x1D80 - 0x0278)
class USettingElement : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldHideOnShipping;                             // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldHideOnPresentation;                         // 0x0291(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_292[0x2];                                      // 0x0292(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HoveredTextStyle;                                  // 0x0294(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TextStyle;                                         // 0x029C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Background;                                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             HoveredBackground;                                 // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             UnhoveredBackground;                               // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FButtonStyle                           HoveredArrow;                                      // 0x02C0(0x0470)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FButtonStyle                           UnHoveredArrow;                                    // 0x0730(0x0470)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FProgressBarStyle                      HoveredSlider;                                     // 0x0BA0(0x02F0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FProgressBarStyle                      UnHoveredSlider;                                   // 0x0E90(0x02F0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSliderStyle                           HoveredThumbSlider;                                // 0x1180(0x05C0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSliderStyle                           UnHoveredThumbSlider;                              // 0x1740(0x05C0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTextWidget*                            NameText;                                          // 0x1D00(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            ValueText;                                         // 0x1D08(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                LeftButton;                                        // 0x1D10(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                RightButton;                                       // 0x1D18(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                LeftButtonImage;                                   // 0x1D20(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                RightButtonImage;                                  // 0x1D28(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar;                                       // 0x1D30(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USlider*                                Slider;                                            // 0x1D38(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 NameLocSID;                                        // 0x1D40(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DescriptionLocSID;                                 // 0x1D50(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USettingElement*>                WidgetDependencies;                                // 0x1D60(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	EInputTypeForButtons                          InputTypeToDisplayButton;                          // 0x1D70(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D71[0x1];                                     // 0x1D71(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSpecialButton;                                  // 0x1D72(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D73[0x5];                                     // 0x1D73(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USettingsMenuSubView*                   Settings;                                          // 0x1D78(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnLeftButtonClicked();
	void OnRightButtonClicked();

	bool GetIsEnabledElement() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingElement">();
	}
	static class USettingElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingElement>();
	}
};
static_assert(alignof(USettingElement) == 0x000010, "Wrong alignment on USettingElement");
static_assert(sizeof(USettingElement) == 0x001D80, "Wrong size on USettingElement");
static_assert(offsetof(USettingElement, bShouldHideOnShipping) == 0x000290, "Member 'USettingElement::bShouldHideOnShipping' has a wrong offset!");
static_assert(offsetof(USettingElement, bShouldHideOnPresentation) == 0x000291, "Member 'USettingElement::bShouldHideOnPresentation' has a wrong offset!");
static_assert(offsetof(USettingElement, HoveredTextStyle) == 0x000294, "Member 'USettingElement::HoveredTextStyle' has a wrong offset!");
static_assert(offsetof(USettingElement, TextStyle) == 0x00029C, "Member 'USettingElement::TextStyle' has a wrong offset!");
static_assert(offsetof(USettingElement, Background) == 0x0002A8, "Member 'USettingElement::Background' has a wrong offset!");
static_assert(offsetof(USettingElement, HoveredBackground) == 0x0002B0, "Member 'USettingElement::HoveredBackground' has a wrong offset!");
static_assert(offsetof(USettingElement, UnhoveredBackground) == 0x0002B8, "Member 'USettingElement::UnhoveredBackground' has a wrong offset!");
static_assert(offsetof(USettingElement, HoveredArrow) == 0x0002C0, "Member 'USettingElement::HoveredArrow' has a wrong offset!");
static_assert(offsetof(USettingElement, UnHoveredArrow) == 0x000730, "Member 'USettingElement::UnHoveredArrow' has a wrong offset!");
static_assert(offsetof(USettingElement, HoveredSlider) == 0x000BA0, "Member 'USettingElement::HoveredSlider' has a wrong offset!");
static_assert(offsetof(USettingElement, UnHoveredSlider) == 0x000E90, "Member 'USettingElement::UnHoveredSlider' has a wrong offset!");
static_assert(offsetof(USettingElement, HoveredThumbSlider) == 0x001180, "Member 'USettingElement::HoveredThumbSlider' has a wrong offset!");
static_assert(offsetof(USettingElement, UnHoveredThumbSlider) == 0x001740, "Member 'USettingElement::UnHoveredThumbSlider' has a wrong offset!");
static_assert(offsetof(USettingElement, NameText) == 0x001D00, "Member 'USettingElement::NameText' has a wrong offset!");
static_assert(offsetof(USettingElement, ValueText) == 0x001D08, "Member 'USettingElement::ValueText' has a wrong offset!");
static_assert(offsetof(USettingElement, LeftButton) == 0x001D10, "Member 'USettingElement::LeftButton' has a wrong offset!");
static_assert(offsetof(USettingElement, RightButton) == 0x001D18, "Member 'USettingElement::RightButton' has a wrong offset!");
static_assert(offsetof(USettingElement, LeftButtonImage) == 0x001D20, "Member 'USettingElement::LeftButtonImage' has a wrong offset!");
static_assert(offsetof(USettingElement, RightButtonImage) == 0x001D28, "Member 'USettingElement::RightButtonImage' has a wrong offset!");
static_assert(offsetof(USettingElement, ProgressBar) == 0x001D30, "Member 'USettingElement::ProgressBar' has a wrong offset!");
static_assert(offsetof(USettingElement, Slider) == 0x001D38, "Member 'USettingElement::Slider' has a wrong offset!");
static_assert(offsetof(USettingElement, NameLocSID) == 0x001D40, "Member 'USettingElement::NameLocSID' has a wrong offset!");
static_assert(offsetof(USettingElement, DescriptionLocSID) == 0x001D50, "Member 'USettingElement::DescriptionLocSID' has a wrong offset!");
static_assert(offsetof(USettingElement, WidgetDependencies) == 0x001D60, "Member 'USettingElement::WidgetDependencies' has a wrong offset!");
static_assert(offsetof(USettingElement, InputTypeToDisplayButton) == 0x001D70, "Member 'USettingElement::InputTypeToDisplayButton' has a wrong offset!");
static_assert(offsetof(USettingElement, bIsSpecialButton) == 0x001D72, "Member 'USettingElement::bIsSpecialButton' has a wrong offset!");
static_assert(offsetof(USettingElement, Settings) == 0x001D78, "Member 'USettingElement::Settings' has a wrong offset!");

// Class Stalker2.AnimNotify_PlayFacialAnimationContextualAction
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify_PlayFacialAnimationContextualAction final : public UAnimNotifyBase
{
public:
	TArray<struct FWeightedFacialAnimation>       FacialAnimations;                                  // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayFacialAnimationContextualAction">();
	}
	static class UAnimNotify_PlayFacialAnimationContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayFacialAnimationContextualAction>();
	}
};
static_assert(alignof(UAnimNotify_PlayFacialAnimationContextualAction) == 0x000008, "Wrong alignment on UAnimNotify_PlayFacialAnimationContextualAction");
static_assert(sizeof(UAnimNotify_PlayFacialAnimationContextualAction) == 0x000050, "Wrong size on UAnimNotify_PlayFacialAnimationContextualAction");
static_assert(offsetof(UAnimNotify_PlayFacialAnimationContextualAction, FacialAnimations) == 0x000040, "Member 'UAnimNotify_PlayFacialAnimationContextualAction::FacialAnimations' has a wrong offset!");

// Class Stalker2.VoiceModulatorControllerSubsystem
// 0x0010 (0x0040 - 0x0030)
class UVoiceModulatorControllerSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoiceModulatorControllerSubsystem">();
	}
	static class UVoiceModulatorControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoiceModulatorControllerSubsystem>();
	}
};
static_assert(alignof(UVoiceModulatorControllerSubsystem) == 0x000008, "Wrong alignment on UVoiceModulatorControllerSubsystem");
static_assert(sizeof(UVoiceModulatorControllerSubsystem) == 0x000040, "Wrong size on UVoiceModulatorControllerSubsystem");

// Class Stalker2.ActorInteractionDataInterface
// 0x0000 (0x0000 - 0x0000)
class IActorInteractionDataInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorInteractionDataInterface">();
	}
	static class IActorInteractionDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IActorInteractionDataInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IActorInteractionDataInterface) == 0x000001, "Wrong alignment on IActorInteractionDataInterface");
static_assert(sizeof(IActorInteractionDataInterface) == 0x000001, "Wrong size on IActorInteractionDataInterface");

// Class Stalker2.ModelCharacter
// 0x0010 (0x0640 - 0x0630)
class AModelCharacter : public ACharacter
{
public:
	uint8                                         Pad_628[0x18];                                     // 0x0628(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModelCharacter">();
	}
	static class AModelCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AModelCharacter>();
	}
};
static_assert(alignof(AModelCharacter) == 0x000010, "Wrong alignment on AModelCharacter");
static_assert(sizeof(AModelCharacter) == 0x000640, "Wrong size on AModelCharacter");

// Class Stalker2.LightningBallNavigationComponent
// 0x0088 (0x0128 - 0x00A0)
class ULightningBallNavigationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x88];                                      // 0x00A0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightningBallNavigationComponent">();
	}
	static class ULightningBallNavigationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightningBallNavigationComponent>();
	}
};
static_assert(alignof(ULightningBallNavigationComponent) == 0x000008, "Wrong alignment on ULightningBallNavigationComponent");
static_assert(sizeof(ULightningBallNavigationComponent) == 0x000128, "Wrong size on ULightningBallNavigationComponent");

// Class Stalker2.AnimNotify_ParkourCameraRelease
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_ParkourCameraRelease final : public UAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ParkourCameraRelease">();
	}
	static class UAnimNotify_ParkourCameraRelease* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ParkourCameraRelease>();
	}
};
static_assert(alignof(UAnimNotify_ParkourCameraRelease) == 0x000008, "Wrong alignment on UAnimNotify_ParkourCameraRelease");
static_assert(sizeof(UAnimNotify_ParkourCameraRelease) == 0x000040, "Wrong size on UAnimNotify_ParkourCameraRelease");

// Class Stalker2.UserMarkerSelectorButton
// 0x00C8 (0x0340 - 0x0278)
class UUserMarkerSelectorButton final : public UWidgetBase
{
public:
	EMarkerType                                   MarkerType;                                        // 0x0278(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMarkerPosition                               MarkerPosition;                                    // 0x0279(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A[0x26];                                     // 0x027A(0x0026)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HoverColorStyleID;                                 // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DisableHoverColorStyleID;                          // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   NotHoverColorStyleID;                              // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ButtonElement;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MarkerImage;                                       // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Background;                                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               RotationOverlay;                                   // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HoverOptionAnimation;                              // 0x02D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       SelectAnimation;                                   // 0x02E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SelectAnimationSpeedMultiplier;                    // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoverAnimationSpeedMultiplier;                     // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HideHoverAnimationSpeedMultiplier;                 // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HighlightDirectionParameterName;                   // 0x02F4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BackgroundImageParameterName;                      // 0x02FC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StartColorParameterName;                           // 0x0304(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FinishColorParameterName;                          // 0x030C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HoverColorParameterName;                           // 0x0314(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0x24];                                     // 0x031C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHoveredButtonElement();
	void OnPressedButtonElement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserMarkerSelectorButton">();
	}
	static class UUserMarkerSelectorButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserMarkerSelectorButton>();
	}
};
static_assert(alignof(UUserMarkerSelectorButton) == 0x000008, "Wrong alignment on UUserMarkerSelectorButton");
static_assert(sizeof(UUserMarkerSelectorButton) == 0x000340, "Wrong size on UUserMarkerSelectorButton");
static_assert(offsetof(UUserMarkerSelectorButton, MarkerType) == 0x000278, "Member 'UUserMarkerSelectorButton::MarkerType' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, MarkerPosition) == 0x000279, "Member 'UUserMarkerSelectorButton::MarkerPosition' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, HoverColorStyleID) == 0x0002A0, "Member 'UUserMarkerSelectorButton::HoverColorStyleID' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, DisableHoverColorStyleID) == 0x0002A8, "Member 'UUserMarkerSelectorButton::DisableHoverColorStyleID' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, NotHoverColorStyleID) == 0x0002B0, "Member 'UUserMarkerSelectorButton::NotHoverColorStyleID' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, ButtonElement) == 0x0002B8, "Member 'UUserMarkerSelectorButton::ButtonElement' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, MarkerImage) == 0x0002C0, "Member 'UUserMarkerSelectorButton::MarkerImage' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, Background) == 0x0002C8, "Member 'UUserMarkerSelectorButton::Background' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, RotationOverlay) == 0x0002D0, "Member 'UUserMarkerSelectorButton::RotationOverlay' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, HoverOptionAnimation) == 0x0002D8, "Member 'UUserMarkerSelectorButton::HoverOptionAnimation' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, SelectAnimation) == 0x0002E0, "Member 'UUserMarkerSelectorButton::SelectAnimation' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, SelectAnimationSpeedMultiplier) == 0x0002E8, "Member 'UUserMarkerSelectorButton::SelectAnimationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, HoverAnimationSpeedMultiplier) == 0x0002EC, "Member 'UUserMarkerSelectorButton::HoverAnimationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, HideHoverAnimationSpeedMultiplier) == 0x0002F0, "Member 'UUserMarkerSelectorButton::HideHoverAnimationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, HighlightDirectionParameterName) == 0x0002F4, "Member 'UUserMarkerSelectorButton::HighlightDirectionParameterName' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, BackgroundImageParameterName) == 0x0002FC, "Member 'UUserMarkerSelectorButton::BackgroundImageParameterName' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, StartColorParameterName) == 0x000304, "Member 'UUserMarkerSelectorButton::StartColorParameterName' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, FinishColorParameterName) == 0x00030C, "Member 'UUserMarkerSelectorButton::FinishColorParameterName' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelectorButton, HoverColorParameterName) == 0x000314, "Member 'UUserMarkerSelectorButton::HoverColorParameterName' has a wrong offset!");

// Class Stalker2.Obj
// 0x0310 (0x0950 - 0x0640)
class AObj : public AModelCharacter
{
public:
	uint8                                         Pad_640[0x160];                                    // 0x0640(0x0160)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemAppearanceComponent*               ItemAppearanceComponent;                           // 0x07A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPhysicalAnimationComponent*>    PhysicalAnimationComponents;                       // 0x07A8(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UWetnessComponent*                      WetnessComponent;                                  // 0x07B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class US2TargetMeleeSectorComponent*          MeleeSectorComponent;                              // 0x07C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C8[0x8];                                      // 0x07C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitBlocker>                    HitBlockers;                                       // 0x07D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UMovementComponentExt*                  MovementComponentExt;                              // 0x07E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicalAnimationComponent*            PhysicalAnimationComponent;                        // 0x07E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObjWaterContactController*             WaterContactController;                            // 0x07F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULaserSightComponent*                   LaserSightComponent;                               // 0x07F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveVector*                           FallingDamageCurve;                                // 0x0800(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          FallingDamageSound;                                // 0x0808(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         FallingDamageEasySoundSwitch;                      // 0x0810(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         FallingDamageMediumSoundSwitch;                    // 0x0818(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         FallingDamageHighSoundSwitch;                      // 0x0820(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCollisionProfileName                  CutsceneCollisionProfile;                          // 0x0828(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_830[0x18];                                     // 0x0830(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             AkComponentRetargetTable;                          // 0x0848(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_850[0x50];                                     // 0x0850(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UAttackComponent*                       AttackComponent;                                   // 0x08A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeadFlashlightComponent*               FlashlightComponent;                               // 0x08A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkAudioRootComponent;                              // 0x08B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkAudioHeadComponent;                              // 0x08B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkAudioPelvisComponent;                            // 0x08C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkAudioLeftHandComponent;                          // 0x08C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkAudioRightHandComponent;                         // 0x08D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkAudioComponent;                                  // 0x08D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ShootingParticle;                                  // 0x08E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      PostShootingParticle;                              // 0x08E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F0[0x60];                                     // 0x08F0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndCutsceneSequence();
	void OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void StartCutsceneSequence(const class AActor* SynchronizationPoint, const struct FRotator& OverrideRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Obj">();
	}
	static class AObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<AObj>();
	}
};
static_assert(alignof(AObj) == 0x000010, "Wrong alignment on AObj");
static_assert(sizeof(AObj) == 0x000950, "Wrong size on AObj");
static_assert(offsetof(AObj, ItemAppearanceComponent) == 0x0007A0, "Member 'AObj::ItemAppearanceComponent' has a wrong offset!");
static_assert(offsetof(AObj, PhysicalAnimationComponents) == 0x0007A8, "Member 'AObj::PhysicalAnimationComponents' has a wrong offset!");
static_assert(offsetof(AObj, WetnessComponent) == 0x0007B8, "Member 'AObj::WetnessComponent' has a wrong offset!");
static_assert(offsetof(AObj, MeleeSectorComponent) == 0x0007C0, "Member 'AObj::MeleeSectorComponent' has a wrong offset!");
static_assert(offsetof(AObj, HitBlockers) == 0x0007D0, "Member 'AObj::HitBlockers' has a wrong offset!");
static_assert(offsetof(AObj, MovementComponentExt) == 0x0007E0, "Member 'AObj::MovementComponentExt' has a wrong offset!");
static_assert(offsetof(AObj, PhysicalAnimationComponent) == 0x0007E8, "Member 'AObj::PhysicalAnimationComponent' has a wrong offset!");
static_assert(offsetof(AObj, WaterContactController) == 0x0007F0, "Member 'AObj::WaterContactController' has a wrong offset!");
static_assert(offsetof(AObj, LaserSightComponent) == 0x0007F8, "Member 'AObj::LaserSightComponent' has a wrong offset!");
static_assert(offsetof(AObj, FallingDamageCurve) == 0x000800, "Member 'AObj::FallingDamageCurve' has a wrong offset!");
static_assert(offsetof(AObj, FallingDamageSound) == 0x000808, "Member 'AObj::FallingDamageSound' has a wrong offset!");
static_assert(offsetof(AObj, FallingDamageEasySoundSwitch) == 0x000810, "Member 'AObj::FallingDamageEasySoundSwitch' has a wrong offset!");
static_assert(offsetof(AObj, FallingDamageMediumSoundSwitch) == 0x000818, "Member 'AObj::FallingDamageMediumSoundSwitch' has a wrong offset!");
static_assert(offsetof(AObj, FallingDamageHighSoundSwitch) == 0x000820, "Member 'AObj::FallingDamageHighSoundSwitch' has a wrong offset!");
static_assert(offsetof(AObj, CutsceneCollisionProfile) == 0x000828, "Member 'AObj::CutsceneCollisionProfile' has a wrong offset!");
static_assert(offsetof(AObj, AkComponentRetargetTable) == 0x000848, "Member 'AObj::AkComponentRetargetTable' has a wrong offset!");
static_assert(offsetof(AObj, AttackComponent) == 0x0008A0, "Member 'AObj::AttackComponent' has a wrong offset!");
static_assert(offsetof(AObj, FlashlightComponent) == 0x0008A8, "Member 'AObj::FlashlightComponent' has a wrong offset!");
static_assert(offsetof(AObj, AkAudioRootComponent) == 0x0008B0, "Member 'AObj::AkAudioRootComponent' has a wrong offset!");
static_assert(offsetof(AObj, AkAudioHeadComponent) == 0x0008B8, "Member 'AObj::AkAudioHeadComponent' has a wrong offset!");
static_assert(offsetof(AObj, AkAudioPelvisComponent) == 0x0008C0, "Member 'AObj::AkAudioPelvisComponent' has a wrong offset!");
static_assert(offsetof(AObj, AkAudioLeftHandComponent) == 0x0008C8, "Member 'AObj::AkAudioLeftHandComponent' has a wrong offset!");
static_assert(offsetof(AObj, AkAudioRightHandComponent) == 0x0008D0, "Member 'AObj::AkAudioRightHandComponent' has a wrong offset!");
static_assert(offsetof(AObj, AkAudioComponent) == 0x0008D8, "Member 'AObj::AkAudioComponent' has a wrong offset!");
static_assert(offsetof(AObj, ShootingParticle) == 0x0008E0, "Member 'AObj::ShootingParticle' has a wrong offset!");
static_assert(offsetof(AObj, PostShootingParticle) == 0x0008E8, "Member 'AObj::PostShootingParticle' has a wrong offset!");

// Class Stalker2.Agent
// 0x0200 (0x0B50 - 0x0950)
#pragma pack(push, 0x1)
class alignas(0x10) AAgent : public AObj
{
public:
	uint8                                         Pad_950[0x18];                                     // 0x0950(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsSoundsComponent*                PhysicsSoundsComponent;                            // 0x0968(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_970[0x40];                                     // 0x0970(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UNPCComponent*                          NPCComponent;                                      // 0x09B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsInteractionComponent*           PhysicsInteractionComponent;                       // 0x09B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWoundedHoldComponent*                  WoundedHoldComponent;                              // 0x09C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTouchComponent*                        TouchComponent;                                    // 0x09C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMotionWarpingComponent*                MotionWarpingComponent;                            // 0x09D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAITickComponent*                       AITickComponent;                                   // 0x09D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsControlComponent*               PhysicsControlComponent;                           // 0x09E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULODSyncComponent*                      LODSyncComponent;                                  // 0x09E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataLayerPhysicsComponent*             DataLayerPhysicsComponent;                         // 0x09F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDeadBody*                              DeadBodyComponent;                                 // 0x09F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDamageInteractVFXData                 DamageInteractVFXData;                             // 0x0A00(0x0010)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class FName                                   AttachDamageInteractVFXBoneName;                   // 0x0A10(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 CutsceneLookAtActor;                               // 0x0A18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Interp, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CutsceneEyesLookAtWeight;                          // 0x0A20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CutsceneHeadLookAtWeight;                          // 0x0A24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECutsceneBlinkProfile                         CutsceneBlinkProfile;                              // 0x0A28(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECutsceneEyesIdleProfile                      CutsceneEyesIdleProfile;                           // 0x0A29(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A2A[0x2];                                      // 0x0A2A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CutsceneProceduralEyesWeight;                      // 0x0A2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CutsceneProceduralEyesAmplitude;                   // 0x0A30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CutsceneProceduralEyesIntensity;                   // 0x0A34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GuaranteedRelevancyUpdateTime;                     // 0x0A38(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   RagdollProfileName;                                // 0x0A3C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   RagdollSelfCollisionProfileName;                   // 0x0A44(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4C[0x4];                                      // 0x0A4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RagdollBonesToOverlap;                             // 0x0A50(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A60[0x90];                                     // 0x0A60(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TWeakObjectPtr<class USceneComponent>>   SpawnInvisibilityWarmupAttachments;                // 0x0AF0(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B40[0x8];                                      // 0x0B40(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyDamageInteractParticle(class UNiagaraComponent* ParticleSystem);
	void PsyNPCInteractionStarted(class AObj* InteractActor);

	void Blink() const;
	ESpawnSource GetSpawnSource() const;
	void SetCutsceneBlinkProfile(ECutsceneBlinkProfile NewCutsceneBlinkProfile) const;
	void SetCutsceneEyesIdleProfile(ECutsceneEyesIdleProfile NewCutsceneEyesIdleProfile) const;
	void SetCutsceneEyesLookAtWeight(float Weight) const;
	void SetCutsceneHeadLookAtWeight(float Weight) const;
	void SetCutsceneLookAtActor(const class AActor* Value) const;
	void SetCutsceneProceduralEyesAmplitude(float Value) const;
	void SetCutsceneProceduralEyesIntensity(float Value) const;
	void SetCutsceneProceduralEyesWeight(float Value) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Agent">();
	}
	static class AAgent* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAgent>();
	}
};
#pragma pack(pop)
static_assert(alignof(AAgent) == 0x000010, "Wrong alignment on AAgent");
static_assert(sizeof(AAgent) == 0x000B50, "Wrong size on AAgent");
static_assert(offsetof(AAgent, PhysicsSoundsComponent) == 0x000968, "Member 'AAgent::PhysicsSoundsComponent' has a wrong offset!");
static_assert(offsetof(AAgent, NPCComponent) == 0x0009B0, "Member 'AAgent::NPCComponent' has a wrong offset!");
static_assert(offsetof(AAgent, PhysicsInteractionComponent) == 0x0009B8, "Member 'AAgent::PhysicsInteractionComponent' has a wrong offset!");
static_assert(offsetof(AAgent, WoundedHoldComponent) == 0x0009C0, "Member 'AAgent::WoundedHoldComponent' has a wrong offset!");
static_assert(offsetof(AAgent, TouchComponent) == 0x0009C8, "Member 'AAgent::TouchComponent' has a wrong offset!");
static_assert(offsetof(AAgent, MotionWarpingComponent) == 0x0009D0, "Member 'AAgent::MotionWarpingComponent' has a wrong offset!");
static_assert(offsetof(AAgent, AITickComponent) == 0x0009D8, "Member 'AAgent::AITickComponent' has a wrong offset!");
static_assert(offsetof(AAgent, PhysicsControlComponent) == 0x0009E0, "Member 'AAgent::PhysicsControlComponent' has a wrong offset!");
static_assert(offsetof(AAgent, LODSyncComponent) == 0x0009E8, "Member 'AAgent::LODSyncComponent' has a wrong offset!");
static_assert(offsetof(AAgent, DataLayerPhysicsComponent) == 0x0009F0, "Member 'AAgent::DataLayerPhysicsComponent' has a wrong offset!");
static_assert(offsetof(AAgent, DeadBodyComponent) == 0x0009F8, "Member 'AAgent::DeadBodyComponent' has a wrong offset!");
static_assert(offsetof(AAgent, DamageInteractVFXData) == 0x000A00, "Member 'AAgent::DamageInteractVFXData' has a wrong offset!");
static_assert(offsetof(AAgent, AttachDamageInteractVFXBoneName) == 0x000A10, "Member 'AAgent::AttachDamageInteractVFXBoneName' has a wrong offset!");
static_assert(offsetof(AAgent, CutsceneLookAtActor) == 0x000A18, "Member 'AAgent::CutsceneLookAtActor' has a wrong offset!");
static_assert(offsetof(AAgent, CutsceneEyesLookAtWeight) == 0x000A20, "Member 'AAgent::CutsceneEyesLookAtWeight' has a wrong offset!");
static_assert(offsetof(AAgent, CutsceneHeadLookAtWeight) == 0x000A24, "Member 'AAgent::CutsceneHeadLookAtWeight' has a wrong offset!");
static_assert(offsetof(AAgent, CutsceneBlinkProfile) == 0x000A28, "Member 'AAgent::CutsceneBlinkProfile' has a wrong offset!");
static_assert(offsetof(AAgent, CutsceneEyesIdleProfile) == 0x000A29, "Member 'AAgent::CutsceneEyesIdleProfile' has a wrong offset!");
static_assert(offsetof(AAgent, CutsceneProceduralEyesWeight) == 0x000A2C, "Member 'AAgent::CutsceneProceduralEyesWeight' has a wrong offset!");
static_assert(offsetof(AAgent, CutsceneProceduralEyesAmplitude) == 0x000A30, "Member 'AAgent::CutsceneProceduralEyesAmplitude' has a wrong offset!");
static_assert(offsetof(AAgent, CutsceneProceduralEyesIntensity) == 0x000A34, "Member 'AAgent::CutsceneProceduralEyesIntensity' has a wrong offset!");
static_assert(offsetof(AAgent, GuaranteedRelevancyUpdateTime) == 0x000A38, "Member 'AAgent::GuaranteedRelevancyUpdateTime' has a wrong offset!");
static_assert(offsetof(AAgent, RagdollProfileName) == 0x000A3C, "Member 'AAgent::RagdollProfileName' has a wrong offset!");
static_assert(offsetof(AAgent, RagdollSelfCollisionProfileName) == 0x000A44, "Member 'AAgent::RagdollSelfCollisionProfileName' has a wrong offset!");
static_assert(offsetof(AAgent, RagdollBonesToOverlap) == 0x000A50, "Member 'AAgent::RagdollBonesToOverlap' has a wrong offset!");
static_assert(offsetof(AAgent, SpawnInvisibilityWarmupAttachments) == 0x000AF0, "Member 'AAgent::SpawnInvisibilityWarmupAttachments' has a wrong offset!");

// Class Stalker2.AnimNotify_InteractAction
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_InteractAction final : public UAnimNotifyBase
{
public:
	EAnimInteractAction                           InteractAction;                                    // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_InteractAction">();
	}
	static class UAnimNotify_InteractAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_InteractAction>();
	}
};
static_assert(alignof(UAnimNotify_InteractAction) == 0x000008, "Wrong alignment on UAnimNotify_InteractAction");
static_assert(sizeof(UAnimNotify_InteractAction) == 0x000048, "Wrong size on UAnimNotify_InteractAction");
static_assert(offsetof(UAnimNotify_InteractAction, InteractAction) == 0x000040, "Member 'UAnimNotify_InteractAction::InteractAction' has a wrong offset!");

// Class Stalker2.AIConstraintSubsystem
// 0x0010 (0x0040 - 0x0030)
class UAIConstraintSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIConstraintSubsystem">();
	}
	static class UAIConstraintSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIConstraintSubsystem>();
	}
};
static_assert(alignof(UAIConstraintSubsystem) == 0x000008, "Wrong alignment on UAIConstraintSubsystem");
static_assert(sizeof(UAIConstraintSubsystem) == 0x000040, "Wrong size on UAIConstraintSubsystem");

// Class Stalker2.AICoreSubsystem
// 0x05E8 (0x0618 - 0x0030)
class UAICoreSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x5E8];                                     // 0x0030(0x05E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICoreSubsystem">();
	}
	static class UAICoreSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICoreSubsystem>();
	}
};
static_assert(alignof(UAICoreSubsystem) == 0x000008, "Wrong alignment on UAICoreSubsystem");
static_assert(sizeof(UAICoreSubsystem) == 0x000618, "Wrong size on UAICoreSubsystem");

// Class Stalker2.InputMappingSettingsPage
// 0x0060 (0x02F0 - 0x0290)
class UInputMappingSettingsPage : public USettingsPage
{
public:
	TSubclassOf<class USettingsCategory>          AnchorClass;                                       // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                AnchorPadding;                                     // 0x0298(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class USettingElementInput>       InputElementClass;                                 // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USettingElementBindedInput> BindedInputElementClass;                           // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                SettingElementPadding;                             // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMargin                                ToggleElementPadding;                              // 0x02C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class USettingsCategory*>              Anchors;                                           // 0x02D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UInputMappingSettingsModel*             InputMappingSettingsModel;                         // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputMappingSettingsPage">();
	}
	static class UInputMappingSettingsPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputMappingSettingsPage>();
	}
};
static_assert(alignof(UInputMappingSettingsPage) == 0x000008, "Wrong alignment on UInputMappingSettingsPage");
static_assert(sizeof(UInputMappingSettingsPage) == 0x0002F0, "Wrong size on UInputMappingSettingsPage");
static_assert(offsetof(UInputMappingSettingsPage, AnchorClass) == 0x000290, "Member 'UInputMappingSettingsPage::AnchorClass' has a wrong offset!");
static_assert(offsetof(UInputMappingSettingsPage, AnchorPadding) == 0x000298, "Member 'UInputMappingSettingsPage::AnchorPadding' has a wrong offset!");
static_assert(offsetof(UInputMappingSettingsPage, InputElementClass) == 0x0002A8, "Member 'UInputMappingSettingsPage::InputElementClass' has a wrong offset!");
static_assert(offsetof(UInputMappingSettingsPage, BindedInputElementClass) == 0x0002B0, "Member 'UInputMappingSettingsPage::BindedInputElementClass' has a wrong offset!");
static_assert(offsetof(UInputMappingSettingsPage, SettingElementPadding) == 0x0002B8, "Member 'UInputMappingSettingsPage::SettingElementPadding' has a wrong offset!");
static_assert(offsetof(UInputMappingSettingsPage, ToggleElementPadding) == 0x0002C8, "Member 'UInputMappingSettingsPage::ToggleElementPadding' has a wrong offset!");
static_assert(offsetof(UInputMappingSettingsPage, Anchors) == 0x0002D8, "Member 'UInputMappingSettingsPage::Anchors' has a wrong offset!");
static_assert(offsetof(UInputMappingSettingsPage, InputMappingSettingsModel) == 0x0002E8, "Member 'UInputMappingSettingsPage::InputMappingSettingsModel' has a wrong offset!");

// Class Stalker2.AnimNotify_PlayerActionTrigger
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify_PlayerActionTrigger final : public UAnimNotifyBase
{
public:
	EPlayerActionTriggerState                     TriggerNewState;                                   // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerTriggerState                           ActionTrigger;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayerActionTrigger">();
	}
	static class UAnimNotify_PlayerActionTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayerActionTrigger>();
	}
};
static_assert(alignof(UAnimNotify_PlayerActionTrigger) == 0x000008, "Wrong alignment on UAnimNotify_PlayerActionTrigger");
static_assert(sizeof(UAnimNotify_PlayerActionTrigger) == 0x000050, "Wrong size on UAnimNotify_PlayerActionTrigger");
static_assert(offsetof(UAnimNotify_PlayerActionTrigger, TriggerNewState) == 0x000040, "Member 'UAnimNotify_PlayerActionTrigger::TriggerNewState' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayerActionTrigger, ActionTrigger) == 0x000048, "Member 'UAnimNotify_PlayerActionTrigger::ActionTrigger' has a wrong offset!");

// Class Stalker2.AIDebugSubsystem
// 0x0000 (0x0030 - 0x0030)
class UAIDebugSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDebugSubsystem">();
	}
	static class UAIDebugSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDebugSubsystem>();
	}
};
static_assert(alignof(UAIDebugSubsystem) == 0x000008, "Wrong alignment on UAIDebugSubsystem");
static_assert(sizeof(UAIDebugSubsystem) == 0x000030, "Wrong size on UAIDebugSubsystem");

// Class Stalker2.AIFeatureManager
// 0x0008 (0x0080 - 0x0078)
class UAIFeatureManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIFeatureManager">();
	}
	static class UAIFeatureManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIFeatureManager>();
	}
};
static_assert(alignof(UAIFeatureManager) == 0x000008, "Wrong alignment on UAIFeatureManager");
static_assert(sizeof(UAIFeatureManager) == 0x000080, "Wrong size on UAIFeatureManager");

// Class Stalker2.GSCNavModifierVolume
// 0x0018 (0x0308 - 0x02F0)
class AGSCNavModifierVolume : public ANavModifierVolume
{
public:
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGuidActorComponent*                    GuidComponent;                                     // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActive;                                         // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCNavModifierVolume">();
	}
	static class AGSCNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGSCNavModifierVolume>();
	}
};
static_assert(alignof(AGSCNavModifierVolume) == 0x000008, "Wrong alignment on AGSCNavModifierVolume");
static_assert(sizeof(AGSCNavModifierVolume) == 0x000308, "Wrong size on AGSCNavModifierVolume");
static_assert(offsetof(AGSCNavModifierVolume, GuidComponent) == 0x0002F8, "Member 'AGSCNavModifierVolume::GuidComponent' has a wrong offset!");
static_assert(offsetof(AGSCNavModifierVolume, bIsActive) == 0x000300, "Member 'AGSCNavModifierVolume::bIsActive' has a wrong offset!");

// Class Stalker2.ScriptedNavModifierVolume
// 0x0008 (0x0310 - 0x0308)
class AScriptedNavModifierVolume final : public AGSCNavModifierVolume
{
public:
	TSubclassOf<class UNavArea_Scripted>          TargetNavArea;                                     // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Activate();
	void Deactivate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptedNavModifierVolume">();
	}
	static class AScriptedNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScriptedNavModifierVolume>();
	}
};
static_assert(alignof(AScriptedNavModifierVolume) == 0x000008, "Wrong alignment on AScriptedNavModifierVolume");
static_assert(sizeof(AScriptedNavModifierVolume) == 0x000310, "Wrong size on AScriptedNavModifierVolume");
static_assert(offsetof(AScriptedNavModifierVolume, TargetNavArea) == 0x000308, "Member 'AScriptedNavModifierVolume::TargetNavArea' has a wrong offset!");

// Class Stalker2.AnimNotify_EnableStateTagForDuration
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_EnableStateTagForDuration final : public UAnimNotifyState
{
public:
	EStateTag                                     StateTag;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableIfDied;                                    // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EnableStateTagForDuration">();
	}
	static class UAnimNotify_EnableStateTagForDuration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EnableStateTagForDuration>();
	}
};
static_assert(alignof(UAnimNotify_EnableStateTagForDuration) == 0x000008, "Wrong alignment on UAnimNotify_EnableStateTagForDuration");
static_assert(sizeof(UAnimNotify_EnableStateTagForDuration) == 0x000038, "Wrong size on UAnimNotify_EnableStateTagForDuration");
static_assert(offsetof(UAnimNotify_EnableStateTagForDuration, StateTag) == 0x000030, "Member 'UAnimNotify_EnableStateTagForDuration::StateTag' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EnableStateTagForDuration, bDisableIfDied) == 0x000034, "Member 'UAnimNotify_EnableStateTagForDuration::bDisableIfDied' has a wrong offset!");

// Class Stalker2.AchievementTracker_PerfectBarter
// 0x0018 (0x0050 - 0x0038)
class UAchievementTracker_PerfectBarter final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_PerfectBarter">();
	}
	static class UAchievementTracker_PerfectBarter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_PerfectBarter>();
	}
};
static_assert(alignof(UAchievementTracker_PerfectBarter) == 0x000008, "Wrong alignment on UAchievementTracker_PerfectBarter");
static_assert(sizeof(UAchievementTracker_PerfectBarter) == 0x000050, "Wrong size on UAchievementTracker_PerfectBarter");

// Class Stalker2.AIFlashlightUseManager
// 0x0088 (0x0100 - 0x0078)
class UAIFlashlightUseManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x88];                                      // 0x0078(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIFlashlightUseManager">();
	}
	static class UAIFlashlightUseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIFlashlightUseManager>();
	}
};
static_assert(alignof(UAIFlashlightUseManager) == 0x000008, "Wrong alignment on UAIFlashlightUseManager");
static_assert(sizeof(UAIFlashlightUseManager) == 0x000100, "Wrong size on UAIFlashlightUseManager");

// Class Stalker2.AILuminanceManager
// 0x0018 (0x0090 - 0x0078)
class UAILuminanceManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AILuminanceManager">();
	}
	static class UAILuminanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAILuminanceManager>();
	}
};
static_assert(alignof(UAILuminanceManager) == 0x000008, "Wrong alignment on UAILuminanceManager");
static_assert(sizeof(UAILuminanceManager) == 0x000090, "Wrong size on UAILuminanceManager");

// Class Stalker2.InteractableVersionComponent
// 0x0008 (0x00A8 - 0x00A0)
class UInteractableVersionComponent : public UActorComponent
{
public:
	uint8                                         Version;                                           // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateFromVersion(const uint8 OldVersion);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableVersionComponent">();
	}
	static class UInteractableVersionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableVersionComponent>();
	}
};
static_assert(alignof(UInteractableVersionComponent) == 0x000008, "Wrong alignment on UInteractableVersionComponent");
static_assert(sizeof(UInteractableVersionComponent) == 0x0000A8, "Wrong size on UInteractableVersionComponent");
static_assert(offsetof(UInteractableVersionComponent, Version) == 0x0000A0, "Member 'UInteractableVersionComponent::Version' has a wrong offset!");

// Class Stalker2.RootMotionModifier_WarpWithScale
// 0x0010 (0x0260 - 0x0250)
class URootMotionModifier_WarpWithScale final : public URootMotionModifier_SkewWarp
{
public:
	class FName                                   ScaleWarpTargetName;                               // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RootMotionModifier_WarpWithScale">();
	}
	static class URootMotionModifier_WarpWithScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<URootMotionModifier_WarpWithScale>();
	}
};
static_assert(alignof(URootMotionModifier_WarpWithScale) == 0x000010, "Wrong alignment on URootMotionModifier_WarpWithScale");
static_assert(sizeof(URootMotionModifier_WarpWithScale) == 0x000260, "Wrong size on URootMotionModifier_WarpWithScale");
static_assert(offsetof(URootMotionModifier_WarpWithScale, ScaleWarpTargetName) == 0x000250, "Member 'URootMotionModifier_WarpWithScale::ScaleWarpTargetName' has a wrong offset!");

// Class Stalker2.AnimNotify_PlaySoundDependOnMaterialContextualAction
// 0x0038 (0x0078 - 0x0040)
class UAnimNotify_PlaySoundDependOnMaterialContextualAction final : public UAnimNotifyBase
{
public:
	class UAkAudioEvent*                          ImpactSound;                                       // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         BoneReference;                                     // 0x0048(0x0010)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               TraceDirection;                                    // 0x0058(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TraceLength;                                       // 0x0070(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlaySoundDependOnMaterialContextualAction">();
	}
	static class UAnimNotify_PlaySoundDependOnMaterialContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlaySoundDependOnMaterialContextualAction>();
	}
};
static_assert(alignof(UAnimNotify_PlaySoundDependOnMaterialContextualAction) == 0x000008, "Wrong alignment on UAnimNotify_PlaySoundDependOnMaterialContextualAction");
static_assert(sizeof(UAnimNotify_PlaySoundDependOnMaterialContextualAction) == 0x000078, "Wrong size on UAnimNotify_PlaySoundDependOnMaterialContextualAction");
static_assert(offsetof(UAnimNotify_PlaySoundDependOnMaterialContextualAction, ImpactSound) == 0x000040, "Member 'UAnimNotify_PlaySoundDependOnMaterialContextualAction::ImpactSound' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlaySoundDependOnMaterialContextualAction, BoneReference) == 0x000048, "Member 'UAnimNotify_PlaySoundDependOnMaterialContextualAction::BoneReference' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlaySoundDependOnMaterialContextualAction, TraceDirection) == 0x000058, "Member 'UAnimNotify_PlaySoundDependOnMaterialContextualAction::TraceDirection' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlaySoundDependOnMaterialContextualAction, TraceLength) == 0x000070, "Member 'UAnimNotify_PlaySoundDependOnMaterialContextualAction::TraceLength' has a wrong offset!");

// Class Stalker2.SingleClickComponent
// 0x0030 (0x01F8 - 0x01C8)
class USingleClickComponent : public UInteractionComponent
{
public:
	TMulticastInlineDelegate<void()>              OnSingleClickInteractFailed;                       // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FSingleClickInteractionData            InteractionData;                                   // 0x01D8(0x0018)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bNeedSendFailedEvent;                              // 0x01F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetNeededFailedEvent(const bool bNeedEvent);

	bool CanSendFailedEvent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleClickComponent">();
	}
	static class USingleClickComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleClickComponent>();
	}
};
static_assert(alignof(USingleClickComponent) == 0x000008, "Wrong alignment on USingleClickComponent");
static_assert(sizeof(USingleClickComponent) == 0x0001F8, "Wrong size on USingleClickComponent");
static_assert(offsetof(USingleClickComponent, OnSingleClickInteractFailed) == 0x0001C8, "Member 'USingleClickComponent::OnSingleClickInteractFailed' has a wrong offset!");
static_assert(offsetof(USingleClickComponent, InteractionData) == 0x0001D8, "Member 'USingleClickComponent::InteractionData' has a wrong offset!");
static_assert(offsetof(USingleClickComponent, bNeedSendFailedEvent) == 0x0001F0, "Member 'USingleClickComponent::bNeedSendFailedEvent' has a wrong offset!");

// Class Stalker2.TopazSingleClickComponent
// 0x0030 (0x0228 - 0x01F8)
class UTopazSingleClickComponent final : public USingleClickComponent
{
public:
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionAngle;                                  // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableAnimCollection*            ActivationAnimCollection;                          // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractableAnimCollection*            CollectAnimCollection;                             // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCustomInteractText;                               // 0x0218(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATopazScanner*                          OwnerScanner;                                      // 0x0220(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TopazSingleClickComponent">();
	}
	static class UTopazSingleClickComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTopazSingleClickComponent>();
	}
};
static_assert(alignof(UTopazSingleClickComponent) == 0x000008, "Wrong alignment on UTopazSingleClickComponent");
static_assert(sizeof(UTopazSingleClickComponent) == 0x000228, "Wrong size on UTopazSingleClickComponent");
static_assert(offsetof(UTopazSingleClickComponent, InteractionAngle) == 0x000200, "Member 'UTopazSingleClickComponent::InteractionAngle' has a wrong offset!");
static_assert(offsetof(UTopazSingleClickComponent, ActivationAnimCollection) == 0x000208, "Member 'UTopazSingleClickComponent::ActivationAnimCollection' has a wrong offset!");
static_assert(offsetof(UTopazSingleClickComponent, CollectAnimCollection) == 0x000210, "Member 'UTopazSingleClickComponent::CollectAnimCollection' has a wrong offset!");
static_assert(offsetof(UTopazSingleClickComponent, bCustomInteractText) == 0x000218, "Member 'UTopazSingleClickComponent::bCustomInteractText' has a wrong offset!");
static_assert(offsetof(UTopazSingleClickComponent, OwnerScanner) == 0x000220, "Member 'UTopazSingleClickComponent::OwnerScanner' has a wrong offset!");

// Class Stalker2.AimAssistInvisibleTargetComponent
// 0x0018 (0x00B8 - 0x00A0)
class UAimAssistInvisibleTargetComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAimAssistTargetDataAsset*              InvisibleAimAssistTargetData;                      // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAimAssistTargetDataAsset*              VisibleAimAssistTargetData;                        // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistInvisibleTargetComponent">();
	}
	static class UAimAssistInvisibleTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimAssistInvisibleTargetComponent>();
	}
};
static_assert(alignof(UAimAssistInvisibleTargetComponent) == 0x000008, "Wrong alignment on UAimAssistInvisibleTargetComponent");
static_assert(sizeof(UAimAssistInvisibleTargetComponent) == 0x0000B8, "Wrong size on UAimAssistInvisibleTargetComponent");
static_assert(offsetof(UAimAssistInvisibleTargetComponent, InvisibleAimAssistTargetData) == 0x0000A8, "Member 'UAimAssistInvisibleTargetComponent::InvisibleAimAssistTargetData' has a wrong offset!");
static_assert(offsetof(UAimAssistInvisibleTargetComponent, VisibleAimAssistTargetData) == 0x0000B0, "Member 'UAimAssistInvisibleTargetComponent::VisibleAimAssistTargetData' has a wrong offset!");

// Class Stalker2.AimAssistBloodsuckerComponent
// 0x0010 (0x00C8 - 0x00B8)
class UAimAssistBloodsuckerComponent final : public UAimAssistInvisibleTargetComponent
{
public:
	float                                         InvisibilityThreshold;                             // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0xC];                                       // 0x00BC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistBloodsuckerComponent">();
	}
	static class UAimAssistBloodsuckerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimAssistBloodsuckerComponent>();
	}
};
static_assert(alignof(UAimAssistBloodsuckerComponent) == 0x000008, "Wrong alignment on UAimAssistBloodsuckerComponent");
static_assert(sizeof(UAimAssistBloodsuckerComponent) == 0x0000C8, "Wrong size on UAimAssistBloodsuckerComponent");
static_assert(offsetof(UAimAssistBloodsuckerComponent, InvisibilityThreshold) == 0x0000B8, "Member 'UAimAssistBloodsuckerComponent::InvisibilityThreshold' has a wrong offset!");

// Class Stalker2.AnimNotify_PlayAnimationOnAttachedItemContextualAction
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify_PlayAnimationOnAttachedItemContextualAction final : public UAnimNotifyBase
{
public:
	TArray<struct FPlayAnimationOnAttachedItemData> PlayAnimationOnAttachedItemData;                 // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayAnimationOnAttachedItemContextualAction">();
	}
	static class UAnimNotify_PlayAnimationOnAttachedItemContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayAnimationOnAttachedItemContextualAction>();
	}
};
static_assert(alignof(UAnimNotify_PlayAnimationOnAttachedItemContextualAction) == 0x000008, "Wrong alignment on UAnimNotify_PlayAnimationOnAttachedItemContextualAction");
static_assert(sizeof(UAnimNotify_PlayAnimationOnAttachedItemContextualAction) == 0x000050, "Wrong size on UAnimNotify_PlayAnimationOnAttachedItemContextualAction");
static_assert(offsetof(UAnimNotify_PlayAnimationOnAttachedItemContextualAction, PlayAnimationOnAttachedItemData) == 0x000040, "Member 'UAnimNotify_PlayAnimationOnAttachedItemContextualAction::PlayAnimationOnAttachedItemData' has a wrong offset!");

// Class Stalker2.QuickSlotBaseIPU
// 0x0008 (0x0048 - 0x0040)
class UQuickSlotBaseIPU : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickSlotBaseIPU">();
	}
	static class UQuickSlotBaseIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickSlotBaseIPU>();
	}
};
static_assert(alignof(UQuickSlotBaseIPU) == 0x000008, "Wrong alignment on UQuickSlotBaseIPU");
static_assert(sizeof(UQuickSlotBaseIPU) == 0x000048, "Wrong size on UQuickSlotBaseIPU");

// Class Stalker2.QuickSlot1IPU
// 0x0000 (0x0048 - 0x0048)
class UQuickSlot1IPU final : public UQuickSlotBaseIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickSlot1IPU">();
	}
	static class UQuickSlot1IPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickSlot1IPU>();
	}
};
static_assert(alignof(UQuickSlot1IPU) == 0x000008, "Wrong alignment on UQuickSlot1IPU");
static_assert(sizeof(UQuickSlot1IPU) == 0x000048, "Wrong size on UQuickSlot1IPU");

// Class Stalker2.AimAssistComponent
// 0x0120 (0x01C0 - 0x00A0)
class alignas(0x10) UAimAssistComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0xC0];                                      // 0x00A0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SnappingTimeCurve;                                 // 0x0160(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x58];                                     // 0x0168(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistComponent">();
	}
	static class UAimAssistComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimAssistComponent>();
	}
};
static_assert(alignof(UAimAssistComponent) == 0x000010, "Wrong alignment on UAimAssistComponent");
static_assert(sizeof(UAimAssistComponent) == 0x0001C0, "Wrong size on UAimAssistComponent");
static_assert(offsetof(UAimAssistComponent, SnappingTimeCurve) == 0x000160, "Member 'UAimAssistComponent::SnappingTimeCurve' has a wrong offset!");

// Class Stalker2.DPadLeftIPU
// 0x0000 (0x0040 - 0x0040)
class UDPadLeftIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DPadLeftIPU">();
	}
	static class UDPadLeftIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDPadLeftIPU>();
	}
};
static_assert(alignof(UDPadLeftIPU) == 0x000008, "Wrong alignment on UDPadLeftIPU");
static_assert(sizeof(UDPadLeftIPU) == 0x000040, "Wrong size on UDPadLeftIPU");

// Class Stalker2.ALifeDirector
// 0x00C8 (0x0170 - 0x00A8)
class UALifeDirector final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0xC8];                                      // 0x00A8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ALifeDirector">();
	}
	static class UALifeDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UALifeDirector>();
	}
};
static_assert(alignof(UALifeDirector) == 0x000008, "Wrong alignment on UALifeDirector");
static_assert(sizeof(UALifeDirector) == 0x000170, "Wrong size on UALifeDirector");

// Class Stalker2.AimAssistCustomTargetComponent
// 0x0010 (0x00B0 - 0x00A0)
class UAimAssistCustomTargetComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAimAssistTargetDataAsset*              AimAssistTargetData;                               // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistCustomTargetComponent">();
	}
	static class UAimAssistCustomTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimAssistCustomTargetComponent>();
	}
};
static_assert(alignof(UAimAssistCustomTargetComponent) == 0x000008, "Wrong alignment on UAimAssistCustomTargetComponent");
static_assert(sizeof(UAimAssistCustomTargetComponent) == 0x0000B0, "Wrong size on UAimAssistCustomTargetComponent");
static_assert(offsetof(UAimAssistCustomTargetComponent, AimAssistTargetData) == 0x0000A8, "Member 'UAimAssistCustomTargetComponent::AimAssistTargetData' has a wrong offset!");

// Class Stalker2.UIDActor_InteractableObject
// 0x0010 (0x02A8 - 0x0298)
class AUIDActor_InteractableObject : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActor_InteractableObject">();
	}
	static class AUIDActor_InteractableObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDActor_InteractableObject>();
	}
};
static_assert(alignof(AUIDActor_InteractableObject) == 0x000008, "Wrong alignment on AUIDActor_InteractableObject");
static_assert(sizeof(AUIDActor_InteractableObject) == 0x0002A8, "Wrong size on AUIDActor_InteractableObject");

// Class Stalker2.InteractableObject
// 0x0040 (0x02E8 - 0x02A8)
class AInteractableObject : public AUIDActor_InteractableObject
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnabled;                                          // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnbreakable;                                      // 0x02B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBroken;                                           // 0x02B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelfSufficient;                                   // 0x02B3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrerequisiteRequired;                             // 0x02B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteractionActive;                                // 0x02B5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstPlay;                                        // 0x02B6(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B7[0x1];                                      // 0x02B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x20];                                     // 0x02C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationEventTriggered();
	void OnDayStart();
	void OnEmissionFinish();
	void OnEmissionStart();
	void OnFirstPlay();
	void OnNightStart();
	void PauseSkeletalComponent(const bool bPause);
	void SetBroken(const bool bInBroken);
	void SetEnabled(const bool bInEnabled);
	void SetInteractionActive(const bool bInInteractionActive);
	void SetPrerequisiteRequired(const bool bInPrerequisiteRequired);
	void SetSelfSufficient(const bool bInSelfSufficient);
	void SetUnbreakable(const bool bInUnbreakable);
	bool Toggle();

	bool IsBroken() const;
	bool IsEnabled() const;
	bool IsInteractionActive() const;
	bool IsPrerequisiteRequired() const;
	bool IsSelfSufficient() const;
	bool IsUnbreakable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableObject">();
	}
	static class AInteractableObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractableObject>();
	}
};
static_assert(alignof(AInteractableObject) == 0x000008, "Wrong alignment on AInteractableObject");
static_assert(sizeof(AInteractableObject) == 0x0002E8, "Wrong size on AInteractableObject");
static_assert(offsetof(AInteractableObject, bEnabled) == 0x0002B0, "Member 'AInteractableObject::bEnabled' has a wrong offset!");
static_assert(offsetof(AInteractableObject, bUnbreakable) == 0x0002B1, "Member 'AInteractableObject::bUnbreakable' has a wrong offset!");
static_assert(offsetof(AInteractableObject, bBroken) == 0x0002B2, "Member 'AInteractableObject::bBroken' has a wrong offset!");
static_assert(offsetof(AInteractableObject, bSelfSufficient) == 0x0002B3, "Member 'AInteractableObject::bSelfSufficient' has a wrong offset!");
static_assert(offsetof(AInteractableObject, bPrerequisiteRequired) == 0x0002B4, "Member 'AInteractableObject::bPrerequisiteRequired' has a wrong offset!");
static_assert(offsetof(AInteractableObject, bInteractionActive) == 0x0002B5, "Member 'AInteractableObject::bInteractionActive' has a wrong offset!");
static_assert(offsetof(AInteractableObject, bFirstPlay) == 0x0002B6, "Member 'AInteractableObject::bFirstPlay' has a wrong offset!");
static_assert(offsetof(AInteractableObject, Guid) == 0x0002B8, "Member 'AInteractableObject::Guid' has a wrong offset!");

// Class Stalker2.InteractableStunVolume
// 0x0078 (0x0360 - 0x02E8)
class AInteractableStunVolume final : public AInteractableObject
{
public:
	class UStaticMeshComponent*                   RootMesh;                                          // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CollisionMesh;                                     // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGSCNavModifierComponent*               SpaceRestrictorComponent;                          // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USignalSenderComponent*                 MonitorActivationSignalSender;                     // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USignalSenderComponent*                 ObjectActivationSignalSender;                      // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USignalSenderComponent*                 MonitorDeactivationSignalSender;                   // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USignalSenderComponent*                 ObjectDeactivationSignalSender;                    // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USignalSenderComponent*                 MonitorDestructionSignalSender;                    // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USignalReceiverComponent*               VolumeActivationSignalReceiver;                    // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        TargetPoints;                                      // 0x0330(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         CollisionRadius;                                   // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CollisionHeight;                                   // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StunDuration;                                      // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownDuration;                                  // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateVolume(class UObject* InObject);
	void OnCooldownEnded(class UObject* InObject);
	void OnVolumeActivated(class UObject* InObject);
	void OnVolumeDeactivated(class UObject* InObject);
	void OnVolumeForceDeactivated(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableStunVolume">();
	}
	static class AInteractableStunVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractableStunVolume>();
	}
};
static_assert(alignof(AInteractableStunVolume) == 0x000008, "Wrong alignment on AInteractableStunVolume");
static_assert(sizeof(AInteractableStunVolume) == 0x000360, "Wrong size on AInteractableStunVolume");
static_assert(offsetof(AInteractableStunVolume, RootMesh) == 0x0002E8, "Member 'AInteractableStunVolume::RootMesh' has a wrong offset!");
static_assert(offsetof(AInteractableStunVolume, CollisionMesh) == 0x0002F0, "Member 'AInteractableStunVolume::CollisionMesh' has a wrong offset!");
static_assert(offsetof(AInteractableStunVolume, SpaceRestrictorComponent) == 0x0002F8, "Member 'AInteractableStunVolume::SpaceRestrictorComponent' has a wrong offset!");
static_assert(offsetof(AInteractableStunVolume, MonitorActivationSignalSender) == 0x000300, "Member 'AInteractableStunVolume::MonitorActivationSignalSender' has a wrong offset!");
static_assert(offsetof(AInteractableStunVolume, ObjectActivationSignalSender) == 0x000308, "Member 'AInteractableStunVolume::ObjectActivationSignalSender' has a wrong offset!");
static_assert(offsetof(AInteractableStunVolume, MonitorDeactivationSignalSender) == 0x000310, "Member 'AInteractableStunVolume::MonitorDeactivationSignalSender' has a wrong offset!");
static_assert(offsetof(AInteractableStunVolume, ObjectDeactivationSignalSender) == 0x000318, "Member 'AInteractableStunVolume::ObjectDeactivationSignalSender' has a wrong offset!");
static_assert(offsetof(AInteractableStunVolume, MonitorDestructionSignalSender) == 0x000320, "Member 'AInteractableStunVolume::MonitorDestructionSignalSender' has a wrong offset!");
static_assert(offsetof(AInteractableStunVolume, VolumeActivationSignalReceiver) == 0x000328, "Member 'AInteractableStunVolume::VolumeActivationSignalReceiver' has a wrong offset!");
static_assert(offsetof(AInteractableStunVolume, TargetPoints) == 0x000330, "Member 'AInteractableStunVolume::TargetPoints' has a wrong offset!");
static_assert(offsetof(AInteractableStunVolume, CollisionRadius) == 0x000340, "Member 'AInteractableStunVolume::CollisionRadius' has a wrong offset!");
static_assert(offsetof(AInteractableStunVolume, CollisionHeight) == 0x000344, "Member 'AInteractableStunVolume::CollisionHeight' has a wrong offset!");
static_assert(offsetof(AInteractableStunVolume, StunDuration) == 0x000348, "Member 'AInteractableStunVolume::StunDuration' has a wrong offset!");
static_assert(offsetof(AInteractableStunVolume, CooldownDuration) == 0x00034C, "Member 'AInteractableStunVolume::CooldownDuration' has a wrong offset!");

// Class Stalker2.AnimNotify_RetargetedAkEvent
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_RetargetedAkEvent final : public UAnimNotify
{
public:
	void AsyncPostAkEventAtMeshLocation(class USkeletalMeshComponent* Mesh, TSoftObjectPtr<class UAkAudioEvent> Event) const;
	void AsyncPostAkEventOnComponent(class UAkComponent* AkComponent, TSoftObjectPtr<class UAkAudioEvent> Event) const;
	class UAkComponent* GetAkComponentForSocket(class USkeletalMeshComponent* Mesh, const class FName& Socket, const class UAnimSequenceBase* AnimSequenceBase) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_RetargetedAkEvent">();
	}
	static class UAnimNotify_RetargetedAkEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_RetargetedAkEvent>();
	}
};
static_assert(alignof(UAnimNotify_RetargetedAkEvent) == 0x000008, "Wrong alignment on UAnimNotify_RetargetedAkEvent");
static_assert(sizeof(UAnimNotify_RetargetedAkEvent) == 0x000038, "Wrong size on UAnimNotify_RetargetedAkEvent");

// Class Stalker2.AimAssistPoltergeistComponent
// 0x0008 (0x00C0 - 0x00B8)
class UAimAssistPoltergeistComponent final : public UAimAssistInvisibleTargetComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistPoltergeistComponent">();
	}
	static class UAimAssistPoltergeistComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimAssistPoltergeistComponent>();
	}
};
static_assert(alignof(UAimAssistPoltergeistComponent) == 0x000008, "Wrong alignment on UAimAssistPoltergeistComponent");
static_assert(sizeof(UAimAssistPoltergeistComponent) == 0x0000C0, "Wrong size on UAimAssistPoltergeistComponent");

// Class Stalker2.ForceFeedbackProcessorBase
// 0x0040 (0x0068 - 0x0028)
class UForceFeedbackProcessorBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreSelf;                                       // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FForceFeedbackParams                   Params_0;                                          // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	ERumbleType                                   RumbleType;                                        // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERumbleType                                   DefaultRumbleType;                                 // 0x0045(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46[0x1A];                                      // 0x0046(0x001A)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackEffect*                   CurrentFeedback;                                   // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceFeedbackProcessorBase">();
	}
	static class UForceFeedbackProcessorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceFeedbackProcessorBase>();
	}
};
static_assert(alignof(UForceFeedbackProcessorBase) == 0x000008, "Wrong alignment on UForceFeedbackProcessorBase");
static_assert(sizeof(UForceFeedbackProcessorBase) == 0x000068, "Wrong size on UForceFeedbackProcessorBase");
static_assert(offsetof(UForceFeedbackProcessorBase, Priority) == 0x000030, "Member 'UForceFeedbackProcessorBase::Priority' has a wrong offset!");
static_assert(offsetof(UForceFeedbackProcessorBase, bIgnoreSelf) == 0x000034, "Member 'UForceFeedbackProcessorBase::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(UForceFeedbackProcessorBase, Params_0) == 0x000038, "Member 'UForceFeedbackProcessorBase::Params_0' has a wrong offset!");
static_assert(offsetof(UForceFeedbackProcessorBase, RumbleType) == 0x000044, "Member 'UForceFeedbackProcessorBase::RumbleType' has a wrong offset!");
static_assert(offsetof(UForceFeedbackProcessorBase, DefaultRumbleType) == 0x000045, "Member 'UForceFeedbackProcessorBase::DefaultRumbleType' has a wrong offset!");
static_assert(offsetof(UForceFeedbackProcessorBase, CurrentFeedback) == 0x000060, "Member 'UForceFeedbackProcessorBase::CurrentFeedback' has a wrong offset!");

// Class Stalker2.AISwarmComponent
// 0x0DE0 (0x1080 - 0x02A0)
class UAISwarmComponent final : public USceneComponent
{
public:
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SoundLocation;                                     // 0x02B8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionSoundRadius;                             // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VoiceSoundRadius;                                  // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x40];                                     // 0x02D8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxInstancesInSwarm;                               // 0x0318(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FlockRadius;                                       // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CellSize;                                          // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WallPadding;                                       // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SimulationGridPadding;                             // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovementVariationRange;                            // 0x032C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SwarmBoundsCellCountClamp;                         // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxAttackingInstances;                             // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackTimeout;                                     // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InstanceCollisionRadius;                           // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeavyProjectileDamageThreashold;                   // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MaterialVariantPropertyName;                       // 0x0344(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxTextureVariants;                                // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VisualsSeed;                                       // 0x0350(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              InstanceScaleRange;                                // 0x0358(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     MeshMaterial;                                      // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            StaticMesh;                                        // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          SwarmInstancedMesh;                                // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVATAnimationsConfig*                   VATAnimationsConfig;                               // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EDamageAffectorType, struct FSwarmDamageHandleImpact> DamageImpactConfig;                   // 0x0388(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<ESwarmInstanceStates, struct FSwarmInstanceSimulationConfig> SwarmConfigurations;           // 0x03D8(0x0050)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0xC58];                                    // 0x0428(0x0C58)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConstruction(const struct FTransform& Transform, const float SwarmHealth);
	void SetDamageTarget(const class AActor* Target, const float OffsetToGroundLevel, const float EngageRadius);
	void Simulate(const float DeltaTime);

	TArray<class FName> GetVATAnimationNames() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISwarmComponent">();
	}
	static class UAISwarmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISwarmComponent>();
	}
};
static_assert(alignof(UAISwarmComponent) == 0x000010, "Wrong alignment on UAISwarmComponent");
static_assert(sizeof(UAISwarmComponent) == 0x001080, "Wrong size on UAISwarmComponent");
static_assert(offsetof(UAISwarmComponent, SoundLocation) == 0x0002B8, "Member 'UAISwarmComponent::SoundLocation' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, LocomotionSoundRadius) == 0x0002D0, "Member 'UAISwarmComponent::LocomotionSoundRadius' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, VoiceSoundRadius) == 0x0002D4, "Member 'UAISwarmComponent::VoiceSoundRadius' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, MaxInstancesInSwarm) == 0x000318, "Member 'UAISwarmComponent::MaxInstancesInSwarm' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, FlockRadius) == 0x00031C, "Member 'UAISwarmComponent::FlockRadius' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, CellSize) == 0x000320, "Member 'UAISwarmComponent::CellSize' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, WallPadding) == 0x000324, "Member 'UAISwarmComponent::WallPadding' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, SimulationGridPadding) == 0x000328, "Member 'UAISwarmComponent::SimulationGridPadding' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, MovementVariationRange) == 0x00032C, "Member 'UAISwarmComponent::MovementVariationRange' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, SwarmBoundsCellCountClamp) == 0x000330, "Member 'UAISwarmComponent::SwarmBoundsCellCountClamp' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, MaxAttackingInstances) == 0x000334, "Member 'UAISwarmComponent::MaxAttackingInstances' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, AttackTimeout) == 0x000338, "Member 'UAISwarmComponent::AttackTimeout' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, InstanceCollisionRadius) == 0x00033C, "Member 'UAISwarmComponent::InstanceCollisionRadius' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, HeavyProjectileDamageThreashold) == 0x000340, "Member 'UAISwarmComponent::HeavyProjectileDamageThreashold' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, MaterialVariantPropertyName) == 0x000344, "Member 'UAISwarmComponent::MaterialVariantPropertyName' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, MaxTextureVariants) == 0x00034C, "Member 'UAISwarmComponent::MaxTextureVariants' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, VisualsSeed) == 0x000350, "Member 'UAISwarmComponent::VisualsSeed' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, InstanceScaleRange) == 0x000358, "Member 'UAISwarmComponent::InstanceScaleRange' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, MeshMaterial) == 0x000368, "Member 'UAISwarmComponent::MeshMaterial' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, StaticMesh) == 0x000370, "Member 'UAISwarmComponent::StaticMesh' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, SwarmInstancedMesh) == 0x000378, "Member 'UAISwarmComponent::SwarmInstancedMesh' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, VATAnimationsConfig) == 0x000380, "Member 'UAISwarmComponent::VATAnimationsConfig' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, DamageImpactConfig) == 0x000388, "Member 'UAISwarmComponent::DamageImpactConfig' has a wrong offset!");
static_assert(offsetof(UAISwarmComponent, SwarmConfigurations) == 0x0003D8, "Member 'UAISwarmComponent::SwarmConfigurations' has a wrong offset!");

// Class Stalker2.AimAssistTargetDataAsset
// 0x00A0 (0x00D0 - 0x0030)
class UAimAssistTargetDataAsset final : public UDataAsset
{
public:
	TMap<EAimAssistType, float>                   HeightModifiers;                                   // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<EAimAssistType, float>                   IntensityModifiers;                                // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistTargetDataAsset">();
	}
	static class UAimAssistTargetDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimAssistTargetDataAsset>();
	}
};
static_assert(alignof(UAimAssistTargetDataAsset) == 0x000008, "Wrong alignment on UAimAssistTargetDataAsset");
static_assert(sizeof(UAimAssistTargetDataAsset) == 0x0000D0, "Wrong size on UAimAssistTargetDataAsset");
static_assert(offsetof(UAimAssistTargetDataAsset, HeightModifiers) == 0x000030, "Member 'UAimAssistTargetDataAsset::HeightModifiers' has a wrong offset!");
static_assert(offsetof(UAimAssistTargetDataAsset, IntensityModifiers) == 0x000080, "Member 'UAimAssistTargetDataAsset::IntensityModifiers' has a wrong offset!");

// Class Stalker2.SystemicNavModifierVolume
// 0x0000 (0x0308 - 0x0308)
class ASystemicNavModifierVolume : public AGSCNavModifierVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SystemicNavModifierVolume">();
	}
	static class ASystemicNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASystemicNavModifierVolume>();
	}
};
static_assert(alignof(ASystemicNavModifierVolume) == 0x000008, "Wrong alignment on ASystemicNavModifierVolume");
static_assert(sizeof(ASystemicNavModifierVolume) == 0x000308, "Wrong size on ASystemicNavModifierVolume");

// Class Stalker2.ShelterNavModifierVolume
// 0x0000 (0x0308 - 0x0308)
class AShelterNavModifierVolume final : public ASystemicNavModifierVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterNavModifierVolume">();
	}
	static class AShelterNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShelterNavModifierVolume>();
	}
};
static_assert(alignof(AShelterNavModifierVolume) == 0x000008, "Wrong alignment on AShelterNavModifierVolume");
static_assert(sizeof(AShelterNavModifierVolume) == 0x000308, "Wrong size on AShelterNavModifierVolume");

// Class Stalker2.AnimNotify_TopazActions
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_TopazActions final : public UAnimNotifyBase
{
public:
	EAnimTopazAction                              TopazAction;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_TopazActions">();
	}
	static class UAnimNotify_TopazActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_TopazActions>();
	}
};
static_assert(alignof(UAnimNotify_TopazActions) == 0x000008, "Wrong alignment on UAnimNotify_TopazActions");
static_assert(sizeof(UAnimNotify_TopazActions) == 0x000048, "Wrong size on UAnimNotify_TopazActions");
static_assert(offsetof(UAnimNotify_TopazActions, TopazAction) == 0x000040, "Member 'UAnimNotify_TopazActions::TopazAction' has a wrong offset!");

// Class Stalker2.AchievementTracker_ChimeraRun
// 0x0060 (0x0098 - 0x0038)
class UAchievementTracker_ChimeraRun final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x60];                                      // 0x0038(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_ChimeraRun">();
	}
	static class UAchievementTracker_ChimeraRun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_ChimeraRun>();
	}
};
static_assert(alignof(UAchievementTracker_ChimeraRun) == 0x000008, "Wrong alignment on UAchievementTracker_ChimeraRun");
static_assert(sizeof(UAchievementTracker_ChimeraRun) == 0x000098, "Wrong size on UAchievementTracker_ChimeraRun");

// Class Stalker2.AimAssistTargetInterface
// 0x0000 (0x0000 - 0x0000)
class IAimAssistTargetInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistTargetInterface">();
	}
	static class IAimAssistTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAimAssistTargetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAimAssistTargetInterface) == 0x000001, "Wrong alignment on IAimAssistTargetInterface");
static_assert(sizeof(IAimAssistTargetInterface) == 0x000001, "Wrong size on IAimAssistTargetInterface");

// Class Stalker2.ViewBase
// 0x0048 (0x02C0 - 0x0278)
class UViewBase : public UWidgetBase
{
public:
	struct FViewOpenSettings                      ViewOpenSettings;                                  // 0x0278(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EWidgetNameEx                                 WidgetName;                                        // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0xC];                                      // 0x02B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PreCloseUpdateView();
	void UIClose();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViewBase">();
	}
	static class UViewBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UViewBase>();
	}
};
static_assert(alignof(UViewBase) == 0x000008, "Wrong alignment on UViewBase");
static_assert(sizeof(UViewBase) == 0x0002C0, "Wrong size on UViewBase");
static_assert(offsetof(UViewBase, ViewOpenSettings) == 0x000278, "Member 'UViewBase::ViewOpenSettings' has a wrong offset!");
static_assert(offsetof(UViewBase, WidgetName) == 0x0002B0, "Member 'UViewBase::WidgetName' has a wrong offset!");

// Class Stalker2.InteractViewDots
// 0x0028 (0x02E8 - 0x02C0)
class UInteractViewDots final : public UViewBase
{
public:
	class UCanvasPanel*                           HintCanvas;                                        // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImageWidget*                           HintDot;                                           // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UImageWidget*>                   HintDots;                                          // 0x02D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractViewDots">();
	}
	static class UInteractViewDots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractViewDots>();
	}
};
static_assert(alignof(UInteractViewDots) == 0x000008, "Wrong alignment on UInteractViewDots");
static_assert(sizeof(UInteractViewDots) == 0x0002E8, "Wrong size on UInteractViewDots");
static_assert(offsetof(UInteractViewDots, HintCanvas) == 0x0002C0, "Member 'UInteractViewDots::HintCanvas' has a wrong offset!");
static_assert(offsetof(UInteractViewDots, HintDot) == 0x0002C8, "Member 'UInteractViewDots::HintDot' has a wrong offset!");
static_assert(offsetof(UInteractViewDots, HintDots) == 0x0002D0, "Member 'UInteractViewDots::HintDots' has a wrong offset!");

// Class Stalker2.SettingElementInput
// 0x00D0 (0x1E50 - 0x1D80)
class USettingElementInput : public USettingElement
{
public:
	class UHintImageKeyboard*                     LeftHintImage;                                     // 0x1D80(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintImageKeyboard*                     RightHintImage;                                    // 0x1D88(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMappingContext                               MappingContext;                                    // 0x1D90(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D94[0x7C];                                    // 0x1D94(0x007C)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PopupDescription;                                  // 0x1E10(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PopupTitle;                                        // 0x1E20(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PopupApplyHintSID;                                 // 0x1E30(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PopupCancelHintSID;                                // 0x1E40(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingElementInput">();
	}
	static class USettingElementInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingElementInput>();
	}
};
static_assert(alignof(USettingElementInput) == 0x000010, "Wrong alignment on USettingElementInput");
static_assert(sizeof(USettingElementInput) == 0x001E50, "Wrong size on USettingElementInput");
static_assert(offsetof(USettingElementInput, LeftHintImage) == 0x001D80, "Member 'USettingElementInput::LeftHintImage' has a wrong offset!");
static_assert(offsetof(USettingElementInput, RightHintImage) == 0x001D88, "Member 'USettingElementInput::RightHintImage' has a wrong offset!");
static_assert(offsetof(USettingElementInput, MappingContext) == 0x001D90, "Member 'USettingElementInput::MappingContext' has a wrong offset!");
static_assert(offsetof(USettingElementInput, PopupDescription) == 0x001E10, "Member 'USettingElementInput::PopupDescription' has a wrong offset!");
static_assert(offsetof(USettingElementInput, PopupTitle) == 0x001E20, "Member 'USettingElementInput::PopupTitle' has a wrong offset!");
static_assert(offsetof(USettingElementInput, PopupApplyHintSID) == 0x001E30, "Member 'USettingElementInput::PopupApplyHintSID' has a wrong offset!");
static_assert(offsetof(USettingElementInput, PopupCancelHintSID) == 0x001E40, "Member 'USettingElementInput::PopupCancelHintSID' has a wrong offset!");

// Class Stalker2.SettingElementBindedInput
// 0x0010 (0x1E60 - 0x1E50)
class USettingElementBindedInput final : public USettingElementInput
{
public:
	uint8                                         Pad_1E50[0x10];                                    // 0x1E50(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingElementBindedInput">();
	}
	static class USettingElementBindedInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingElementBindedInput>();
	}
};
static_assert(alignof(USettingElementBindedInput) == 0x000010, "Wrong alignment on USettingElementBindedInput");
static_assert(sizeof(USettingElementBindedInput) == 0x001E60, "Wrong size on USettingElementBindedInput");

// Class Stalker2.AnimNotify_SpawnNiagaraSystemAtLocationContextualAction
// 0x0018 (0x0058 - 0x0040)
class UAnimNotify_SpawnNiagaraSystemAtLocationContextualAction final : public UAnimNotifyBase
{
public:
	struct FSpawnNiagaraSystemAtLocation          SpawnNiagaraSystemAtLocation;                      // 0x0040(0x0018)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SpawnNiagaraSystemAtLocationContextualAction">();
	}
	static class UAnimNotify_SpawnNiagaraSystemAtLocationContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SpawnNiagaraSystemAtLocationContextualAction>();
	}
};
static_assert(alignof(UAnimNotify_SpawnNiagaraSystemAtLocationContextualAction) == 0x000008, "Wrong alignment on UAnimNotify_SpawnNiagaraSystemAtLocationContextualAction");
static_assert(sizeof(UAnimNotify_SpawnNiagaraSystemAtLocationContextualAction) == 0x000058, "Wrong size on UAnimNotify_SpawnNiagaraSystemAtLocationContextualAction");
static_assert(offsetof(UAnimNotify_SpawnNiagaraSystemAtLocationContextualAction, SpawnNiagaraSystemAtLocation) == 0x000040, "Member 'UAnimNotify_SpawnNiagaraSystemAtLocationContextualAction::SpawnNiagaraSystemAtLocation' has a wrong offset!");

// Class Stalker2.AchievementTracker_CatchingUp
// 0x0008 (0x0040 - 0x0038)
class UAchievementTracker_CatchingUp final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_CatchingUp">();
	}
	static class UAchievementTracker_CatchingUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_CatchingUp>();
	}
};
static_assert(alignof(UAchievementTracker_CatchingUp) == 0x000008, "Wrong alignment on UAchievementTracker_CatchingUp");
static_assert(sizeof(UAchievementTracker_CatchingUp) == 0x000040, "Wrong size on UAchievementTracker_CatchingUp");

// Class Stalker2.ForceFeedbackSubsystem
// 0x00C8 (0x00F8 - 0x0030)
class UForceFeedbackSubsystem final : public ULocalPlayerSubsystem
{
public:
	class UForceFeedbackDataAsset*                DataAsset;                                         // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FProcessorsArray> ActiveProcessors;                             // 0x0038(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FProcessorsArray> DelayedProcessors;                            // 0x0088(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BP_StartFeedback(const struct FGameplayTag& Trigger, const struct FForceFeedbackArgs& Args, const float InIntensityMultiplier, const bool bOverrideStopCurrent, const bool bStopCurrent);
	void SetIntensityMultiplier(const float NewValue);
	void StopAll();
	bool StopFeedback(const struct FGameplayTag& Trigger);

	float GetIntensityMultiplier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceFeedbackSubsystem">();
	}
	static class UForceFeedbackSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceFeedbackSubsystem>();
	}
};
static_assert(alignof(UForceFeedbackSubsystem) == 0x000008, "Wrong alignment on UForceFeedbackSubsystem");
static_assert(sizeof(UForceFeedbackSubsystem) == 0x0000F8, "Wrong size on UForceFeedbackSubsystem");
static_assert(offsetof(UForceFeedbackSubsystem, DataAsset) == 0x000030, "Member 'UForceFeedbackSubsystem::DataAsset' has a wrong offset!");
static_assert(offsetof(UForceFeedbackSubsystem, ActiveProcessors) == 0x000038, "Member 'UForceFeedbackSubsystem::ActiveProcessors' has a wrong offset!");
static_assert(offsetof(UForceFeedbackSubsystem, DelayedProcessors) == 0x000088, "Member 'UForceFeedbackSubsystem::DelayedProcessors' has a wrong offset!");

// Class Stalker2.AIUpdateDecisionAsyncManager
// 0x0140 (0x01E8 - 0x00A8)
class UAIUpdateDecisionAsyncManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x140];                                     // 0x00A8(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIUpdateDecisionAsyncManager">();
	}
	static class UAIUpdateDecisionAsyncManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIUpdateDecisionAsyncManager>();
	}
};
static_assert(alignof(UAIUpdateDecisionAsyncManager) == 0x000008, "Wrong alignment on UAIUpdateDecisionAsyncManager");
static_assert(sizeof(UAIUpdateDecisionAsyncManager) == 0x0001E8, "Wrong size on UAIUpdateDecisionAsyncManager");

// Class Stalker2.AimIPU
// 0x0000 (0x0058 - 0x0058)
class UAimIPU final : public UBehaviorBasedIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimIPU">();
	}
	static class UAimIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimIPU>();
	}
};
static_assert(alignof(UAimIPU) == 0x000008, "Wrong alignment on UAimIPU");
static_assert(sizeof(UAimIPU) == 0x000058, "Wrong size on UAimIPU");

// Class Stalker2.AnimNotify_RelaxToStandFinished
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_RelaxToStandFinished final : public UAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_RelaxToStandFinished">();
	}
	static class UAnimNotify_RelaxToStandFinished* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_RelaxToStandFinished>();
	}
};
static_assert(alignof(UAnimNotify_RelaxToStandFinished) == 0x000008, "Wrong alignment on UAnimNotify_RelaxToStandFinished");
static_assert(sizeof(UAnimNotify_RelaxToStandFinished) == 0x000040, "Wrong size on UAnimNotify_RelaxToStandFinished");

// Class Stalker2.AimProcessorComponent
// 0x0018 (0x00B8 - 0x00A0)
class UAimProcessorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimProcessorComponent">();
	}
	static class UAimProcessorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimProcessorComponent>();
	}
};
static_assert(alignof(UAimProcessorComponent) == 0x000008, "Wrong alignment on UAimProcessorComponent");
static_assert(sizeof(UAimProcessorComponent) == 0x0000B8, "Wrong size on UAimProcessorComponent");

// Class Stalker2.VATAnimationsConfig
// 0x0030 (0x0060 - 0x0030)
class UVATAnimationsConfig final : public UPrimaryDataAsset
{
public:
	class FName                                   MaterialNextAnimPropertyName;                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialNextAnimLastFramePropertyName;             // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialPrevAnimPropertyName;                      // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialAnimBlendingPropertyName;                  // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVATAnimation>                  Animations;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VATAnimationsConfig">();
	}
	static class UVATAnimationsConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVATAnimationsConfig>();
	}
};
static_assert(alignof(UVATAnimationsConfig) == 0x000008, "Wrong alignment on UVATAnimationsConfig");
static_assert(sizeof(UVATAnimationsConfig) == 0x000060, "Wrong size on UVATAnimationsConfig");
static_assert(offsetof(UVATAnimationsConfig, MaterialNextAnimPropertyName) == 0x000030, "Member 'UVATAnimationsConfig::MaterialNextAnimPropertyName' has a wrong offset!");
static_assert(offsetof(UVATAnimationsConfig, MaterialNextAnimLastFramePropertyName) == 0x000038, "Member 'UVATAnimationsConfig::MaterialNextAnimLastFramePropertyName' has a wrong offset!");
static_assert(offsetof(UVATAnimationsConfig, MaterialPrevAnimPropertyName) == 0x000040, "Member 'UVATAnimationsConfig::MaterialPrevAnimPropertyName' has a wrong offset!");
static_assert(offsetof(UVATAnimationsConfig, MaterialAnimBlendingPropertyName) == 0x000048, "Member 'UVATAnimationsConfig::MaterialAnimBlendingPropertyName' has a wrong offset!");
static_assert(offsetof(UVATAnimationsConfig, Animations) == 0x000050, "Member 'UVATAnimationsConfig::Animations' has a wrong offset!");

// Class Stalker2.SelectionVolumeBase
// 0x0008 (0x02A0 - 0x0298)
class ASelectionVolumeBase : public AActor
{
public:
	class UShapeComponent*                        CollisionComponent;                                // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectionVolumeBase">();
	}
	static class ASelectionVolumeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASelectionVolumeBase>();
	}
};
static_assert(alignof(ASelectionVolumeBase) == 0x000008, "Wrong alignment on ASelectionVolumeBase");
static_assert(sizeof(ASelectionVolumeBase) == 0x0002A0, "Wrong size on ASelectionVolumeBase");
static_assert(offsetof(ASelectionVolumeBase, CollisionComponent) == 0x000298, "Member 'ASelectionVolumeBase::CollisionComponent' has a wrong offset!");

// Class Stalker2.AITickComponent
// 0x0000 (0x00A0 - 0x00A0)
class UAITickComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITickComponent">();
	}
	static class UAITickComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITickComponent>();
	}
};
static_assert(alignof(UAITickComponent) == 0x000008, "Wrong alignment on UAITickComponent");
static_assert(sizeof(UAITickComponent) == 0x0000A0, "Wrong size on UAITickComponent");

// Class Stalker2.ScarBossComponent
// 0x00A8 (0x0148 - 0x00A0)
class UScarBossComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScarPhaseData>                 Phases;                                            // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FPrototypeSID                          StunMeshGenerator;                                 // 0x00B8(0x0040)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x50];                                      // 0x00F8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScarBossComponent">();
	}
	static class UScarBossComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScarBossComponent>();
	}
};
static_assert(alignof(UScarBossComponent) == 0x000008, "Wrong alignment on UScarBossComponent");
static_assert(sizeof(UScarBossComponent) == 0x000148, "Wrong size on UScarBossComponent");
static_assert(offsetof(UScarBossComponent, Phases) == 0x0000A8, "Member 'UScarBossComponent::Phases' has a wrong offset!");
static_assert(offsetof(UScarBossComponent, StunMeshGenerator) == 0x0000B8, "Member 'UScarBossComponent::StunMeshGenerator' has a wrong offset!");

// Class Stalker2.EditorItemContainer
// 0x0048 (0x02E0 - 0x0298)
class AEditorItemContainer final : public AActor
{
public:
	class FString                                 ConfigSID;                                         // 0x0298(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 BaseItemContainerPrototypeSID;                     // 0x02A8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MeshPath;                                          // 0x02B8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSpawnedItem>                   SimpleItems;                                       // 0x02C8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EMeshSubType                                  ItemContainerType;                                 // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorItemContainer">();
	}
	static class AEditorItemContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEditorItemContainer>();
	}
};
static_assert(alignof(AEditorItemContainer) == 0x000008, "Wrong alignment on AEditorItemContainer");
static_assert(sizeof(AEditorItemContainer) == 0x0002E0, "Wrong size on AEditorItemContainer");
static_assert(offsetof(AEditorItemContainer, ConfigSID) == 0x000298, "Member 'AEditorItemContainer::ConfigSID' has a wrong offset!");
static_assert(offsetof(AEditorItemContainer, BaseItemContainerPrototypeSID) == 0x0002A8, "Member 'AEditorItemContainer::BaseItemContainerPrototypeSID' has a wrong offset!");
static_assert(offsetof(AEditorItemContainer, MeshPath) == 0x0002B8, "Member 'AEditorItemContainer::MeshPath' has a wrong offset!");
static_assert(offsetof(AEditorItemContainer, SimpleItems) == 0x0002C8, "Member 'AEditorItemContainer::SimpleItems' has a wrong offset!");
static_assert(offsetof(AEditorItemContainer, ItemContainerType) == 0x0002D8, "Member 'AEditorItemContainer::ItemContainerType' has a wrong offset!");

// Class Stalker2.Physible
// 0x0000 (0x0000 - 0x0000)
class IPhysible final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Physible">();
	}
	static class IPhysible* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPhysible>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPhysible) == 0x000001, "Wrong alignment on IPhysible");
static_assert(sizeof(IPhysible) == 0x000001, "Wrong size on IPhysible");

// Class Stalker2.AITickManager
// 0x0000 (0x00A8 - 0x00A8)
class UAITickManager final : public UBaseTickableManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITickManager">();
	}
	static class UAITickManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITickManager>();
	}
};
static_assert(alignof(UAITickManager) == 0x000008, "Wrong alignment on UAITickManager");
static_assert(sizeof(UAITickManager) == 0x0000A8, "Wrong size on UAITickManager");

// Class Stalker2.QuickSlot
// 0x01E0 (0x0458 - 0x0278)
class UQuickSlot final : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x90];                                     // 0x0278(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UImageWidget*                           Icon;                                              // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Background;                                        // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 DefaultImage;                                      // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 UseFrame;                                          // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ShouldUseFrame;                                    // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 HighlightImage;                                    // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            ItemCountText;                                     // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               IconSizeBox;                                       // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 InventoryHighlightImage;                           // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ClickAnimation;                                    // 0x0350(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ShouldUseAnimation;                                // 0x0358(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             BackgroundTexture;                                 // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             UseFrameTexture;                                   // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ShouldUseFrameTexture;                             // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DefaultIconTexture;                                // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             InventoryHighlightTexture;                         // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QuickSlotSize;                                     // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconSize;                                          // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableHint;                                       // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableCountText;                                  // 0x0399(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableTransparency;                               // 0x039A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableClickAnimation;                             // 0x039B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableShouldUseAnimation;                         // 0x039C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39D[0x3];                                      // 0x039D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   IconOnTextureParam;                                // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowTransparency;                                   // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HighTransparency;                                  // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClickAnimationSpeed;                               // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShouldUseAnimationSpeed;                           // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShouldUseAnimationDuration;                        // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShouldUseAnimationCooldown;                        // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ESortGroup, TSoftObjectPtr<class UTexture2D>> SortGroupToIconMap;                           // 0x03C0(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UImage*                                 SlotTypeIcon;                                      // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x40];                                     // 0x0418(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StopCooldown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickSlot">();
	}
	static class UQuickSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickSlot>();
	}
};
static_assert(alignof(UQuickSlot) == 0x000008, "Wrong alignment on UQuickSlot");
static_assert(sizeof(UQuickSlot) == 0x000458, "Wrong size on UQuickSlot");
static_assert(offsetof(UQuickSlot, Icon) == 0x000308, "Member 'UQuickSlot::Icon' has a wrong offset!");
static_assert(offsetof(UQuickSlot, Background) == 0x000310, "Member 'UQuickSlot::Background' has a wrong offset!");
static_assert(offsetof(UQuickSlot, DefaultImage) == 0x000318, "Member 'UQuickSlot::DefaultImage' has a wrong offset!");
static_assert(offsetof(UQuickSlot, UseFrame) == 0x000320, "Member 'UQuickSlot::UseFrame' has a wrong offset!");
static_assert(offsetof(UQuickSlot, ShouldUseFrame) == 0x000328, "Member 'UQuickSlot::ShouldUseFrame' has a wrong offset!");
static_assert(offsetof(UQuickSlot, HighlightImage) == 0x000330, "Member 'UQuickSlot::HighlightImage' has a wrong offset!");
static_assert(offsetof(UQuickSlot, ItemCountText) == 0x000338, "Member 'UQuickSlot::ItemCountText' has a wrong offset!");
static_assert(offsetof(UQuickSlot, IconSizeBox) == 0x000340, "Member 'UQuickSlot::IconSizeBox' has a wrong offset!");
static_assert(offsetof(UQuickSlot, InventoryHighlightImage) == 0x000348, "Member 'UQuickSlot::InventoryHighlightImage' has a wrong offset!");
static_assert(offsetof(UQuickSlot, ClickAnimation) == 0x000350, "Member 'UQuickSlot::ClickAnimation' has a wrong offset!");
static_assert(offsetof(UQuickSlot, ShouldUseAnimation) == 0x000358, "Member 'UQuickSlot::ShouldUseAnimation' has a wrong offset!");
static_assert(offsetof(UQuickSlot, SlotIndex) == 0x000360, "Member 'UQuickSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(UQuickSlot, BackgroundTexture) == 0x000368, "Member 'UQuickSlot::BackgroundTexture' has a wrong offset!");
static_assert(offsetof(UQuickSlot, UseFrameTexture) == 0x000370, "Member 'UQuickSlot::UseFrameTexture' has a wrong offset!");
static_assert(offsetof(UQuickSlot, ShouldUseFrameTexture) == 0x000378, "Member 'UQuickSlot::ShouldUseFrameTexture' has a wrong offset!");
static_assert(offsetof(UQuickSlot, DefaultIconTexture) == 0x000380, "Member 'UQuickSlot::DefaultIconTexture' has a wrong offset!");
static_assert(offsetof(UQuickSlot, InventoryHighlightTexture) == 0x000388, "Member 'UQuickSlot::InventoryHighlightTexture' has a wrong offset!");
static_assert(offsetof(UQuickSlot, QuickSlotSize) == 0x000390, "Member 'UQuickSlot::QuickSlotSize' has a wrong offset!");
static_assert(offsetof(UQuickSlot, IconSize) == 0x000394, "Member 'UQuickSlot::IconSize' has a wrong offset!");
static_assert(offsetof(UQuickSlot, bEnableHint) == 0x000398, "Member 'UQuickSlot::bEnableHint' has a wrong offset!");
static_assert(offsetof(UQuickSlot, bEnableCountText) == 0x000399, "Member 'UQuickSlot::bEnableCountText' has a wrong offset!");
static_assert(offsetof(UQuickSlot, bEnableTransparency) == 0x00039A, "Member 'UQuickSlot::bEnableTransparency' has a wrong offset!");
static_assert(offsetof(UQuickSlot, bEnableClickAnimation) == 0x00039B, "Member 'UQuickSlot::bEnableClickAnimation' has a wrong offset!");
static_assert(offsetof(UQuickSlot, bEnableShouldUseAnimation) == 0x00039C, "Member 'UQuickSlot::bEnableShouldUseAnimation' has a wrong offset!");
static_assert(offsetof(UQuickSlot, IconOnTextureParam) == 0x0003A0, "Member 'UQuickSlot::IconOnTextureParam' has a wrong offset!");
static_assert(offsetof(UQuickSlot, LowTransparency) == 0x0003A8, "Member 'UQuickSlot::LowTransparency' has a wrong offset!");
static_assert(offsetof(UQuickSlot, HighTransparency) == 0x0003AC, "Member 'UQuickSlot::HighTransparency' has a wrong offset!");
static_assert(offsetof(UQuickSlot, ClickAnimationSpeed) == 0x0003B0, "Member 'UQuickSlot::ClickAnimationSpeed' has a wrong offset!");
static_assert(offsetof(UQuickSlot, ShouldUseAnimationSpeed) == 0x0003B4, "Member 'UQuickSlot::ShouldUseAnimationSpeed' has a wrong offset!");
static_assert(offsetof(UQuickSlot, ShouldUseAnimationDuration) == 0x0003B8, "Member 'UQuickSlot::ShouldUseAnimationDuration' has a wrong offset!");
static_assert(offsetof(UQuickSlot, ShouldUseAnimationCooldown) == 0x0003BC, "Member 'UQuickSlot::ShouldUseAnimationCooldown' has a wrong offset!");
static_assert(offsetof(UQuickSlot, SortGroupToIconMap) == 0x0003C0, "Member 'UQuickSlot::SortGroupToIconMap' has a wrong offset!");
static_assert(offsetof(UQuickSlot, SlotTypeIcon) == 0x000410, "Member 'UQuickSlot::SlotTypeIcon' has a wrong offset!");

// Class Stalker2.AIVisionUpdateSubsystem
// 0x0100 (0x0178 - 0x0078)
class UAIVisionUpdateSubsystem final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x100];                                     // 0x0078(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIVisionUpdateSubsystem">();
	}
	static class UAIVisionUpdateSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIVisionUpdateSubsystem>();
	}
};
static_assert(alignof(UAIVisionUpdateSubsystem) == 0x000008, "Wrong alignment on UAIVisionUpdateSubsystem");
static_assert(sizeof(UAIVisionUpdateSubsystem) == 0x000178, "Wrong size on UAIVisionUpdateSubsystem");

// Class Stalker2.ALifePOISubsystem
// 0x00C0 (0x0100 - 0x0040)
class UALifePOISubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0xC0];                                      // 0x0040(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ALifePOISubsystem">();
	}
	static class UALifePOISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UALifePOISubsystem>();
	}
};
static_assert(alignof(UALifePOISubsystem) == 0x000008, "Wrong alignment on UALifePOISubsystem");
static_assert(sizeof(UALifePOISubsystem) == 0x000100, "Wrong size on UALifePOISubsystem");

// Class Stalker2.SaveScreenSubView
// 0x00C0 (0x0390 - 0x02D0)
class USaveScreenSubView final : public UMenuSubViewBase
{
public:
	class USaveLoadActionBase*                    SaveButtonActionPrototype;                         // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMenuButtonBase>            SaveButtonStyleClass;                              // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FShortcutData>                  SaveButtonShortcuts;                               // 0x02E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USaveLoadActionBase*                    NewSaveButtonActionPrototype;                      // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMenuButtonBase>            NewSaveButtonStyleClass;                           // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMenuButtonBase>            BlockedButtonStyleClass;                           // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FShortcutData>                  NewSaveButtonShortcuts;                            // 0x0308(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<ESaveType>                               SaveTypesToShow;                                   // 0x0318(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bLoadPage;                                         // 0x0368(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMenuButtonActionBase*                  BlockedSaveButtonAction;                           // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuButtonActionBase*                  SaveButtonAction;                                  // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuNavigationPanelBase*               NavigationPanel;                                   // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNavigationButtonPressed(const int32 InButtonIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveScreenSubView">();
	}
	static class USaveScreenSubView* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveScreenSubView>();
	}
};
static_assert(alignof(USaveScreenSubView) == 0x000008, "Wrong alignment on USaveScreenSubView");
static_assert(sizeof(USaveScreenSubView) == 0x000390, "Wrong size on USaveScreenSubView");
static_assert(offsetof(USaveScreenSubView, SaveButtonActionPrototype) == 0x0002D0, "Member 'USaveScreenSubView::SaveButtonActionPrototype' has a wrong offset!");
static_assert(offsetof(USaveScreenSubView, SaveButtonStyleClass) == 0x0002D8, "Member 'USaveScreenSubView::SaveButtonStyleClass' has a wrong offset!");
static_assert(offsetof(USaveScreenSubView, SaveButtonShortcuts) == 0x0002E0, "Member 'USaveScreenSubView::SaveButtonShortcuts' has a wrong offset!");
static_assert(offsetof(USaveScreenSubView, NewSaveButtonActionPrototype) == 0x0002F0, "Member 'USaveScreenSubView::NewSaveButtonActionPrototype' has a wrong offset!");
static_assert(offsetof(USaveScreenSubView, NewSaveButtonStyleClass) == 0x0002F8, "Member 'USaveScreenSubView::NewSaveButtonStyleClass' has a wrong offset!");
static_assert(offsetof(USaveScreenSubView, BlockedButtonStyleClass) == 0x000300, "Member 'USaveScreenSubView::BlockedButtonStyleClass' has a wrong offset!");
static_assert(offsetof(USaveScreenSubView, NewSaveButtonShortcuts) == 0x000308, "Member 'USaveScreenSubView::NewSaveButtonShortcuts' has a wrong offset!");
static_assert(offsetof(USaveScreenSubView, SaveTypesToShow) == 0x000318, "Member 'USaveScreenSubView::SaveTypesToShow' has a wrong offset!");
static_assert(offsetof(USaveScreenSubView, bLoadPage) == 0x000368, "Member 'USaveScreenSubView::bLoadPage' has a wrong offset!");
static_assert(offsetof(USaveScreenSubView, BlockedSaveButtonAction) == 0x000370, "Member 'USaveScreenSubView::BlockedSaveButtonAction' has a wrong offset!");
static_assert(offsetof(USaveScreenSubView, SaveButtonAction) == 0x000378, "Member 'USaveScreenSubView::SaveButtonAction' has a wrong offset!");
static_assert(offsetof(USaveScreenSubView, NavigationPanel) == 0x000380, "Member 'USaveScreenSubView::NavigationPanel' has a wrong offset!");

// Class Stalker2.GAPlayerProcessorInterface
// 0x0000 (0x0028 - 0x0028)
class UGAPlayerProcessorInterface : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAPlayerProcessorInterface">();
	}
	static class UGAPlayerProcessorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAPlayerProcessorInterface>();
	}
};
static_assert(alignof(UGAPlayerProcessorInterface) == 0x000008, "Wrong alignment on UGAPlayerProcessorInterface");
static_assert(sizeof(UGAPlayerProcessorInterface) == 0x000028, "Wrong size on UGAPlayerProcessorInterface");

// Class Stalker2.GADialogueActionProcessor
// 0x0038 (0x0060 - 0x0028)
class UGADialogueActionProcessor final : public UGAPlayerProcessorInterface
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GADialogueActionProcessor">();
	}
	static class UGADialogueActionProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGADialogueActionProcessor>();
	}
};
static_assert(alignof(UGADialogueActionProcessor) == 0x000008, "Wrong alignment on UGADialogueActionProcessor");
static_assert(sizeof(UGADialogueActionProcessor) == 0x000060, "Wrong size on UGADialogueActionProcessor");

// Class Stalker2.ALifePopulationManager
// 0x0068 (0x0110 - 0x00A8)
class UALifePopulationManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x68];                                      // 0x00A8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ALifePopulationManager">();
	}
	static class UALifePopulationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UALifePopulationManager>();
	}
};
static_assert(alignof(UALifePopulationManager) == 0x000008, "Wrong alignment on UALifePopulationManager");
static_assert(sizeof(UALifePopulationManager) == 0x000110, "Wrong size on UALifePopulationManager");

// Class Stalker2.SettingsNavigationPanel
// 0x0018 (0x0290 - 0x0278)
class USettingsNavigationPanel final : public UWidgetBase
{
public:
	class UPanelWidget*                           SlotContainer;                                     // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScrollBox*                             NavPanelScroll;                                    // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsNavigationPanel">();
	}
	static class USettingsNavigationPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsNavigationPanel>();
	}
};
static_assert(alignof(USettingsNavigationPanel) == 0x000008, "Wrong alignment on USettingsNavigationPanel");
static_assert(sizeof(USettingsNavigationPanel) == 0x000290, "Wrong size on USettingsNavigationPanel");
static_assert(offsetof(USettingsNavigationPanel, SlotContainer) == 0x000278, "Member 'USettingsNavigationPanel::SlotContainer' has a wrong offset!");
static_assert(offsetof(USettingsNavigationPanel, NavPanelScroll) == 0x000280, "Member 'USettingsNavigationPanel::NavPanelScroll' has a wrong offset!");

// Class Stalker2.UpgradesIPU
// 0x0000 (0x0040 - 0x0040)
class UUpgradesIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpgradesIPU">();
	}
	static class UUpgradesIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpgradesIPU>();
	}
};
static_assert(alignof(UUpgradesIPU) == 0x000008, "Wrong alignment on UUpgradesIPU");
static_assert(sizeof(UUpgradesIPU) == 0x000040, "Wrong size on UUpgradesIPU");

// Class Stalker2.EnemyBillboardSubsystem
// 0x0058 (0x0088 - 0x0030)
class UEnemyBillboardSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyBillboardSubsystem">();
	}
	static class UEnemyBillboardSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyBillboardSubsystem>();
	}
};
static_assert(alignof(UEnemyBillboardSubsystem) == 0x000008, "Wrong alignment on UEnemyBillboardSubsystem");
static_assert(sizeof(UEnemyBillboardSubsystem) == 0x000088, "Wrong size on UEnemyBillboardSubsystem");

// Class Stalker2.AmmoWidget
// 0x0138 (0x03B0 - 0x0278)
class UAmmoWidget final : public UChildViewBase
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             AmmoCount;                                         // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             AmmoCountMax;                                      // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Divider;                                           // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             CaliberText;                                       // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImageWidget*                           AmmoIcon;                                          // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         AmmoCounter;                                       // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         FireTypeCounter;                                   // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           AmmoTypeList;                                      // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFireTypeWidget*                        GrenadeLauncherIcon;                               // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 GrenadeLauncherDivider;                            // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AnimAmmoHide;                                      // 0x02E0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AnimAmmoShow;                                      // 0x02E8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAmmoWidgetSettingsAsset*               AmmoWidgetSettings;                                // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryNew*                          InventoryNew;                                      // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTradeView*                             TradeView;                                         // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFireTypeWidget*>                FireTypeWidgets;                                   // 0x0320(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x80];                                     // 0x0330(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoWidget">();
	}
	static class UAmmoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmmoWidget>();
	}
};
static_assert(alignof(UAmmoWidget) == 0x000008, "Wrong alignment on UAmmoWidget");
static_assert(sizeof(UAmmoWidget) == 0x0003B0, "Wrong size on UAmmoWidget");
static_assert(offsetof(UAmmoWidget, AmmoCount) == 0x000290, "Member 'UAmmoWidget::AmmoCount' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, AmmoCountMax) == 0x000298, "Member 'UAmmoWidget::AmmoCountMax' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, Divider) == 0x0002A0, "Member 'UAmmoWidget::Divider' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, CaliberText) == 0x0002A8, "Member 'UAmmoWidget::CaliberText' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, AmmoIcon) == 0x0002B0, "Member 'UAmmoWidget::AmmoIcon' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, AmmoCounter) == 0x0002B8, "Member 'UAmmoWidget::AmmoCounter' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, FireTypeCounter) == 0x0002C0, "Member 'UAmmoWidget::FireTypeCounter' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, AmmoTypeList) == 0x0002C8, "Member 'UAmmoWidget::AmmoTypeList' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, GrenadeLauncherIcon) == 0x0002D0, "Member 'UAmmoWidget::GrenadeLauncherIcon' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, GrenadeLauncherDivider) == 0x0002D8, "Member 'UAmmoWidget::GrenadeLauncherDivider' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, AnimAmmoHide) == 0x0002E0, "Member 'UAmmoWidget::AnimAmmoHide' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, AnimAmmoShow) == 0x0002E8, "Member 'UAmmoWidget::AnimAmmoShow' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, AmmoWidgetSettings) == 0x0002F0, "Member 'UAmmoWidget::AmmoWidgetSettings' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, InventoryNew) == 0x000300, "Member 'UAmmoWidget::InventoryNew' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, TradeView) == 0x000308, "Member 'UAmmoWidget::TradeView' has a wrong offset!");
static_assert(offsetof(UAmmoWidget, FireTypeWidgets) == 0x000320, "Member 'UAmmoWidget::FireTypeWidgets' has a wrong offset!");

// Class Stalker2.ViewBaseExtended
// 0x0008 (0x02C8 - 0x02C0)
class UViewBaseExtended : public UViewBase
{
public:
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViewBaseExtended">();
	}
	static class UViewBaseExtended* GetDefaultObj()
	{
		return GetDefaultObjImpl<UViewBaseExtended>();
	}
};
static_assert(alignof(UViewBaseExtended) == 0x000008, "Wrong alignment on UViewBaseExtended");
static_assert(sizeof(UViewBaseExtended) == 0x0002C8, "Wrong size on UViewBaseExtended");

// Class Stalker2.SleepView
// 0x0008 (0x02D0 - 0x02C8)
class USleepView final : public UViewBaseExtended
{
public:
	class UWidgetAnimation*                       FadeAnimation;                                     // 0x02C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SleepView">();
	}
	static class USleepView* GetDefaultObj()
	{
		return GetDefaultObjImpl<USleepView>();
	}
};
static_assert(alignof(USleepView) == 0x000008, "Wrong alignment on USleepView");
static_assert(sizeof(USleepView) == 0x0002D0, "Wrong size on USleepView");
static_assert(offsetof(USleepView, FadeAnimation) == 0x0002C8, "Member 'USleepView::FadeAnimation' has a wrong offset!");

// Class Stalker2.AmmoWidgetSettingsAsset
// 0x0090 (0x00C0 - 0x0030)
class UAmmoWidgetSettingsAsset final : public UDataAsset
{
public:
	float                                         MinAmmoCount;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EFireType, class UTexture*>              FireIcons;                                         // 0x0038(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmmoTypeDotsActiveColor;                           // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmmoTypeDotsUnactiveColor;                         // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimAmmoHideSpeed;                                 // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimAmmoShowSpeed;                                 // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AnimAmmoColor;                                     // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoWidgetSettingsAsset">();
	}
	static class UAmmoWidgetSettingsAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmmoWidgetSettingsAsset>();
	}
};
static_assert(alignof(UAmmoWidgetSettingsAsset) == 0x000008, "Wrong alignment on UAmmoWidgetSettingsAsset");
static_assert(sizeof(UAmmoWidgetSettingsAsset) == 0x0000C0, "Wrong size on UAmmoWidgetSettingsAsset");
static_assert(offsetof(UAmmoWidgetSettingsAsset, MinAmmoCount) == 0x000030, "Member 'UAmmoWidgetSettingsAsset::MinAmmoCount' has a wrong offset!");
static_assert(offsetof(UAmmoWidgetSettingsAsset, FireIcons) == 0x000038, "Member 'UAmmoWidgetSettingsAsset::FireIcons' has a wrong offset!");
static_assert(offsetof(UAmmoWidgetSettingsAsset, AmmoTypeDotsActiveColor) == 0x000088, "Member 'UAmmoWidgetSettingsAsset::AmmoTypeDotsActiveColor' has a wrong offset!");
static_assert(offsetof(UAmmoWidgetSettingsAsset, AmmoTypeDotsUnactiveColor) == 0x000098, "Member 'UAmmoWidgetSettingsAsset::AmmoTypeDotsUnactiveColor' has a wrong offset!");
static_assert(offsetof(UAmmoWidgetSettingsAsset, AnimAmmoHideSpeed) == 0x0000A8, "Member 'UAmmoWidgetSettingsAsset::AnimAmmoHideSpeed' has a wrong offset!");
static_assert(offsetof(UAmmoWidgetSettingsAsset, AnimAmmoShowSpeed) == 0x0000AC, "Member 'UAmmoWidgetSettingsAsset::AnimAmmoShowSpeed' has a wrong offset!");
static_assert(offsetof(UAmmoWidgetSettingsAsset, AnimAmmoColor) == 0x0000B0, "Member 'UAmmoWidgetSettingsAsset::AnimAmmoColor' has a wrong offset!");

// Class Stalker2.GAPlayerProcessorBase
// 0x0020 (0x0048 - 0x0028)
class UGAPlayerProcessorBase : public UGAPlayerProcessorInterface
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAPlayerProcessorBase">();
	}
	static class UGAPlayerProcessorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAPlayerProcessorBase>();
	}
};
static_assert(alignof(UGAPlayerProcessorBase) == 0x000008, "Wrong alignment on UGAPlayerProcessorBase");
static_assert(sizeof(UGAPlayerProcessorBase) == 0x000048, "Wrong size on UGAPlayerProcessorBase");

// Class Stalker2.GAInventoryStatusProcessor
// 0x0028 (0x0070 - 0x0048)
class UGAInventoryStatusProcessor final : public UGAPlayerProcessorBase
{
public:
	uint8                                         Pad_48[0x28];                                      // 0x0048(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAInventoryStatusProcessor">();
	}
	static class UGAInventoryStatusProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAInventoryStatusProcessor>();
	}
};
static_assert(alignof(UGAInventoryStatusProcessor) == 0x000008, "Wrong alignment on UGAInventoryStatusProcessor");
static_assert(sizeof(UGAInventoryStatusProcessor) == 0x000070, "Wrong size on UGAInventoryStatusProcessor");

// Class Stalker2.AnalyticsManager
// 0x02F8 (0x0370 - 0x0078)
class UAnalyticsManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x2F8];                                     // 0x0078(0x02F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnalyticsManager">();
	}
	static class UAnalyticsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnalyticsManager>();
	}
};
static_assert(alignof(UAnalyticsManager) == 0x000008, "Wrong alignment on UAnalyticsManager");
static_assert(sizeof(UAnalyticsManager) == 0x000370, "Wrong size on UAnalyticsManager");

// Class Stalker2.PhysicsSoundsComponent
// 0x00A0 (0x0140 - 0x00A0)
class UPhysicsSoundsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PhysicsInteractionPrototypeSID;                    // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PhysicalObjectAudioEventPlay;                      // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          PhysicalObjectAudioEventStop;                      // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         DraggingParameterSwitch;                           // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         RollingParameterSwitch;                            // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         HitParameterSwitch;                                // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                PhysicalObjectContinuousSpeedRTPC;                 // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                PhysicalObjectInstantSpeedRTPCParameter;           // 0x0100(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                WaterDepthRtpc;                                    // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           AkAudioComponent;                                  // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x28];                                     // 0x0118(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsSoundsComponent">();
	}
	static class UPhysicsSoundsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsSoundsComponent>();
	}
};
static_assert(alignof(UPhysicsSoundsComponent) == 0x000008, "Wrong alignment on UPhysicsSoundsComponent");
static_assert(sizeof(UPhysicsSoundsComponent) == 0x000140, "Wrong size on UPhysicsSoundsComponent");
static_assert(offsetof(UPhysicsSoundsComponent, PhysicsInteractionPrototypeSID) == 0x0000B8, "Member 'UPhysicsSoundsComponent::PhysicsInteractionPrototypeSID' has a wrong offset!");
static_assert(offsetof(UPhysicsSoundsComponent, PhysicalObjectAudioEventPlay) == 0x0000D0, "Member 'UPhysicsSoundsComponent::PhysicalObjectAudioEventPlay' has a wrong offset!");
static_assert(offsetof(UPhysicsSoundsComponent, PhysicalObjectAudioEventStop) == 0x0000D8, "Member 'UPhysicsSoundsComponent::PhysicalObjectAudioEventStop' has a wrong offset!");
static_assert(offsetof(UPhysicsSoundsComponent, DraggingParameterSwitch) == 0x0000E0, "Member 'UPhysicsSoundsComponent::DraggingParameterSwitch' has a wrong offset!");
static_assert(offsetof(UPhysicsSoundsComponent, RollingParameterSwitch) == 0x0000E8, "Member 'UPhysicsSoundsComponent::RollingParameterSwitch' has a wrong offset!");
static_assert(offsetof(UPhysicsSoundsComponent, HitParameterSwitch) == 0x0000F0, "Member 'UPhysicsSoundsComponent::HitParameterSwitch' has a wrong offset!");
static_assert(offsetof(UPhysicsSoundsComponent, PhysicalObjectContinuousSpeedRTPC) == 0x0000F8, "Member 'UPhysicsSoundsComponent::PhysicalObjectContinuousSpeedRTPC' has a wrong offset!");
static_assert(offsetof(UPhysicsSoundsComponent, PhysicalObjectInstantSpeedRTPCParameter) == 0x000100, "Member 'UPhysicsSoundsComponent::PhysicalObjectInstantSpeedRTPCParameter' has a wrong offset!");
static_assert(offsetof(UPhysicsSoundsComponent, WaterDepthRtpc) == 0x000108, "Member 'UPhysicsSoundsComponent::WaterDepthRtpc' has a wrong offset!");
static_assert(offsetof(UPhysicsSoundsComponent, AkAudioComponent) == 0x000110, "Member 'UPhysicsSoundsComponent::AkAudioComponent' has a wrong offset!");

// Class Stalker2.EnvironmentNiagaraComponent
// 0x0000 (0x0830 - 0x0830)
class UEnvironmentNiagaraComponent : public UNiagaraComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentNiagaraComponent">();
	}
	static class UEnvironmentNiagaraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvironmentNiagaraComponent>();
	}
};
static_assert(alignof(UEnvironmentNiagaraComponent) == 0x000010, "Wrong alignment on UEnvironmentNiagaraComponent");
static_assert(sizeof(UEnvironmentNiagaraComponent) == 0x000830, "Wrong size on UEnvironmentNiagaraComponent");

// Class Stalker2.DynamicEnvironmentNiagaraComponent
// 0x0010 (0x0840 - 0x0830)
class UDynamicEnvironmentNiagaraComponent final : public UEnvironmentNiagaraComponent
{
public:
	uint8                                         Pad_830[0x10];                                     // 0x0830(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicEnvironmentNiagaraComponent">();
	}
	static class UDynamicEnvironmentNiagaraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicEnvironmentNiagaraComponent>();
	}
};
static_assert(alignof(UDynamicEnvironmentNiagaraComponent) == 0x000010, "Wrong alignment on UDynamicEnvironmentNiagaraComponent");
static_assert(sizeof(UDynamicEnvironmentNiagaraComponent) == 0x000840, "Wrong size on UDynamicEnvironmentNiagaraComponent");

// Class Stalker2.UIDActor_Door
// 0x0010 (0x02A8 - 0x0298)
class AUIDActor_Door : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActor_Door">();
	}
	static class AUIDActor_Door* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDActor_Door>();
	}
};
static_assert(alignof(AUIDActor_Door) == 0x000008, "Wrong alignment on AUIDActor_Door");
static_assert(sizeof(AUIDActor_Door) == 0x0002A8, "Wrong size on AUIDActor_Door");

// Class Stalker2.LockableComponent
// 0x0080 (0x0278 - 0x01F8)
class ULockableComponent : public USingleClickComponent
{
public:
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayAlternativeText;                            // 0x0200(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLockStruct                            LockStruct;                                        // 0x0210(0x0060)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bLocked;                                           // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockableComponent">();
	}
	static class ULockableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockableComponent>();
	}
};
static_assert(alignof(ULockableComponent) == 0x000008, "Wrong alignment on ULockableComponent");
static_assert(sizeof(ULockableComponent) == 0x000278, "Wrong size on ULockableComponent");
static_assert(offsetof(ULockableComponent, DisplayAlternativeText) == 0x000200, "Member 'ULockableComponent::DisplayAlternativeText' has a wrong offset!");
static_assert(offsetof(ULockableComponent, LockStruct) == 0x000210, "Member 'ULockableComponent::LockStruct' has a wrong offset!");
static_assert(offsetof(ULockableComponent, bLocked) == 0x000270, "Member 'ULockableComponent::bLocked' has a wrong offset!");

// Class Stalker2.PsyPhantomManager
// 0x0288 (0x0330 - 0x00A8)
class UPsyPhantomManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x288];                                     // 0x00A8(0x0288)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsyPhantomManager">();
	}
	static class UPsyPhantomManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsyPhantomManager>();
	}
};
static_assert(alignof(UPsyPhantomManager) == 0x000008, "Wrong alignment on UPsyPhantomManager");
static_assert(sizeof(UPsyPhantomManager) == 0x000330, "Wrong size on UPsyPhantomManager");

// Class Stalker2.FadeoutScreen
// 0x0038 (0x02F8 - 0x02C0)
class UFadeoutScreen final : public UViewBase
{
public:
	class UTextWidget*                            SpeakerNameText;                                   // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            SubtitleText;                                      // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               SpeakerNameContainer;                              // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 FadeoutImage;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UISkipFadeoutScreen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadeoutScreen">();
	}
	static class UFadeoutScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadeoutScreen>();
	}
};
static_assert(alignof(UFadeoutScreen) == 0x000008, "Wrong alignment on UFadeoutScreen");
static_assert(sizeof(UFadeoutScreen) == 0x0002F8, "Wrong size on UFadeoutScreen");
static_assert(offsetof(UFadeoutScreen, SpeakerNameText) == 0x0002C0, "Member 'UFadeoutScreen::SpeakerNameText' has a wrong offset!");
static_assert(offsetof(UFadeoutScreen, SubtitleText) == 0x0002C8, "Member 'UFadeoutScreen::SubtitleText' has a wrong offset!");
static_assert(offsetof(UFadeoutScreen, SpeakerNameContainer) == 0x0002D0, "Member 'UFadeoutScreen::SpeakerNameContainer' has a wrong offset!");
static_assert(offsetof(UFadeoutScreen, FadeoutImage) == 0x0002D8, "Member 'UFadeoutScreen::FadeoutImage' has a wrong offset!");

// Class Stalker2.ItemContainerInteractionComponent
// 0x0068 (0x02E0 - 0x0278)
class UItemContainerInteractionComponent : public ULockableComponent
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PresetItemContainerPrototypeID;                    // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_294[0x14];                                     // 0x0294(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkSwitchValue*                         StashTypeSwitch;                                   // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          OpenAudioEvent;                                    // 0x02B0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          CloseAudioEvent;                                   // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AObj*                                   InteractedActor;                                   // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x18];                                     // 0x02C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemContainerInteractionComponent">();
	}
	static class UItemContainerInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemContainerInteractionComponent>();
	}
};
static_assert(alignof(UItemContainerInteractionComponent) == 0x000008, "Wrong alignment on UItemContainerInteractionComponent");
static_assert(sizeof(UItemContainerInteractionComponent) == 0x0002E0, "Wrong size on UItemContainerInteractionComponent");
static_assert(offsetof(UItemContainerInteractionComponent, PresetItemContainerPrototypeID) == 0x000290, "Member 'UItemContainerInteractionComponent::PresetItemContainerPrototypeID' has a wrong offset!");
static_assert(offsetof(UItemContainerInteractionComponent, StashTypeSwitch) == 0x0002A8, "Member 'UItemContainerInteractionComponent::StashTypeSwitch' has a wrong offset!");
static_assert(offsetof(UItemContainerInteractionComponent, OpenAudioEvent) == 0x0002B0, "Member 'UItemContainerInteractionComponent::OpenAudioEvent' has a wrong offset!");
static_assert(offsetof(UItemContainerInteractionComponent, CloseAudioEvent) == 0x0002B8, "Member 'UItemContainerInteractionComponent::CloseAudioEvent' has a wrong offset!");
static_assert(offsetof(UItemContainerInteractionComponent, InteractedActor) == 0x0002C0, "Member 'UItemContainerInteractionComponent::InteractedActor' has a wrong offset!");

// Class Stalker2.InteractableAnimCollection
// 0x0278 (0x02A0 - 0x0028)
class UInteractableAnimCollection final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInteractableAnimations                InteractableAnimations;                            // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimInteractableData                  InteractableData;                                  // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPlayerWeaponAnimations                WeaponAnimations;                                  // 0x0070(0x0230)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableAnimCollection">();
	}
	static class UInteractableAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableAnimCollection>();
	}
};
static_assert(alignof(UInteractableAnimCollection) == 0x000008, "Wrong alignment on UInteractableAnimCollection");
static_assert(sizeof(UInteractableAnimCollection) == 0x0002A0, "Wrong size on UInteractableAnimCollection");
static_assert(offsetof(UInteractableAnimCollection, InteractableAnimations) == 0x000030, "Member 'UInteractableAnimCollection::InteractableAnimations' has a wrong offset!");
static_assert(offsetof(UInteractableAnimCollection, InteractableData) == 0x000048, "Member 'UInteractableAnimCollection::InteractableData' has a wrong offset!");
static_assert(offsetof(UInteractableAnimCollection, WeaponAnimations) == 0x000070, "Member 'UInteractableAnimCollection::WeaponAnimations' has a wrong offset!");

// Class Stalker2.AnimatedItemContainerInteractionComponent
// 0x0000 (0x02E0 - 0x02E0)
class UAnimatedItemContainerInteractionComponent final : public UItemContainerInteractionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimatedItemContainerInteractionComponent">();
	}
	static class UAnimatedItemContainerInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimatedItemContainerInteractionComponent>();
	}
};
static_assert(alignof(UAnimatedItemContainerInteractionComponent) == 0x000008, "Wrong alignment on UAnimatedItemContainerInteractionComponent");
static_assert(sizeof(UAnimatedItemContainerInteractionComponent) == 0x0002E0, "Wrong size on UAnimatedItemContainerInteractionComponent");

// Class Stalker2.DPadOpenUpIPU
// 0x0000 (0x0040 - 0x0040)
class UDPadOpenUpIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DPadOpenUpIPU">();
	}
	static class UDPadOpenUpIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDPadOpenUpIPU>();
	}
};
static_assert(alignof(UDPadOpenUpIPU) == 0x000008, "Wrong alignment on UDPadOpenUpIPU");
static_assert(sizeof(UDPadOpenUpIPU) == 0x000040, "Wrong size on UDPadOpenUpIPU");

// Class Stalker2.AnimationBudgetSubsystem
// 0x0030 (0x0060 - 0x0030)
class UAnimationBudgetSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SignificanceMultiplierCurve;                       // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ScreenDistanceToCenterMultiplierCurve;             // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationBudgetSubsystem">();
	}
	static class UAnimationBudgetSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationBudgetSubsystem>();
	}
};
static_assert(alignof(UAnimationBudgetSubsystem) == 0x000008, "Wrong alignment on UAnimationBudgetSubsystem");
static_assert(sizeof(UAnimationBudgetSubsystem) == 0x000060, "Wrong size on UAnimationBudgetSubsystem");
static_assert(offsetof(UAnimationBudgetSubsystem, SignificanceMultiplierCurve) == 0x000040, "Member 'UAnimationBudgetSubsystem::SignificanceMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UAnimationBudgetSubsystem, ScreenDistanceToCenterMultiplierCurve) == 0x000048, "Member 'UAnimationBudgetSubsystem::ScreenDistanceToCenterMultiplierCurve' has a wrong offset!");

// Class Stalker2.SoundManager
// 0x07F8 (0x0870 - 0x0078)
class USoundManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x48];                                      // 0x0078(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioScattererDataAsset*               AudioScatterer;                                    // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x1C];                                      // 0x00C8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ALandscape>              Landscape;                                         // 0x00E4(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRtpc*                                InteriorFlagRTPC;                                  // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnAKEventFinished_Proxy*               OnAKEventFinished_Proxy;                           // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x770];                                    // 0x0100(0x0770)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundManager">();
	}
	static class USoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundManager>();
	}
};
static_assert(alignof(USoundManager) == 0x000008, "Wrong alignment on USoundManager");
static_assert(sizeof(USoundManager) == 0x000870, "Wrong size on USoundManager");
static_assert(offsetof(USoundManager, AudioScatterer) == 0x0000C0, "Member 'USoundManager::AudioScatterer' has a wrong offset!");
static_assert(offsetof(USoundManager, Landscape) == 0x0000E4, "Member 'USoundManager::Landscape' has a wrong offset!");
static_assert(offsetof(USoundManager, InteriorFlagRTPC) == 0x0000F0, "Member 'USoundManager::InteriorFlagRTPC' has a wrong offset!");
static_assert(offsetof(USoundManager, OnAKEventFinished_Proxy) == 0x0000F8, "Member 'USoundManager::OnAKEventFinished_Proxy' has a wrong offset!");

// Class Stalker2.AnimationUtilitiesBPFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UAnimationUtilitiesBPFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UAnimInstance* GetCharacterAnimInstance(class AObj* Obj);
	static bool IsSimulationEnable(class UObject* Object, class UGroomAsset* GroomAsset);
	static void LerpPlayerToInteractable(class APC* PC, class UInteractionComponent* InteractionComponent, const struct FAnimInteractableData& InteractionData);
	static bool MoveAnimNotifiesFromInvalidPoints(class UAnimSequenceBase* Montage, TSubclassOf<class UAnimNotify> NotifyClass, bool bShouldNotifiesBeChangedToBranchingPoint);
	static void RefreshLodSyncComponents(class UObject* Object, class ULODSyncComponent* LODSyncComponent);
	static void SetMontageSectionNextSection(class UAnimMontage* Montage, const class FName& Section, const class FName& NextSection);
	static void SetPlayerLockState(class APC* PC, const bool bLock, const struct FAnimInteractableData& InteractionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationUtilitiesBPFunctionLibrary">();
	}
	static class UAnimationUtilitiesBPFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationUtilitiesBPFunctionLibrary>();
	}
};
static_assert(alignof(UAnimationUtilitiesBPFunctionLibrary) == 0x000008, "Wrong alignment on UAnimationUtilitiesBPFunctionLibrary");
static_assert(sizeof(UAnimationUtilitiesBPFunctionLibrary) == 0x000028, "Wrong size on UAnimationUtilitiesBPFunctionLibrary");

// Class Stalker2.UIDActor_Anomaly
// 0x0010 (0x02A8 - 0x0298)
class AUIDActor_Anomaly : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActor_Anomaly">();
	}
	static class AUIDActor_Anomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDActor_Anomaly>();
	}
};
static_assert(alignof(AUIDActor_Anomaly) == 0x000008, "Wrong alignment on AUIDActor_Anomaly");
static_assert(sizeof(AUIDActor_Anomaly) == 0x0002A8, "Wrong size on AUIDActor_Anomaly");

// Class Stalker2.Anomaly
// 0x00F0 (0x0398 - 0x02A8)
class AAnomaly : public AUIDActor_Anomaly
{
public:
	uint8                                         Pad_2A8[0x60];                                     // 0x02A8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           AnomalyAkComponent;                                // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          SoundEvent;                                        // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          DieSound;                                          // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         IdleSwitch;                                        // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         FadeSwitch;                                        // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         ActiveSwitch;                                      // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         TriggerSwitch;                                     // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         FirstPersonSwitch;                                 // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         ThirdPersonSwitch;                                 // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGSCNavModifierComponent*               SpaceRestrictorComponent;                          // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SpaceRestrictorShape;                              // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWaterContactController*                WaterContactController;                            // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x30];                                     // 0x0368(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceActivateEndless();
	void ForceActivateOnce();
	void ForceDeactivate();
	void OnActivationStateStarted();
	void OnActiveStateStarted();
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);
	void OnDieSoundFinished(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex);
	void OnIdleStateStarted();
	void OnNiagaraFinished(class UNiagaraComponent* FinishedNiagara);
	void OnRechargeStateStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Anomaly">();
	}
	static class AAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnomaly>();
	}
};
static_assert(alignof(AAnomaly) == 0x000008, "Wrong alignment on AAnomaly");
static_assert(sizeof(AAnomaly) == 0x000398, "Wrong size on AAnomaly");
static_assert(offsetof(AAnomaly, AnomalyAkComponent) == 0x000308, "Member 'AAnomaly::AnomalyAkComponent' has a wrong offset!");
static_assert(offsetof(AAnomaly, SoundEvent) == 0x000310, "Member 'AAnomaly::SoundEvent' has a wrong offset!");
static_assert(offsetof(AAnomaly, DieSound) == 0x000318, "Member 'AAnomaly::DieSound' has a wrong offset!");
static_assert(offsetof(AAnomaly, IdleSwitch) == 0x000320, "Member 'AAnomaly::IdleSwitch' has a wrong offset!");
static_assert(offsetof(AAnomaly, FadeSwitch) == 0x000328, "Member 'AAnomaly::FadeSwitch' has a wrong offset!");
static_assert(offsetof(AAnomaly, ActiveSwitch) == 0x000330, "Member 'AAnomaly::ActiveSwitch' has a wrong offset!");
static_assert(offsetof(AAnomaly, TriggerSwitch) == 0x000338, "Member 'AAnomaly::TriggerSwitch' has a wrong offset!");
static_assert(offsetof(AAnomaly, FirstPersonSwitch) == 0x000340, "Member 'AAnomaly::FirstPersonSwitch' has a wrong offset!");
static_assert(offsetof(AAnomaly, ThirdPersonSwitch) == 0x000348, "Member 'AAnomaly::ThirdPersonSwitch' has a wrong offset!");
static_assert(offsetof(AAnomaly, SpaceRestrictorComponent) == 0x000350, "Member 'AAnomaly::SpaceRestrictorComponent' has a wrong offset!");
static_assert(offsetof(AAnomaly, SpaceRestrictorShape) == 0x000358, "Member 'AAnomaly::SpaceRestrictorShape' has a wrong offset!");
static_assert(offsetof(AAnomaly, WaterContactController) == 0x000360, "Member 'AAnomaly::WaterContactController' has a wrong offset!");

// Class Stalker2.ElectroAnomaly
// 0x0018 (0x03B0 - 0x0398)
class AElectroAnomaly final : public AAnomaly
{
public:
	class UStaticMeshComponent*                   RootComponentPtr;                                  // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CollisionMeshPtr;                                  // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BPDoLightningStrikeAfterPauseTime();
	void BPSetActiveIdleVFX(const bool bNewActive);

	struct FElectroAnomalyBakedDataFloat GetElectroBakedData() const;
	struct FVector GetParticleSpawnLocation() const;
	float GetRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ElectroAnomaly">();
	}
	static class AElectroAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AElectroAnomaly>();
	}
};
static_assert(alignof(AElectroAnomaly) == 0x000008, "Wrong alignment on AElectroAnomaly");
static_assert(sizeof(AElectroAnomaly) == 0x0003B0, "Wrong size on AElectroAnomaly");
static_assert(offsetof(AElectroAnomaly, RootComponentPtr) == 0x000398, "Member 'AElectroAnomaly::RootComponentPtr' has a wrong offset!");
static_assert(offsetof(AElectroAnomaly, CollisionMeshPtr) == 0x0003A0, "Member 'AElectroAnomaly::CollisionMeshPtr' has a wrong offset!");

// Class Stalker2.PlayerWeaponAnimCollectionInterface
// 0x0000 (0x0000 - 0x0000)
class IPlayerWeaponAnimCollectionInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerWeaponAnimCollectionInterface">();
	}
	static class IPlayerWeaponAnimCollectionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerWeaponAnimCollectionInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPlayerWeaponAnimCollectionInterface) == 0x000001, "Wrong alignment on IPlayerWeaponAnimCollectionInterface");
static_assert(sizeof(IPlayerWeaponAnimCollectionInterface) == 0x000001, "Wrong size on IPlayerWeaponAnimCollectionInterface");

// Class Stalker2.DraggableComponent
// 0x0010 (0x0208 - 0x01F8)
class UDraggableComponent final : public USingleClickComponent
{
public:
	uint8                                         Pad_1F8[0x10];                                     // 0x01F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DraggableComponent">();
	}
	static class UDraggableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDraggableComponent>();
	}
};
static_assert(alignof(UDraggableComponent) == 0x000008, "Wrong alignment on UDraggableComponent");
static_assert(sizeof(UDraggableComponent) == 0x000208, "Wrong size on UDraggableComponent");

// Class Stalker2.VideoWidget
// 0x0000 (0x0000 - 0x0000)
class IVideoWidget final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VideoWidget">();
	}
	static class IVideoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVideoWidget>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IVideoWidget) == 0x000001, "Wrong alignment on IVideoWidget");
static_assert(sizeof(IVideoWidget) == 0x000001, "Wrong size on IVideoWidget");

// Class Stalker2.PopupBase
// 0x00E8 (0x0360 - 0x0278)
class UPopupBase : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextWidget*                            Title;                                             // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            Description;                                       // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   ConfirmHint;                                       // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   DiscardHint;                                       // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   RetryHint;                                         // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   CancelHint;                                        // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         NoIconHorizontalBox;                               // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         IconHorizontalBox;                                 // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Icon;                                              // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHyperlinkButton*                       PrivacyPolicyButton;                               // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHyperlinkButton*                       TermsOfUseButton;                                  // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             SaveIcon;                                          // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BrokenIcon;                                        // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             AttentionIcon;                                     // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x60];                                     // 0x0300(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupBase">();
	}
	static class UPopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupBase>();
	}
};
static_assert(alignof(UPopupBase) == 0x000008, "Wrong alignment on UPopupBase");
static_assert(sizeof(UPopupBase) == 0x000360, "Wrong size on UPopupBase");
static_assert(offsetof(UPopupBase, Title) == 0x000290, "Member 'UPopupBase::Title' has a wrong offset!");
static_assert(offsetof(UPopupBase, Description) == 0x000298, "Member 'UPopupBase::Description' has a wrong offset!");
static_assert(offsetof(UPopupBase, ConfirmHint) == 0x0002A0, "Member 'UPopupBase::ConfirmHint' has a wrong offset!");
static_assert(offsetof(UPopupBase, DiscardHint) == 0x0002A8, "Member 'UPopupBase::DiscardHint' has a wrong offset!");
static_assert(offsetof(UPopupBase, RetryHint) == 0x0002B0, "Member 'UPopupBase::RetryHint' has a wrong offset!");
static_assert(offsetof(UPopupBase, CancelHint) == 0x0002B8, "Member 'UPopupBase::CancelHint' has a wrong offset!");
static_assert(offsetof(UPopupBase, NoIconHorizontalBox) == 0x0002C0, "Member 'UPopupBase::NoIconHorizontalBox' has a wrong offset!");
static_assert(offsetof(UPopupBase, IconHorizontalBox) == 0x0002C8, "Member 'UPopupBase::IconHorizontalBox' has a wrong offset!");
static_assert(offsetof(UPopupBase, Icon) == 0x0002D0, "Member 'UPopupBase::Icon' has a wrong offset!");
static_assert(offsetof(UPopupBase, PrivacyPolicyButton) == 0x0002D8, "Member 'UPopupBase::PrivacyPolicyButton' has a wrong offset!");
static_assert(offsetof(UPopupBase, TermsOfUseButton) == 0x0002E0, "Member 'UPopupBase::TermsOfUseButton' has a wrong offset!");
static_assert(offsetof(UPopupBase, SaveIcon) == 0x0002E8, "Member 'UPopupBase::SaveIcon' has a wrong offset!");
static_assert(offsetof(UPopupBase, BrokenIcon) == 0x0002F0, "Member 'UPopupBase::BrokenIcon' has a wrong offset!");
static_assert(offsetof(UPopupBase, AttentionIcon) == 0x0002F8, "Member 'UPopupBase::AttentionIcon' has a wrong offset!");

// Class Stalker2.GreetingsPopup
// 0x0018 (0x0378 - 0x0360)
class UGreetingsPopup : public UPopupBase
{
public:
	class UModifiableRichText*                    DescriptionRich;                                   // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           DescriptionContainer;                              // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImageWidget*                           BackgroundImage;                                   // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GreetingsPopup">();
	}
	static class UGreetingsPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGreetingsPopup>();
	}
};
static_assert(alignof(UGreetingsPopup) == 0x000008, "Wrong alignment on UGreetingsPopup");
static_assert(sizeof(UGreetingsPopup) == 0x000378, "Wrong size on UGreetingsPopup");
static_assert(offsetof(UGreetingsPopup, DescriptionRich) == 0x000360, "Member 'UGreetingsPopup::DescriptionRich' has a wrong offset!");
static_assert(offsetof(UGreetingsPopup, DescriptionContainer) == 0x000368, "Member 'UGreetingsPopup::DescriptionContainer' has a wrong offset!");
static_assert(offsetof(UGreetingsPopup, BackgroundImage) == 0x000370, "Member 'UGreetingsPopup::BackgroundImage' has a wrong offset!");

// Class Stalker2.AnimInstanceContextualFace
// 0x0010 (0x0410 - 0x0400)
class UAnimInstanceContextualFace final : public UAnimInstanceBase
{
public:
	class USkeletalMeshComponent*                 HumanBody;                                         // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceContextualFace">();
	}
	static class UAnimInstanceContextualFace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceContextualFace>();
	}
};
static_assert(alignof(UAnimInstanceContextualFace) == 0x000010, "Wrong alignment on UAnimInstanceContextualFace");
static_assert(sizeof(UAnimInstanceContextualFace) == 0x000410, "Wrong size on UAnimInstanceContextualFace");
static_assert(offsetof(UAnimInstanceContextualFace, HumanBody) == 0x000400, "Member 'UAnimInstanceContextualFace::HumanBody' has a wrong offset!");

// Class Stalker2.Stalker2BaseGameMode
// 0x0000 (0x0340 - 0x0340)
class AStalker2BaseGameMode : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Stalker2BaseGameMode">();
	}
	static class AStalker2BaseGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStalker2BaseGameMode>();
	}
};
static_assert(alignof(AStalker2BaseGameMode) == 0x000008, "Wrong alignment on AStalker2BaseGameMode");
static_assert(sizeof(AStalker2BaseGameMode) == 0x000340, "Wrong size on AStalker2BaseGameMode");

// Class Stalker2.Stalker2GameMode
// 0x0010 (0x0350 - 0x0340)
class AStalker2GameMode : public AStalker2BaseGameMode
{
public:
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Stalker2GameMode">();
	}
	static class AStalker2GameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStalker2GameMode>();
	}
};
static_assert(alignof(AStalker2GameMode) == 0x000008, "Wrong alignment on AStalker2GameMode");
static_assert(sizeof(AStalker2GameMode) == 0x000350, "Wrong size on AStalker2GameMode");

// Class Stalker2.Stalker2MoviePipelineGameMode
// 0x0000 (0x0350 - 0x0350)
class AStalker2MoviePipelineGameMode final : public AStalker2GameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Stalker2MoviePipelineGameMode">();
	}
	static class AStalker2MoviePipelineGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStalker2MoviePipelineGameMode>();
	}
};
static_assert(alignof(AStalker2MoviePipelineGameMode) == 0x000008, "Wrong alignment on AStalker2MoviePipelineGameMode");
static_assert(sizeof(AStalker2MoviePipelineGameMode) == 0x000350, "Wrong size on AStalker2MoviePipelineGameMode");

// Class Stalker2.AnimInstanceFace
// 0x0290 (0x0690 - 0x0400)
class UAnimInstanceFace : public UAnimInstanceBase
{
public:
	struct FAnimHumanStateData                    StateData;                                         // 0x0400(0x003C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimHumanFaceData                     FaceData;                                          // 0x0440(0x01F8)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAnimWoundedData                       WoundedData;                                       // 0x0638(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimSleepData                         SleepData;                                         // 0x0680(0x0001)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_681[0x3];                                      // 0x0681(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimCutsceneData                      CutsceneData;                                      // 0x0684(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_68C[0x4];                                      // 0x068C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceFace">();
	}
	static class UAnimInstanceFace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceFace>();
	}
};
static_assert(alignof(UAnimInstanceFace) == 0x000010, "Wrong alignment on UAnimInstanceFace");
static_assert(sizeof(UAnimInstanceFace) == 0x000690, "Wrong size on UAnimInstanceFace");
static_assert(offsetof(UAnimInstanceFace, StateData) == 0x000400, "Member 'UAnimInstanceFace::StateData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceFace, FaceData) == 0x000440, "Member 'UAnimInstanceFace::FaceData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceFace, WoundedData) == 0x000638, "Member 'UAnimInstanceFace::WoundedData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceFace, SleepData) == 0x000680, "Member 'UAnimInstanceFace::SleepData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceFace, CutsceneData) == 0x000684, "Member 'UAnimInstanceFace::CutsceneData' has a wrong offset!");

// Class Stalker2.DynamicObstacleAvoidanceManager
// 0x0068 (0x0110 - 0x00A8)
class UDynamicObstacleAvoidanceManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x68];                                      // 0x00A8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicObstacleAvoidanceManager">();
	}
	static class UDynamicObstacleAvoidanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicObstacleAvoidanceManager>();
	}
};
static_assert(alignof(UDynamicObstacleAvoidanceManager) == 0x000008, "Wrong alignment on UDynamicObstacleAvoidanceManager");
static_assert(sizeof(UDynamicObstacleAvoidanceManager) == 0x000110, "Wrong size on UDynamicObstacleAvoidanceManager");

// Class Stalker2.AnimInstanceHuman
// 0x0DF0 (0x11F0 - 0x0400)
class UAnimInstanceHuman final : public UAnimInstanceBase
{
public:
	struct FAnimHumanWeaponData                   WeaponData;                                        // 0x0400(0x0038)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAnimHitData                           HitData;                                           // 0x0438(0x0140)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimWoundedData                       WoundedData;                                       // 0x0578(0x0048)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimKnockDownData                     KnockDownData;                                     // 0x05C0(0x0002)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C2[0x6];                                      // 0x05C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimHumanCollectionsData              CollectionsData;                                   // 0x05C8(0x0128)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimHumanStateData                    StateData;                                         // 0x06F0(0x003C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_72C[0x4];                                      // 0x072C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimTwoHandsIKData                    HandsIKData;                                       // 0x0730(0x0078)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimHumanFaceData                     FaceData;                                          // 0x07A8(0x01F8)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAnimHumanLookAtData                   LookAtData;                                        // 0x09A0(0x01B0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimHumanDialogData                   DialogData;                                        // 0x0B50(0x00A8)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BF8[0x8];                                      // 0x0BF8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimPoseSearchLocomotionData          PoseSearchLocomotionData;                          // 0x0C00(0x01D0)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAnimPhysicalData                      PhysicalData;                                      // 0x0DD0(0x03D0)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTwoLegIKData                          LegsData;                                          // 0x11A0(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimCutsceneData                      CutsceneData;                                      // 0x11C8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      LastGestureAnimation;                              // 0x11D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimAbilityData                       AbilityData;                                       // 0x11D8(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceHuman">();
	}
	static class UAnimInstanceHuman* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceHuman>();
	}
};
static_assert(alignof(UAnimInstanceHuman) == 0x000010, "Wrong alignment on UAnimInstanceHuman");
static_assert(sizeof(UAnimInstanceHuman) == 0x0011F0, "Wrong size on UAnimInstanceHuman");
static_assert(offsetof(UAnimInstanceHuman, WeaponData) == 0x000400, "Member 'UAnimInstanceHuman::WeaponData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, HitData) == 0x000438, "Member 'UAnimInstanceHuman::HitData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, WoundedData) == 0x000578, "Member 'UAnimInstanceHuman::WoundedData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, KnockDownData) == 0x0005C0, "Member 'UAnimInstanceHuman::KnockDownData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, CollectionsData) == 0x0005C8, "Member 'UAnimInstanceHuman::CollectionsData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, StateData) == 0x0006F0, "Member 'UAnimInstanceHuman::StateData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, HandsIKData) == 0x000730, "Member 'UAnimInstanceHuman::HandsIKData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, FaceData) == 0x0007A8, "Member 'UAnimInstanceHuman::FaceData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, LookAtData) == 0x0009A0, "Member 'UAnimInstanceHuman::LookAtData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, DialogData) == 0x000B50, "Member 'UAnimInstanceHuman::DialogData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, PoseSearchLocomotionData) == 0x000C00, "Member 'UAnimInstanceHuman::PoseSearchLocomotionData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, PhysicalData) == 0x000DD0, "Member 'UAnimInstanceHuman::PhysicalData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, LegsData) == 0x0011A0, "Member 'UAnimInstanceHuman::LegsData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, CutsceneData) == 0x0011C8, "Member 'UAnimInstanceHuman::CutsceneData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, LastGestureAnimation) == 0x0011D0, "Member 'UAnimInstanceHuman::LastGestureAnimation' has a wrong offset!");
static_assert(offsetof(UAnimInstanceHuman, AbilityData) == 0x0011D8, "Member 'UAnimInstanceHuman::AbilityData' has a wrong offset!");

// Class Stalker2.EULAView
// 0x0040 (0x0308 - 0x02C8)
class UEULAView final : public UViewBaseExtended
{
public:
	class UTextWidget*                            EULATitle;                                         // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           TextVerticalBox;                                   // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScrollBox*                             EULAScrollBox;                                     // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModifiableRichText*                    EULAMainText;                                      // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementSwitcher*                SendAnalyticsDataSwitcher;                         // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x18];                                     // 0x02F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Accept();
	void Decline();
	void OnUserScrolled(float Offset);
	void ScrollDown();
	void ScrollUp();
	void ShowAcceptButtonBP();
	void TurnSendAnalyticsOff();
	void TurnSendAnalyticsOn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EULAView">();
	}
	static class UEULAView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEULAView>();
	}
};
static_assert(alignof(UEULAView) == 0x000008, "Wrong alignment on UEULAView");
static_assert(sizeof(UEULAView) == 0x000308, "Wrong size on UEULAView");
static_assert(offsetof(UEULAView, EULATitle) == 0x0002C8, "Member 'UEULAView::EULATitle' has a wrong offset!");
static_assert(offsetof(UEULAView, TextVerticalBox) == 0x0002D0, "Member 'UEULAView::TextVerticalBox' has a wrong offset!");
static_assert(offsetof(UEULAView, EULAScrollBox) == 0x0002D8, "Member 'UEULAView::EULAScrollBox' has a wrong offset!");
static_assert(offsetof(UEULAView, EULAMainText) == 0x0002E0, "Member 'UEULAView::EULAMainText' has a wrong offset!");
static_assert(offsetof(UEULAView, SendAnalyticsDataSwitcher) == 0x0002E8, "Member 'UEULAView::SendAnalyticsDataSwitcher' has a wrong offset!");

// Class Stalker2.AnimInstanceMutant
// 0x0760 (0x0B60 - 0x0400)
class UAnimInstanceMutant final : public UAnimInstanceBase
{
public:
	struct FAnimHitData                           HitData;                                           // 0x0400(0x0140)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimMutantStateData                   StateData;                                         // 0x0540(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimMutantCollectionsData             CollectionData;                                    // 0x0558(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimPoseSearchLocomotionData          PoseSearchLocomotionData;                          // 0x0560(0x01D0)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAnimPhysicalData                      PhysicalData;                                      // 0x0730(0x03D0)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTwoLegIKData                          LegsData;                                          // 0x0B00(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimAbilityData                       AbilityData;                                       // 0x0B28(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLookAtMutantData                      LookAtData;                                        // 0x0B40(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceMutant">();
	}
	static class UAnimInstanceMutant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceMutant>();
	}
};
static_assert(alignof(UAnimInstanceMutant) == 0x000010, "Wrong alignment on UAnimInstanceMutant");
static_assert(sizeof(UAnimInstanceMutant) == 0x000B60, "Wrong size on UAnimInstanceMutant");
static_assert(offsetof(UAnimInstanceMutant, HitData) == 0x000400, "Member 'UAnimInstanceMutant::HitData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceMutant, StateData) == 0x000540, "Member 'UAnimInstanceMutant::StateData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceMutant, CollectionData) == 0x000558, "Member 'UAnimInstanceMutant::CollectionData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceMutant, PoseSearchLocomotionData) == 0x000560, "Member 'UAnimInstanceMutant::PoseSearchLocomotionData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceMutant, PhysicalData) == 0x000730, "Member 'UAnimInstanceMutant::PhysicalData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceMutant, LegsData) == 0x000B00, "Member 'UAnimInstanceMutant::LegsData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceMutant, AbilityData) == 0x000B28, "Member 'UAnimInstanceMutant::AbilityData' has a wrong offset!");
static_assert(offsetof(UAnimInstanceMutant, LookAtData) == 0x000B40, "Member 'UAnimInstanceMutant::LookAtData' has a wrong offset!");

// Class Stalker2.AnimInstancePlayer
// 0x1110 (0x1510 - 0x0400)
class UAnimInstancePlayer final : public UAnimInstanceBase
{
public:
	struct FAnimLocomotionData                    LocomotionData;                                    // 0x0400(0x0130)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerWeaponData                  WeaponData;                                        // 0x0530(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerCameraData                  CameraData;                                        // 0x05B0(0x0090)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerTransitionData              TransitionData;                                    // 0x0640(0x0070)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerStateData                   StateData;                                         // 0x06B0(0x0040)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerCollectionsData             CollectionData;                                    // 0x06F0(0x0328)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimTwoHandsIKData                    HandsIKData;                                       // 0x0A18(0x0078)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTwoLegIKData                          LegsIKData;                                        // 0x0A90(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerIdleSwayData                IdleSwayData;                                      // 0x0AB8(0x00F0)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerClimbingData                ClimbingData;                                      // 0x0BA8(0x0120)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerWeaponSwingData             WeaponSwingData;                                   // 0x0CC8(0x0080)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerWeaponInertiaData           WeaponInertiaData;                                 // 0x0D48(0x0098)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerWeaponPushbackData          WeaponPushbackData;                                // 0x0DE0(0x0080)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerDetectorData                DetectorData;                                      // 0x0E60(0x0128)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAnimHandItemData                      HandItemData;                                      // 0x0F88(0x0138)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerMaterialData                MaterialData;                                      // 0x10C0(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerLookAtData                  LookAtData;                                        // 0x10C8(0x00D0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerAutoCoverData               AutoCoverData;                                     // 0x1198(0x0088)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerHitData                     HitData;                                           // 0x1220(0x0080)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerGuitarData                  GuitarData;                                        // 0x12A0(0x0024)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C4[0x4];                                     // 0x12C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimPlayerDodgeData                   DodgeData;                                         // 0x12C8(0x0068)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerDialogData                  DialogData;                                        // 0x1330(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerUnfocusableTargetData       AnimPlayerUnfocusableTargetData;                   // 0x1338(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1339[0x7];                                     // 0x1339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimPlayerVaultingData                VaultingData;                                      // 0x1340(0x0158)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerShadowData                  ShadowData;                                        // 0x1498(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerStealthData                 StealthData;                                       // 0x14C8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimCutsceneData                      CutsceneData;                                      // 0x14E8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14F0[0x20];                                    // 0x14F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimNotify_InteractionEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstancePlayer">();
	}
	static class UAnimInstancePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstancePlayer>();
	}
};
static_assert(alignof(UAnimInstancePlayer) == 0x000010, "Wrong alignment on UAnimInstancePlayer");
static_assert(sizeof(UAnimInstancePlayer) == 0x001510, "Wrong size on UAnimInstancePlayer");
static_assert(offsetof(UAnimInstancePlayer, LocomotionData) == 0x000400, "Member 'UAnimInstancePlayer::LocomotionData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, WeaponData) == 0x000530, "Member 'UAnimInstancePlayer::WeaponData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, CameraData) == 0x0005B0, "Member 'UAnimInstancePlayer::CameraData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, TransitionData) == 0x000640, "Member 'UAnimInstancePlayer::TransitionData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, StateData) == 0x0006B0, "Member 'UAnimInstancePlayer::StateData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, CollectionData) == 0x0006F0, "Member 'UAnimInstancePlayer::CollectionData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, HandsIKData) == 0x000A18, "Member 'UAnimInstancePlayer::HandsIKData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, LegsIKData) == 0x000A90, "Member 'UAnimInstancePlayer::LegsIKData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, IdleSwayData) == 0x000AB8, "Member 'UAnimInstancePlayer::IdleSwayData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, ClimbingData) == 0x000BA8, "Member 'UAnimInstancePlayer::ClimbingData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, WeaponSwingData) == 0x000CC8, "Member 'UAnimInstancePlayer::WeaponSwingData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, WeaponInertiaData) == 0x000D48, "Member 'UAnimInstancePlayer::WeaponInertiaData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, WeaponPushbackData) == 0x000DE0, "Member 'UAnimInstancePlayer::WeaponPushbackData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, DetectorData) == 0x000E60, "Member 'UAnimInstancePlayer::DetectorData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, HandItemData) == 0x000F88, "Member 'UAnimInstancePlayer::HandItemData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, MaterialData) == 0x0010C0, "Member 'UAnimInstancePlayer::MaterialData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, LookAtData) == 0x0010C8, "Member 'UAnimInstancePlayer::LookAtData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, AutoCoverData) == 0x001198, "Member 'UAnimInstancePlayer::AutoCoverData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, HitData) == 0x001220, "Member 'UAnimInstancePlayer::HitData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, GuitarData) == 0x0012A0, "Member 'UAnimInstancePlayer::GuitarData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, DodgeData) == 0x0012C8, "Member 'UAnimInstancePlayer::DodgeData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, DialogData) == 0x001330, "Member 'UAnimInstancePlayer::DialogData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, AnimPlayerUnfocusableTargetData) == 0x001338, "Member 'UAnimInstancePlayer::AnimPlayerUnfocusableTargetData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, VaultingData) == 0x001340, "Member 'UAnimInstancePlayer::VaultingData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, ShadowData) == 0x001498, "Member 'UAnimInstancePlayer::ShadowData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, StealthData) == 0x0014C8, "Member 'UAnimInstancePlayer::StealthData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayer, CutsceneData) == 0x0014E8, "Member 'UAnimInstancePlayer::CutsceneData' has a wrong offset!");

// Class Stalker2.SkipCutsceneIPU
// 0x0000 (0x0040 - 0x0040)
class USkipCutsceneIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkipCutsceneIPU">();
	}
	static class USkipCutsceneIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkipCutsceneIPU>();
	}
};
static_assert(alignof(USkipCutsceneIPU) == 0x000008, "Wrong alignment on USkipCutsceneIPU");
static_assert(sizeof(USkipCutsceneIPU) == 0x000040, "Wrong size on USkipCutsceneIPU");

// Class Stalker2.DamageInteractableComponent
// 0x00B0 (0x0168 - 0x00B8)
class UDamageInteractableComponent final : public UUIDActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FUID& LastDamageDealerUID, bool bProjectileFlownThroughObject)> OnDamageAccumulated; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnDamageDealt;                                     // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TSet<EDamageSource>                           DamageSources;                                     // 0x00E8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         InteractionDamageThreshold;                        // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCalculateDamageWithArmor;                         // 0x013C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FObjectArmorData                       ArmorData;                                         // 0x0140(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bOnlyPlayerDamage;                                 // 0x014C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageAccumulator;                                 // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x14];                                     // 0x0154(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageInteractableComponent">();
	}
	static class UDamageInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageInteractableComponent>();
	}
};
static_assert(alignof(UDamageInteractableComponent) == 0x000008, "Wrong alignment on UDamageInteractableComponent");
static_assert(sizeof(UDamageInteractableComponent) == 0x000168, "Wrong size on UDamageInteractableComponent");
static_assert(offsetof(UDamageInteractableComponent, OnDamageAccumulated) == 0x0000C8, "Member 'UDamageInteractableComponent::OnDamageAccumulated' has a wrong offset!");
static_assert(offsetof(UDamageInteractableComponent, OnDamageDealt) == 0x0000D8, "Member 'UDamageInteractableComponent::OnDamageDealt' has a wrong offset!");
static_assert(offsetof(UDamageInteractableComponent, DamageSources) == 0x0000E8, "Member 'UDamageInteractableComponent::DamageSources' has a wrong offset!");
static_assert(offsetof(UDamageInteractableComponent, InteractionDamageThreshold) == 0x000138, "Member 'UDamageInteractableComponent::InteractionDamageThreshold' has a wrong offset!");
static_assert(offsetof(UDamageInteractableComponent, bCalculateDamageWithArmor) == 0x00013C, "Member 'UDamageInteractableComponent::bCalculateDamageWithArmor' has a wrong offset!");
static_assert(offsetof(UDamageInteractableComponent, ArmorData) == 0x000140, "Member 'UDamageInteractableComponent::ArmorData' has a wrong offset!");
static_assert(offsetof(UDamageInteractableComponent, bOnlyPlayerDamage) == 0x00014C, "Member 'UDamageInteractableComponent::bOnlyPlayerDamage' has a wrong offset!");
static_assert(offsetof(UDamageInteractableComponent, DamageAccumulator) == 0x000150, "Member 'UDamageInteractableComponent::DamageAccumulator' has a wrong offset!");

// Class Stalker2.AnimInstancePlayerDetector
// 0x0010 (0x0410 - 0x0400)
class UAnimInstancePlayerDetector final : public UAnimInstanceBase
{
public:
	class UPlayerDetectorAnimCollection*          DetectorAnimCollection;                            // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstancePlayerDetector">();
	}
	static class UAnimInstancePlayerDetector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstancePlayerDetector>();
	}
};
static_assert(alignof(UAnimInstancePlayerDetector) == 0x000010, "Wrong alignment on UAnimInstancePlayerDetector");
static_assert(sizeof(UAnimInstancePlayerDetector) == 0x000410, "Wrong size on UAnimInstancePlayerDetector");
static_assert(offsetof(UAnimInstancePlayerDetector, DetectorAnimCollection) == 0x000400, "Member 'UAnimInstancePlayerDetector::DetectorAnimCollection' has a wrong offset!");

// Class Stalker2.AnimInstancePlayerInjector
// 0x0010 (0x0410 - 0x0400)
class UAnimInstancePlayerInjector final : public UAnimInstanceBase
{
public:
	struct FInjectorAnimations                    InjectorAnimations;                                // 0x0400(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstancePlayerInjector">();
	}
	static class UAnimInstancePlayerInjector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstancePlayerInjector>();
	}
};
static_assert(alignof(UAnimInstancePlayerInjector) == 0x000010, "Wrong alignment on UAnimInstancePlayerInjector");
static_assert(sizeof(UAnimInstancePlayerInjector) == 0x000410, "Wrong size on UAnimInstancePlayerInjector");
static_assert(offsetof(UAnimInstancePlayerInjector, InjectorAnimations) == 0x000400, "Member 'UAnimInstancePlayerInjector::InjectorAnimations' has a wrong offset!");

// Class Stalker2.PlayerGameHUDView
// 0x0120 (0x03E0 - 0x02C0)
class UPlayerGameHUDView final : public UViewBase
{
public:
	uint8                                         Pad_2C0[0x18];                                     // 0x02C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UHUDContextualLegend*                   ContextualLegend;                                  // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQuickPanel*                            QuickPanel;                                        // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHudHintsPanel*                         HudHintsPanel;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USystemNotificationWidget*              SystemNotification;                                // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Container;                                         // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCompassWidget*                         CompassWidget;                                     // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAmmoWidget*                            AmmoPanel;                                         // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HoldBreathHint;                                    // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrosshairWidgetSwitcher*               Crosshair;                                         // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStatPanel*                             StatPanel;                                         // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNotificationWidget*                    NotificationWidget;                                // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UThreatIndicator*                       ThreatIndicator;                                   // 0x0330(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBackgroundBlur*                        BackgroundBlur;                                    // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ItemSelectorHudModeAnimation;                      // 0x0340(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemSelectorHUDMod;                                // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemSelectorHUDModSpeed;                           // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEnableAutoHideWidgets;                      // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeUpdateHideWidgetsMax;                          // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeUpdateHideWidgets;                             // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEnableTurnAngleAutoHide;                    // 0x035C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerTurnAngleMax;                                // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ApproximationPlayerLocation;                       // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x78];                                     // 0x0368(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerGameHUDView">();
	}
	static class UPlayerGameHUDView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerGameHUDView>();
	}
};
static_assert(alignof(UPlayerGameHUDView) == 0x000008, "Wrong alignment on UPlayerGameHUDView");
static_assert(sizeof(UPlayerGameHUDView) == 0x0003E0, "Wrong size on UPlayerGameHUDView");
static_assert(offsetof(UPlayerGameHUDView, ContextualLegend) == 0x0002D8, "Member 'UPlayerGameHUDView::ContextualLegend' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, QuickPanel) == 0x0002E0, "Member 'UPlayerGameHUDView::QuickPanel' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, HudHintsPanel) == 0x0002E8, "Member 'UPlayerGameHUDView::HudHintsPanel' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, SystemNotification) == 0x0002F0, "Member 'UPlayerGameHUDView::SystemNotification' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, Container) == 0x0002F8, "Member 'UPlayerGameHUDView::Container' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, CompassWidget) == 0x000300, "Member 'UPlayerGameHUDView::CompassWidget' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, AmmoPanel) == 0x000308, "Member 'UPlayerGameHUDView::AmmoPanel' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, HoldBreathHint) == 0x000310, "Member 'UPlayerGameHUDView::HoldBreathHint' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, Crosshair) == 0x000318, "Member 'UPlayerGameHUDView::Crosshair' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, StatPanel) == 0x000320, "Member 'UPlayerGameHUDView::StatPanel' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, NotificationWidget) == 0x000328, "Member 'UPlayerGameHUDView::NotificationWidget' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, ThreatIndicator) == 0x000330, "Member 'UPlayerGameHUDView::ThreatIndicator' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, BackgroundBlur) == 0x000338, "Member 'UPlayerGameHUDView::BackgroundBlur' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, ItemSelectorHudModeAnimation) == 0x000340, "Member 'UPlayerGameHUDView::ItemSelectorHudModeAnimation' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, ItemSelectorHUDMod) == 0x000348, "Member 'UPlayerGameHUDView::ItemSelectorHUDMod' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, ItemSelectorHUDModSpeed) == 0x00034C, "Member 'UPlayerGameHUDView::ItemSelectorHUDModSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, bShouldEnableAutoHideWidgets) == 0x000350, "Member 'UPlayerGameHUDView::bShouldEnableAutoHideWidgets' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, TimeUpdateHideWidgetsMax) == 0x000354, "Member 'UPlayerGameHUDView::TimeUpdateHideWidgetsMax' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, TimeUpdateHideWidgets) == 0x000358, "Member 'UPlayerGameHUDView::TimeUpdateHideWidgets' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, bShouldEnableTurnAngleAutoHide) == 0x00035C, "Member 'UPlayerGameHUDView::bShouldEnableTurnAngleAutoHide' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, PlayerTurnAngleMax) == 0x000360, "Member 'UPlayerGameHUDView::PlayerTurnAngleMax' has a wrong offset!");
static_assert(offsetof(UPlayerGameHUDView, ApproximationPlayerLocation) == 0x000364, "Member 'UPlayerGameHUDView::ApproximationPlayerLocation' has a wrong offset!");

// Class Stalker2.FollowNPCSubsystem
// 0x0000 (0x0040 - 0x0040)
class UFollowNPCSubsystem final : public UTickableWorldSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FollowNPCSubsystem">();
	}
	static class UFollowNPCSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFollowNPCSubsystem>();
	}
};
static_assert(alignof(UFollowNPCSubsystem) == 0x000008, "Wrong alignment on UFollowNPCSubsystem");
static_assert(sizeof(UFollowNPCSubsystem) == 0x000040, "Wrong size on UFollowNPCSubsystem");

// Class Stalker2.AnimInstancePlayerShadow
// 0x0070 (0x0470 - 0x0400)
class UAnimInstancePlayerShadow final : public UAnimInstanceBase
{
public:
	struct FAnimPlayerShadowData                  ShadowData;                                        // 0x0400(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerStateData                   StateData;                                         // 0x0430(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstancePlayerShadow">();
	}
	static class UAnimInstancePlayerShadow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstancePlayerShadow>();
	}
};
static_assert(alignof(UAnimInstancePlayerShadow) == 0x000010, "Wrong alignment on UAnimInstancePlayerShadow");
static_assert(sizeof(UAnimInstancePlayerShadow) == 0x000470, "Wrong size on UAnimInstancePlayerShadow");
static_assert(offsetof(UAnimInstancePlayerShadow, ShadowData) == 0x000400, "Member 'UAnimInstancePlayerShadow::ShadowData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayerShadow, StateData) == 0x000430, "Member 'UAnimInstancePlayerShadow::StateData' has a wrong offset!");

// Class Stalker2.UIDActor_PoppyFieldAnomaly
// 0x0010 (0x02A8 - 0x0298)
class AUIDActor_PoppyFieldAnomaly : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActor_PoppyFieldAnomaly">();
	}
	static class AUIDActor_PoppyFieldAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDActor_PoppyFieldAnomaly>();
	}
};
static_assert(alignof(AUIDActor_PoppyFieldAnomaly) == 0x000008, "Wrong alignment on AUIDActor_PoppyFieldAnomaly");
static_assert(sizeof(AUIDActor_PoppyFieldAnomaly) == 0x0002A8, "Wrong size on AUIDActor_PoppyFieldAnomaly");

// Class Stalker2.AnimInstancePlayerWeaponBase
// 0x0030 (0x0430 - 0x0400)
class UAnimInstancePlayerWeaponBase : public UAnimInstanceBase
{
public:
	struct FAnimPlayerBaseWeaponData              BaseData;                                          // 0x0400(0x0030)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstancePlayerWeaponBase">();
	}
	static class UAnimInstancePlayerWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstancePlayerWeaponBase>();
	}
};
static_assert(alignof(UAnimInstancePlayerWeaponBase) == 0x000010, "Wrong alignment on UAnimInstancePlayerWeaponBase");
static_assert(sizeof(UAnimInstancePlayerWeaponBase) == 0x000430, "Wrong size on UAnimInstancePlayerWeaponBase");
static_assert(offsetof(UAnimInstancePlayerWeaponBase, BaseData) == 0x000400, "Member 'UAnimInstancePlayerWeaponBase::BaseData' has a wrong offset!");

// Class Stalker2.HoldComponent
// 0x0068 (0x0230 - 0x01C8)
class UHoldComponent : public UInteractionComponent
{
public:
	TMulticastInlineDelegate<void(class AObj* Object)> OnHoldStartedEvent;                           // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AObj* Object)> OnHoldInterruptedEvent;                       // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AObj* Object)> OnHoldFinishedEvent;                          // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHoldInteractionData                   InteractionData;                                   // 0x01F8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsHoldStarted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoldComponent">();
	}
	static class UHoldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoldComponent>();
	}
};
static_assert(alignof(UHoldComponent) == 0x000008, "Wrong alignment on UHoldComponent");
static_assert(sizeof(UHoldComponent) == 0x000230, "Wrong size on UHoldComponent");
static_assert(offsetof(UHoldComponent, OnHoldStartedEvent) == 0x0001C8, "Member 'UHoldComponent::OnHoldStartedEvent' has a wrong offset!");
static_assert(offsetof(UHoldComponent, OnHoldInterruptedEvent) == 0x0001D8, "Member 'UHoldComponent::OnHoldInterruptedEvent' has a wrong offset!");
static_assert(offsetof(UHoldComponent, OnHoldFinishedEvent) == 0x0001E8, "Member 'UHoldComponent::OnHoldFinishedEvent' has a wrong offset!");
static_assert(offsetof(UHoldComponent, InteractionData) == 0x0001F8, "Member 'UHoldComponent::InteractionData' has a wrong offset!");

// Class Stalker2.DeadBodyHoldComponent
// 0x0008 (0x0238 - 0x0230)
class UDeadBodyHoldComponent final : public UHoldComponent
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeadBodyHoldComponent">();
	}
	static class UDeadBodyHoldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeadBodyHoldComponent>();
	}
};
static_assert(alignof(UDeadBodyHoldComponent) == 0x000008, "Wrong alignment on UDeadBodyHoldComponent");
static_assert(sizeof(UDeadBodyHoldComponent) == 0x000238, "Wrong size on UDeadBodyHoldComponent");

// Class Stalker2.AnimInstancePlayerFirearm
// 0x0040 (0x0470 - 0x0430)
class UAnimInstancePlayerFirearm final : public UAnimInstancePlayerWeaponBase
{
public:
	class UPlayerFirearmAnimCollection*           WeaponAnimCollection;                              // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimPlayerAimingData                  AimingData;                                        // 0x0438(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerFirearmData                 FirearmData;                                       // 0x0450(0x001C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstancePlayerFirearm">();
	}
	static class UAnimInstancePlayerFirearm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstancePlayerFirearm>();
	}
};
static_assert(alignof(UAnimInstancePlayerFirearm) == 0x000010, "Wrong alignment on UAnimInstancePlayerFirearm");
static_assert(sizeof(UAnimInstancePlayerFirearm) == 0x000470, "Wrong size on UAnimInstancePlayerFirearm");
static_assert(offsetof(UAnimInstancePlayerFirearm, WeaponAnimCollection) == 0x000430, "Member 'UAnimInstancePlayerFirearm::WeaponAnimCollection' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayerFirearm, AimingData) == 0x000438, "Member 'UAnimInstancePlayerFirearm::AimingData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayerFirearm, FirearmData) == 0x000450, "Member 'UAnimInstancePlayerFirearm::FirearmData' has a wrong offset!");

// Class Stalker2.SaveLoadNotificationManager
// 0x0038 (0x00B0 - 0x0078)
class alignas(0x10) USaveLoadNotificationManager final : public UBaseManager
{
public:
	class USaveLoadNotificationView*              SaveLoadNotificationView;                          // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x30];                                      // 0x0080(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadNotificationManager">();
	}
	static class USaveLoadNotificationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadNotificationManager>();
	}
};
static_assert(alignof(USaveLoadNotificationManager) == 0x000010, "Wrong alignment on USaveLoadNotificationManager");
static_assert(sizeof(USaveLoadNotificationManager) == 0x0000B0, "Wrong size on USaveLoadNotificationManager");
static_assert(offsetof(USaveLoadNotificationManager, SaveLoadNotificationView) == 0x000078, "Member 'USaveLoadNotificationManager::SaveLoadNotificationView' has a wrong offset!");

// Class Stalker2.AnimInstancePlayerThrowable
// 0x0020 (0x0450 - 0x0430)
class UAnimInstancePlayerThrowable final : public UAnimInstancePlayerWeaponBase
{
public:
	class UPlayerThrowableItemAnimCollection*     WeaponAnimCollection;                              // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimPlayerAimingData                  AimingData;                                        // 0x0438(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstancePlayerThrowable">();
	}
	static class UAnimInstancePlayerThrowable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstancePlayerThrowable>();
	}
};
static_assert(alignof(UAnimInstancePlayerThrowable) == 0x000010, "Wrong alignment on UAnimInstancePlayerThrowable");
static_assert(sizeof(UAnimInstancePlayerThrowable) == 0x000450, "Wrong size on UAnimInstancePlayerThrowable");
static_assert(offsetof(UAnimInstancePlayerThrowable, WeaponAnimCollection) == 0x000430, "Member 'UAnimInstancePlayerThrowable::WeaponAnimCollection' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayerThrowable, AimingData) == 0x000438, "Member 'UAnimInstancePlayerThrowable::AimingData' has a wrong offset!");

// Class Stalker2.FaustBossfightController
// 0x0198 (0x0430 - 0x0298)
class AFaustBossfightController final : public AActor
{
public:
	uint8                                         Pad_298[0x58];                                     // 0x0298(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       ControllerVolume;                                  // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         CloneSpawnEffect;                                  // 0x02F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalSenderComponent*                 CloneKilledSender;                                 // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FTransform>                     CloneSpawnPoints;                                  // 0x0308(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TArray<struct FObjPrototypeSID>               ClonePrototypes;                                   // 0x0318(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FObjPrototypeSID                       BossPrototype;                                     // 0x0328(0x0040)(Edit, NativeAccessSpecifierPrivate)
	float                                         PlayerFieldOfViewAngle;                            // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinSpawnDistance;                                  // 0x036C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0xC0];                                     // 0x0370(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCloneKilled(const class AActor* CloneActor);
	void OnCloneSpawned(const class AActor* CloneActor);
	void OnCloneSwitch(const class AActor* CloneActor);
	void SetCloneSpawnEnabled(const bool bEnabled);
	void TryTeleportBossToHiddenLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FaustBossfightController">();
	}
	static class AFaustBossfightController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFaustBossfightController>();
	}
};
static_assert(alignof(AFaustBossfightController) == 0x000008, "Wrong alignment on AFaustBossfightController");
static_assert(sizeof(AFaustBossfightController) == 0x000430, "Wrong size on AFaustBossfightController");
static_assert(offsetof(AFaustBossfightController, ControllerVolume) == 0x0002F0, "Member 'AFaustBossfightController::ControllerVolume' has a wrong offset!");
static_assert(offsetof(AFaustBossfightController, CloneSpawnEffect) == 0x0002F8, "Member 'AFaustBossfightController::CloneSpawnEffect' has a wrong offset!");
static_assert(offsetof(AFaustBossfightController, CloneKilledSender) == 0x000300, "Member 'AFaustBossfightController::CloneKilledSender' has a wrong offset!");
static_assert(offsetof(AFaustBossfightController, CloneSpawnPoints) == 0x000308, "Member 'AFaustBossfightController::CloneSpawnPoints' has a wrong offset!");
static_assert(offsetof(AFaustBossfightController, ClonePrototypes) == 0x000318, "Member 'AFaustBossfightController::ClonePrototypes' has a wrong offset!");
static_assert(offsetof(AFaustBossfightController, BossPrototype) == 0x000328, "Member 'AFaustBossfightController::BossPrototype' has a wrong offset!");
static_assert(offsetof(AFaustBossfightController, PlayerFieldOfViewAngle) == 0x000368, "Member 'AFaustBossfightController::PlayerFieldOfViewAngle' has a wrong offset!");
static_assert(offsetof(AFaustBossfightController, MinSpawnDistance) == 0x00036C, "Member 'AFaustBossfightController::MinSpawnDistance' has a wrong offset!");

// Class Stalker2.AnimInstancePlayerKnife
// 0x0030 (0x0460 - 0x0430)
class UAnimInstancePlayerKnife final : public UAnimInstancePlayerWeaponBase
{
public:
	class UPlayerKnifeAnimCollection*             WeaponAnimCollection;                              // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimPlayerStealthData                 StealthData;                                       // 0x0438(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstancePlayerKnife">();
	}
	static class UAnimInstancePlayerKnife* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstancePlayerKnife>();
	}
};
static_assert(alignof(UAnimInstancePlayerKnife) == 0x000010, "Wrong alignment on UAnimInstancePlayerKnife");
static_assert(sizeof(UAnimInstancePlayerKnife) == 0x000460, "Wrong size on UAnimInstancePlayerKnife");
static_assert(offsetof(UAnimInstancePlayerKnife, WeaponAnimCollection) == 0x000430, "Member 'UAnimInstancePlayerKnife::WeaponAnimCollection' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayerKnife, StealthData) == 0x000438, "Member 'UAnimInstancePlayerKnife::StealthData' has a wrong offset!");

// Class Stalker2.AnimInstanceItem
// 0x0010 (0x0410 - 0x0400)
class UAnimInstanceItem final : public UAnimInstanceBase
{
public:
	class UItemAnimCollection*                    ItemAnimCollection;                                // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceItem">();
	}
	static class UAnimInstanceItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceItem>();
	}
};
static_assert(alignof(UAnimInstanceItem) == 0x000010, "Wrong alignment on UAnimInstanceItem");
static_assert(sizeof(UAnimInstanceItem) == 0x000410, "Wrong size on UAnimInstanceItem");
static_assert(offsetof(UAnimInstanceItem, ItemAnimCollection) == 0x000400, "Member 'UAnimInstanceItem::ItemAnimCollection' has a wrong offset!");

// Class Stalker2.PlayerDetectorAnimCollection
// 0x02D8 (0x0300 - 0x0028)
class UPlayerDetectorAnimCollection final : public UObject
{
public:
	struct FCharacterDetectorAnimations           Equip;                                             // 0x0028(0x0068)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FCharacterDetectorAnimations           Unequip;                                           // 0x0090(0x0068)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FCharacterDetectorAnimations           UnequipFast;                                       // 0x00F8(0x0068)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FCharacterDetectorAnimations           EquipBothHands;                                    // 0x0160(0x0068)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FCharacterDetectorWeaponAnimations     WeaponSwitch;                                      // 0x01C8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterDetectorWeaponAnimations     WeaponShoot;                                       // 0x01D0(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterDetectorWeaponAnimations     WeaponAimShoot;                                    // 0x01D8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterDetectorFailedLandingAnimations FailedLanding;                                  // 0x01E0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FDetectorToggleFlashlightAnimations    ToggleFlashlight;                                  // 0x0230(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UClass*                                 PlayerAnimBlueprint;                               // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimWeaponSwingContainer              SwingConfigContainer;                              // 0x0288(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponInertiaContainer                StopSwingInertia;                                  // 0x02C0(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponInertiaContainer                StopSprintInertia;                                 // 0x02E0(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDetectorAnimCollection">();
	}
	static class UPlayerDetectorAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDetectorAnimCollection>();
	}
};
static_assert(alignof(UPlayerDetectorAnimCollection) == 0x000008, "Wrong alignment on UPlayerDetectorAnimCollection");
static_assert(sizeof(UPlayerDetectorAnimCollection) == 0x000300, "Wrong size on UPlayerDetectorAnimCollection");
static_assert(offsetof(UPlayerDetectorAnimCollection, Equip) == 0x000028, "Member 'UPlayerDetectorAnimCollection::Equip' has a wrong offset!");
static_assert(offsetof(UPlayerDetectorAnimCollection, Unequip) == 0x000090, "Member 'UPlayerDetectorAnimCollection::Unequip' has a wrong offset!");
static_assert(offsetof(UPlayerDetectorAnimCollection, UnequipFast) == 0x0000F8, "Member 'UPlayerDetectorAnimCollection::UnequipFast' has a wrong offset!");
static_assert(offsetof(UPlayerDetectorAnimCollection, EquipBothHands) == 0x000160, "Member 'UPlayerDetectorAnimCollection::EquipBothHands' has a wrong offset!");
static_assert(offsetof(UPlayerDetectorAnimCollection, WeaponSwitch) == 0x0001C8, "Member 'UPlayerDetectorAnimCollection::WeaponSwitch' has a wrong offset!");
static_assert(offsetof(UPlayerDetectorAnimCollection, WeaponShoot) == 0x0001D0, "Member 'UPlayerDetectorAnimCollection::WeaponShoot' has a wrong offset!");
static_assert(offsetof(UPlayerDetectorAnimCollection, WeaponAimShoot) == 0x0001D8, "Member 'UPlayerDetectorAnimCollection::WeaponAimShoot' has a wrong offset!");
static_assert(offsetof(UPlayerDetectorAnimCollection, FailedLanding) == 0x0001E0, "Member 'UPlayerDetectorAnimCollection::FailedLanding' has a wrong offset!");
static_assert(offsetof(UPlayerDetectorAnimCollection, ToggleFlashlight) == 0x000230, "Member 'UPlayerDetectorAnimCollection::ToggleFlashlight' has a wrong offset!");
static_assert(offsetof(UPlayerDetectorAnimCollection, PlayerAnimBlueprint) == 0x000280, "Member 'UPlayerDetectorAnimCollection::PlayerAnimBlueprint' has a wrong offset!");
static_assert(offsetof(UPlayerDetectorAnimCollection, SwingConfigContainer) == 0x000288, "Member 'UPlayerDetectorAnimCollection::SwingConfigContainer' has a wrong offset!");
static_assert(offsetof(UPlayerDetectorAnimCollection, StopSwingInertia) == 0x0002C0, "Member 'UPlayerDetectorAnimCollection::StopSwingInertia' has a wrong offset!");
static_assert(offsetof(UPlayerDetectorAnimCollection, StopSprintInertia) == 0x0002E0, "Member 'UPlayerDetectorAnimCollection::StopSprintInertia' has a wrong offset!");

// Class Stalker2.MenuMainViewBase
// 0x0070 (0x0338 - 0x02C8)
class UMenuMainViewBase : public UViewBaseExtended
{
public:
	class UOverlay*                               SubMenuViewOverlay;                                // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuLegendSubView*                     LegendSubView;                                     // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuMainBackgroundVideo*               MainMenuBackgroundVideo;                           // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMenuSubViewBase>           RootSubViewClass;                                  // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeOutAnimation;                                  // 0x02E8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeInAnimation;                                   // 0x02F0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInSpeedMultiplier;                             // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutSpeedMultiplier;                            // 0x02FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEnhancedInputComponent*                EnhancedInputComponent;                            // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x30];                                     // 0x0308(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeInFinishedFunction();
	void FadeInStartedFunction();
	void FadeOutFinishedFunction();
	void FadeOutStartedFunction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuMainViewBase">();
	}
	static class UMenuMainViewBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuMainViewBase>();
	}
};
static_assert(alignof(UMenuMainViewBase) == 0x000008, "Wrong alignment on UMenuMainViewBase");
static_assert(sizeof(UMenuMainViewBase) == 0x000338, "Wrong size on UMenuMainViewBase");
static_assert(offsetof(UMenuMainViewBase, SubMenuViewOverlay) == 0x0002C8, "Member 'UMenuMainViewBase::SubMenuViewOverlay' has a wrong offset!");
static_assert(offsetof(UMenuMainViewBase, LegendSubView) == 0x0002D0, "Member 'UMenuMainViewBase::LegendSubView' has a wrong offset!");
static_assert(offsetof(UMenuMainViewBase, MainMenuBackgroundVideo) == 0x0002D8, "Member 'UMenuMainViewBase::MainMenuBackgroundVideo' has a wrong offset!");
static_assert(offsetof(UMenuMainViewBase, RootSubViewClass) == 0x0002E0, "Member 'UMenuMainViewBase::RootSubViewClass' has a wrong offset!");
static_assert(offsetof(UMenuMainViewBase, FadeOutAnimation) == 0x0002E8, "Member 'UMenuMainViewBase::FadeOutAnimation' has a wrong offset!");
static_assert(offsetof(UMenuMainViewBase, FadeInAnimation) == 0x0002F0, "Member 'UMenuMainViewBase::FadeInAnimation' has a wrong offset!");
static_assert(offsetof(UMenuMainViewBase, FadeInSpeedMultiplier) == 0x0002F8, "Member 'UMenuMainViewBase::FadeInSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UMenuMainViewBase, FadeOutSpeedMultiplier) == 0x0002FC, "Member 'UMenuMainViewBase::FadeOutSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UMenuMainViewBase, EnhancedInputComponent) == 0x000300, "Member 'UMenuMainViewBase::EnhancedInputComponent' has a wrong offset!");

// Class Stalker2.DeathScreen
// 0x0090 (0x03C8 - 0x0338)
class UDeathScreen final : public UMenuMainViewBase
{
public:
	class UImage*                                 BlackBackground;                                   // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               DeathScreenOverlay;                                // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Background;                                        // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            DeadByText;                                        // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDeathCounter*                          DeathCounterWidget;                                // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultDeathScreenSID;                             // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              DefaultDeathScreenImage;                           // 0x0368(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDeathScreenSIDData>            DeathScreenSIDSettings;                            // 0x0398(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDeathScreenImageData>          DeathScreenImageSettings;                          // 0x03A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x10];                                     // 0x03B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathScreen">();
	}
	static class UDeathScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathScreen>();
	}
};
static_assert(alignof(UDeathScreen) == 0x000008, "Wrong alignment on UDeathScreen");
static_assert(sizeof(UDeathScreen) == 0x0003C8, "Wrong size on UDeathScreen");
static_assert(offsetof(UDeathScreen, BlackBackground) == 0x000338, "Member 'UDeathScreen::BlackBackground' has a wrong offset!");
static_assert(offsetof(UDeathScreen, DeathScreenOverlay) == 0x000340, "Member 'UDeathScreen::DeathScreenOverlay' has a wrong offset!");
static_assert(offsetof(UDeathScreen, Background) == 0x000348, "Member 'UDeathScreen::Background' has a wrong offset!");
static_assert(offsetof(UDeathScreen, DeadByText) == 0x000350, "Member 'UDeathScreen::DeadByText' has a wrong offset!");
static_assert(offsetof(UDeathScreen, DeathCounterWidget) == 0x000358, "Member 'UDeathScreen::DeathCounterWidget' has a wrong offset!");
static_assert(offsetof(UDeathScreen, DefaultDeathScreenSID) == 0x000360, "Member 'UDeathScreen::DefaultDeathScreenSID' has a wrong offset!");
static_assert(offsetof(UDeathScreen, DefaultDeathScreenImage) == 0x000368, "Member 'UDeathScreen::DefaultDeathScreenImage' has a wrong offset!");
static_assert(offsetof(UDeathScreen, DeathScreenSIDSettings) == 0x000398, "Member 'UDeathScreen::DeathScreenSIDSettings' has a wrong offset!");
static_assert(offsetof(UDeathScreen, DeathScreenImageSettings) == 0x0003A8, "Member 'UDeathScreen::DeathScreenImageSettings' has a wrong offset!");

// Class Stalker2.AnimInstancePlayerWeaponAttach
// 0x0040 (0x0440 - 0x0400)
class UAnimInstancePlayerWeaponAttach final : public UAnimInstanceBase
{
public:
	class UWeaponAttachAnimCollection*            AttachAnimCollection;                              // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimPlayerFirearmData                 FirearmData;                                       // 0x0408(0x001C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimPlayerAimingData                  AimingData;                                        // 0x0424(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstancePlayerWeaponAttach">();
	}
	static class UAnimInstancePlayerWeaponAttach* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstancePlayerWeaponAttach>();
	}
};
static_assert(alignof(UAnimInstancePlayerWeaponAttach) == 0x000010, "Wrong alignment on UAnimInstancePlayerWeaponAttach");
static_assert(sizeof(UAnimInstancePlayerWeaponAttach) == 0x000440, "Wrong size on UAnimInstancePlayerWeaponAttach");
static_assert(offsetof(UAnimInstancePlayerWeaponAttach, AttachAnimCollection) == 0x000400, "Member 'UAnimInstancePlayerWeaponAttach::AttachAnimCollection' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayerWeaponAttach, FirearmData) == 0x000408, "Member 'UAnimInstancePlayerWeaponAttach::FirearmData' has a wrong offset!");
static_assert(offsetof(UAnimInstancePlayerWeaponAttach, AimingData) == 0x000424, "Member 'UAnimInstancePlayerWeaponAttach::AimingData' has a wrong offset!");

// Class Stalker2.AnimInstanceReplicateMesh
// 0x0000 (0x0370 - 0x0370)
class UAnimInstanceReplicateMesh final : public UAnimInstance
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceReplicateMesh">();
	}
	static class UAnimInstanceReplicateMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceReplicateMesh>();
	}
};
static_assert(alignof(UAnimInstanceReplicateMesh) == 0x000010, "Wrong alignment on UAnimInstanceReplicateMesh");
static_assert(sizeof(UAnimInstanceReplicateMesh) == 0x000370, "Wrong size on UAnimInstanceReplicateMesh");
static_assert(offsetof(UAnimInstanceReplicateMesh, SkeletalMeshComponent) == 0x000368, "Member 'UAnimInstanceReplicateMesh::SkeletalMeshComponent' has a wrong offset!");

// Class Stalker2.StreamingDistanceOverrideSubsystem
// 0x0148 (0x0178 - 0x0030)
class UStreamingDistanceOverrideSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStreamingDistanceOverrideVolumeState> RegisteredSDOVolumeStates;                  // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x108];                                     // 0x0070(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamingDistanceOverrideSubsystem">();
	}
	static class UStreamingDistanceOverrideSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStreamingDistanceOverrideSubsystem>();
	}
};
static_assert(alignof(UStreamingDistanceOverrideSubsystem) == 0x000008, "Wrong alignment on UStreamingDistanceOverrideSubsystem");
static_assert(sizeof(UStreamingDistanceOverrideSubsystem) == 0x000178, "Wrong size on UStreamingDistanceOverrideSubsystem");
static_assert(offsetof(UStreamingDistanceOverrideSubsystem, RegisteredSDOVolumeStates) == 0x000060, "Member 'UStreamingDistanceOverrideSubsystem::RegisteredSDOVolumeStates' has a wrong offset!");

// Class Stalker2.GAAttachSelectorActionProcessor
// 0x0020 (0x0048 - 0x0028)
class UGAAttachSelectorActionProcessor final : public UGAPlayerProcessorInterface
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAAttachSelectorActionProcessor">();
	}
	static class UGAAttachSelectorActionProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAAttachSelectorActionProcessor>();
	}
};
static_assert(alignof(UGAAttachSelectorActionProcessor) == 0x000008, "Wrong alignment on UGAAttachSelectorActionProcessor");
static_assert(sizeof(UGAAttachSelectorActionProcessor) == 0x000048, "Wrong size on UGAAttachSelectorActionProcessor");

// Class Stalker2.AnimInstanceSyncPoint
// 0x00D0 (0x0440 - 0x0370)
class UAnimInstanceSyncPoint final : public UAnimInstance
{
public:
	uint8                                         Pad_368[0xD8];                                     // 0x0368(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceSyncPoint">();
	}
	static class UAnimInstanceSyncPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceSyncPoint>();
	}
};
static_assert(alignof(UAnimInstanceSyncPoint) == 0x000010, "Wrong alignment on UAnimInstanceSyncPoint");
static_assert(sizeof(UAnimInstanceSyncPoint) == 0x000440, "Wrong size on UAnimInstanceSyncPoint");

// Class Stalker2.PsyBeaconView
// 0x0008 (0x02F0 - 0x02E8)
class APsyBeaconView final : public AInteractableObject
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsyBeaconView">();
	}
	static class APsyBeaconView* GetDefaultObj()
	{
		return GetDefaultObjImpl<APsyBeaconView>();
	}
};
static_assert(alignof(APsyBeaconView) == 0x000008, "Wrong alignment on APsyBeaconView");
static_assert(sizeof(APsyBeaconView) == 0x0002F0, "Wrong size on APsyBeaconView");

// Class Stalker2.AnimInstanceTestFace
// 0x0010 (0x06A0 - 0x0690)
class UAnimInstanceTestFace final : public UAnimInstanceFace
{
public:
	bool                                          bUseBlendShapeAnimations;                          // 0x0690(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_691[0xF];                                      // 0x0691(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceTestFace">();
	}
	static class UAnimInstanceTestFace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceTestFace>();
	}
};
static_assert(alignof(UAnimInstanceTestFace) == 0x000010, "Wrong alignment on UAnimInstanceTestFace");
static_assert(sizeof(UAnimInstanceTestFace) == 0x0006A0, "Wrong size on UAnimInstanceTestFace");
static_assert(offsetof(UAnimInstanceTestFace, bUseBlendShapeAnimations) == 0x000690, "Member 'UAnimInstanceTestFace::bUseBlendShapeAnimations' has a wrong offset!");

// Class Stalker2.DebugWidgetBase
// 0x0008 (0x0280 - 0x0278)
class UDebugWidgetBase : public UWidgetBase
{
public:
	bool                                          bShouldDisabledOnStart;                            // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugWidgetBase">();
	}
	static class UDebugWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugWidgetBase>();
	}
};
static_assert(alignof(UDebugWidgetBase) == 0x000008, "Wrong alignment on UDebugWidgetBase");
static_assert(sizeof(UDebugWidgetBase) == 0x000280, "Wrong size on UDebugWidgetBase");
static_assert(offsetof(UDebugWidgetBase, bShouldDisabledOnStart) == 0x000278, "Member 'UDebugWidgetBase::bShouldDisabledOnStart' has a wrong offset!");

// Class Stalker2.DebugTextWidgetBase
// 0x0028 (0x02A8 - 0x0280)
class UDebugTextWidgetBase : public UDebugWidgetBase
{
public:
	class FName                                   WidgetWarningId;                                   // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TextWarningDT;                                     // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShouldEnableInWidget;                            // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 DebugImage;                                        // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGSCTextBlock*                          DebugText;                                         // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CheckDebugTextBluprint(const class FText& Text, class UUserWidget* InOwnerWidget);
	struct FUIWarningSettings FindRengeSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugTextWidgetBase">();
	}
	static class UDebugTextWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugTextWidgetBase>();
	}
};
static_assert(alignof(UDebugTextWidgetBase) == 0x000008, "Wrong alignment on UDebugTextWidgetBase");
static_assert(sizeof(UDebugTextWidgetBase) == 0x0002A8, "Wrong size on UDebugTextWidgetBase");
static_assert(offsetof(UDebugTextWidgetBase, WidgetWarningId) == 0x000280, "Member 'UDebugTextWidgetBase::WidgetWarningId' has a wrong offset!");
static_assert(offsetof(UDebugTextWidgetBase, TextWarningDT) == 0x000288, "Member 'UDebugTextWidgetBase::TextWarningDT' has a wrong offset!");
static_assert(offsetof(UDebugTextWidgetBase, IsShouldEnableInWidget) == 0x000290, "Member 'UDebugTextWidgetBase::IsShouldEnableInWidget' has a wrong offset!");
static_assert(offsetof(UDebugTextWidgetBase, DebugImage) == 0x000298, "Member 'UDebugTextWidgetBase::DebugImage' has a wrong offset!");
static_assert(offsetof(UDebugTextWidgetBase, DebugText) == 0x0002A0, "Member 'UDebugTextWidgetBase::DebugText' has a wrong offset!");

// Class Stalker2.DebugTextLenWidget
// 0x0000 (0x02A8 - 0x02A8)
class UDebugTextLenWidget final : public UDebugTextWidgetBase
{
public:
	int32 GetWarningIndex(const class FString& Text, const int32 TextLen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugTextLenWidget">();
	}
	static class UDebugTextLenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugTextLenWidget>();
	}
};
static_assert(alignof(UDebugTextLenWidget) == 0x000008, "Wrong alignment on UDebugTextLenWidget");
static_assert(sizeof(UDebugTextLenWidget) == 0x0002A8, "Wrong size on UDebugTextLenWidget");

// Class Stalker2.AnimInstanceValve
// 0x0010 (0x0410 - 0x0400)
class UAnimInstanceValve final : public UAnimInstanceBase
{
public:
	struct FAnimValveData                         ValveData;                                         // 0x0400(0x0001)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0xF];                                      // 0x0401(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetValveState(const EValveState ValveState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceValve">();
	}
	static class UAnimInstanceValve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceValve>();
	}
};
static_assert(alignof(UAnimInstanceValve) == 0x000010, "Wrong alignment on UAnimInstanceValve");
static_assert(sizeof(UAnimInstanceValve) == 0x000410, "Wrong size on UAnimInstanceValve");
static_assert(offsetof(UAnimInstanceValve, ValveData) == 0x000400, "Member 'UAnimInstanceValve::ValveData' has a wrong offset!");

// Class Stalker2.FlowerParticleComponent
// 0x0020 (0x02C0 - 0x02A0)
class UFlowerParticleComponent final : public USceneComponent
{
public:
	class USplineComponent*                       Spline;                                            // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UShapeComponent*                        Collision;                                         // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      Particle;                                          // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Speed;                                             // 0x02B8(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Distance;                                          // 0x02BC(0x0004)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowerParticleComponent">();
	}
	static class UFlowerParticleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowerParticleComponent>();
	}
};
static_assert(alignof(UFlowerParticleComponent) == 0x000010, "Wrong alignment on UFlowerParticleComponent");
static_assert(sizeof(UFlowerParticleComponent) == 0x0002C0, "Wrong size on UFlowerParticleComponent");
static_assert(offsetof(UFlowerParticleComponent, Spline) == 0x0002A0, "Member 'UFlowerParticleComponent::Spline' has a wrong offset!");
static_assert(offsetof(UFlowerParticleComponent, Collision) == 0x0002A8, "Member 'UFlowerParticleComponent::Collision' has a wrong offset!");
static_assert(offsetof(UFlowerParticleComponent, Particle) == 0x0002B0, "Member 'UFlowerParticleComponent::Particle' has a wrong offset!");
static_assert(offsetof(UFlowerParticleComponent, Speed) == 0x0002B8, "Member 'UFlowerParticleComponent::Speed' has a wrong offset!");
static_assert(offsetof(UFlowerParticleComponent, Distance) == 0x0002BC, "Member 'UFlowerParticleComponent::Distance' has a wrong offset!");

// Class Stalker2.FirstTimeSettingsWidget
// 0x0038 (0x02C8 - 0x0290)
class UFirstTimeSettingsWidget final : public USettingsPage
{
public:
	class USettingElementSwitcher*                ColorBlindness;                                    // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementSwitcher*                InterfaceLanguage;                                 // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementSwitcher*                VoicingLanguage;                                   // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingsElementPercent*                Gamma;                                             // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementSwitcher*                DynamicRange;                                      // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const bool InSelected)> OnGammaSelectedDelegate;                   // 0x02B8(0x0010)(Edit, ZeroConstructor, EditConst, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnColorBlindnessChanged(const int32 Value);
	void OnDynamicRangeChanged(const int32 Value);
	void OnGammaChanged(const float Value);
	void OnGammaSelected(const bool InSelected);
	void OnInterfaceLanguageChanged(const int32 Value);
	void OnVoiceLanguageChanged(const int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirstTimeSettingsWidget">();
	}
	static class UFirstTimeSettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirstTimeSettingsWidget>();
	}
};
static_assert(alignof(UFirstTimeSettingsWidget) == 0x000008, "Wrong alignment on UFirstTimeSettingsWidget");
static_assert(sizeof(UFirstTimeSettingsWidget) == 0x0002C8, "Wrong size on UFirstTimeSettingsWidget");
static_assert(offsetof(UFirstTimeSettingsWidget, ColorBlindness) == 0x000290, "Member 'UFirstTimeSettingsWidget::ColorBlindness' has a wrong offset!");
static_assert(offsetof(UFirstTimeSettingsWidget, InterfaceLanguage) == 0x000298, "Member 'UFirstTimeSettingsWidget::InterfaceLanguage' has a wrong offset!");
static_assert(offsetof(UFirstTimeSettingsWidget, VoicingLanguage) == 0x0002A0, "Member 'UFirstTimeSettingsWidget::VoicingLanguage' has a wrong offset!");
static_assert(offsetof(UFirstTimeSettingsWidget, Gamma) == 0x0002A8, "Member 'UFirstTimeSettingsWidget::Gamma' has a wrong offset!");
static_assert(offsetof(UFirstTimeSettingsWidget, DynamicRange) == 0x0002B0, "Member 'UFirstTimeSettingsWidget::DynamicRange' has a wrong offset!");
static_assert(offsetof(UFirstTimeSettingsWidget, OnGammaSelectedDelegate) == 0x0002B8, "Member 'UFirstTimeSettingsWidget::OnGammaSelectedDelegate' has a wrong offset!");

// Class Stalker2.AnimNotifyState_ApplyDurationalEffectContextualAction
// 0x0010 (0x0040 - 0x0030)
class UAnimNotifyState_ApplyDurationalEffectContextualAction final : public UAnimNotifyState
{
public:
	TArray<struct FModifyVFXValue>                ModifyVFXAttachmentsValue;                         // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ApplyDurationalEffectContextualAction">();
	}
	static class UAnimNotifyState_ApplyDurationalEffectContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ApplyDurationalEffectContextualAction>();
	}
};
static_assert(alignof(UAnimNotifyState_ApplyDurationalEffectContextualAction) == 0x000008, "Wrong alignment on UAnimNotifyState_ApplyDurationalEffectContextualAction");
static_assert(sizeof(UAnimNotifyState_ApplyDurationalEffectContextualAction) == 0x000040, "Wrong size on UAnimNotifyState_ApplyDurationalEffectContextualAction");
static_assert(offsetof(UAnimNotifyState_ApplyDurationalEffectContextualAction, ModifyVFXAttachmentsValue) == 0x000030, "Member 'UAnimNotifyState_ApplyDurationalEffectContextualAction::ModifyVFXAttachmentsValue' has a wrong offset!");

// Class Stalker2.AnimNotifyState_AttachItemInteractAction
// 0x0038 (0x0068 - 0x0030)
class UAnimNotifyState_AttachItemInteractAction final : public UAnimNotifyState
{
public:
	EAttachItemType                               AttachItemType;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         BoneReference;                                     // 0x0034(0x0010)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         RequiredItemIndex;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStreamableRenderAsset*                 MeshToAttach;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         AttachedMesh;                                      // 0x0050(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_AttachItemInteractAction">();
	}
	static class UAnimNotifyState_AttachItemInteractAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_AttachItemInteractAction>();
	}
};
static_assert(alignof(UAnimNotifyState_AttachItemInteractAction) == 0x000008, "Wrong alignment on UAnimNotifyState_AttachItemInteractAction");
static_assert(sizeof(UAnimNotifyState_AttachItemInteractAction) == 0x000068, "Wrong size on UAnimNotifyState_AttachItemInteractAction");
static_assert(offsetof(UAnimNotifyState_AttachItemInteractAction, AttachItemType) == 0x000030, "Member 'UAnimNotifyState_AttachItemInteractAction::AttachItemType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_AttachItemInteractAction, BoneReference) == 0x000034, "Member 'UAnimNotifyState_AttachItemInteractAction::BoneReference' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_AttachItemInteractAction, RequiredItemIndex) == 0x000044, "Member 'UAnimNotifyState_AttachItemInteractAction::RequiredItemIndex' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_AttachItemInteractAction, MeshToAttach) == 0x000048, "Member 'UAnimNotifyState_AttachItemInteractAction::MeshToAttach' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_AttachItemInteractAction, AttachedMesh) == 0x000050, "Member 'UAnimNotifyState_AttachItemInteractAction::AttachedMesh' has a wrong offset!");

// Class Stalker2.StackSplittingWidget
// 0x00D0 (0x0348 - 0x0278)
class UStackSplittingWidget final : public UWidgetBase
{
public:
	class UTextBlock*                             TextBlock_AmountToDrop;                            // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlider*                                Slider_ItemSplit;                                  // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_FullAmount;                              // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                Button_Cancel;                                     // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                Button_Split;                                      // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_Split;                                   // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImageWidget*                           ItemImage;                                         // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             HeaderText;                                        // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             ItemName;                                          // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x88];                                     // 0x02C0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCancelButtonClicked();
	void OnSplitButtonClicked();
	void OnSplitValueChanged(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StackSplittingWidget">();
	}
	static class UStackSplittingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStackSplittingWidget>();
	}
};
static_assert(alignof(UStackSplittingWidget) == 0x000008, "Wrong alignment on UStackSplittingWidget");
static_assert(sizeof(UStackSplittingWidget) == 0x000348, "Wrong size on UStackSplittingWidget");
static_assert(offsetof(UStackSplittingWidget, TextBlock_AmountToDrop) == 0x000278, "Member 'UStackSplittingWidget::TextBlock_AmountToDrop' has a wrong offset!");
static_assert(offsetof(UStackSplittingWidget, Slider_ItemSplit) == 0x000280, "Member 'UStackSplittingWidget::Slider_ItemSplit' has a wrong offset!");
static_assert(offsetof(UStackSplittingWidget, TextBlock_FullAmount) == 0x000288, "Member 'UStackSplittingWidget::TextBlock_FullAmount' has a wrong offset!");
static_assert(offsetof(UStackSplittingWidget, Button_Cancel) == 0x000290, "Member 'UStackSplittingWidget::Button_Cancel' has a wrong offset!");
static_assert(offsetof(UStackSplittingWidget, Button_Split) == 0x000298, "Member 'UStackSplittingWidget::Button_Split' has a wrong offset!");
static_assert(offsetof(UStackSplittingWidget, TextBlock_Split) == 0x0002A0, "Member 'UStackSplittingWidget::TextBlock_Split' has a wrong offset!");
static_assert(offsetof(UStackSplittingWidget, ItemImage) == 0x0002A8, "Member 'UStackSplittingWidget::ItemImage' has a wrong offset!");
static_assert(offsetof(UStackSplittingWidget, HeaderText) == 0x0002B0, "Member 'UStackSplittingWidget::HeaderText' has a wrong offset!");
static_assert(offsetof(UStackSplittingWidget, ItemName) == 0x0002B8, "Member 'UStackSplittingWidget::ItemName' has a wrong offset!");

// Class Stalker2.FastTravelManager
// 0x0018 (0x0090 - 0x0078)
class UFastTravelManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FastTravelManager">();
	}
	static class UFastTravelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFastTravelManager>();
	}
};
static_assert(alignof(UFastTravelManager) == 0x000008, "Wrong alignment on UFastTravelManager");
static_assert(sizeof(UFastTravelManager) == 0x000090, "Wrong size on UFastTravelManager");

// Class Stalker2.AnimNotifyState_Attack
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_Attack final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_Attack">();
	}
	static class UAnimNotifyState_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_Attack>();
	}
};
static_assert(alignof(UAnimNotifyState_Attack) == 0x000008, "Wrong alignment on UAnimNotifyState_Attack");
static_assert(sizeof(UAnimNotifyState_Attack) == 0x000030, "Wrong size on UAnimNotifyState_Attack");

// Class Stalker2.AnimNotifyState_BoundsScale
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_BoundsScale final : public UAnimNotifyState
{
public:
	float                                         BoundsScale;                                       // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BoundsScale">();
	}
	static class UAnimNotifyState_BoundsScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BoundsScale>();
	}
};
static_assert(alignof(UAnimNotifyState_BoundsScale) == 0x000008, "Wrong alignment on UAnimNotifyState_BoundsScale");
static_assert(sizeof(UAnimNotifyState_BoundsScale) == 0x000038, "Wrong size on UAnimNotifyState_BoundsScale");
static_assert(offsetof(UAnimNotifyState_BoundsScale, BoundsScale) == 0x000030, "Member 'UAnimNotifyState_BoundsScale::BoundsScale' has a wrong offset!");

// Class Stalker2.RichPresenceSubsystem
// 0x0080 (0x00B0 - 0x0030)
class URichPresenceSubsystem final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichPresenceSubsystem">();
	}
	static class URichPresenceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichPresenceSubsystem>();
	}
};
static_assert(alignof(URichPresenceSubsystem) == 0x000008, "Wrong alignment on URichPresenceSubsystem");
static_assert(sizeof(URichPresenceSubsystem) == 0x0000B0, "Wrong size on URichPresenceSubsystem");

// Class Stalker2.GameControllerTrackerManager
// 0x0000 (0x0078 - 0x0078)
class UGameControllerTrackerManager final : public UBaseManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameControllerTrackerManager">();
	}
	static class UGameControllerTrackerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameControllerTrackerManager>();
	}
};
static_assert(alignof(UGameControllerTrackerManager) == 0x000008, "Wrong alignment on UGameControllerTrackerManager");
static_assert(sizeof(UGameControllerTrackerManager) == 0x000078, "Wrong size on UGameControllerTrackerManager");

// Class Stalker2.AnimNotifyState_DisableDialogContextualAction
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_DisableDialogContextualAction final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DisableDialogContextualAction">();
	}
	static class UAnimNotifyState_DisableDialogContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DisableDialogContextualAction>();
	}
};
static_assert(alignof(UAnimNotifyState_DisableDialogContextualAction) == 0x000008, "Wrong alignment on UAnimNotifyState_DisableDialogContextualAction");
static_assert(sizeof(UAnimNotifyState_DisableDialogContextualAction) == 0x000030, "Wrong size on UAnimNotifyState_DisableDialogContextualAction");

// Class Stalker2.ProgressBarWidget
// 0x0008 (0x0290 - 0x0288)
class UProgressBarWidget : public UAbstractProgressBar
{
public:
	class UProgressBar*                           ProgressBarObj;                                    // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressBarWidget">();
	}
	static class UProgressBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressBarWidget>();
	}
};
static_assert(alignof(UProgressBarWidget) == 0x000008, "Wrong alignment on UProgressBarWidget");
static_assert(sizeof(UProgressBarWidget) == 0x000290, "Wrong size on UProgressBarWidget");
static_assert(offsetof(UProgressBarWidget, ProgressBarObj) == 0x000288, "Member 'UProgressBarWidget::ProgressBarObj' has a wrong offset!");

// Class Stalker2.AnimNotifyState_DIsableLookAtRestriction
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_DIsableLookAtRestriction final : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DIsableLookAtRestriction">();
	}
	static class UAnimNotifyState_DIsableLookAtRestriction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DIsableLookAtRestriction>();
	}
};
static_assert(alignof(UAnimNotifyState_DIsableLookAtRestriction) == 0x000008, "Wrong alignment on UAnimNotifyState_DIsableLookAtRestriction");
static_assert(sizeof(UAnimNotifyState_DIsableLookAtRestriction) == 0x000038, "Wrong size on UAnimNotifyState_DIsableLookAtRestriction");

// Class Stalker2.FaustInductor
// 0x00A0 (0x0338 - 0x0298)
class AFaustInductor final : public AActor
{
public:
	uint8                                         Pad_298[0x60];                                     // 0x0298(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageThreshold;                                   // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCalculateDamageWithArmor;                         // 0x02FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FD[0x3];                                      // 0x02FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FObjectArmorData                       ArmorData;                                         // 0x0300(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         NumberOfInductorPhases;                            // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InductorCooldownTime;                              // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AccumulatedDamage;                                 // 0x0314(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x20];                                     // 0x0318(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDamageAccumulated(const struct FUID& LastDamageDealerUID, const bool bProjectileFlownThroughObject);
	void OnDamageDealt();
	void OnInductorCooldown();
	void OnInductorDisabled();
	void OnInductorEnabled();
	void OnInvulnerableHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FaustInductor">();
	}
	static class AFaustInductor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFaustInductor>();
	}
};
static_assert(alignof(AFaustInductor) == 0x000008, "Wrong alignment on AFaustInductor");
static_assert(sizeof(AFaustInductor) == 0x000338, "Wrong size on AFaustInductor");
static_assert(offsetof(AFaustInductor, DamageThreshold) == 0x0002F8, "Member 'AFaustInductor::DamageThreshold' has a wrong offset!");
static_assert(offsetof(AFaustInductor, bCalculateDamageWithArmor) == 0x0002FC, "Member 'AFaustInductor::bCalculateDamageWithArmor' has a wrong offset!");
static_assert(offsetof(AFaustInductor, ArmorData) == 0x000300, "Member 'AFaustInductor::ArmorData' has a wrong offset!");
static_assert(offsetof(AFaustInductor, NumberOfInductorPhases) == 0x00030C, "Member 'AFaustInductor::NumberOfInductorPhases' has a wrong offset!");
static_assert(offsetof(AFaustInductor, InductorCooldownTime) == 0x000310, "Member 'AFaustInductor::InductorCooldownTime' has a wrong offset!");
static_assert(offsetof(AFaustInductor, AccumulatedDamage) == 0x000314, "Member 'AFaustInductor::AccumulatedDamage' has a wrong offset!");

// Class Stalker2.AnimNotifyState_ForceReloadingEnd
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_ForceReloadingEnd final : public UAnimNotifyState
{
public:
	bool                                          IsUnloading;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ForceReloadingEnd">();
	}
	static class UAnimNotifyState_ForceReloadingEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ForceReloadingEnd>();
	}
};
static_assert(alignof(UAnimNotifyState_ForceReloadingEnd) == 0x000008, "Wrong alignment on UAnimNotifyState_ForceReloadingEnd");
static_assert(sizeof(UAnimNotifyState_ForceReloadingEnd) == 0x000038, "Wrong size on UAnimNotifyState_ForceReloadingEnd");
static_assert(offsetof(UAnimNotifyState_ForceReloadingEnd, IsUnloading) == 0x000030, "Member 'UAnimNotifyState_ForceReloadingEnd::IsUnloading' has a wrong offset!");

// Class Stalker2.PSYAnomaly
// 0x0018 (0x03B0 - 0x0398)
class APSYAnomaly : public AAnomaly
{
public:
	class USphereComponent*                       CollisionComponent;                                // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      PSYParticle;                                       // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PSYAnomaly">();
	}
	static class APSYAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<APSYAnomaly>();
	}
};
static_assert(alignof(APSYAnomaly) == 0x000008, "Wrong alignment on APSYAnomaly");
static_assert(sizeof(APSYAnomaly) == 0x0003B0, "Wrong size on APSYAnomaly");
static_assert(offsetof(APSYAnomaly, CollisionComponent) == 0x000398, "Member 'APSYAnomaly::CollisionComponent' has a wrong offset!");
static_assert(offsetof(APSYAnomaly, PSYParticle) == 0x0003A0, "Member 'APSYAnomaly::PSYParticle' has a wrong offset!");

// Class Stalker2.PSYEmitterAnomaly
// 0x0000 (0x03B0 - 0x03B0)
class APSYEmitterAnomaly final : public APSYAnomaly
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PSYEmitterAnomaly">();
	}
	static class APSYEmitterAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<APSYEmitterAnomaly>();
	}
};
static_assert(alignof(APSYEmitterAnomaly) == 0x000008, "Wrong alignment on APSYEmitterAnomaly");
static_assert(sizeof(APSYEmitterAnomaly) == 0x0003B0, "Wrong size on APSYEmitterAnomaly");

// Class Stalker2.AnimNotifyState_ForceWarpActorRotation
// 0x0060 (0x0090 - 0x0030)
class UAnimNotifyState_ForceWarpActorRotation final : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WarpTargetName;                                    // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldExcludeWarpTargetAfterComplete;             // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ForceWarpActorRotation">();
	}
	static class UAnimNotifyState_ForceWarpActorRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ForceWarpActorRotation>();
	}
};
static_assert(alignof(UAnimNotifyState_ForceWarpActorRotation) == 0x000008, "Wrong alignment on UAnimNotifyState_ForceWarpActorRotation");
static_assert(sizeof(UAnimNotifyState_ForceWarpActorRotation) == 0x000090, "Wrong size on UAnimNotifyState_ForceWarpActorRotation");
static_assert(offsetof(UAnimNotifyState_ForceWarpActorRotation, WarpTargetName) == 0x000080, "Member 'UAnimNotifyState_ForceWarpActorRotation::WarpTargetName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ForceWarpActorRotation, bShouldExcludeWarpTargetAfterComplete) == 0x000088, "Member 'UAnimNotifyState_ForceWarpActorRotation::bShouldExcludeWarpTargetAfterComplete' has a wrong offset!");

// Class Stalker2.AnimNotifyState_FOVBlend
// 0x0068 (0x0098 - 0x0030)
class UAnimNotifyState_FOVBlend final : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsBlendIn;                                        // 0x0080(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendOption;                                       // 0x0081(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CustomCurve;                                       // 0x0088(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBlendWeaponInHands;                         // 0x0090(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldIgnoreNotifyEndOnInterrupt;                 // 0x0091(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_FOVBlend">();
	}
	static class UAnimNotifyState_FOVBlend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_FOVBlend>();
	}
};
static_assert(alignof(UAnimNotifyState_FOVBlend) == 0x000008, "Wrong alignment on UAnimNotifyState_FOVBlend");
static_assert(sizeof(UAnimNotifyState_FOVBlend) == 0x000098, "Wrong size on UAnimNotifyState_FOVBlend");
static_assert(offsetof(UAnimNotifyState_FOVBlend, bIsBlendIn) == 0x000080, "Member 'UAnimNotifyState_FOVBlend::bIsBlendIn' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_FOVBlend, BlendOption) == 0x000081, "Member 'UAnimNotifyState_FOVBlend::BlendOption' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_FOVBlend, CustomCurve) == 0x000088, "Member 'UAnimNotifyState_FOVBlend::CustomCurve' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_FOVBlend, bShouldBlendWeaponInHands) == 0x000090, "Member 'UAnimNotifyState_FOVBlend::bShouldBlendWeaponInHands' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_FOVBlend, bShouldIgnoreNotifyEndOnInterrupt) == 0x000091, "Member 'UAnimNotifyState_FOVBlend::bShouldIgnoreNotifyEndOnInterrupt' has a wrong offset!");

// Class Stalker2.AnimNotifyState_LookAt
// 0x00E8 (0x0118 - 0x0030)
class UAnimNotifyState_LookAt final : public UAnimNotifyState
{
public:
	EAttractionPointType                          AttractionPointType;                               // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtPlayer;                                     // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LookAtPlaceholderQuestGuid;                        // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LookAtActorFName;                                  // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactionTime;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EApplyRestrictionType                         ApplyRestrictionType;                              // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ERotationPartType, struct FBodyPartRestriction> HorizontalRestrictions;                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TMap<ERotationPartType, struct FBodyPartRestriction> VerticalRestrictions;                       // 0x00C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_LookAt">();
	}
	static class UAnimNotifyState_LookAt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_LookAt>();
	}
};
static_assert(alignof(UAnimNotifyState_LookAt) == 0x000008, "Wrong alignment on UAnimNotifyState_LookAt");
static_assert(sizeof(UAnimNotifyState_LookAt) == 0x000118, "Wrong size on UAnimNotifyState_LookAt");
static_assert(offsetof(UAnimNotifyState_LookAt, AttractionPointType) == 0x000030, "Member 'UAnimNotifyState_LookAt::AttractionPointType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_LookAt, bLookAtPlayer) == 0x000031, "Member 'UAnimNotifyState_LookAt::bLookAtPlayer' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_LookAt, LookAtPlaceholderQuestGuid) == 0x000034, "Member 'UAnimNotifyState_LookAt::LookAtPlaceholderQuestGuid' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_LookAt, LookAtActorFName) == 0x00003C, "Member 'UAnimNotifyState_LookAt::LookAtActorFName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_LookAt, TargetLocation) == 0x000048, "Member 'UAnimNotifyState_LookAt::TargetLocation' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_LookAt, BoneName) == 0x000060, "Member 'UAnimNotifyState_LookAt::BoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_LookAt, ReactionTime) == 0x000068, "Member 'UAnimNotifyState_LookAt::ReactionTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_LookAt, Priority) == 0x00006C, "Member 'UAnimNotifyState_LookAt::Priority' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_LookAt, CollisionChannel) == 0x000070, "Member 'UAnimNotifyState_LookAt::CollisionChannel' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_LookAt, ApplyRestrictionType) == 0x000071, "Member 'UAnimNotifyState_LookAt::ApplyRestrictionType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_LookAt, HorizontalRestrictions) == 0x000078, "Member 'UAnimNotifyState_LookAt::HorizontalRestrictions' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_LookAt, VerticalRestrictions) == 0x0000C8, "Member 'UAnimNotifyState_LookAt::VerticalRestrictions' has a wrong offset!");

// Class Stalker2.RepairPriceWidget
// 0x0008 (0x0280 - 0x0278)
class URepairPriceWidget final : public UWidgetBase
{
public:
	class UTextBlock*                             Price;                                             // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepairPriceWidget">();
	}
	static class URepairPriceWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URepairPriceWidget>();
	}
};
static_assert(alignof(URepairPriceWidget) == 0x000008, "Wrong alignment on URepairPriceWidget");
static_assert(sizeof(URepairPriceWidget) == 0x000280, "Wrong size on URepairPriceWidget");
static_assert(offsetof(URepairPriceWidget, Price) == 0x000278, "Member 'URepairPriceWidget::Price' has a wrong offset!");

// Class Stalker2.FireIPU
// 0x0000 (0x0040 - 0x0040)
class UFireIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireIPU">();
	}
	static class UFireIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireIPU>();
	}
};
static_assert(alignof(UFireIPU) == 0x000008, "Wrong alignment on UFireIPU");
static_assert(sizeof(UFireIPU) == 0x000040, "Wrong size on UFireIPU");

// Class Stalker2.AnimNotifyState_MotionAudioEnveloper
// 0x0060 (0x0090 - 0x0030)
class UAnimNotifyState_MotionAudioEnveloper final : public UAnimNotifyState
{
public:
	class UAkAudioEvent*                          PlayAkEvent;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopAkEvent;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                MotionSpeedRTPC;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBoneVelocity;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBoneVelocity;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterpolationTime;                                 // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBoneVelocityInfo;                             // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           AttachedAudioComponent;                            // 0x0060(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x28];                                      // 0x0068(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_MotionAudioEnveloper">();
	}
	static class UAnimNotifyState_MotionAudioEnveloper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_MotionAudioEnveloper>();
	}
};
static_assert(alignof(UAnimNotifyState_MotionAudioEnveloper) == 0x000008, "Wrong alignment on UAnimNotifyState_MotionAudioEnveloper");
static_assert(sizeof(UAnimNotifyState_MotionAudioEnveloper) == 0x000090, "Wrong size on UAnimNotifyState_MotionAudioEnveloper");
static_assert(offsetof(UAnimNotifyState_MotionAudioEnveloper, PlayAkEvent) == 0x000030, "Member 'UAnimNotifyState_MotionAudioEnveloper::PlayAkEvent' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MotionAudioEnveloper, StopAkEvent) == 0x000038, "Member 'UAnimNotifyState_MotionAudioEnveloper::StopAkEvent' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MotionAudioEnveloper, MotionSpeedRTPC) == 0x000040, "Member 'UAnimNotifyState_MotionAudioEnveloper::MotionSpeedRTPC' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MotionAudioEnveloper, BoneName) == 0x000048, "Member 'UAnimNotifyState_MotionAudioEnveloper::BoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MotionAudioEnveloper, MinBoneVelocity) == 0x000050, "Member 'UAnimNotifyState_MotionAudioEnveloper::MinBoneVelocity' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MotionAudioEnveloper, MaxBoneVelocity) == 0x000054, "Member 'UAnimNotifyState_MotionAudioEnveloper::MaxBoneVelocity' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MotionAudioEnveloper, InterpolationTime) == 0x000058, "Member 'UAnimNotifyState_MotionAudioEnveloper::InterpolationTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MotionAudioEnveloper, bShowBoneVelocityInfo) == 0x00005C, "Member 'UAnimNotifyState_MotionAudioEnveloper::bShowBoneVelocityInfo' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MotionAudioEnveloper, AttachedAudioComponent) == 0x000060, "Member 'UAnimNotifyState_MotionAudioEnveloper::AttachedAudioComponent' has a wrong offset!");

// Class Stalker2.AnimNotifyState_PreciseRootMotion
// 0x0058 (0x0088 - 0x0030)
class UAnimNotifyState_PreciseRootMotion final : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	EPreciseRootMotionDeltaTimeModifier           DeltaTimeModifier;                                 // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopTimeCompareTolerance;                          // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_PreciseRootMotion">();
	}
	static class UAnimNotifyState_PreciseRootMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_PreciseRootMotion>();
	}
};
static_assert(alignof(UAnimNotifyState_PreciseRootMotion) == 0x000008, "Wrong alignment on UAnimNotifyState_PreciseRootMotion");
static_assert(sizeof(UAnimNotifyState_PreciseRootMotion) == 0x000088, "Wrong size on UAnimNotifyState_PreciseRootMotion");
static_assert(offsetof(UAnimNotifyState_PreciseRootMotion, DeltaTimeModifier) == 0x000080, "Member 'UAnimNotifyState_PreciseRootMotion::DeltaTimeModifier' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_PreciseRootMotion, LoopTimeCompareTolerance) == 0x000084, "Member 'UAnimNotifyState_PreciseRootMotion::LoopTimeCompareTolerance' has a wrong offset!");

// Class Stalker2.SelectionVolumeSphere
// 0x0000 (0x02A0 - 0x02A0)
class ASelectionVolumeSphere final : public ASelectionVolumeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectionVolumeSphere">();
	}
	static class ASelectionVolumeSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASelectionVolumeSphere>();
	}
};
static_assert(alignof(ASelectionVolumeSphere) == 0x000008, "Wrong alignment on ASelectionVolumeSphere");
static_assert(sizeof(ASelectionVolumeSphere) == 0x0002A0, "Wrong size on ASelectionVolumeSphere");

// Class Stalker2.TelekineticShield
// 0x00F0 (0x0388 - 0x0298)
class ATelekineticShield final : public AActor
{
public:
	uint8                                         Pad_298[0x20];                                     // 0x0298(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      Particle;                                          // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ShieldDestroyedParticle;                           // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         HitImpactParticle;                                 // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkAudioComponent;                                  // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ShieldDestroyedSound;                              // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ShieldSpawnedSound;                                // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ShieldImpactSound;                                 // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Health;                                            // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovementSpeed;                                     // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DistanceFromOwner;                                 // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OwnerHeightOffset;                                 // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ParticleIntensityChangeSpeed;                      // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxLifetime;                                       // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpawnShiftFraction;                                // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_314[0x74];                                     // 0x0314(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeathParticleFinished(class UNiagaraComponent* DeathVFXComponent);
	void OnHitReceivedBP(const struct FCommonHitArgs& HitArgs);
	void OnShieldDestroyedBP();

	class AObj* GetOwnerActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TelekineticShield">();
	}
	static class ATelekineticShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATelekineticShield>();
	}
};
static_assert(alignof(ATelekineticShield) == 0x000008, "Wrong alignment on ATelekineticShield");
static_assert(sizeof(ATelekineticShield) == 0x000388, "Wrong size on ATelekineticShield");
static_assert(offsetof(ATelekineticShield, MeshComponent) == 0x0002B8, "Member 'ATelekineticShield::MeshComponent' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, Particle) == 0x0002C0, "Member 'ATelekineticShield::Particle' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, ShieldDestroyedParticle) == 0x0002C8, "Member 'ATelekineticShield::ShieldDestroyedParticle' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, HitImpactParticle) == 0x0002D0, "Member 'ATelekineticShield::HitImpactParticle' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, AkAudioComponent) == 0x0002D8, "Member 'ATelekineticShield::AkAudioComponent' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, ShieldDestroyedSound) == 0x0002E0, "Member 'ATelekineticShield::ShieldDestroyedSound' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, ShieldSpawnedSound) == 0x0002E8, "Member 'ATelekineticShield::ShieldSpawnedSound' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, ShieldImpactSound) == 0x0002F0, "Member 'ATelekineticShield::ShieldImpactSound' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, Health) == 0x0002F8, "Member 'ATelekineticShield::Health' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, MovementSpeed) == 0x0002FC, "Member 'ATelekineticShield::MovementSpeed' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, DistanceFromOwner) == 0x000300, "Member 'ATelekineticShield::DistanceFromOwner' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, OwnerHeightOffset) == 0x000304, "Member 'ATelekineticShield::OwnerHeightOffset' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, ParticleIntensityChangeSpeed) == 0x000308, "Member 'ATelekineticShield::ParticleIntensityChangeSpeed' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, MaxLifetime) == 0x00030C, "Member 'ATelekineticShield::MaxLifetime' has a wrong offset!");
static_assert(offsetof(ATelekineticShield, SpawnShiftFraction) == 0x000310, "Member 'ATelekineticShield::SpawnShiftFraction' has a wrong offset!");

// Class Stalker2.DPADSelection
// 0x0028 (0x02A0 - 0x0278)
class UDPADSelection final : public UWidgetBase
{
public:
	class USizeBox*                               SizeContainer;                                     // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDpadNavigation                               DpadNavigation;                                    // 0x0280(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DPadStyleId;                                       // 0x0284(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLoadWidgetSize;                             // 0x028C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D[0x3];                                      // 0x028D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WidgetSize;                                        // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImageWidget*                           Dpad_Active;                                       // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DPADSelection">();
	}
	static class UDPADSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDPADSelection>();
	}
};
static_assert(alignof(UDPADSelection) == 0x000008, "Wrong alignment on UDPADSelection");
static_assert(sizeof(UDPADSelection) == 0x0002A0, "Wrong size on UDPADSelection");
static_assert(offsetof(UDPADSelection, SizeContainer) == 0x000278, "Member 'UDPADSelection::SizeContainer' has a wrong offset!");
static_assert(offsetof(UDPADSelection, DpadNavigation) == 0x000280, "Member 'UDPADSelection::DpadNavigation' has a wrong offset!");
static_assert(offsetof(UDPADSelection, DPadStyleId) == 0x000284, "Member 'UDPADSelection::DPadStyleId' has a wrong offset!");
static_assert(offsetof(UDPADSelection, bShouldLoadWidgetSize) == 0x00028C, "Member 'UDPADSelection::bShouldLoadWidgetSize' has a wrong offset!");
static_assert(offsetof(UDPADSelection, WidgetSize) == 0x000290, "Member 'UDPADSelection::WidgetSize' has a wrong offset!");
static_assert(offsetof(UDPADSelection, Dpad_Active) == 0x000298, "Member 'UDPADSelection::Dpad_Active' has a wrong offset!");

// Class Stalker2.AnimNotify_SetAdditiveWeaponMode
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_SetAdditiveWeaponMode final : public UAnimNotifyState
{
public:
	EAnimWeaponAdditivePoseMode                   TargetWeaponAdditivePoseMod;                       // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetAdditiveWeaponMode">();
	}
	static class UAnimNotify_SetAdditiveWeaponMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetAdditiveWeaponMode>();
	}
};
static_assert(alignof(UAnimNotify_SetAdditiveWeaponMode) == 0x000008, "Wrong alignment on UAnimNotify_SetAdditiveWeaponMode");
static_assert(sizeof(UAnimNotify_SetAdditiveWeaponMode) == 0x000038, "Wrong size on UAnimNotify_SetAdditiveWeaponMode");
static_assert(offsetof(UAnimNotify_SetAdditiveWeaponMode, TargetWeaponAdditivePoseMod) == 0x000030, "Member 'UAnimNotify_SetAdditiveWeaponMode::TargetWeaponAdditivePoseMod' has a wrong offset!");

// Class Stalker2.QuickSaveIPU
// 0x0000 (0x0040 - 0x0040)
class UQuickSaveIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickSaveIPU">();
	}
	static class UQuickSaveIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickSaveIPU>();
	}
};
static_assert(alignof(UQuickSaveIPU) == 0x000008, "Wrong alignment on UQuickSaveIPU");
static_assert(sizeof(UQuickSaveIPU) == 0x000040, "Wrong size on UQuickSaveIPU");

// Class Stalker2.AnimNotifyState_SpawnParticleTimeline
// 0x0018 (0x0048 - 0x0030)
class UAnimNotifyState_SpawnParticleTimeline final : public UAnimNotifyState
{
public:
	class UFXSystemAsset*                         ParticlePFX;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneToSpawnOnName;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAttachToBone;                                   // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SpawnParticleTimeline">();
	}
	static class UAnimNotifyState_SpawnParticleTimeline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SpawnParticleTimeline>();
	}
};
static_assert(alignof(UAnimNotifyState_SpawnParticleTimeline) == 0x000008, "Wrong alignment on UAnimNotifyState_SpawnParticleTimeline");
static_assert(sizeof(UAnimNotifyState_SpawnParticleTimeline) == 0x000048, "Wrong size on UAnimNotifyState_SpawnParticleTimeline");
static_assert(offsetof(UAnimNotifyState_SpawnParticleTimeline, ParticlePFX) == 0x000030, "Member 'UAnimNotifyState_SpawnParticleTimeline::ParticlePFX' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnParticleTimeline, BoneToSpawnOnName) == 0x000038, "Member 'UAnimNotifyState_SpawnParticleTimeline::BoneToSpawnOnName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnParticleTimeline, bIsAttachToBone) == 0x000040, "Member 'UAnimNotifyState_SpawnParticleTimeline::bIsAttachToBone' has a wrong offset!");

// Class Stalker2.FlycatcherAnomaly
// 0x0048 (0x03E0 - 0x0398)
class AFlycatcherAnomaly final : public AAnomaly
{
public:
	class USphereComponent*                       OverlapSphereComponent;                            // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   VFXEffectSphere;                                   // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAuxBus*                              FlycatcherAuxBus;                                  // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkLateReverbComponent*                 FlycatcherAuxComponent;                            // 0x03B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                InfluenceLevelRTPC;                                // 0x03B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkStateValue*                          DefaultStateValue;                                 // 0x03C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkStateValue*                          FlycatcherStateValue;                              // 0x03C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x10];                                     // 0x03D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlycatcherAnomaly">();
	}
	static class AFlycatcherAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlycatcherAnomaly>();
	}
};
static_assert(alignof(AFlycatcherAnomaly) == 0x000008, "Wrong alignment on AFlycatcherAnomaly");
static_assert(sizeof(AFlycatcherAnomaly) == 0x0003E0, "Wrong size on AFlycatcherAnomaly");
static_assert(offsetof(AFlycatcherAnomaly, OverlapSphereComponent) == 0x000398, "Member 'AFlycatcherAnomaly::OverlapSphereComponent' has a wrong offset!");
static_assert(offsetof(AFlycatcherAnomaly, VFXEffectSphere) == 0x0003A0, "Member 'AFlycatcherAnomaly::VFXEffectSphere' has a wrong offset!");
static_assert(offsetof(AFlycatcherAnomaly, FlycatcherAuxBus) == 0x0003A8, "Member 'AFlycatcherAnomaly::FlycatcherAuxBus' has a wrong offset!");
static_assert(offsetof(AFlycatcherAnomaly, FlycatcherAuxComponent) == 0x0003B0, "Member 'AFlycatcherAnomaly::FlycatcherAuxComponent' has a wrong offset!");
static_assert(offsetof(AFlycatcherAnomaly, InfluenceLevelRTPC) == 0x0003B8, "Member 'AFlycatcherAnomaly::InfluenceLevelRTPC' has a wrong offset!");
static_assert(offsetof(AFlycatcherAnomaly, DefaultStateValue) == 0x0003C0, "Member 'AFlycatcherAnomaly::DefaultStateValue' has a wrong offset!");
static_assert(offsetof(AFlycatcherAnomaly, FlycatcherStateValue) == 0x0003C8, "Member 'AFlycatcherAnomaly::FlycatcherStateValue' has a wrong offset!");

// Class Stalker2.AnimNotifyState_StandToRelaxIdle
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_StandToRelaxIdle final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_StandToRelaxIdle">();
	}
	static class UAnimNotifyState_StandToRelaxIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_StandToRelaxIdle>();
	}
};
static_assert(alignof(UAnimNotifyState_StandToRelaxIdle) == 0x000008, "Wrong alignment on UAnimNotifyState_StandToRelaxIdle");
static_assert(sizeof(UAnimNotifyState_StandToRelaxIdle) == 0x000030, "Wrong size on UAnimNotifyState_StandToRelaxIdle");

// Class Stalker2.HoverIndicator
// 0x0018 (0x0290 - 0x0278)
class UHoverIndicator : public UWidgetBase
{
public:
	class UImage*                                 Background;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsHovered)> OnHoverIndicator;                                // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoverIndicator">();
	}
	static class UHoverIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoverIndicator>();
	}
};
static_assert(alignof(UHoverIndicator) == 0x000008, "Wrong alignment on UHoverIndicator");
static_assert(sizeof(UHoverIndicator) == 0x000290, "Wrong size on UHoverIndicator");
static_assert(offsetof(UHoverIndicator, Background) == 0x000278, "Member 'UHoverIndicator::Background' has a wrong offset!");
static_assert(offsetof(UHoverIndicator, OnHoverIndicator) == 0x000280, "Member 'UHoverIndicator::OnHoverIndicator' has a wrong offset!");

// Class Stalker2.PDAQuestTaskContainer
// 0x0068 (0x02F8 - 0x0290)
class UPDAQuestTaskContainer final : public UHoverIndicator
{
public:
	class UScrollBox*                             TaskScroll;                                        // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPDAQuestTaskSlot>          TaskListClass;                                     // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TaskListSize;                                      // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDebug;                                      // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FontStyle;                                         // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InputAction;                                       // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UPDAQuestTaskSlot* StageSlotWidget)> OnTrackingStage;        // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnUpdateStageHover;                                // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MouseHoverStage(const bool bHovered, const int32 IndexOnParent);
	void StageClick(class UPDAQuestTaskSlot* InSlot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAQuestTaskContainer">();
	}
	static class UPDAQuestTaskContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAQuestTaskContainer>();
	}
};
static_assert(alignof(UPDAQuestTaskContainer) == 0x000008, "Wrong alignment on UPDAQuestTaskContainer");
static_assert(sizeof(UPDAQuestTaskContainer) == 0x0002F8, "Wrong size on UPDAQuestTaskContainer");
static_assert(offsetof(UPDAQuestTaskContainer, TaskScroll) == 0x000290, "Member 'UPDAQuestTaskContainer::TaskScroll' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskContainer, TaskListClass) == 0x000298, "Member 'UPDAQuestTaskContainer::TaskListClass' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskContainer, TaskListSize) == 0x0002A0, "Member 'UPDAQuestTaskContainer::TaskListSize' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskContainer, bShouldDebug) == 0x0002A4, "Member 'UPDAQuestTaskContainer::bShouldDebug' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskContainer, FontStyle) == 0x0002A8, "Member 'UPDAQuestTaskContainer::FontStyle' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskContainer, InputAction) == 0x0002B8, "Member 'UPDAQuestTaskContainer::InputAction' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskContainer, OnTrackingStage) == 0x0002C8, "Member 'UPDAQuestTaskContainer::OnTrackingStage' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskContainer, OnUpdateStageHover) == 0x0002D8, "Member 'UPDAQuestTaskContainer::OnUpdateStageHover' has a wrong offset!");

// Class Stalker2.AnimNotify_GSCPlayMontageNotifyWindow
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_GSCPlayMontageNotifyWindow : public UAnimNotifyState
{
public:
	struct FGameplayTag                           NotifyTag;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GSCPlayMontageNotifyWindow">();
	}
	static class UAnimNotify_GSCPlayMontageNotifyWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GSCPlayMontageNotifyWindow>();
	}
};
static_assert(alignof(UAnimNotify_GSCPlayMontageNotifyWindow) == 0x000008, "Wrong alignment on UAnimNotify_GSCPlayMontageNotifyWindow");
static_assert(sizeof(UAnimNotify_GSCPlayMontageNotifyWindow) == 0x000038, "Wrong size on UAnimNotify_GSCPlayMontageNotifyWindow");
static_assert(offsetof(UAnimNotify_GSCPlayMontageNotifyWindow, NotifyTag) == 0x000030, "Member 'UAnimNotify_GSCPlayMontageNotifyWindow::NotifyTag' has a wrong offset!");

// Class Stalker2.GAInventoryActionProcessor
// 0x0058 (0x0080 - 0x0028)
class UGAInventoryActionProcessor final : public UGAPlayerProcessorInterface
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAInventoryActionProcessor">();
	}
	static class UGAInventoryActionProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAInventoryActionProcessor>();
	}
};
static_assert(alignof(UGAInventoryActionProcessor) == 0x000008, "Wrong alignment on UGAInventoryActionProcessor");
static_assert(sizeof(UGAInventoryActionProcessor) == 0x000080, "Wrong size on UGAInventoryActionProcessor");

// Class Stalker2.AnimNotifyState_ThrowGrenade
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_ThrowGrenade final : public UAnimNotify_GSCPlayMontageNotifyWindow
{
public:
	class FName                                   BoneName;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ThrowGrenade">();
	}
	static class UAnimNotifyState_ThrowGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ThrowGrenade>();
	}
};
static_assert(alignof(UAnimNotifyState_ThrowGrenade) == 0x000008, "Wrong alignment on UAnimNotifyState_ThrowGrenade");
static_assert(sizeof(UAnimNotifyState_ThrowGrenade) == 0x000040, "Wrong size on UAnimNotifyState_ThrowGrenade");
static_assert(offsetof(UAnimNotifyState_ThrowGrenade, BoneName) == 0x000038, "Member 'UAnimNotifyState_ThrowGrenade::BoneName' has a wrong offset!");

// Class Stalker2.AnimNotify_AIAnimationAction
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_AIAnimationAction final : public UAnimNotifyBase
{
public:
	EAIAnimationAction                            AnimationAction;                                   // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AIAnimationAction">();
	}
	static class UAnimNotify_AIAnimationAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AIAnimationAction>();
	}
};
static_assert(alignof(UAnimNotify_AIAnimationAction) == 0x000008, "Wrong alignment on UAnimNotify_AIAnimationAction");
static_assert(sizeof(UAnimNotify_AIAnimationAction) == 0x000048, "Wrong size on UAnimNotify_AIAnimationAction");
static_assert(offsetof(UAnimNotify_AIAnimationAction, AnimationAction) == 0x000040, "Member 'UAnimNotify_AIAnimationAction::AnimationAction' has a wrong offset!");

// Class Stalker2.PDASlotPanelBase
// 0x0068 (0x02E0 - 0x0278)
class UPDASlotPanelBase : public UChildViewBase
{
public:
	class UVerticalBox*                           SlotContainer;                                     // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDAArrowButton*                        ArrowDown;                                         // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDAArrowButton*                        ArrowTop;                                          // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsEmptyDetails)> OnUpdateDetails;                            // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 OutIndexSelectButton)> OnUpdateSelectButton;                 // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   ArrowActionIdTop;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ArrowActionIdDown;                                 // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x20];                                     // 0x02C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClickArrowButton(const class FName ButtonId);
	void ClickSlot(const int32 QuestSlotIndex);
	void UpdateSelectSlotID();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDASlotPanelBase">();
	}
	static class UPDASlotPanelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDASlotPanelBase>();
	}
};
static_assert(alignof(UPDASlotPanelBase) == 0x000008, "Wrong alignment on UPDASlotPanelBase");
static_assert(sizeof(UPDASlotPanelBase) == 0x0002E0, "Wrong size on UPDASlotPanelBase");
static_assert(offsetof(UPDASlotPanelBase, SlotContainer) == 0x000278, "Member 'UPDASlotPanelBase::SlotContainer' has a wrong offset!");
static_assert(offsetof(UPDASlotPanelBase, ArrowDown) == 0x000280, "Member 'UPDASlotPanelBase::ArrowDown' has a wrong offset!");
static_assert(offsetof(UPDASlotPanelBase, ArrowTop) == 0x000288, "Member 'UPDASlotPanelBase::ArrowTop' has a wrong offset!");
static_assert(offsetof(UPDASlotPanelBase, OnUpdateDetails) == 0x000290, "Member 'UPDASlotPanelBase::OnUpdateDetails' has a wrong offset!");
static_assert(offsetof(UPDASlotPanelBase, OnUpdateSelectButton) == 0x0002A0, "Member 'UPDASlotPanelBase::OnUpdateSelectButton' has a wrong offset!");
static_assert(offsetof(UPDASlotPanelBase, ArrowActionIdTop) == 0x0002B0, "Member 'UPDASlotPanelBase::ArrowActionIdTop' has a wrong offset!");
static_assert(offsetof(UPDASlotPanelBase, ArrowActionIdDown) == 0x0002B8, "Member 'UPDASlotPanelBase::ArrowActionIdDown' has a wrong offset!");

// Class Stalker2.PDAQuestPanel
// 0x00F0 (0x03D0 - 0x02E0)
class UPDAQuestPanel final : public UPDASlotPanelBase
{
public:
	class UPDATextBorder*                         MainQuestBorder;                                   // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDATextBorder*                         CancelledQuestBorder;                              // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDATextBorder*                         SecondaryQuestBorder;                              // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               EmptySizeBorder;                                   // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               SecondEmptySizeBorder;                             // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelectInput;                                       // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InputActionName;                                   // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MainQuestTint;                                     // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultQuestTint;                                  // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MainQuestLocalizationSID;                          // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SecondaryQuestLocalizationSID;                     // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FinishQuestLocalizationSID;                        // 0x0360(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FailedQuestLocalizationSID;                        // 0x0370(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CanceledQuestLocalizationSID;                      // 0x0380(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x10];                                     // 0x0390(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UScenarioManager*                       ScenarioManager;                                   // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x28];                                     // 0x03A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeSelectedQuestSlot(const int32 JournalQuestIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAQuestPanel">();
	}
	static class UPDAQuestPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAQuestPanel>();
	}
};
static_assert(alignof(UPDAQuestPanel) == 0x000008, "Wrong alignment on UPDAQuestPanel");
static_assert(sizeof(UPDAQuestPanel) == 0x0003D0, "Wrong size on UPDAQuestPanel");
static_assert(offsetof(UPDAQuestPanel, MainQuestBorder) == 0x0002E0, "Member 'UPDAQuestPanel::MainQuestBorder' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, CancelledQuestBorder) == 0x0002E8, "Member 'UPDAQuestPanel::CancelledQuestBorder' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, SecondaryQuestBorder) == 0x0002F0, "Member 'UPDAQuestPanel::SecondaryQuestBorder' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, EmptySizeBorder) == 0x0002F8, "Member 'UPDAQuestPanel::EmptySizeBorder' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, SecondEmptySizeBorder) == 0x000300, "Member 'UPDAQuestPanel::SecondEmptySizeBorder' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, SelectInput) == 0x000308, "Member 'UPDAQuestPanel::SelectInput' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, InputActionName) == 0x000310, "Member 'UPDAQuestPanel::InputActionName' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, MainQuestTint) == 0x000320, "Member 'UPDAQuestPanel::MainQuestTint' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, DefaultQuestTint) == 0x000330, "Member 'UPDAQuestPanel::DefaultQuestTint' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, MainQuestLocalizationSID) == 0x000340, "Member 'UPDAQuestPanel::MainQuestLocalizationSID' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, SecondaryQuestLocalizationSID) == 0x000350, "Member 'UPDAQuestPanel::SecondaryQuestLocalizationSID' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, FinishQuestLocalizationSID) == 0x000360, "Member 'UPDAQuestPanel::FinishQuestLocalizationSID' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, FailedQuestLocalizationSID) == 0x000370, "Member 'UPDAQuestPanel::FailedQuestLocalizationSID' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, CanceledQuestLocalizationSID) == 0x000380, "Member 'UPDAQuestPanel::CanceledQuestLocalizationSID' has a wrong offset!");
static_assert(offsetof(UPDAQuestPanel, ScenarioManager) == 0x0003A0, "Member 'UPDAQuestPanel::ScenarioManager' has a wrong offset!");

// Class Stalker2.AnimNotify_AnyFootOnGround
// 0x0060 (0x0098 - 0x0038)
class UAnimNotify_AnyFootOnGround final : public UAnimNotify
{
public:
	EFootType                                     Foot;                                              // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToeSocketName;                                     // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachedParticle;                                 // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0080(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AnyFootOnGround">();
	}
	static class UAnimNotify_AnyFootOnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AnyFootOnGround>();
	}
};
static_assert(alignof(UAnimNotify_AnyFootOnGround) == 0x000008, "Wrong alignment on UAnimNotify_AnyFootOnGround");
static_assert(sizeof(UAnimNotify_AnyFootOnGround) == 0x000098, "Wrong size on UAnimNotify_AnyFootOnGround");
static_assert(offsetof(UAnimNotify_AnyFootOnGround, Foot) == 0x000038, "Member 'UAnimNotify_AnyFootOnGround::Foot' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AnyFootOnGround, SocketName) == 0x00003C, "Member 'UAnimNotify_AnyFootOnGround::SocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AnyFootOnGround, ToeSocketName) == 0x000044, "Member 'UAnimNotify_AnyFootOnGround::ToeSocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AnyFootOnGround, bAttachedParticle) == 0x00004C, "Member 'UAnimNotify_AnyFootOnGround::bAttachedParticle' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AnyFootOnGround, LocationOffset) == 0x000050, "Member 'UAnimNotify_AnyFootOnGround::LocationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AnyFootOnGround, RotationOffset) == 0x000068, "Member 'UAnimNotify_AnyFootOnGround::RotationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AnyFootOnGround, Scale) == 0x000080, "Member 'UAnimNotify_AnyFootOnGround::Scale' has a wrong offset!");

// Class Stalker2.GSCDataTable
// 0x0000 (0x00B0 - 0x00B0)
class UGSCDataTable final : public UDataTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCDataTable">();
	}
	static class UGSCDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSCDataTable>();
	}
};
static_assert(alignof(UGSCDataTable) == 0x000008, "Wrong alignment on UGSCDataTable");
static_assert(sizeof(UGSCDataTable) == 0x0000B0, "Wrong size on UGSCDataTable");

// Class Stalker2.AnimNotify_AttachItem
// 0x0030 (0x0070 - 0x0040)
class UAnimNotify_AttachItem final : public UAnimNotifyBase
{
public:
	EAttachAction                                 AttachAction;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceBindedHandsLookVertical;                     // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldOverwritePitch;                             // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x1];                                       // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PitchRotation;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachType                                   AttachedItem;                                      // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BindedAttachSid;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          AttachMesh;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AttachItem">();
	}
	static class UAnimNotify_AttachItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AttachItem>();
	}
};
static_assert(alignof(UAnimNotify_AttachItem) == 0x000008, "Wrong alignment on UAnimNotify_AttachItem");
static_assert(sizeof(UAnimNotify_AttachItem) == 0x000070, "Wrong size on UAnimNotify_AttachItem");
static_assert(offsetof(UAnimNotify_AttachItem, AttachAction) == 0x000040, "Member 'UAnimNotify_AttachItem::AttachAction' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AttachItem, bForceBindedHandsLookVertical) == 0x000041, "Member 'UAnimNotify_AttachItem::bForceBindedHandsLookVertical' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AttachItem, bShouldOverwritePitch) == 0x000042, "Member 'UAnimNotify_AttachItem::bShouldOverwritePitch' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AttachItem, PitchRotation) == 0x000044, "Member 'UAnimNotify_AttachItem::PitchRotation' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AttachItem, SocketName) == 0x000048, "Member 'UAnimNotify_AttachItem::SocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AttachItem, AttachedItem) == 0x000050, "Member 'UAnimNotify_AttachItem::AttachedItem' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AttachItem, BindedAttachSid) == 0x000058, "Member 'UAnimNotify_AttachItem::BindedAttachSid' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AttachItem, AttachMesh) == 0x000068, "Member 'UAnimNotify_AttachItem::AttachMesh' has a wrong offset!");

// Class Stalker2.StaticEnvironmentParticleActor
// 0x0008 (0x02A0 - 0x0298)
class AStaticEnvironmentParticleActor final : public AActor
{
public:
	class UStaticEnvironmentNiagaraComponent*     EnvironmentParticleComponent;                      // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticEnvironmentParticleActor">();
	}
	static class AStaticEnvironmentParticleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticEnvironmentParticleActor>();
	}
};
static_assert(alignof(AStaticEnvironmentParticleActor) == 0x000008, "Wrong alignment on AStaticEnvironmentParticleActor");
static_assert(sizeof(AStaticEnvironmentParticleActor) == 0x0002A0, "Wrong size on AStaticEnvironmentParticleActor");
static_assert(offsetof(AStaticEnvironmentParticleActor, EnvironmentParticleComponent) == 0x000298, "Member 'AStaticEnvironmentParticleActor::EnvironmentParticleComponent' has a wrong offset!");

// Class Stalker2.SwitchWeaponIPU
// 0x0000 (0x0040 - 0x0040)
class USwitchWeaponIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwitchWeaponIPU">();
	}
	static class USwitchWeaponIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwitchWeaponIPU>();
	}
};
static_assert(alignof(USwitchWeaponIPU) == 0x000008, "Wrong alignment on USwitchWeaponIPU");
static_assert(sizeof(USwitchWeaponIPU) == 0x000040, "Wrong size on USwitchWeaponIPU");

// Class Stalker2.GameplayEventManager
// 0x0050 (0x00C8 - 0x0078)
class UGameplayEventManager final : public UBaseManager
{
public:
	TMap<class UClass*, class UGameplayEventData*> EventDataPool;                                    // 0x0078(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEventManager">();
	}
	static class UGameplayEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEventManager>();
	}
};
static_assert(alignof(UGameplayEventManager) == 0x000008, "Wrong alignment on UGameplayEventManager");
static_assert(sizeof(UGameplayEventManager) == 0x0000C8, "Wrong size on UGameplayEventManager");
static_assert(offsetof(UGameplayEventManager, EventDataPool) == 0x000078, "Member 'UGameplayEventManager::EventDataPool' has a wrong offset!");

// Class Stalker2.AnimNotify_AttachItemContextualAction
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify_AttachItemContextualAction final : public UAnimNotifyBase
{
public:
	TArray<struct FContextualItemAttachment>      ContextualItemAttachments;                         // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AttachItemContextualAction">();
	}
	static class UAnimNotify_AttachItemContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AttachItemContextualAction>();
	}
};
static_assert(alignof(UAnimNotify_AttachItemContextualAction) == 0x000008, "Wrong alignment on UAnimNotify_AttachItemContextualAction");
static_assert(sizeof(UAnimNotify_AttachItemContextualAction) == 0x000050, "Wrong size on UAnimNotify_AttachItemContextualAction");
static_assert(offsetof(UAnimNotify_AttachItemContextualAction, ContextualItemAttachments) == 0x000040, "Member 'UAnimNotify_AttachItemContextualAction::ContextualItemAttachments' has a wrong offset!");

// Class Stalker2.MenuButtonBase
// 0x0088 (0x0300 - 0x0278)
class UMenuButtonBase : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextWidget*                            ActionName;                                        // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button;                                            // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HoverAnimation;                                    // 0x02A0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       PressAnimation;                                    // 0x02A8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoverAnimationSpeedMultiplier;                     // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HideHoverAnimationSpeedMultiplier;                 // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PressButtonAnimationSpeed;                         // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IsNotActiveOpacity;                                // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuButtonActionBase*                  ButtonAction;                                      // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x18];                                     // 0x02C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FShortcutData>                  ButtonShortcuts;                                   // 0x02E0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UMenuButtonStateDefiner*>        ButtonStateDefiners;                               // 0x02F0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void ExecuteAction();
	void OnButtonHovered();
	void OnMousePressed();
	void OnPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuButtonBase">();
	}
	static class UMenuButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuButtonBase>();
	}
};
static_assert(alignof(UMenuButtonBase) == 0x000008, "Wrong alignment on UMenuButtonBase");
static_assert(sizeof(UMenuButtonBase) == 0x000300, "Wrong size on UMenuButtonBase");
static_assert(offsetof(UMenuButtonBase, ActionName) == 0x000290, "Member 'UMenuButtonBase::ActionName' has a wrong offset!");
static_assert(offsetof(UMenuButtonBase, Button) == 0x000298, "Member 'UMenuButtonBase::Button' has a wrong offset!");
static_assert(offsetof(UMenuButtonBase, HoverAnimation) == 0x0002A0, "Member 'UMenuButtonBase::HoverAnimation' has a wrong offset!");
static_assert(offsetof(UMenuButtonBase, PressAnimation) == 0x0002A8, "Member 'UMenuButtonBase::PressAnimation' has a wrong offset!");
static_assert(offsetof(UMenuButtonBase, HoverAnimationSpeedMultiplier) == 0x0002B0, "Member 'UMenuButtonBase::HoverAnimationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UMenuButtonBase, HideHoverAnimationSpeedMultiplier) == 0x0002B4, "Member 'UMenuButtonBase::HideHoverAnimationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UMenuButtonBase, PressButtonAnimationSpeed) == 0x0002B8, "Member 'UMenuButtonBase::PressButtonAnimationSpeed' has a wrong offset!");
static_assert(offsetof(UMenuButtonBase, IsNotActiveOpacity) == 0x0002BC, "Member 'UMenuButtonBase::IsNotActiveOpacity' has a wrong offset!");
static_assert(offsetof(UMenuButtonBase, ButtonAction) == 0x0002C0, "Member 'UMenuButtonBase::ButtonAction' has a wrong offset!");
static_assert(offsetof(UMenuButtonBase, ButtonShortcuts) == 0x0002E0, "Member 'UMenuButtonBase::ButtonShortcuts' has a wrong offset!");
static_assert(offsetof(UMenuButtonBase, ButtonStateDefiners) == 0x0002F0, "Member 'UMenuButtonBase::ButtonStateDefiners' has a wrong offset!");

// Class Stalker2.PushOptionButton
// 0x0000 (0x0300 - 0x0300)
class UPushOptionButton final : public UMenuButtonBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushOptionButton">();
	}
	static class UPushOptionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPushOptionButton>();
	}
};
static_assert(alignof(UPushOptionButton) == 0x000008, "Wrong alignment on UPushOptionButton");
static_assert(sizeof(UPushOptionButton) == 0x000300, "Wrong size on UPushOptionButton");

// Class Stalker2.AnimNotify_AttachNiagaraSystem
// 0x0010 (0x00E0 - 0x00D0)
class UAnimNotify_AttachNiagaraSystem final : public UAnimNotify_PlayNiagaraEffect
{
public:
	EParticleAction                               AttachAction;                                      // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0xF];                                       // 0x00D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AttachNiagaraSystem">();
	}
	static class UAnimNotify_AttachNiagaraSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AttachNiagaraSystem>();
	}
};
static_assert(alignof(UAnimNotify_AttachNiagaraSystem) == 0x000010, "Wrong alignment on UAnimNotify_AttachNiagaraSystem");
static_assert(sizeof(UAnimNotify_AttachNiagaraSystem) == 0x0000E0, "Wrong size on UAnimNotify_AttachNiagaraSystem");
static_assert(offsetof(UAnimNotify_AttachNiagaraSystem, AttachAction) == 0x0000D0, "Member 'UAnimNotify_AttachNiagaraSystem::AttachAction' has a wrong offset!");

// Class Stalker2.AnimNotify_AttackHitDetection
// 0x0000 (0x0030 - 0x0030)
class UAnimNotify_AttackHitDetection final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AttackHitDetection">();
	}
	static class UAnimNotify_AttackHitDetection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AttackHitDetection>();
	}
};
static_assert(alignof(UAnimNotify_AttackHitDetection) == 0x000008, "Wrong alignment on UAnimNotify_AttackHitDetection");
static_assert(sizeof(UAnimNotify_AttackHitDetection) == 0x000030, "Wrong size on UAnimNotify_AttackHitDetection");

// Class Stalker2.ModSubsystemBase
// 0x0000 (0x0030 - 0x0030)
class UModSubsystemBase : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModSubsystemBase">();
	}
	static class UModSubsystemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModSubsystemBase>();
	}
};
static_assert(alignof(UModSubsystemBase) == 0x000008, "Wrong alignment on UModSubsystemBase");
static_assert(sizeof(UModSubsystemBase) == 0x000030, "Wrong size on UModSubsystemBase");

// Class Stalker2.GunRecoilTextureDataAsset
// 0x0020 (0x0050 - 0x0030)
class UGunRecoilTextureDataAsset : public UDataAsset
{
public:
	TArray<struct FRecoilKeys>                    RecoilPatternAimKeys;                              // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRecoilKeys>                    RecoilPatternHipKeys;                              // 0x0040(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunRecoilTextureDataAsset">();
	}
	static class UGunRecoilTextureDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGunRecoilTextureDataAsset>();
	}
};
static_assert(alignof(UGunRecoilTextureDataAsset) == 0x000008, "Wrong alignment on UGunRecoilTextureDataAsset");
static_assert(sizeof(UGunRecoilTextureDataAsset) == 0x000050, "Wrong size on UGunRecoilTextureDataAsset");
static_assert(offsetof(UGunRecoilTextureDataAsset, RecoilPatternAimKeys) == 0x000030, "Member 'UGunRecoilTextureDataAsset::RecoilPatternAimKeys' has a wrong offset!");
static_assert(offsetof(UGunRecoilTextureDataAsset, RecoilPatternHipKeys) == 0x000040, "Member 'UGunRecoilTextureDataAsset::RecoilPatternHipKeys' has a wrong offset!");

// Class Stalker2.ShotgunRecoilTextureDataAsset
// 0x0010 (0x0060 - 0x0050)
class UShotgunRecoilTextureDataAsset final : public UGunRecoilTextureDataAsset
{
public:
	TArray<struct FBuckRecoilKeys>                RecoilPatternBuckKeys;                             // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShotgunRecoilTextureDataAsset">();
	}
	static class UShotgunRecoilTextureDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShotgunRecoilTextureDataAsset>();
	}
};
static_assert(alignof(UShotgunRecoilTextureDataAsset) == 0x000008, "Wrong alignment on UShotgunRecoilTextureDataAsset");
static_assert(sizeof(UShotgunRecoilTextureDataAsset) == 0x000060, "Wrong size on UShotgunRecoilTextureDataAsset");
static_assert(offsetof(UShotgunRecoilTextureDataAsset, RecoilPatternBuckKeys) == 0x000050, "Member 'UShotgunRecoilTextureDataAsset::RecoilPatternBuckKeys' has a wrong offset!");

// Class Stalker2.AnimNotify_BedInteract
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_BedInteract final : public UAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_BedInteract">();
	}
	static class UAnimNotify_BedInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_BedInteract>();
	}
};
static_assert(alignof(UAnimNotify_BedInteract) == 0x000008, "Wrong alignment on UAnimNotify_BedInteract");
static_assert(sizeof(UAnimNotify_BedInteract) == 0x000040, "Wrong size on UAnimNotify_BedInteract");

// Class Stalker2.GameLoadingSubsystem
// 0x0160 (0x0190 - 0x0030)
class UGameLoadingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x100];                                     // 0x0030(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWorldPartitionRuntimeCell*>     LevelsToActivate;                                  // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TSet<class ULevel*>                           LevelsToRemove;                                    // 0x0140(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameLoadingSubsystem">();
	}
	static class UGameLoadingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameLoadingSubsystem>();
	}
};
static_assert(alignof(UGameLoadingSubsystem) == 0x000008, "Wrong alignment on UGameLoadingSubsystem");
static_assert(sizeof(UGameLoadingSubsystem) == 0x000190, "Wrong size on UGameLoadingSubsystem");
static_assert(offsetof(UGameLoadingSubsystem, LevelsToActivate) == 0x000130, "Member 'UGameLoadingSubsystem::LevelsToActivate' has a wrong offset!");
static_assert(offsetof(UGameLoadingSubsystem, LevelsToRemove) == 0x000140, "Member 'UGameLoadingSubsystem::LevelsToRemove' has a wrong offset!");

// Class Stalker2.AnimNotify_BlendToSection
// 0x0038 (0x0078 - 0x0040)
class UAnimNotify_BlendToSection final : public UAnimNotifyBase
{
public:
	class FName                                   SectionName;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAlphaBlend                            BlendOption;                                       // 0x0048(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_BlendToSection">();
	}
	static class UAnimNotify_BlendToSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_BlendToSection>();
	}
};
static_assert(alignof(UAnimNotify_BlendToSection) == 0x000008, "Wrong alignment on UAnimNotify_BlendToSection");
static_assert(sizeof(UAnimNotify_BlendToSection) == 0x000078, "Wrong size on UAnimNotify_BlendToSection");
static_assert(offsetof(UAnimNotify_BlendToSection, SectionName) == 0x000040, "Member 'UAnimNotify_BlendToSection::SectionName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_BlendToSection, BlendOption) == 0x000048, "Member 'UAnimNotify_BlendToSection::BlendOption' has a wrong offset!");

// Class Stalker2.AnimNotify_ChangeFaceMask
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_ChangeFaceMask final : public UAnimNotifyBase
{
public:
	EEmotionalFaceMasks                           FaceMask;                                          // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ChangeFaceMask">();
	}
	static class UAnimNotify_ChangeFaceMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ChangeFaceMask>();
	}
};
static_assert(alignof(UAnimNotify_ChangeFaceMask) == 0x000008, "Wrong alignment on UAnimNotify_ChangeFaceMask");
static_assert(sizeof(UAnimNotify_ChangeFaceMask) == 0x000048, "Wrong size on UAnimNotify_ChangeFaceMask");
static_assert(offsetof(UAnimNotify_ChangeFaceMask, FaceMask) == 0x000040, "Member 'UAnimNotify_ChangeFaceMask::FaceMask' has a wrong offset!");

// Class Stalker2.Stalker2Spectator
// 0x0000 (0x0348 - 0x0348)
class AStalker2Spectator final : public ASpectatorPawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Stalker2Spectator">();
	}
	static class AStalker2Spectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStalker2Spectator>();
	}
};
static_assert(alignof(AStalker2Spectator) == 0x000008, "Wrong alignment on AStalker2Spectator");
static_assert(sizeof(AStalker2Spectator) == 0x000348, "Wrong size on AStalker2Spectator");

// Class Stalker2.AnimNotify_ChangeWeaponIdle
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify_ChangeWeaponIdle final : public UAnimNotifyBase
{
public:
	EWeaponIdleState                              WeaponIdle;                                        // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShutterState                                 NewShutterState;                                   // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewJamIndex;                                       // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponIdleType                               NewUnderbarrelState;                               // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimationAimState                            NewAimState;                                       // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponCustomAdditionalIdle                   AdditionalType;                                    // 0x004A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ChangeWeaponIdle">();
	}
	static class UAnimNotify_ChangeWeaponIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ChangeWeaponIdle>();
	}
};
static_assert(alignof(UAnimNotify_ChangeWeaponIdle) == 0x000008, "Wrong alignment on UAnimNotify_ChangeWeaponIdle");
static_assert(sizeof(UAnimNotify_ChangeWeaponIdle) == 0x000050, "Wrong size on UAnimNotify_ChangeWeaponIdle");
static_assert(offsetof(UAnimNotify_ChangeWeaponIdle, WeaponIdle) == 0x000040, "Member 'UAnimNotify_ChangeWeaponIdle::WeaponIdle' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ChangeWeaponIdle, NewShutterState) == 0x000041, "Member 'UAnimNotify_ChangeWeaponIdle::NewShutterState' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ChangeWeaponIdle, NewJamIndex) == 0x000044, "Member 'UAnimNotify_ChangeWeaponIdle::NewJamIndex' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ChangeWeaponIdle, NewUnderbarrelState) == 0x000048, "Member 'UAnimNotify_ChangeWeaponIdle::NewUnderbarrelState' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ChangeWeaponIdle, NewAimState) == 0x000049, "Member 'UAnimNotify_ChangeWeaponIdle::NewAimState' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ChangeWeaponIdle, AdditionalType) == 0x00004A, "Member 'UAnimNotify_ChangeWeaponIdle::AdditionalType' has a wrong offset!");

// Class Stalker2.GSCNavData
// 0x0068 (0x0630 - 0x05C8)
class AGSCNavData final : public ARecastNavMesh
{
public:
	uint8                                         Pad_5C8[0x68];                                     // 0x05C8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCNavData">();
	}
	static class AGSCNavData* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGSCNavData>();
	}
};
static_assert(alignof(AGSCNavData) == 0x000008, "Wrong alignment on AGSCNavData");
static_assert(sizeof(AGSCNavData) == 0x000630, "Wrong size on AGSCNavData");

// Class Stalker2.AnimNotify_ClimbingActions
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_ClimbingActions final : public UAnimNotifyBase
{
public:
	EAnimationType                                AnimationType;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ClimbingActions">();
	}
	static class UAnimNotify_ClimbingActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ClimbingActions>();
	}
};
static_assert(alignof(UAnimNotify_ClimbingActions) == 0x000008, "Wrong alignment on UAnimNotify_ClimbingActions");
static_assert(sizeof(UAnimNotify_ClimbingActions) == 0x000048, "Wrong size on UAnimNotify_ClimbingActions");
static_assert(offsetof(UAnimNotify_ClimbingActions, AnimationType) == 0x000040, "Member 'UAnimNotify_ClimbingActions::AnimationType' has a wrong offset!");

// Class Stalker2.GAPlayerComponent
// 0x0020 (0x00C0 - 0x00A0)
class UGAPlayerComponent final : public UActorComponent
{
public:
	TArray<class UGAPlayerProcessorInterface*>    Processors;                                        // 0x00A0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAPlayerComponent">();
	}
	static class UGAPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAPlayerComponent>();
	}
};
static_assert(alignof(UGAPlayerComponent) == 0x000008, "Wrong alignment on UGAPlayerComponent");
static_assert(sizeof(UGAPlayerComponent) == 0x0000C0, "Wrong size on UGAPlayerComponent");
static_assert(offsetof(UGAPlayerComponent, Processors) == 0x0000A0, "Member 'UGAPlayerComponent::Processors' has a wrong offset!");

// Class Stalker2.AnimNotify_ClothState
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_ClothState final : public UAnimNotifyBase
{
public:
	EClothSimulationState                         ClothSimState;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ClothState">();
	}
	static class UAnimNotify_ClothState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ClothState>();
	}
};
static_assert(alignof(UAnimNotify_ClothState) == 0x000008, "Wrong alignment on UAnimNotify_ClothState");
static_assert(sizeof(UAnimNotify_ClothState) == 0x000048, "Wrong size on UAnimNotify_ClothState");
static_assert(offsetof(UAnimNotify_ClothState, ClothSimState) == 0x000040, "Member 'UAnimNotify_ClothState::ClothSimState' has a wrong offset!");

// Class Stalker2.AnimNotify_CodelockKeyPress
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_CodelockKeyPress final : public UAnimNotifyBase
{
public:
	ECodelockKeyType                              KeyType;                                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CodeDigit;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_CodelockKeyPress">();
	}
	static class UAnimNotify_CodelockKeyPress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_CodelockKeyPress>();
	}
};
static_assert(alignof(UAnimNotify_CodelockKeyPress) == 0x000008, "Wrong alignment on UAnimNotify_CodelockKeyPress");
static_assert(sizeof(UAnimNotify_CodelockKeyPress) == 0x000048, "Wrong size on UAnimNotify_CodelockKeyPress");
static_assert(offsetof(UAnimNotify_CodelockKeyPress, KeyType) == 0x000040, "Member 'UAnimNotify_CodelockKeyPress::KeyType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_CodelockKeyPress, CodeDigit) == 0x000044, "Member 'UAnimNotify_CodelockKeyPress::CodeDigit' has a wrong offset!");

// Class Stalker2.AnimNotify_ContextualSectionEnding
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_ContextualSectionEnding final : public UAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ContextualSectionEnding">();
	}
	static class UAnimNotify_ContextualSectionEnding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ContextualSectionEnding>();
	}
};
static_assert(alignof(UAnimNotify_ContextualSectionEnding) == 0x000008, "Wrong alignment on UAnimNotify_ContextualSectionEnding");
static_assert(sizeof(UAnimNotify_ContextualSectionEnding) == 0x000040, "Wrong size on UAnimNotify_ContextualSectionEnding");

// Class Stalker2.GSCNavModifierComponent
// 0x0040 (0x01D0 - 0x0190)
class UGSCNavModifierComponent final : public UNavModifierComponent
{
public:
	uint8                                         Pad_190[0x8];                                      // 0x0190(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnabled;                                          // 0x0198(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            SelectedComponents;                                // 0x01A0(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FNavModifierBodyConfig>         PhysicalBodies;                                    // 0x01B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UNavArea>                   TargetAreaClass;                                   // 0x01C0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSelectedComponent(class UPrimitiveComponent* PrimitiveComponent);
	void ClearSelectedComponents();
	void RemoveSelectedComponent(class UPrimitiveComponent* PrimitiveComponent);
	void RequestBoundsRecalculation();
	void SetEnabled(bool bNewEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCNavModifierComponent">();
	}
	static class UGSCNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSCNavModifierComponent>();
	}
};
static_assert(alignof(UGSCNavModifierComponent) == 0x000010, "Wrong alignment on UGSCNavModifierComponent");
static_assert(sizeof(UGSCNavModifierComponent) == 0x0001D0, "Wrong size on UGSCNavModifierComponent");
static_assert(offsetof(UGSCNavModifierComponent, bEnabled) == 0x000198, "Member 'UGSCNavModifierComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UGSCNavModifierComponent, SelectedComponents) == 0x0001A0, "Member 'UGSCNavModifierComponent::SelectedComponents' has a wrong offset!");
static_assert(offsetof(UGSCNavModifierComponent, PhysicalBodies) == 0x0001B0, "Member 'UGSCNavModifierComponent::PhysicalBodies' has a wrong offset!");
static_assert(offsetof(UGSCNavModifierComponent, TargetAreaClass) == 0x0001C0, "Member 'UGSCNavModifierComponent::TargetAreaClass' has a wrong offset!");

// Class Stalker2.QuestNotification
// 0x00E0 (0x0358 - 0x0278)
class UQuestNotification final : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UQuestTaskNotification*>         TaskWidgets;                                       // 0x0288(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x4];                                      // 0x0298(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TextureID;                                         // 0x029C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextWidget*                            QuestTitle;                                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 QuestImage;                                        // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorldMapTooltipHeader*                 QuestNotificationHeader;                           // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 LabelBackground;                                   // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ContentLine;                                       // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            LabelText;                                         // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHintInputController*                   Hint;                                              // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           QuestVerticalBox;                                  // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       ShowAnimation;                                     // 0x02E8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       HideAnimation;                                     // 0x02F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMainQuest;                                        // 0x02F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EUISound                                      QuestAddedSound;                                   // 0x02FC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EUISound                                      QuestCompletedSound;                               // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UQuestTaskNotification*                 LastUpdatedTask;                                   // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQuestNotificationDataAsset*            Settings;                                          // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 PrototypeID;                                       // 0x0318(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         QuestStagesLen;                                    // 0x0328(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTaskAnimationWasFinished;                         // 0x032C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTaskAnimationWasStarted;                          // 0x032D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32E[0x2A];                                     // 0x032E(0x002A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideTasks();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestNotification">();
	}
	static class UQuestNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestNotification>();
	}
};
static_assert(alignof(UQuestNotification) == 0x000008, "Wrong alignment on UQuestNotification");
static_assert(sizeof(UQuestNotification) == 0x000358, "Wrong size on UQuestNotification");
static_assert(offsetof(UQuestNotification, TaskWidgets) == 0x000288, "Member 'UQuestNotification::TaskWidgets' has a wrong offset!");
static_assert(offsetof(UQuestNotification, TextureID) == 0x00029C, "Member 'UQuestNotification::TextureID' has a wrong offset!");
static_assert(offsetof(UQuestNotification, QuestTitle) == 0x0002A8, "Member 'UQuestNotification::QuestTitle' has a wrong offset!");
static_assert(offsetof(UQuestNotification, QuestImage) == 0x0002B0, "Member 'UQuestNotification::QuestImage' has a wrong offset!");
static_assert(offsetof(UQuestNotification, QuestNotificationHeader) == 0x0002B8, "Member 'UQuestNotification::QuestNotificationHeader' has a wrong offset!");
static_assert(offsetof(UQuestNotification, LabelBackground) == 0x0002C0, "Member 'UQuestNotification::LabelBackground' has a wrong offset!");
static_assert(offsetof(UQuestNotification, ContentLine) == 0x0002C8, "Member 'UQuestNotification::ContentLine' has a wrong offset!");
static_assert(offsetof(UQuestNotification, LabelText) == 0x0002D0, "Member 'UQuestNotification::LabelText' has a wrong offset!");
static_assert(offsetof(UQuestNotification, Hint) == 0x0002D8, "Member 'UQuestNotification::Hint' has a wrong offset!");
static_assert(offsetof(UQuestNotification, QuestVerticalBox) == 0x0002E0, "Member 'UQuestNotification::QuestVerticalBox' has a wrong offset!");
static_assert(offsetof(UQuestNotification, ShowAnimation) == 0x0002E8, "Member 'UQuestNotification::ShowAnimation' has a wrong offset!");
static_assert(offsetof(UQuestNotification, HideAnimation) == 0x0002F0, "Member 'UQuestNotification::HideAnimation' has a wrong offset!");
static_assert(offsetof(UQuestNotification, bMainQuest) == 0x0002F8, "Member 'UQuestNotification::bMainQuest' has a wrong offset!");
static_assert(offsetof(UQuestNotification, QuestAddedSound) == 0x0002FC, "Member 'UQuestNotification::QuestAddedSound' has a wrong offset!");
static_assert(offsetof(UQuestNotification, QuestCompletedSound) == 0x000300, "Member 'UQuestNotification::QuestCompletedSound' has a wrong offset!");
static_assert(offsetof(UQuestNotification, LastUpdatedTask) == 0x000308, "Member 'UQuestNotification::LastUpdatedTask' has a wrong offset!");
static_assert(offsetof(UQuestNotification, Settings) == 0x000310, "Member 'UQuestNotification::Settings' has a wrong offset!");
static_assert(offsetof(UQuestNotification, PrototypeID) == 0x000318, "Member 'UQuestNotification::PrototypeID' has a wrong offset!");
static_assert(offsetof(UQuestNotification, QuestStagesLen) == 0x000328, "Member 'UQuestNotification::QuestStagesLen' has a wrong offset!");
static_assert(offsetof(UQuestNotification, bTaskAnimationWasFinished) == 0x00032C, "Member 'UQuestNotification::bTaskAnimationWasFinished' has a wrong offset!");
static_assert(offsetof(UQuestNotification, bTaskAnimationWasStarted) == 0x00032D, "Member 'UQuestNotification::bTaskAnimationWasStarted' has a wrong offset!");

// Class Stalker2.AnimNotify_CopyNiagaraValueFromAnotherContextualAction
// 0x0018 (0x0058 - 0x0040)
class UAnimNotify_CopyNiagaraValueFromAnotherContextualAction final : public UAnimNotifyBase
{
public:
	struct FNiagaraValueCopyFromTo                CopyFromTo;                                        // 0x0040(0x0018)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_CopyNiagaraValueFromAnotherContextualAction">();
	}
	static class UAnimNotify_CopyNiagaraValueFromAnotherContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_CopyNiagaraValueFromAnotherContextualAction>();
	}
};
static_assert(alignof(UAnimNotify_CopyNiagaraValueFromAnotherContextualAction) == 0x000008, "Wrong alignment on UAnimNotify_CopyNiagaraValueFromAnotherContextualAction");
static_assert(sizeof(UAnimNotify_CopyNiagaraValueFromAnotherContextualAction) == 0x000058, "Wrong size on UAnimNotify_CopyNiagaraValueFromAnotherContextualAction");
static_assert(offsetof(UAnimNotify_CopyNiagaraValueFromAnotherContextualAction, CopyFromTo) == 0x000040, "Member 'UAnimNotify_CopyNiagaraValueFromAnotherContextualAction::CopyFromTo' has a wrong offset!");

// Class Stalker2.GameplayEventData
// 0x0000 (0x0028 - 0x0028)
class UGameplayEventData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEventData">();
	}
	static class UGameplayEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEventData>();
	}
};
static_assert(alignof(UGameplayEventData) == 0x000008, "Wrong alignment on UGameplayEventData");
static_assert(sizeof(UGameplayEventData) == 0x000028, "Wrong size on UGameplayEventData");

// Class Stalker2.MovementModeChangedEventData
// 0x0008 (0x0030 - 0x0028)
class UMovementModeChangedEventData final : public UGameplayEventData
{
public:
	EMovementBehaviour                            NewMovementBehavior;                               // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementBehaviour                            OldMovementBehavior;                               // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementModeChangedEventData">();
	}
	static class UMovementModeChangedEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementModeChangedEventData>();
	}
};
static_assert(alignof(UMovementModeChangedEventData) == 0x000008, "Wrong alignment on UMovementModeChangedEventData");
static_assert(sizeof(UMovementModeChangedEventData) == 0x000030, "Wrong size on UMovementModeChangedEventData");
static_assert(offsetof(UMovementModeChangedEventData, NewMovementBehavior) == 0x000028, "Member 'UMovementModeChangedEventData::NewMovementBehavior' has a wrong offset!");
static_assert(offsetof(UMovementModeChangedEventData, OldMovementBehavior) == 0x000029, "Member 'UMovementModeChangedEventData::OldMovementBehavior' has a wrong offset!");

// Class Stalker2.NavArea_Anomaly
// 0x0000 (0x0048 - 0x0048)
class UNavArea_Anomaly final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Anomaly">();
	}
	static class UNavArea_Anomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Anomaly>();
	}
};
static_assert(alignof(UNavArea_Anomaly) == 0x000008, "Wrong alignment on UNavArea_Anomaly");
static_assert(sizeof(UNavArea_Anomaly) == 0x000048, "Wrong size on UNavArea_Anomaly");

// Class Stalker2.AnimNotify_DeathEnded
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_DeathEnded final : public UAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DeathEnded">();
	}
	static class UAnimNotify_DeathEnded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DeathEnded>();
	}
};
static_assert(alignof(UAnimNotify_DeathEnded) == 0x000008, "Wrong alignment on UAnimNotify_DeathEnded");
static_assert(sizeof(UAnimNotify_DeathEnded) == 0x000040, "Wrong size on UAnimNotify_DeathEnded");

// Class Stalker2.NavigationSlotInterface
// 0x0000 (0x0000 - 0x0000)
class INavigationSlotInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationSlotInterface">();
	}
	static class INavigationSlotInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INavigationSlotInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(INavigationSlotInterface) == 0x000001, "Wrong alignment on INavigationSlotInterface");
static_assert(sizeof(INavigationSlotInterface) == 0x000001, "Wrong size on INavigationSlotInterface");

// Class Stalker2.GameGraphData
// 0x00D0 (0x0368 - 0x0298)
class AGameGraphData final : public AActor
{
public:
	uint8                                         Pad_298[0x20];                                     // 0x0298(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FGameGraphContextualActions> VertexContextualActions;                        // 0x02B8(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FContextualActionsGameGraphInfo> ContextualActionsVerticesInfo;        // 0x0308(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameGraphRenderingComponent*           DebugRenderingComp;                                // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameGraphData">();
	}
	static class AGameGraphData* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameGraphData>();
	}
};
static_assert(alignof(AGameGraphData) == 0x000008, "Wrong alignment on AGameGraphData");
static_assert(sizeof(AGameGraphData) == 0x000368, "Wrong size on AGameGraphData");
static_assert(offsetof(AGameGraphData, VertexContextualActions) == 0x0002B8, "Member 'AGameGraphData::VertexContextualActions' has a wrong offset!");
static_assert(offsetof(AGameGraphData, ContextualActionsVerticesInfo) == 0x000308, "Member 'AGameGraphData::ContextualActionsVerticesInfo' has a wrong offset!");
static_assert(offsetof(AGameGraphData, DebugRenderingComp) == 0x000360, "Member 'AGameGraphData::DebugRenderingComp' has a wrong offset!");

// Class Stalker2.AnimNotify_DialogAction
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_DialogAction final : public UAnimNotifyBase
{
public:
	ENotifyDialogAction                           NotifyDialogAction;                                // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DialogAction">();
	}
	static class UAnimNotify_DialogAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DialogAction>();
	}
};
static_assert(alignof(UAnimNotify_DialogAction) == 0x000008, "Wrong alignment on UAnimNotify_DialogAction");
static_assert(sizeof(UAnimNotify_DialogAction) == 0x000048, "Wrong size on UAnimNotify_DialogAction");
static_assert(offsetof(UAnimNotify_DialogAction, NotifyDialogAction) == 0x000040, "Member 'UAnimNotify_DialogAction::NotifyDialogAction' has a wrong offset!");

// Class Stalker2.AnimNotify_DragDeadBody
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_DragDeadBody final : public UAnimNotifyBase
{
public:
	EDragDeadBodyState                            DragDeadBodyState;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DragDeadBody">();
	}
	static class UAnimNotify_DragDeadBody* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DragDeadBody>();
	}
};
static_assert(alignof(UAnimNotify_DragDeadBody) == 0x000008, "Wrong alignment on UAnimNotify_DragDeadBody");
static_assert(sizeof(UAnimNotify_DragDeadBody) == 0x000048, "Wrong size on UAnimNotify_DragDeadBody");
static_assert(offsetof(UAnimNotify_DragDeadBody, DragDeadBodyState) == 0x000040, "Member 'UAnimNotify_DragDeadBody::DragDeadBodyState' has a wrong offset!");

// Class Stalker2.SettingElementValueLocSwitcher
// 0x0030 (0x1DB0 - 0x1D80)
class USettingElementValueLocSwitcher final : public USettingElement
{
public:
	uint8                                         Pad_1D80[0x18];                                    // 0x1D80(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FValueLocalisationPair>         Values;                                            // 0x1D98(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DA8[0x4];                                     // 0x1DA8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index_0;                                           // 0x1DAC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingElementValueLocSwitcher">();
	}
	static class USettingElementValueLocSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingElementValueLocSwitcher>();
	}
};
static_assert(alignof(USettingElementValueLocSwitcher) == 0x000010, "Wrong alignment on USettingElementValueLocSwitcher");
static_assert(sizeof(USettingElementValueLocSwitcher) == 0x001DB0, "Wrong size on USettingElementValueLocSwitcher");
static_assert(offsetof(USettingElementValueLocSwitcher, Values) == 0x001D98, "Member 'USettingElementValueLocSwitcher::Values' has a wrong offset!");
static_assert(offsetof(USettingElementValueLocSwitcher, Index_0) == 0x001DAC, "Member 'USettingElementValueLocSwitcher::Index_0' has a wrong offset!");

// Class Stalker2.TickAggregationManager
// 0x0A20 (0x0AC8 - 0x00A8)
class UTickAggregationManager final : public UBaseTickableManager
{
public:
	struct FAgentCollection                       AgentsCollection;                                  // 0x00A8(0x00A0)(Transient, NativeAccessSpecifierPrivate)
	struct FAIEntityCollection                    AIEntityCollection;                                // 0x0148(0x0068)(Transient, NativeAccessSpecifierPrivate)
	struct FArtifactCollection                    ArtifactsCollection;                               // 0x01B0(0x0098)(Transient, NativeAccessSpecifierPrivate)
	struct FAnomalyCollection                     AnomaliesCollection;                               // 0x0248(0x0098)(Transient, NativeAccessSpecifierPrivate)
	struct FAITickComponentCollection             AITickComponentsCollection;                        // 0x02E0(0x0078)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FDestructibleObjectCollection          DestructibleCollection;                            // 0x0358(0x0098)(Transient, NativeAccessSpecifierPrivate)
	struct FWetnessComponentCollection            WetnessComponentCollection;                        // 0x03F0(0x0098)(Transient, NativeAccessSpecifierPrivate)
	struct FHeadFlashlightComponentCollection     HeadFlashlightComponentCollection;                 // 0x0488(0x0098)(Transient, NativeAccessSpecifierPrivate)
	struct FItemContainerModelCollection          ItemContainersCollection;                          // 0x0520(0x0098)(Transient, NativeAccessSpecifierPrivate)
	struct FAkRoomCollection                      AkRoomComponentsCollection;                        // 0x05B8(0x0078)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAkComponentCollection                 AkComponentsCollection;                            // 0x0630(0x0078)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAkLateReverbCollection                AkLateReverbComponentsCollection;                  // 0x06A8(0x0078)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAkSurfaceReflectorSetCollection       AkSurfaceReflectorSetsCollection;                  // 0x0720(0x0078)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAgentModelCollection                  AgentModelCollection;                              // 0x0798(0x00B8)(Transient, NativeAccessSpecifierPrivate)
	struct FAnomalyModelCollection                AnomalyModelCollection;                            // 0x0850(0x00A0)(Transient, NativeAccessSpecifierPrivate)
	struct FDestructibleModelCollection           DestructibleModelCollection;                       // 0x08F0(0x00A0)(Transient, NativeAccessSpecifierPrivate)
	struct FContextualActionModelCollection       ContextualActionModelCollection;                   // 0x0990(0x00A0)(Transient, NativeAccessSpecifierPrivate)
	struct FQuestNodeCollection                   QuestNodeCollection;                               // 0x0A30(0x0098)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TickAggregationManager">();
	}
	static class UTickAggregationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTickAggregationManager>();
	}
};
static_assert(alignof(UTickAggregationManager) == 0x000008, "Wrong alignment on UTickAggregationManager");
static_assert(sizeof(UTickAggregationManager) == 0x000AC8, "Wrong size on UTickAggregationManager");
static_assert(offsetof(UTickAggregationManager, AgentsCollection) == 0x0000A8, "Member 'UTickAggregationManager::AgentsCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, AIEntityCollection) == 0x000148, "Member 'UTickAggregationManager::AIEntityCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, ArtifactsCollection) == 0x0001B0, "Member 'UTickAggregationManager::ArtifactsCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, AnomaliesCollection) == 0x000248, "Member 'UTickAggregationManager::AnomaliesCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, AITickComponentsCollection) == 0x0002E0, "Member 'UTickAggregationManager::AITickComponentsCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, DestructibleCollection) == 0x000358, "Member 'UTickAggregationManager::DestructibleCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, WetnessComponentCollection) == 0x0003F0, "Member 'UTickAggregationManager::WetnessComponentCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, HeadFlashlightComponentCollection) == 0x000488, "Member 'UTickAggregationManager::HeadFlashlightComponentCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, ItemContainersCollection) == 0x000520, "Member 'UTickAggregationManager::ItemContainersCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, AkRoomComponentsCollection) == 0x0005B8, "Member 'UTickAggregationManager::AkRoomComponentsCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, AkComponentsCollection) == 0x000630, "Member 'UTickAggregationManager::AkComponentsCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, AkLateReverbComponentsCollection) == 0x0006A8, "Member 'UTickAggregationManager::AkLateReverbComponentsCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, AkSurfaceReflectorSetsCollection) == 0x000720, "Member 'UTickAggregationManager::AkSurfaceReflectorSetsCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, AgentModelCollection) == 0x000798, "Member 'UTickAggregationManager::AgentModelCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, AnomalyModelCollection) == 0x000850, "Member 'UTickAggregationManager::AnomalyModelCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, DestructibleModelCollection) == 0x0008F0, "Member 'UTickAggregationManager::DestructibleModelCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, ContextualActionModelCollection) == 0x000990, "Member 'UTickAggregationManager::ContextualActionModelCollection' has a wrong offset!");
static_assert(offsetof(UTickAggregationManager, QuestNodeCollection) == 0x000A30, "Member 'UTickAggregationManager::QuestNodeCollection' has a wrong offset!");

// Class Stalker2.GAUpgradeActionProcessor
// 0x0020 (0x0048 - 0x0028)
class UGAUpgradeActionProcessor final : public UGAPlayerProcessorInterface
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAUpgradeActionProcessor">();
	}
	static class UGAUpgradeActionProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAUpgradeActionProcessor>();
	}
};
static_assert(alignof(UGAUpgradeActionProcessor) == 0x000008, "Wrong alignment on UGAUpgradeActionProcessor");
static_assert(sizeof(UGAUpgradeActionProcessor) == 0x000048, "Wrong size on UGAUpgradeActionProcessor");

// Class Stalker2.AnimNotify_DragWeapon
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_DragWeapon final : public UAnimNotifyBase
{
public:
	struct FInputRange                            DragImpulseRange;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DragWeapon">();
	}
	static class UAnimNotify_DragWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DragWeapon>();
	}
};
static_assert(alignof(UAnimNotify_DragWeapon) == 0x000008, "Wrong alignment on UAnimNotify_DragWeapon");
static_assert(sizeof(UAnimNotify_DragWeapon) == 0x000048, "Wrong size on UAnimNotify_DragWeapon");
static_assert(offsetof(UAnimNotify_DragWeapon, DragImpulseRange) == 0x000040, "Member 'UAnimNotify_DragWeapon::DragImpulseRange' has a wrong offset!");

// Class Stalker2.RadiationNavModifierVolume
// 0x0008 (0x0310 - 0x0308)
class ARadiationNavModifierVolume final : public ASystemicNavModifierVolume
{
public:
	ERadiationPreset                              RadiationPreset;                                   // 0x0308(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadiationNavModifierVolume">();
	}
	static class ARadiationNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARadiationNavModifierVolume>();
	}
};
static_assert(alignof(ARadiationNavModifierVolume) == 0x000008, "Wrong alignment on ARadiationNavModifierVolume");
static_assert(sizeof(ARadiationNavModifierVolume) == 0x000310, "Wrong size on ARadiationNavModifierVolume");
static_assert(offsetof(ARadiationNavModifierVolume, RadiationPreset) == 0x000308, "Member 'ARadiationNavModifierVolume::RadiationPreset' has a wrong offset!");

// Class Stalker2.CustomConsoleManagerAnalytics
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerAnalytics final : public UBaseConsoleManager
{
public:
	void XAnalyticsPrintDeaths();
	void XAnalyticsPrintGlobalKills();
	void XAnalyticsPrintGlobalTotals();
	void XAnalyticsPrintLocalKills();
	void XAnalyticsPrintLocalTotals();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerAnalytics">();
	}
	static class UCustomConsoleManagerAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerAnalytics>();
	}
};
static_assert(alignof(UCustomConsoleManagerAnalytics) == 0x000008, "Wrong alignment on UCustomConsoleManagerAnalytics");
static_assert(sizeof(UCustomConsoleManagerAnalytics) == 0x0000A8, "Wrong size on UCustomConsoleManagerAnalytics");

// Class Stalker2.AnimNotify_EjectMagazine
// 0x0028 (0x0068 - 0x0040)
class UAnimNotify_EjectMagazine final : public UAnimNotifyBase
{
public:
	float                                         Lifetime;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitialImpulse;                                    // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MagazineSocketName;                                // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EjectMagazine">();
	}
	static class UAnimNotify_EjectMagazine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EjectMagazine>();
	}
};
static_assert(alignof(UAnimNotify_EjectMagazine) == 0x000008, "Wrong alignment on UAnimNotify_EjectMagazine");
static_assert(sizeof(UAnimNotify_EjectMagazine) == 0x000068, "Wrong size on UAnimNotify_EjectMagazine");
static_assert(offsetof(UAnimNotify_EjectMagazine, Lifetime) == 0x000040, "Member 'UAnimNotify_EjectMagazine::Lifetime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EjectMagazine, InitialImpulse) == 0x000048, "Member 'UAnimNotify_EjectMagazine::InitialImpulse' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EjectMagazine, MagazineSocketName) == 0x000060, "Member 'UAnimNotify_EjectMagazine::MagazineSocketName' has a wrong offset!");

// Class Stalker2.GameMenuElement
// 0x0050 (0x02C8 - 0x0278)
class UGameMenuElement final : public UWidgetBase
{
public:
	class FText                                   LocName;                                           // 0x0278(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       SelectedAnim;                                      // 0x0290(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                Button;                                            // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            Caption;                                           // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x20];                                     // 0x02A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Confirm();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuElement">();
	}
	static class UGameMenuElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuElement>();
	}
};
static_assert(alignof(UGameMenuElement) == 0x000008, "Wrong alignment on UGameMenuElement");
static_assert(sizeof(UGameMenuElement) == 0x0002C8, "Wrong size on UGameMenuElement");
static_assert(offsetof(UGameMenuElement, LocName) == 0x000278, "Member 'UGameMenuElement::LocName' has a wrong offset!");
static_assert(offsetof(UGameMenuElement, SelectedAnim) == 0x000290, "Member 'UGameMenuElement::SelectedAnim' has a wrong offset!");
static_assert(offsetof(UGameMenuElement, Button) == 0x000298, "Member 'UGameMenuElement::Button' has a wrong offset!");
static_assert(offsetof(UGameMenuElement, Caption) == 0x0002A0, "Member 'UGameMenuElement::Caption' has a wrong offset!");

// Class Stalker2.AnimNotify_EquipItemContextualAction
// 0x0080 (0x00C0 - 0x0040)
class UAnimNotify_EquipItemContextualAction final : public UAnimNotifyBase
{
public:
	struct FPrototypeSID                          ItemSID;                                           // 0x0040(0x0040)(Edit, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBoneReference                         BoneToEquip;                                       // 0x0080(0x0010)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bForceChangeItemInHand;                            // 0x0090(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_91[0x2F];                                      // 0x0091(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EquipItemContextualAction">();
	}
	static class UAnimNotify_EquipItemContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EquipItemContextualAction>();
	}
};
static_assert(alignof(UAnimNotify_EquipItemContextualAction) == 0x000008, "Wrong alignment on UAnimNotify_EquipItemContextualAction");
static_assert(sizeof(UAnimNotify_EquipItemContextualAction) == 0x0000C0, "Wrong size on UAnimNotify_EquipItemContextualAction");
static_assert(offsetof(UAnimNotify_EquipItemContextualAction, ItemSID) == 0x000040, "Member 'UAnimNotify_EquipItemContextualAction::ItemSID' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EquipItemContextualAction, BoneToEquip) == 0x000080, "Member 'UAnimNotify_EquipItemContextualAction::BoneToEquip' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EquipItemContextualAction, bForceChangeItemInHand) == 0x000090, "Member 'UAnimNotify_EquipItemContextualAction::bForceChangeItemInHand' has a wrong offset!");

// Class Stalker2.AnimNotify_EquipWeaponContextualAction
// 0x0018 (0x0058 - 0x0040)
class UAnimNotify_EquipWeaponContextualAction final : public UAnimNotifyBase
{
public:
	TArray<struct FContextualActionNotifyWeaponEquipData> ItemsToEquip;                              // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bForceChangeItemInHand;                            // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EquipWeaponContextualAction">();
	}
	static class UAnimNotify_EquipWeaponContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EquipWeaponContextualAction>();
	}
};
static_assert(alignof(UAnimNotify_EquipWeaponContextualAction) == 0x000008, "Wrong alignment on UAnimNotify_EquipWeaponContextualAction");
static_assert(sizeof(UAnimNotify_EquipWeaponContextualAction) == 0x000058, "Wrong size on UAnimNotify_EquipWeaponContextualAction");
static_assert(offsetof(UAnimNotify_EquipWeaponContextualAction, ItemsToEquip) == 0x000040, "Member 'UAnimNotify_EquipWeaponContextualAction::ItemsToEquip' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EquipWeaponContextualAction, bForceChangeItemInHand) == 0x000050, "Member 'UAnimNotify_EquipWeaponContextualAction::bForceChangeItemInHand' has a wrong offset!");

// Class Stalker2.GameSettingsWidget
// 0x0040 (0x02D0 - 0x0290)
class UGameSettingsWidget final : public USettingsPage
{
public:
	class USettingElementOnOff*                   AutoSave;                                          // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   Tutorial;                                          // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   InteractPaint;                                     // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementSwitcher*                Difficulty;                                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementSwitcher*                InterfaceLanguage;                                 // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementSwitcher*                VoicingLanguage;                                   // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   EnableStreamerMode;                                // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   SendAnalyticsData;                                 // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSettingsWidget">();
	}
	static class UGameSettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSettingsWidget>();
	}
};
static_assert(alignof(UGameSettingsWidget) == 0x000008, "Wrong alignment on UGameSettingsWidget");
static_assert(sizeof(UGameSettingsWidget) == 0x0002D0, "Wrong size on UGameSettingsWidget");
static_assert(offsetof(UGameSettingsWidget, AutoSave) == 0x000290, "Member 'UGameSettingsWidget::AutoSave' has a wrong offset!");
static_assert(offsetof(UGameSettingsWidget, Tutorial) == 0x000298, "Member 'UGameSettingsWidget::Tutorial' has a wrong offset!");
static_assert(offsetof(UGameSettingsWidget, InteractPaint) == 0x0002A0, "Member 'UGameSettingsWidget::InteractPaint' has a wrong offset!");
static_assert(offsetof(UGameSettingsWidget, Difficulty) == 0x0002A8, "Member 'UGameSettingsWidget::Difficulty' has a wrong offset!");
static_assert(offsetof(UGameSettingsWidget, InterfaceLanguage) == 0x0002B0, "Member 'UGameSettingsWidget::InterfaceLanguage' has a wrong offset!");
static_assert(offsetof(UGameSettingsWidget, VoicingLanguage) == 0x0002B8, "Member 'UGameSettingsWidget::VoicingLanguage' has a wrong offset!");
static_assert(offsetof(UGameSettingsWidget, EnableStreamerMode) == 0x0002C0, "Member 'UGameSettingsWidget::EnableStreamerMode' has a wrong offset!");
static_assert(offsetof(UGameSettingsWidget, SendAnalyticsData) == 0x0002C8, "Member 'UGameSettingsWidget::SendAnalyticsData' has a wrong offset!");

// Class Stalker2.AnimNotify_FootIKState
// 0x0018 (0x0048 - 0x0030)
class UAnimNotify_FootIKState final : public UAnimNotifyState
{
public:
	bool                                          bShouldAffectAllBones;                             // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoneReference>                 AffectedBones;                                     // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_FootIKState">();
	}
	static class UAnimNotify_FootIKState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_FootIKState>();
	}
};
static_assert(alignof(UAnimNotify_FootIKState) == 0x000008, "Wrong alignment on UAnimNotify_FootIKState");
static_assert(sizeof(UAnimNotify_FootIKState) == 0x000048, "Wrong size on UAnimNotify_FootIKState");
static_assert(offsetof(UAnimNotify_FootIKState, bShouldAffectAllBones) == 0x000030, "Member 'UAnimNotify_FootIKState::bShouldAffectAllBones' has a wrong offset!");
static_assert(offsetof(UAnimNotify_FootIKState, AffectedBones) == 0x000038, "Member 'UAnimNotify_FootIKState::AffectedBones' has a wrong offset!");

// Class Stalker2.CustomConsoleManagerDK
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerDK final : public UBaseConsoleManager
{
public:
	void AllwaysShowDropHere(const bool bShow) const;
	void HideCursorInMouseDrag(const bool bHide) const;
	void MoveItemsInTrade(const bool bMoveTraderItems, const bool bMoveOwnItems, const bool bMoveBarterItems) const;
	void UseStackSplitContextual(const bool bInUse) const;
	void XDKFinishQuest(const class FString& SID, const bool bWin) const;
	void XDKFinishQuestStage(const class FString& QSID, const class FString& SSID, const bool bWin) const;
	void XDKStartQuest(const class FString& SID) const;
	void XDKStartQuestStage(const class FString& QSID, const class FString& SSID) const;
	void XDKStartTwoQuestStage(const class FString& QSID) const;
	void XDrawDebugInventoryNavigation(const bool bDraw) const;
	void XGridNavigationVar(const int32 InVar) const;
	void XSetGamepadNavigationBorderSpeed(const float Speed) const;
	void XSetInventoryGamepadInputDelay(const float InputDelay) const;
	void XSetInventoryGamepadInputSelectionDelay(const float InputSelectionDelay) const;
	void XSetInventoryGamepadInputThreshold(const float InputThreshold) const;
	void XSetInventoryGamepadNavigationByAxises(const bool bAxes) const;
	void XSetInventoryGamepadNavigationParams(const float InputDelay, const float InputThreshold, const float SelectionDelay) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerDK">();
	}
	static class UCustomConsoleManagerDK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerDK>();
	}
};
static_assert(alignof(UCustomConsoleManagerDK) == 0x000008, "Wrong alignment on UCustomConsoleManagerDK");
static_assert(sizeof(UCustomConsoleManagerDK) == 0x0000A8, "Wrong size on UCustomConsoleManagerDK");

// Class Stalker2.AnimNotify_ForceFeedback
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_ForceFeedback final : public UAnimNotifyBase
{
public:
	struct FGameplayTag                           FeedbackTag;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ForceFeedback">();
	}
	static class UAnimNotify_ForceFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ForceFeedback>();
	}
};
static_assert(alignof(UAnimNotify_ForceFeedback) == 0x000008, "Wrong alignment on UAnimNotify_ForceFeedback");
static_assert(sizeof(UAnimNotify_ForceFeedback) == 0x000048, "Wrong size on UAnimNotify_ForceFeedback");
static_assert(offsetof(UAnimNotify_ForceFeedback, FeedbackTag) == 0x000040, "Member 'UAnimNotify_ForceFeedback::FeedbackTag' has a wrong offset!");

// Class Stalker2.SettingElementOnOff
// 0x0040 (0x1DC0 - 0x1D80)
class USettingElementOnOff : public USettingElement
{
public:
	uint8                                         Pad_1D80[0x31];                                    // 0x1D80(0x0031)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisableDependenciesWhenValueIs;                   // 0x1DB1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DB2[0xE];                                     // 0x1DB2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingElementOnOff">();
	}
	static class USettingElementOnOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingElementOnOff>();
	}
};
static_assert(alignof(USettingElementOnOff) == 0x000010, "Wrong alignment on USettingElementOnOff");
static_assert(sizeof(USettingElementOnOff) == 0x001DC0, "Wrong size on USettingElementOnOff");
static_assert(offsetof(USettingElementOnOff, bDisableDependenciesWhenValueIs) == 0x001DB1, "Member 'USettingElementOnOff::bDisableDependenciesWhenValueIs' has a wrong offset!");

// Class Stalker2.AgentBehaviourEventData
// 0x0008 (0x0030 - 0x0028)
class UAgentBehaviourEventData final : public UGameplayEventData
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EGoalType GetGoalType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgentBehaviourEventData">();
	}
	static class UAgentBehaviourEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgentBehaviourEventData>();
	}
};
static_assert(alignof(UAgentBehaviourEventData) == 0x000008, "Wrong alignment on UAgentBehaviourEventData");
static_assert(sizeof(UAgentBehaviourEventData) == 0x000030, "Wrong size on UAgentBehaviourEventData");

// Class Stalker2.AnimNotify_GSCPlayMontageNotify
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_GSCPlayMontageNotify final : public UAnimNotify
{
public:
	struct FGameplayTag                           NotifyTag;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GSCPlayMontageNotify">();
	}
	static class UAnimNotify_GSCPlayMontageNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GSCPlayMontageNotify>();
	}
};
static_assert(alignof(UAnimNotify_GSCPlayMontageNotify) == 0x000008, "Wrong alignment on UAnimNotify_GSCPlayMontageNotify");
static_assert(sizeof(UAnimNotify_GSCPlayMontageNotify) == 0x000040, "Wrong size on UAnimNotify_GSCPlayMontageNotify");
static_assert(offsetof(UAnimNotify_GSCPlayMontageNotify, NotifyTag) == 0x000038, "Member 'UAnimNotify_GSCPlayMontageNotify::NotifyTag' has a wrong offset!");

// Class Stalker2.AnimNotify_GSCPoseSearchBlockTransition
// 0x0000 (0x0030 - 0x0030)
class UAnimNotify_GSCPoseSearchBlockTransition final : public UAnimNotifyState_PoseSearchBlockTransition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GSCPoseSearchBlockTransition">();
	}
	static class UAnimNotify_GSCPoseSearchBlockTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GSCPoseSearchBlockTransition>();
	}
};
static_assert(alignof(UAnimNotify_GSCPoseSearchBlockTransition) == 0x000008, "Wrong alignment on UAnimNotify_GSCPoseSearchBlockTransition");
static_assert(sizeof(UAnimNotify_GSCPoseSearchBlockTransition) == 0x000030, "Wrong size on UAnimNotify_GSCPoseSearchBlockTransition");

// Class Stalker2.AnimNotify_GuitarAction
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_GuitarAction final : public UAnimNotifyBase
{
public:
	ENotifyGuitarAction                           GuitarAction;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GuitarAction">();
	}
	static class UAnimNotify_GuitarAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GuitarAction>();
	}
};
static_assert(alignof(UAnimNotify_GuitarAction) == 0x000008, "Wrong alignment on UAnimNotify_GuitarAction");
static_assert(sizeof(UAnimNotify_GuitarAction) == 0x000048, "Wrong size on UAnimNotify_GuitarAction");
static_assert(offsetof(UAnimNotify_GuitarAction, GuitarAction) == 0x000040, "Member 'UAnimNotify_GuitarAction::GuitarAction' has a wrong offset!");

// Class Stalker2.ParticleCallbackHandler
// 0x0020 (0x0048 - 0x0028)
class UParticleCallbackHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleCallbackHandler">();
	}
	static class UParticleCallbackHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleCallbackHandler>();
	}
};
static_assert(alignof(UParticleCallbackHandler) == 0x000008, "Wrong alignment on UParticleCallbackHandler");
static_assert(sizeof(UParticleCallbackHandler) == 0x000048, "Wrong size on UParticleCallbackHandler");

// Class Stalker2.CustomConsoleManagerGA
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerGA final : public UBaseConsoleManager
{
public:
	void XShowAnalyticsUserId() const;
	void XToggleAnalyticsTracking_Player(const bool bTracking) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerGA">();
	}
	static class UCustomConsoleManagerGA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerGA>();
	}
};
static_assert(alignof(UCustomConsoleManagerGA) == 0x000008, "Wrong alignment on UCustomConsoleManagerGA");
static_assert(sizeof(UCustomConsoleManagerGA) == 0x0000A8, "Wrong size on UCustomConsoleManagerGA");

// Class Stalker2.AnimNotify_HandIK
// 0x0018 (0x0058 - 0x0040)
class UAnimNotify_HandIK final : public UAnimNotifyBase
{
public:
	EAnimationHands                               HandToApply;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSetStartValue;                               // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartValue;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndValue;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendOption;                                       // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_HandIK">();
	}
	static class UAnimNotify_HandIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_HandIK>();
	}
};
static_assert(alignof(UAnimNotify_HandIK) == 0x000008, "Wrong alignment on UAnimNotify_HandIK");
static_assert(sizeof(UAnimNotify_HandIK) == 0x000058, "Wrong size on UAnimNotify_HandIK");
static_assert(offsetof(UAnimNotify_HandIK, HandToApply) == 0x000040, "Member 'UAnimNotify_HandIK::HandToApply' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HandIK, bForceSetStartValue) == 0x000041, "Member 'UAnimNotify_HandIK::bForceSetStartValue' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HandIK, StartValue) == 0x000044, "Member 'UAnimNotify_HandIK::StartValue' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HandIK, EndValue) == 0x000048, "Member 'UAnimNotify_HandIK::EndValue' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HandIK, BlendTime) == 0x00004C, "Member 'UAnimNotify_HandIK::BlendTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HandIK, BlendOption) == 0x000050, "Member 'UAnimNotify_HandIK::BlendOption' has a wrong offset!");

// Class Stalker2.DeathEventData
// 0x0008 (0x0030 - 0x0028)
class UDeathEventData final : public UGameplayEventData
{
public:
	EDamageType                                   DamageType;                                        // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageSource                                 DamageSource;                                      // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECauseOfDeath                                 CauseOfDeath;                                      // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathEventData">();
	}
	static class UDeathEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathEventData>();
	}
};
static_assert(alignof(UDeathEventData) == 0x000008, "Wrong alignment on UDeathEventData");
static_assert(sizeof(UDeathEventData) == 0x000030, "Wrong size on UDeathEventData");
static_assert(offsetof(UDeathEventData, DamageType) == 0x000028, "Member 'UDeathEventData::DamageType' has a wrong offset!");
static_assert(offsetof(UDeathEventData, DamageSource) == 0x000029, "Member 'UDeathEventData::DamageSource' has a wrong offset!");
static_assert(offsetof(UDeathEventData, CauseOfDeath) == 0x00002A, "Member 'UDeathEventData::CauseOfDeath' has a wrong offset!");

// Class Stalker2.AnimNotify_HandIKState
// 0x0018 (0x0048 - 0x0030)
class UAnimNotify_HandIKState final : public UAnimNotifyState
{
public:
	EAnimationHands                               HandToApply;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartValue;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndValue;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendOption;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_HandIKState">();
	}
	static class UAnimNotify_HandIKState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_HandIKState>();
	}
};
static_assert(alignof(UAnimNotify_HandIKState) == 0x000008, "Wrong alignment on UAnimNotify_HandIKState");
static_assert(sizeof(UAnimNotify_HandIKState) == 0x000048, "Wrong size on UAnimNotify_HandIKState");
static_assert(offsetof(UAnimNotify_HandIKState, HandToApply) == 0x000030, "Member 'UAnimNotify_HandIKState::HandToApply' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HandIKState, StartValue) == 0x000034, "Member 'UAnimNotify_HandIKState::StartValue' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HandIKState, EndValue) == 0x000038, "Member 'UAnimNotify_HandIKState::EndValue' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HandIKState, BlendTime) == 0x00003C, "Member 'UAnimNotify_HandIKState::BlendTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HandIKState, BlendOption) == 0x000040, "Member 'UAnimNotify_HandIKState::BlendOption' has a wrong offset!");

// Class Stalker2.WaterContactController
// 0x0058 (0x00F8 - 0x00A0)
class UWaterContactController : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x48];                                      // 0x00A0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWaterComponent*>                ActiveWaterBodies;                                 // 0x00E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	const struct FWaterSurfaceObstructionResult IsPathToWaterSurfaceObstructed() const;
	const struct FVector ProjectOwnerPositionOnWaterSurface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterContactController">();
	}
	static class UWaterContactController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterContactController>();
	}
};
static_assert(alignof(UWaterContactController) == 0x000008, "Wrong alignment on UWaterContactController");
static_assert(sizeof(UWaterContactController) == 0x0000F8, "Wrong size on UWaterContactController");
static_assert(offsetof(UWaterContactController, ActiveWaterBodies) == 0x0000E8, "Member 'UWaterContactController::ActiveWaterBodies' has a wrong offset!");

// Class Stalker2.SimpleVolumeForEffects
// 0x0010 (0x02E8 - 0x02D8)
class ASimpleVolumeForEffects final : public AVolume
{
public:
	class UApplyEffectComponent*                  EffectComponent;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRemoveEffectOnEndOverlap;                         // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleVolumeForEffects">();
	}
	static class ASimpleVolumeForEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASimpleVolumeForEffects>();
	}
};
static_assert(alignof(ASimpleVolumeForEffects) == 0x000008, "Wrong alignment on ASimpleVolumeForEffects");
static_assert(sizeof(ASimpleVolumeForEffects) == 0x0002E8, "Wrong size on ASimpleVolumeForEffects");
static_assert(offsetof(ASimpleVolumeForEffects, EffectComponent) == 0x0002D8, "Member 'ASimpleVolumeForEffects::EffectComponent' has a wrong offset!");
static_assert(offsetof(ASimpleVolumeForEffects, bRemoveEffectOnEndOverlap) == 0x0002E0, "Member 'ASimpleVolumeForEffects::bRemoveEffectOnEndOverlap' has a wrong offset!");

// Class Stalker2.AnimNotify_HealReceived
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_HealReceived final : public UAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_HealReceived">();
	}
	static class UAnimNotify_HealReceived* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_HealReceived>();
	}
};
static_assert(alignof(UAnimNotify_HealReceived) == 0x000008, "Wrong alignment on UAnimNotify_HealReceived");
static_assert(sizeof(UAnimNotify_HealReceived) == 0x000040, "Wrong size on UAnimNotify_HealReceived");

// Class Stalker2.GAQuestProcessor
// 0x0038 (0x0060 - 0x0028)
class UGAQuestProcessor final : public UGAPlayerProcessorInterface
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAQuestProcessor">();
	}
	static class UGAQuestProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAQuestProcessor>();
	}
};
static_assert(alignof(UGAQuestProcessor) == 0x000008, "Wrong alignment on UGAQuestProcessor");
static_assert(sizeof(UGAQuestProcessor) == 0x000060, "Wrong size on UGAQuestProcessor");

// Class Stalker2.NiagaraParameterProvider
// 0x0060 (0x0100 - 0x00A0)
class UNiagaraParameterProvider : public UActorComponent
{
public:
	TSet<class UNiagaraComponent*>                ValueReceivers;                                    // 0x00A0(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraParameterProvider">();
	}
	static class UNiagaraParameterProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraParameterProvider>();
	}
};
static_assert(alignof(UNiagaraParameterProvider) == 0x000008, "Wrong alignment on UNiagaraParameterProvider");
static_assert(sizeof(UNiagaraParameterProvider) == 0x000100, "Wrong size on UNiagaraParameterProvider");
static_assert(offsetof(UNiagaraParameterProvider, ValueReceivers) == 0x0000A0, "Member 'UNiagaraParameterProvider::ValueReceivers' has a wrong offset!");

// Class Stalker2.NiagaraPlayerLocationProvider
// 0x0000 (0x0100 - 0x0100)
class UNiagaraPlayerLocationProvider final : public UNiagaraParameterProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraPlayerLocationProvider">();
	}
	static class UNiagaraPlayerLocationProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraPlayerLocationProvider>();
	}
};
static_assert(alignof(UNiagaraPlayerLocationProvider) == 0x000008, "Wrong alignment on UNiagaraPlayerLocationProvider");
static_assert(sizeof(UNiagaraPlayerLocationProvider) == 0x000100, "Wrong size on UNiagaraPlayerLocationProvider");

// Class Stalker2.AnimNotify_HideBones
// 0x0020 (0x0060 - 0x0040)
class UAnimNotify_HideBones final : public UAnimNotifyBase
{
public:
	EBoneInteractionType                          BoneInteractionType;                               // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParentBoneName;                                    // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChildAttachName;                                   // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideBone;                                         // 0x0055(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmmoCount;                                         // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_HideBones">();
	}
	static class UAnimNotify_HideBones* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_HideBones>();
	}
};
static_assert(alignof(UAnimNotify_HideBones) == 0x000008, "Wrong alignment on UAnimNotify_HideBones");
static_assert(sizeof(UAnimNotify_HideBones) == 0x000060, "Wrong size on UAnimNotify_HideBones");
static_assert(offsetof(UAnimNotify_HideBones, BoneInteractionType) == 0x000040, "Member 'UAnimNotify_HideBones::BoneInteractionType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HideBones, ParentBoneName) == 0x000044, "Member 'UAnimNotify_HideBones::ParentBoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HideBones, ChildAttachName) == 0x00004C, "Member 'UAnimNotify_HideBones::ChildAttachName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HideBones, bPropagateToChildren) == 0x000054, "Member 'UAnimNotify_HideBones::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HideBones, bHideBone) == 0x000055, "Member 'UAnimNotify_HideBones::bHideBone' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HideBones, AmmoCount) == 0x000058, "Member 'UAnimNotify_HideBones::AmmoCount' has a wrong offset!");

// Class Stalker2.EjectedMagazine
// 0x0020 (0x02B8 - 0x0298)
class AEjectedMagazine final : public AActor
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsSoundsComponent*                PhysicsSoundsComponent;                            // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHittableComponent*                     HittableComponent;                                 // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  OwnerActor;                                        // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EjectedMagazine">();
	}
	static class AEjectedMagazine* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEjectedMagazine>();
	}
};
static_assert(alignof(AEjectedMagazine) == 0x000008, "Wrong alignment on AEjectedMagazine");
static_assert(sizeof(AEjectedMagazine) == 0x0002B8, "Wrong size on AEjectedMagazine");
static_assert(offsetof(AEjectedMagazine, MeshComponent) == 0x000298, "Member 'AEjectedMagazine::MeshComponent' has a wrong offset!");
static_assert(offsetof(AEjectedMagazine, PhysicsSoundsComponent) == 0x0002A0, "Member 'AEjectedMagazine::PhysicsSoundsComponent' has a wrong offset!");
static_assert(offsetof(AEjectedMagazine, HittableComponent) == 0x0002A8, "Member 'AEjectedMagazine::HittableComponent' has a wrong offset!");
static_assert(offsetof(AEjectedMagazine, OwnerActor) == 0x0002B0, "Member 'AEjectedMagazine::OwnerActor' has a wrong offset!");

// Class Stalker2.AnimNotify_Jump
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_Jump final : public UAnimNotifyBase
{
public:
	EJumpState                                    JumpState;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Jump">();
	}
	static class UAnimNotify_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Jump>();
	}
};
static_assert(alignof(UAnimNotify_Jump) == 0x000008, "Wrong alignment on UAnimNotify_Jump");
static_assert(sizeof(UAnimNotify_Jump) == 0x000048, "Wrong size on UAnimNotify_Jump");
static_assert(offsetof(UAnimNotify_Jump, JumpState) == 0x000040, "Member 'UAnimNotify_Jump::JumpState' has a wrong offset!");

// Class Stalker2.AnimNotify_LaunchDialogAnimation
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_LaunchDialogAnimation final : public UAnimNotifyBase
{
public:
	EDialogAnimationType                          DialogAnimationType;                               // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_LaunchDialogAnimation">();
	}
	static class UAnimNotify_LaunchDialogAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_LaunchDialogAnimation>();
	}
};
static_assert(alignof(UAnimNotify_LaunchDialogAnimation) == 0x000008, "Wrong alignment on UAnimNotify_LaunchDialogAnimation");
static_assert(sizeof(UAnimNotify_LaunchDialogAnimation) == 0x000048, "Wrong size on UAnimNotify_LaunchDialogAnimation");
static_assert(offsetof(UAnimNotify_LaunchDialogAnimation, DialogAnimationType) == 0x000040, "Member 'UAnimNotify_LaunchDialogAnimation::DialogAnimationType' has a wrong offset!");

// Class Stalker2.QuickSlot3IPU
// 0x0000 (0x0048 - 0x0048)
class UQuickSlot3IPU final : public UQuickSlotBaseIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickSlot3IPU">();
	}
	static class UQuickSlot3IPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickSlot3IPU>();
	}
};
static_assert(alignof(UQuickSlot3IPU) == 0x000008, "Wrong alignment on UQuickSlot3IPU");
static_assert(sizeof(UQuickSlot3IPU) == 0x000048, "Wrong size on UQuickSlot3IPU");

// Class Stalker2.AnimNotify_LaunchVoiceOver
// 0x0018 (0x0058 - 0x0040)
class UAnimNotify_LaunchVoiceOver final : public UAnimNotifyBase
{
public:
	class FString                                 VoiceOverSID;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bQuest;                                            // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FString> GetVoiceoverSIDOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_LaunchVoiceOver">();
	}
	static class UAnimNotify_LaunchVoiceOver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_LaunchVoiceOver>();
	}
};
static_assert(alignof(UAnimNotify_LaunchVoiceOver) == 0x000008, "Wrong alignment on UAnimNotify_LaunchVoiceOver");
static_assert(sizeof(UAnimNotify_LaunchVoiceOver) == 0x000058, "Wrong size on UAnimNotify_LaunchVoiceOver");
static_assert(offsetof(UAnimNotify_LaunchVoiceOver, VoiceOverSID) == 0x000040, "Member 'UAnimNotify_LaunchVoiceOver::VoiceOverSID' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LaunchVoiceOver, bQuest) == 0x000050, "Member 'UAnimNotify_LaunchVoiceOver::bQuest' has a wrong offset!");

// Class Stalker2.EmptyObject
// 0x0018 (0x02B0 - 0x0298)
class AEmptyObject final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          BoxCollision;                                      // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmptyObject">();
	}
	static class AEmptyObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEmptyObject>();
	}
};
static_assert(alignof(AEmptyObject) == 0x000008, "Wrong alignment on AEmptyObject");
static_assert(sizeof(AEmptyObject) == 0x0002B0, "Wrong size on AEmptyObject");
static_assert(offsetof(AEmptyObject, SceneComponent) == 0x000298, "Member 'AEmptyObject::SceneComponent' has a wrong offset!");
static_assert(offsetof(AEmptyObject, BoxCollision) == 0x0002A0, "Member 'AEmptyObject::BoxCollision' has a wrong offset!");
static_assert(offsetof(AEmptyObject, StaticMesh) == 0x0002A8, "Member 'AEmptyObject::StaticMesh' has a wrong offset!");

// Class Stalker2.AnimNotify_MakeAttack
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_MakeAttack final : public UAnimNotifyBase
{
public:
	bool                                          bInstantAttack;                                    // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_MakeAttack">();
	}
	static class UAnimNotify_MakeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_MakeAttack>();
	}
};
static_assert(alignof(UAnimNotify_MakeAttack) == 0x000008, "Wrong alignment on UAnimNotify_MakeAttack");
static_assert(sizeof(UAnimNotify_MakeAttack) == 0x000048, "Wrong size on UAnimNotify_MakeAttack");
static_assert(offsetof(UAnimNotify_MakeAttack, bInstantAttack) == 0x000040, "Member 'UAnimNotify_MakeAttack::bInstantAttack' has a wrong offset!");

// Class Stalker2.Global
// 0x0008 (0x01C8 - 0x01C0)
class UGlobal : public UGameInstance
{
public:
	class UMapSettingsAsset*                      PA_MapSettings;                                    // 0x01C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void GoToMap(const class FName MapName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Global">();
	}
	static class UGlobal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobal>();
	}
};
static_assert(alignof(UGlobal) == 0x000008, "Wrong alignment on UGlobal");
static_assert(sizeof(UGlobal) == 0x0001C8, "Wrong size on UGlobal");
static_assert(offsetof(UGlobal, PA_MapSettings) == 0x0001C0, "Member 'UGlobal::PA_MapSettings' has a wrong offset!");

// Class Stalker2.AnimNotify_ParkourFinalPosition
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_ParkourFinalPosition final : public UAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ParkourFinalPosition">();
	}
	static class UAnimNotify_ParkourFinalPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ParkourFinalPosition>();
	}
};
static_assert(alignof(UAnimNotify_ParkourFinalPosition) == 0x000008, "Wrong alignment on UAnimNotify_ParkourFinalPosition");
static_assert(sizeof(UAnimNotify_ParkourFinalPosition) == 0x000040, "Wrong size on UAnimNotify_ParkourFinalPosition");

// Class Stalker2.ItemSlotBaseWidget
// 0x0198 (0x0410 - 0x0278)
class UItemSlotBaseWidget : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               ItemAndAttachesOverlay;                            // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               AttachesOverlay;                                   // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImageWidget*                           ItemImage;                                         // 0x02A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemSlotState*                         SlotState;                                         // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIconSettings                          IconSettings;                                      // 0x02B0(0x0120)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UImageWidget>               AttachImageWidgetClass;                            // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UImageWidget*>                   AttachesImages;                                    // 0x03E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0x18];                                     // 0x03F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSlotBaseWidget">();
	}
	static class UItemSlotBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSlotBaseWidget>();
	}
};
static_assert(alignof(UItemSlotBaseWidget) == 0x000010, "Wrong alignment on UItemSlotBaseWidget");
static_assert(sizeof(UItemSlotBaseWidget) == 0x000410, "Wrong size on UItemSlotBaseWidget");
static_assert(offsetof(UItemSlotBaseWidget, SlotIndex) == 0x000288, "Member 'UItemSlotBaseWidget::SlotIndex' has a wrong offset!");
static_assert(offsetof(UItemSlotBaseWidget, ItemAndAttachesOverlay) == 0x000290, "Member 'UItemSlotBaseWidget::ItemAndAttachesOverlay' has a wrong offset!");
static_assert(offsetof(UItemSlotBaseWidget, AttachesOverlay) == 0x000298, "Member 'UItemSlotBaseWidget::AttachesOverlay' has a wrong offset!");
static_assert(offsetof(UItemSlotBaseWidget, ItemImage) == 0x0002A0, "Member 'UItemSlotBaseWidget::ItemImage' has a wrong offset!");
static_assert(offsetof(UItemSlotBaseWidget, SlotState) == 0x0002A8, "Member 'UItemSlotBaseWidget::SlotState' has a wrong offset!");
static_assert(offsetof(UItemSlotBaseWidget, IconSettings) == 0x0002B0, "Member 'UItemSlotBaseWidget::IconSettings' has a wrong offset!");
static_assert(offsetof(UItemSlotBaseWidget, AttachImageWidgetClass) == 0x0003D0, "Member 'UItemSlotBaseWidget::AttachImageWidgetClass' has a wrong offset!");
static_assert(offsetof(UItemSlotBaseWidget, AttachesImages) == 0x0003E8, "Member 'UItemSlotBaseWidget::AttachesImages' has a wrong offset!");

// Class Stalker2.InteractableItemSlotBaseWidget
// 0x0110 (0x0520 - 0x0410)
#pragma pack(push, 0x1)
class alignas(0x10) UInteractableItemSlotBaseWidget : public UItemSlotBaseWidget
{
public:
	uint8                                         Pad_410[0x108];                                    // 0x0410(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableItemSlotBaseWidget">();
	}
	static class UInteractableItemSlotBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableItemSlotBaseWidget>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInteractableItemSlotBaseWidget) == 0x000010, "Wrong alignment on UInteractableItemSlotBaseWidget");
static_assert(sizeof(UInteractableItemSlotBaseWidget) == 0x000520, "Wrong size on UInteractableItemSlotBaseWidget");

// Class Stalker2.EquipmentSlot
// 0x0120 (0x0640 - 0x0520)
#pragma pack(push, 0x1)
class alignas(0x10) UEquipmentSlot : public UInteractableItemSlotBaseWidget
{
public:
	class UImage*                                 Background;                                        // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 EffectsHighlight;                                  // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 bLocked;                                           // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 DefaultImage;                                      // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Broken;                                            // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Attach;                                            // 0x0540(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScaleBox*                              ItemImageScaleBox;                                 // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                HighlightBorder;                                   // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           DefaultImageColor;                                 // 0x0558(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FWidgetTransform                       DefaultIconTransform;                              // 0x0568(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FLinearColor                           TransparentDefaultImageColor;                      // 0x05A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             DefaultIcon;                                       // 0x05B0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             BackgroundIcon;                                    // 0x05B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             BlockedIcon;                                       // 0x05C0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bArtifact;                                         // 0x05C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C9[0x3];                                      // 0x05C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultImageScaleX;                                // 0x05CC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultImageScaleY;                                // 0x05D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 InventoryHighlightImage;                           // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             InventoryHighlightTexture;                         // 0x05E0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x50];                                     // 0x05E8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentSlot">();
	}
	static class UEquipmentSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentSlot>();
	}
};
#pragma pack(pop)
static_assert(alignof(UEquipmentSlot) == 0x000010, "Wrong alignment on UEquipmentSlot");
static_assert(sizeof(UEquipmentSlot) == 0x000640, "Wrong size on UEquipmentSlot");
static_assert(offsetof(UEquipmentSlot, Background) == 0x000518, "Member 'UEquipmentSlot::Background' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, EffectsHighlight) == 0x000520, "Member 'UEquipmentSlot::EffectsHighlight' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, bLocked) == 0x000528, "Member 'UEquipmentSlot::bLocked' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, DefaultImage) == 0x000530, "Member 'UEquipmentSlot::DefaultImage' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, Broken) == 0x000538, "Member 'UEquipmentSlot::Broken' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, Attach) == 0x000540, "Member 'UEquipmentSlot::Attach' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, ItemImageScaleBox) == 0x000548, "Member 'UEquipmentSlot::ItemImageScaleBox' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, HighlightBorder) == 0x000550, "Member 'UEquipmentSlot::HighlightBorder' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, DefaultImageColor) == 0x000558, "Member 'UEquipmentSlot::DefaultImageColor' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, DefaultIconTransform) == 0x000568, "Member 'UEquipmentSlot::DefaultIconTransform' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, TransparentDefaultImageColor) == 0x0005A0, "Member 'UEquipmentSlot::TransparentDefaultImageColor' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, DefaultIcon) == 0x0005B0, "Member 'UEquipmentSlot::DefaultIcon' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, BackgroundIcon) == 0x0005B8, "Member 'UEquipmentSlot::BackgroundIcon' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, BlockedIcon) == 0x0005C0, "Member 'UEquipmentSlot::BlockedIcon' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, bArtifact) == 0x0005C8, "Member 'UEquipmentSlot::bArtifact' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, DefaultImageScaleX) == 0x0005CC, "Member 'UEquipmentSlot::DefaultImageScaleX' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, DefaultImageScaleY) == 0x0005D0, "Member 'UEquipmentSlot::DefaultImageScaleY' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, InventoryHighlightImage) == 0x0005D8, "Member 'UEquipmentSlot::InventoryHighlightImage' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, InventoryHighlightTexture) == 0x0005E0, "Member 'UEquipmentSlot::InventoryHighlightTexture' has a wrong offset!");

// Class Stalker2.AnimNotify_PlayerAction
// 0x0018 (0x0058 - 0x0040)
class UAnimNotify_PlayerAction final : public UAnimNotifyBase
{
public:
	EPlayerActionResult                           PlayerActionResult;                                // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionType                                   PlayerActionType;                                  // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerTriggerState                           PlayerTriggerToOverride;                           // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionType                                   PlayerActionTypeToOverride;                        // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayerAction">();
	}
	static class UAnimNotify_PlayerAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayerAction>();
	}
};
static_assert(alignof(UAnimNotify_PlayerAction) == 0x000008, "Wrong alignment on UAnimNotify_PlayerAction");
static_assert(sizeof(UAnimNotify_PlayerAction) == 0x000058, "Wrong size on UAnimNotify_PlayerAction");
static_assert(offsetof(UAnimNotify_PlayerAction, PlayerActionResult) == 0x000040, "Member 'UAnimNotify_PlayerAction::PlayerActionResult' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayerAction, PlayerActionType) == 0x000041, "Member 'UAnimNotify_PlayerAction::PlayerActionType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayerAction, PlayerTriggerToOverride) == 0x000048, "Member 'UAnimNotify_PlayerAction::PlayerTriggerToOverride' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayerAction, PlayerActionTypeToOverride) == 0x000050, "Member 'UAnimNotify_PlayerAction::PlayerActionTypeToOverride' has a wrong offset!");

// Class Stalker2.AnimNotify_PlayerUIEvent
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_PlayerUIEvent final : public UAnimNotifyBase
{
public:
	EPlayerUIEvent                                EventType;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayerUIEvent">();
	}
	static class UAnimNotify_PlayerUIEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayerUIEvent>();
	}
};
static_assert(alignof(UAnimNotify_PlayerUIEvent) == 0x000008, "Wrong alignment on UAnimNotify_PlayerUIEvent");
static_assert(sizeof(UAnimNotify_PlayerUIEvent) == 0x000048, "Wrong size on UAnimNotify_PlayerUIEvent");
static_assert(offsetof(UAnimNotify_PlayerUIEvent, EventType) == 0x000040, "Member 'UAnimNotify_PlayerUIEvent::EventType' has a wrong offset!");

// Class Stalker2.ExplosionComponent
// 0x0070 (0x0110 - 0x00A0)
class UExplosionComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         ExplosionParticles;                                // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrototypeSID                          PrototypeSID;                                      // 0x00B0(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x20];                                      // 0x00F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Explode(const struct FUID& ExplosionInstigatorUID);
	void ExplodeAtCustomLocation(const struct FVector& Location, class UObject* ExplosionInstigator);
	void ExplodeWithCustomLocation(const struct FVector& Location, const struct FUID& ExplosionInstigatorUID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosionComponent">();
	}
	static class UExplosionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExplosionComponent>();
	}
};
static_assert(alignof(UExplosionComponent) == 0x000008, "Wrong alignment on UExplosionComponent");
static_assert(sizeof(UExplosionComponent) == 0x000110, "Wrong size on UExplosionComponent");
static_assert(offsetof(UExplosionComponent, ExplosionParticles) == 0x0000A8, "Member 'UExplosionComponent::ExplosionParticles' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, PrototypeSID) == 0x0000B0, "Member 'UExplosionComponent::PrototypeSID' has a wrong offset!");

// Class Stalker2.AnimNotify_PlayInteractablesFX
// 0x0018 (0x0058 - 0x0040)
class UAnimNotify_PlayInteractablesFX final : public UAnimNotifyBase
{
public:
	class FName                                   BoneName;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomBoneName;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractFXType                               InteractFXType;                                    // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class FString> GetAvailableBones();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayInteractablesFX">();
	}
	static class UAnimNotify_PlayInteractablesFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayInteractablesFX>();
	}
};
static_assert(alignof(UAnimNotify_PlayInteractablesFX) == 0x000008, "Wrong alignment on UAnimNotify_PlayInteractablesFX");
static_assert(sizeof(UAnimNotify_PlayInteractablesFX) == 0x000058, "Wrong size on UAnimNotify_PlayInteractablesFX");
static_assert(offsetof(UAnimNotify_PlayInteractablesFX, BoneName) == 0x000040, "Member 'UAnimNotify_PlayInteractablesFX::BoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayInteractablesFX, CustomBoneName) == 0x000048, "Member 'UAnimNotify_PlayInteractablesFX::CustomBoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayInteractablesFX, InteractFXType) == 0x000050, "Member 'UAnimNotify_PlayInteractablesFX::InteractFXType' has a wrong offset!");

// Class Stalker2.GSCAblityBlueprintFunctions
// 0x0000 (0x0028 - 0x0028)
class UGSCAblityBlueprintFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void ExecuteAbilityByActivationTagAttackPayload(class AActor* Actor, class FName ActivationTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCAblityBlueprintFunctions">();
	}
	static class UGSCAblityBlueprintFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSCAblityBlueprintFunctions>();
	}
};
static_assert(alignof(UGSCAblityBlueprintFunctions) == 0x000008, "Wrong alignment on UGSCAblityBlueprintFunctions");
static_assert(sizeof(UGSCAblityBlueprintFunctions) == 0x000028, "Wrong size on UGSCAblityBlueprintFunctions");

// Class Stalker2.OldSchoolTrigger
// 0x0018 (0x02B0 - 0x0298)
class AOldSchoolTrigger final : public AActor
{
public:
	class UBoxComponent*                          Trigger;                                           // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceToHinge;                                   // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HalfAngleToHinge;                                  // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADoorView*                              door;                                              // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTriggerBeginOverlap(const class UPrimitiveComponent* Comp, const class AActor* OtherActor, const class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);
	void OnTriggerEndOverlap(const class UPrimitiveComponent* OverlappedComponent, const class AActor* OtherActor, const class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OldSchoolTrigger">();
	}
	static class AOldSchoolTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOldSchoolTrigger>();
	}
};
static_assert(alignof(AOldSchoolTrigger) == 0x000008, "Wrong alignment on AOldSchoolTrigger");
static_assert(sizeof(AOldSchoolTrigger) == 0x0002B0, "Wrong size on AOldSchoolTrigger");
static_assert(offsetof(AOldSchoolTrigger, Trigger) == 0x000298, "Member 'AOldSchoolTrigger::Trigger' has a wrong offset!");
static_assert(offsetof(AOldSchoolTrigger, DistanceToHinge) == 0x0002A0, "Member 'AOldSchoolTrigger::DistanceToHinge' has a wrong offset!");
static_assert(offsetof(AOldSchoolTrigger, HalfAngleToHinge) == 0x0002A4, "Member 'AOldSchoolTrigger::HalfAngleToHinge' has a wrong offset!");
static_assert(offsetof(AOldSchoolTrigger, door) == 0x0002A8, "Member 'AOldSchoolTrigger::door' has a wrong offset!");

// Class Stalker2.AnimNotify_RagdollAction
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_RagdollAction final : public UAnimNotifyBase
{
public:
	ERagdollAction                                RagdollAction;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_RagdollAction">();
	}
	static class UAnimNotify_RagdollAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_RagdollAction>();
	}
};
static_assert(alignof(UAnimNotify_RagdollAction) == 0x000008, "Wrong alignment on UAnimNotify_RagdollAction");
static_assert(sizeof(UAnimNotify_RagdollAction) == 0x000048, "Wrong size on UAnimNotify_RagdollAction");
static_assert(offsetof(UAnimNotify_RagdollAction, RagdollAction) == 0x000040, "Member 'UAnimNotify_RagdollAction::RagdollAction' has a wrong offset!");

// Class Stalker2.PC
// 0x07E0 (0x1130 - 0x0950)
class APC final : public AObj
{
public:
	uint8                                         Pad_950[0x18];                                     // 0x0950(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPlayerItemsSounds>      PlayerItemSounds;                                  // 0x0968(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_998[0x18];                                     // 0x0998(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMouthComponent*                        Mouth;                                             // 0x09B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDamageVoiceoverComponent*              DamageVoiceover;                                   // 0x09B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimAssistComponent*                    AimAssistComponent;                                // 0x09C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimProcessorComponent*                 AimProcessor;                                      // 0x09C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 ShadowMeshComponent;                               // 0x09D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGeigerCounterComponent*                GeigerCounterComponent;                            // 0x09D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPsyNoiseSFXComponent*                  PsyNoiseSFXComponent;                              // 0x09E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnomalyDetectorComponent*              AnomalyDetectorComponent;                          // 0x09E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerOpticScopeComponent*             PlayerOpticScopeComponent;                         // 0x09F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerInteractionComponent*            PlayerInteractionComponent;                        // 0x09F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStealthKillComponent*                  StealthKillComponent;                              // 0x0A00(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 StealthKillTarget;                                 // 0x0A08(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USearchpointDetectorComponent*          SearchpointDetectorComponent;                      // 0x0A10(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGAPlayerComponent*                     GAComponent;                                       // 0x0A18(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A20[0x540];                                    // 0x0A20(0x0540)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          InteractionFromBluerint;                           // 0x0F60(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F61[0x7];                                      // 0x0F61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MinObjectInteractImpulse;                          // 0x0F68(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        MaxObjectInteractImpulse;                          // 0x0F70(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        ObjectInteractDelay;                               // 0x0F78(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        MinSpeedToObjectResponse;                          // 0x0F80(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NormalReapeatFPS;                                  // 0x0F88(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VelocityMultimplier;                               // 0x0F8C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ObjectPenetrationToImpulseCurve;                   // 0x0F90(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ObjectMassToImpulseCurve;                          // 0x0F98(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ObjectMassToMaxImpulseCurve;                       // 0x0FA0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ReduceDamageFromNPCCurve;                          // 0x0FA8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FB0[0x8];                                      // 0x0FB0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerMovementType                           AllowedMovementActions;                            // 0x0FB8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FB9[0xBF];                                     // 0x0FB9(0x00BF)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRtpc*                                PoppyFieldSleepinessParameter;                     // 0x1078(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1080[0xB0];                                    // 0x1080(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayInteractionInAnimation();
	void PlayInteractionOutAnimation();
	void SetInteractionTarget(const class UInteractionComponent* Target);
	void SetLegsIKEnabled(const bool bEnabled);

	class UInteractionComponent* GetInteractionTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PC">();
	}
	static class APC* GetDefaultObj()
	{
		return GetDefaultObjImpl<APC>();
	}
};
static_assert(alignof(APC) == 0x000010, "Wrong alignment on APC");
static_assert(sizeof(APC) == 0x001130, "Wrong size on APC");
static_assert(offsetof(APC, PlayerItemSounds) == 0x000968, "Member 'APC::PlayerItemSounds' has a wrong offset!");
static_assert(offsetof(APC, Mouth) == 0x0009B0, "Member 'APC::Mouth' has a wrong offset!");
static_assert(offsetof(APC, DamageVoiceover) == 0x0009B8, "Member 'APC::DamageVoiceover' has a wrong offset!");
static_assert(offsetof(APC, AimAssistComponent) == 0x0009C0, "Member 'APC::AimAssistComponent' has a wrong offset!");
static_assert(offsetof(APC, AimProcessor) == 0x0009C8, "Member 'APC::AimProcessor' has a wrong offset!");
static_assert(offsetof(APC, ShadowMeshComponent) == 0x0009D0, "Member 'APC::ShadowMeshComponent' has a wrong offset!");
static_assert(offsetof(APC, GeigerCounterComponent) == 0x0009D8, "Member 'APC::GeigerCounterComponent' has a wrong offset!");
static_assert(offsetof(APC, PsyNoiseSFXComponent) == 0x0009E0, "Member 'APC::PsyNoiseSFXComponent' has a wrong offset!");
static_assert(offsetof(APC, AnomalyDetectorComponent) == 0x0009E8, "Member 'APC::AnomalyDetectorComponent' has a wrong offset!");
static_assert(offsetof(APC, PlayerOpticScopeComponent) == 0x0009F0, "Member 'APC::PlayerOpticScopeComponent' has a wrong offset!");
static_assert(offsetof(APC, PlayerInteractionComponent) == 0x0009F8, "Member 'APC::PlayerInteractionComponent' has a wrong offset!");
static_assert(offsetof(APC, StealthKillComponent) == 0x000A00, "Member 'APC::StealthKillComponent' has a wrong offset!");
static_assert(offsetof(APC, StealthKillTarget) == 0x000A08, "Member 'APC::StealthKillTarget' has a wrong offset!");
static_assert(offsetof(APC, SearchpointDetectorComponent) == 0x000A10, "Member 'APC::SearchpointDetectorComponent' has a wrong offset!");
static_assert(offsetof(APC, GAComponent) == 0x000A18, "Member 'APC::GAComponent' has a wrong offset!");
static_assert(offsetof(APC, InteractionFromBluerint) == 0x000F60, "Member 'APC::InteractionFromBluerint' has a wrong offset!");
static_assert(offsetof(APC, MinObjectInteractImpulse) == 0x000F68, "Member 'APC::MinObjectInteractImpulse' has a wrong offset!");
static_assert(offsetof(APC, MaxObjectInteractImpulse) == 0x000F70, "Member 'APC::MaxObjectInteractImpulse' has a wrong offset!");
static_assert(offsetof(APC, ObjectInteractDelay) == 0x000F78, "Member 'APC::ObjectInteractDelay' has a wrong offset!");
static_assert(offsetof(APC, MinSpeedToObjectResponse) == 0x000F80, "Member 'APC::MinSpeedToObjectResponse' has a wrong offset!");
static_assert(offsetof(APC, NormalReapeatFPS) == 0x000F88, "Member 'APC::NormalReapeatFPS' has a wrong offset!");
static_assert(offsetof(APC, VelocityMultimplier) == 0x000F8C, "Member 'APC::VelocityMultimplier' has a wrong offset!");
static_assert(offsetof(APC, ObjectPenetrationToImpulseCurve) == 0x000F90, "Member 'APC::ObjectPenetrationToImpulseCurve' has a wrong offset!");
static_assert(offsetof(APC, ObjectMassToImpulseCurve) == 0x000F98, "Member 'APC::ObjectMassToImpulseCurve' has a wrong offset!");
static_assert(offsetof(APC, ObjectMassToMaxImpulseCurve) == 0x000FA0, "Member 'APC::ObjectMassToMaxImpulseCurve' has a wrong offset!");
static_assert(offsetof(APC, ReduceDamageFromNPCCurve) == 0x000FA8, "Member 'APC::ReduceDamageFromNPCCurve' has a wrong offset!");
static_assert(offsetof(APC, AllowedMovementActions) == 0x000FB8, "Member 'APC::AllowedMovementActions' has a wrong offset!");
static_assert(offsetof(APC, PoppyFieldSleepinessParameter) == 0x001078, "Member 'APC::PoppyFieldSleepinessParameter' has a wrong offset!");

// Class Stalker2.PlayerEffectsSFXComponent
// 0x0030 (0x00D0 - 0x00A0)
class UPlayerEffectsSFXComponent : public UActorComponent
{
public:
	class UAkAudioEvent*                          SFXStartEvent;                                     // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          SFXStopEvent;                                      // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                SFXParameter;                                      // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerEffectsSFXComponent">();
	}
	static class UPlayerEffectsSFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerEffectsSFXComponent>();
	}
};
static_assert(alignof(UPlayerEffectsSFXComponent) == 0x000008, "Wrong alignment on UPlayerEffectsSFXComponent");
static_assert(sizeof(UPlayerEffectsSFXComponent) == 0x0000D0, "Wrong size on UPlayerEffectsSFXComponent");
static_assert(offsetof(UPlayerEffectsSFXComponent, SFXStartEvent) == 0x0000A0, "Member 'UPlayerEffectsSFXComponent::SFXStartEvent' has a wrong offset!");
static_assert(offsetof(UPlayerEffectsSFXComponent, SFXStopEvent) == 0x0000A8, "Member 'UPlayerEffectsSFXComponent::SFXStopEvent' has a wrong offset!");
static_assert(offsetof(UPlayerEffectsSFXComponent, SFXParameter) == 0x0000B0, "Member 'UPlayerEffectsSFXComponent::SFXParameter' has a wrong offset!");

// Class Stalker2.AnimNotify_ResetControlRotation
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_ResetControlRotation final : public UAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ResetControlRotation">();
	}
	static class UAnimNotify_ResetControlRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ResetControlRotation>();
	}
};
static_assert(alignof(UAnimNotify_ResetControlRotation) == 0x000008, "Wrong alignment on UAnimNotify_ResetControlRotation");
static_assert(sizeof(UAnimNotify_ResetControlRotation) == 0x000040, "Wrong size on UAnimNotify_ResetControlRotation");

// Class Stalker2.AnimNotify_SetStateTag
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_SetStateTag final : public UAnimNotifyBase
{
public:
	EStateTag                                     StateTag;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetStateTag">();
	}
	static class UAnimNotify_SetStateTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetStateTag>();
	}
};
static_assert(alignof(UAnimNotify_SetStateTag) == 0x000008, "Wrong alignment on UAnimNotify_SetStateTag");
static_assert(sizeof(UAnimNotify_SetStateTag) == 0x000048, "Wrong size on UAnimNotify_SetStateTag");
static_assert(offsetof(UAnimNotify_SetStateTag, StateTag) == 0x000040, "Member 'UAnimNotify_SetStateTag::StateTag' has a wrong offset!");
static_assert(offsetof(UAnimNotify_SetStateTag, bEnabled) == 0x000044, "Member 'UAnimNotify_SetStateTag::bEnabled' has a wrong offset!");

// Class Stalker2.GlobalVariableManager
// 0x0058 (0x00D0 - 0x0078)
class UGlobalVariableManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x58];                                      // 0x0078(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalVariableManager">();
	}
	static class UGlobalVariableManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalVariableManager>();
	}
};
static_assert(alignof(UGlobalVariableManager) == 0x000008, "Wrong alignment on UGlobalVariableManager");
static_assert(sizeof(UGlobalVariableManager) == 0x0000D0, "Wrong size on UGlobalVariableManager");

// Class Stalker2.AnimNotify_SetWeaponEnabled
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_SetWeaponEnabled final : public UAnimNotifyBase
{
public:
	bool                                          bEnabled;                                          // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetWeaponEnabled">();
	}
	static class UAnimNotify_SetWeaponEnabled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetWeaponEnabled>();
	}
};
static_assert(alignof(UAnimNotify_SetWeaponEnabled) == 0x000008, "Wrong alignment on UAnimNotify_SetWeaponEnabled");
static_assert(sizeof(UAnimNotify_SetWeaponEnabled) == 0x000048, "Wrong size on UAnimNotify_SetWeaponEnabled");
static_assert(offsetof(UAnimNotify_SetWeaponEnabled, bEnabled) == 0x000040, "Member 'UAnimNotify_SetWeaponEnabled::bEnabled' has a wrong offset!");

// Class Stalker2.AnimNotify_SpawnParticle
// 0x0018 (0x0058 - 0x0040)
class UAnimNotify_SpawnParticle final : public UAnimNotifyBase
{
public:
	class UFXSystemAsset*                         ParticlePFX;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneToSpawnOnName;                                 // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAttachToBone;                                   // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bListenCollision;                                  // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SpawnParticle">();
	}
	static class UAnimNotify_SpawnParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SpawnParticle>();
	}
};
static_assert(alignof(UAnimNotify_SpawnParticle) == 0x000008, "Wrong alignment on UAnimNotify_SpawnParticle");
static_assert(sizeof(UAnimNotify_SpawnParticle) == 0x000058, "Wrong size on UAnimNotify_SpawnParticle");
static_assert(offsetof(UAnimNotify_SpawnParticle, ParticlePFX) == 0x000040, "Member 'UAnimNotify_SpawnParticle::ParticlePFX' has a wrong offset!");
static_assert(offsetof(UAnimNotify_SpawnParticle, BoneToSpawnOnName) == 0x000048, "Member 'UAnimNotify_SpawnParticle::BoneToSpawnOnName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_SpawnParticle, bIsAttachToBone) == 0x000050, "Member 'UAnimNotify_SpawnParticle::bIsAttachToBone' has a wrong offset!");
static_assert(offsetof(UAnimNotify_SpawnParticle, bListenCollision) == 0x000051, "Member 'UAnimNotify_SpawnParticle::bListenCollision' has a wrong offset!");

// Class Stalker2.AnimNotify_StashSound
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_StashSound final : public UAnimNotifyBase
{
public:
	EStashActionType                              StashActionType;                                   // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_StashSound">();
	}
	static class UAnimNotify_StashSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_StashSound>();
	}
};
static_assert(alignof(UAnimNotify_StashSound) == 0x000008, "Wrong alignment on UAnimNotify_StashSound");
static_assert(sizeof(UAnimNotify_StashSound) == 0x000048, "Wrong size on UAnimNotify_StashSound");
static_assert(offsetof(UAnimNotify_StashSound, StashActionType) == 0x000040, "Member 'UAnimNotify_StashSound::StashActionType' has a wrong offset!");

// Class Stalker2.UIDActorOwnsModel
// 0x0008 (0x02A0 - 0x0298)
class AUIDActorOwnsModel : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActorOwnsModel">();
	}
	static class AUIDActorOwnsModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDActorOwnsModel>();
	}
};
static_assert(alignof(AUIDActorOwnsModel) == 0x000008, "Wrong alignment on AUIDActorOwnsModel");
static_assert(sizeof(AUIDActorOwnsModel) == 0x0002A0, "Wrong size on AUIDActorOwnsModel");

// Class Stalker2.UIDActor_Grenade
// 0x0008 (0x02A8 - 0x02A0)
class AUIDActor_Grenade : public AUIDActorOwnsModel
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActor_Grenade">();
	}
	static class AUIDActor_Grenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDActor_Grenade>();
	}
};
static_assert(alignof(AUIDActor_Grenade) == 0x000008, "Wrong alignment on AUIDActor_Grenade");
static_assert(sizeof(AUIDActor_Grenade) == 0x0002A8, "Wrong size on AUIDActor_Grenade");

// Class Stalker2.Grenade
// 0x0108 (0x03B0 - 0x02A8)
class alignas(0x10) AGrenade final : public AUIDActor_Grenade
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGrenadeExplosionComponent*             ExplosionComponent;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           ExplosionAudioComponent;                           // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHittableComponent*                     HittableComponent;                                 // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsInteractionComponent*           PhysicsInteractionComponent;                       // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsSoundsComponent*                PhysicsSoundsComponent;                            // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWaterContactController*                WaterContactController;                            // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SID;                                               // 0x02F8(0x0010)(Edit, ZeroConstructor, EditConst, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0xC];                                      // 0x0308(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToExplosion;                                   // 0x0314(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x50];                                     // 0x0318(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ExplosionDecalMaterial;                            // 0x0368(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x40];                                     // 0x0370(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

	void Explode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Grenade">();
	}
	static class AGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGrenade>();
	}
};
static_assert(alignof(AGrenade) == 0x000010, "Wrong alignment on AGrenade");
static_assert(sizeof(AGrenade) == 0x0003B0, "Wrong size on AGrenade");
static_assert(offsetof(AGrenade, ExplosionComponent) == 0x0002B0, "Member 'AGrenade::ExplosionComponent' has a wrong offset!");
static_assert(offsetof(AGrenade, ExplosionAudioComponent) == 0x0002B8, "Member 'AGrenade::ExplosionAudioComponent' has a wrong offset!");
static_assert(offsetof(AGrenade, StaticMeshComponent) == 0x0002C0, "Member 'AGrenade::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGrenade, HittableComponent) == 0x0002C8, "Member 'AGrenade::HittableComponent' has a wrong offset!");
static_assert(offsetof(AGrenade, PhysicsInteractionComponent) == 0x0002D0, "Member 'AGrenade::PhysicsInteractionComponent' has a wrong offset!");
static_assert(offsetof(AGrenade, PhysicsSoundsComponent) == 0x0002D8, "Member 'AGrenade::PhysicsSoundsComponent' has a wrong offset!");
static_assert(offsetof(AGrenade, WaterContactController) == 0x0002E0, "Member 'AGrenade::WaterContactController' has a wrong offset!");
static_assert(offsetof(AGrenade, SID) == 0x0002F8, "Member 'AGrenade::SID' has a wrong offset!");
static_assert(offsetof(AGrenade, TimeToExplosion) == 0x000314, "Member 'AGrenade::TimeToExplosion' has a wrong offset!");
static_assert(offsetof(AGrenade, ExplosionDecalMaterial) == 0x000368, "Member 'AGrenade::ExplosionDecalMaterial' has a wrong offset!");

// Class Stalker2.AnimNotify_ThroatAnimationEnded
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_ThroatAnimationEnded final : public UAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ThroatAnimationEnded">();
	}
	static class UAnimNotify_ThroatAnimationEnded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ThroatAnimationEnded>();
	}
};
static_assert(alignof(UAnimNotify_ThroatAnimationEnded) == 0x000008, "Wrong alignment on UAnimNotify_ThroatAnimationEnded");
static_assert(sizeof(UAnimNotify_ThroatAnimationEnded) == 0x000040, "Wrong size on UAnimNotify_ThroatAnimationEnded");

// Class Stalker2.AnimNotify_ToggleEyesLookAt
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_ToggleEyesLookAt final : public UAnimNotifyBase
{
public:
	bool                                          bIsEnabled;                                        // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldChangeEyesIdle;                             // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECutsceneEyesIdleProfile                      NewEyesIdleProfile;                                // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ToggleEyesLookAt">();
	}
	static class UAnimNotify_ToggleEyesLookAt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ToggleEyesLookAt>();
	}
};
static_assert(alignof(UAnimNotify_ToggleEyesLookAt) == 0x000008, "Wrong alignment on UAnimNotify_ToggleEyesLookAt");
static_assert(sizeof(UAnimNotify_ToggleEyesLookAt) == 0x000048, "Wrong size on UAnimNotify_ToggleEyesLookAt");
static_assert(offsetof(UAnimNotify_ToggleEyesLookAt, bIsEnabled) == 0x000040, "Member 'UAnimNotify_ToggleEyesLookAt::bIsEnabled' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ToggleEyesLookAt, bShouldChangeEyesIdle) == 0x000041, "Member 'UAnimNotify_ToggleEyesLookAt::bShouldChangeEyesIdle' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ToggleEyesLookAt, NewEyesIdleProfile) == 0x000042, "Member 'UAnimNotify_ToggleEyesLookAt::NewEyesIdleProfile' has a wrong offset!");

// Class Stalker2.TutorialBase
// 0x0150 (0x0418 - 0x02C8)
class UTutorialBase : public UViewBaseExtended
{
public:
	uint8                                         Pad_2C8[0x18];                                     // 0x02C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class URichTextBlock*                         Text;                                              // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               TutorialOverlay;                                   // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 HintFont;                                          // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0xFC];                                     // 0x0300(0x00FC)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationInSeconds;                                 // 0x03FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x18];                                     // 0x0400(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialBase">();
	}
	static class UTutorialBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialBase>();
	}
};
static_assert(alignof(UTutorialBase) == 0x000008, "Wrong alignment on UTutorialBase");
static_assert(sizeof(UTutorialBase) == 0x000418, "Wrong size on UTutorialBase");
static_assert(offsetof(UTutorialBase, Text) == 0x0002E0, "Member 'UTutorialBase::Text' has a wrong offset!");
static_assert(offsetof(UTutorialBase, TutorialOverlay) == 0x0002E8, "Member 'UTutorialBase::TutorialOverlay' has a wrong offset!");
static_assert(offsetof(UTutorialBase, HintFont) == 0x0002F0, "Member 'UTutorialBase::HintFont' has a wrong offset!");
static_assert(offsetof(UTutorialBase, DurationInSeconds) == 0x0003FC, "Member 'UTutorialBase::DurationInSeconds' has a wrong offset!");

// Class Stalker2.TutorialReference
// 0x0020 (0x0438 - 0x0418)
class UTutorialReference final : public UTutorialBase
{
public:
	class UVerticalBox*                           TitleBox;                                          // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           TitleLineBox;                                      // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           LineWithIconBox;                                   // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextBlock*                         TitleTutorText;                                    // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialReference">();
	}
	static class UTutorialReference* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialReference>();
	}
};
static_assert(alignof(UTutorialReference) == 0x000008, "Wrong alignment on UTutorialReference");
static_assert(sizeof(UTutorialReference) == 0x000438, "Wrong size on UTutorialReference");
static_assert(offsetof(UTutorialReference, TitleBox) == 0x000418, "Member 'UTutorialReference::TitleBox' has a wrong offset!");
static_assert(offsetof(UTutorialReference, TitleLineBox) == 0x000420, "Member 'UTutorialReference::TitleLineBox' has a wrong offset!");
static_assert(offsetof(UTutorialReference, LineWithIconBox) == 0x000428, "Member 'UTutorialReference::LineWithIconBox' has a wrong offset!");
static_assert(offsetof(UTutorialReference, TitleTutorText) == 0x000430, "Member 'UTutorialReference::TitleTutorText' has a wrong offset!");

// Class Stalker2.AnimNotify_ToggleFlashlight
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_ToggleFlashlight final : public UAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ToggleFlashlight">();
	}
	static class UAnimNotify_ToggleFlashlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ToggleFlashlight>();
	}
};
static_assert(alignof(UAnimNotify_ToggleFlashlight) == 0x000008, "Wrong alignment on UAnimNotify_ToggleFlashlight");
static_assert(sizeof(UAnimNotify_ToggleFlashlight) == 0x000040, "Wrong size on UAnimNotify_ToggleFlashlight");

// Class Stalker2.AnimNotify_UnequipItemContextualAction
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_UnequipItemContextualAction final : public UAnimNotifyBase
{
public:
	EMainHandEquipmentType                        SlotToUnequip;                                     // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_UnequipItemContextualAction">();
	}
	static class UAnimNotify_UnequipItemContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_UnequipItemContextualAction>();
	}
};
static_assert(alignof(UAnimNotify_UnequipItemContextualAction) == 0x000008, "Wrong alignment on UAnimNotify_UnequipItemContextualAction");
static_assert(sizeof(UAnimNotify_UnequipItemContextualAction) == 0x000048, "Wrong size on UAnimNotify_UnequipItemContextualAction");
static_assert(offsetof(UAnimNotify_UnequipItemContextualAction, SlotToUnequip) == 0x000040, "Member 'UAnimNotify_UnequipItemContextualAction::SlotToUnequip' has a wrong offset!");

// Class Stalker2.ProjectileImpactEffectSubsystem
// 0x0058 (0x0088 - 0x0030)
class UProjectileImpactEffectSubsystem final : public UWorldSubsystem
{
public:
	TMap<uint32, struct FProjectileImpactFXData>  ImpactRequests;                                    // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileImpactEffectSubsystem">();
	}
	static class UProjectileImpactEffectSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileImpactEffectSubsystem>();
	}
};
static_assert(alignof(UProjectileImpactEffectSubsystem) == 0x000008, "Wrong alignment on UProjectileImpactEffectSubsystem");
static_assert(sizeof(UProjectileImpactEffectSubsystem) == 0x000088, "Wrong size on UProjectileImpactEffectSubsystem");
static_assert(offsetof(UProjectileImpactEffectSubsystem, ImpactRequests) == 0x000030, "Member 'UProjectileImpactEffectSubsystem::ImpactRequests' has a wrong offset!");

// Class Stalker2.AnimNotify_UpdateMagazineVisibililty
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_UpdateMagazineVisibililty final : public UAnimNotifyBase
{
public:
	bool                                          bShowMagazine;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachedMagazineType                         TargetAttachedMagazineType;                        // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUpdateSource                                 UpdateSource;                                      // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_UpdateMagazineVisibililty">();
	}
	static class UAnimNotify_UpdateMagazineVisibililty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_UpdateMagazineVisibililty>();
	}
};
static_assert(alignof(UAnimNotify_UpdateMagazineVisibililty) == 0x000008, "Wrong alignment on UAnimNotify_UpdateMagazineVisibililty");
static_assert(sizeof(UAnimNotify_UpdateMagazineVisibililty) == 0x000048, "Wrong size on UAnimNotify_UpdateMagazineVisibililty");
static_assert(offsetof(UAnimNotify_UpdateMagazineVisibililty, bShowMagazine) == 0x000040, "Member 'UAnimNotify_UpdateMagazineVisibililty::bShowMagazine' has a wrong offset!");
static_assert(offsetof(UAnimNotify_UpdateMagazineVisibililty, TargetAttachedMagazineType) == 0x000041, "Member 'UAnimNotify_UpdateMagazineVisibililty::TargetAttachedMagazineType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_UpdateMagazineVisibililty, UpdateSource) == 0x000042, "Member 'UAnimNotify_UpdateMagazineVisibililty::UpdateSource' has a wrong offset!");

// Class Stalker2.AnimNotify_UseConsumable
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_UseConsumable final : public UAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_UseConsumable">();
	}
	static class UAnimNotify_UseConsumable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_UseConsumable>();
	}
};
static_assert(alignof(UAnimNotify_UseConsumable) == 0x000008, "Wrong alignment on UAnimNotify_UseConsumable");
static_assert(sizeof(UAnimNotify_UseConsumable) == 0x000040, "Wrong size on UAnimNotify_UseConsumable");

// Class Stalker2.CreditsNamesWidget
// 0x0028 (0x02A0 - 0x0278)
class UCreditsNamesWidget final : public UUserWidget
{
public:
	class UVerticalBox*                           NamesVerticalBox;                                  // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCreditsName>               CreditsNameClass;                                  // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNameDisplaySettings                   NameDisplaySettings;                               // 0x0288(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreditsNamesWidget">();
	}
	static class UCreditsNamesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreditsNamesWidget>();
	}
};
static_assert(alignof(UCreditsNamesWidget) == 0x000008, "Wrong alignment on UCreditsNamesWidget");
static_assert(sizeof(UCreditsNamesWidget) == 0x0002A0, "Wrong size on UCreditsNamesWidget");
static_assert(offsetof(UCreditsNamesWidget, NamesVerticalBox) == 0x000278, "Member 'UCreditsNamesWidget::NamesVerticalBox' has a wrong offset!");
static_assert(offsetof(UCreditsNamesWidget, CreditsNameClass) == 0x000280, "Member 'UCreditsNamesWidget::CreditsNameClass' has a wrong offset!");
static_assert(offsetof(UCreditsNamesWidget, NameDisplaySettings) == 0x000288, "Member 'UCreditsNamesWidget::NameDisplaySettings' has a wrong offset!");

// Class Stalker2.AnimNotify_UseHandItem
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_UseHandItem final : public UAnimNotifyBase
{
public:
	EHandItem                                     HandItem;                                          // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_UseHandItem">();
	}
	static class UAnimNotify_UseHandItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_UseHandItem>();
	}
};
static_assert(alignof(UAnimNotify_UseHandItem) == 0x000008, "Wrong alignment on UAnimNotify_UseHandItem");
static_assert(sizeof(UAnimNotify_UseHandItem) == 0x000048, "Wrong size on UAnimNotify_UseHandItem");
static_assert(offsetof(UAnimNotify_UseHandItem, HandItem) == 0x000040, "Member 'UAnimNotify_UseHandItem::HandItem' has a wrong offset!");

// Class Stalker2.PressBuildControlSettingsWidget
// 0x0010 (0x0288 - 0x0278)
class UPressBuildControlSettingsWidget final : public UWidgetBase
{
public:
	class ULocalizedImage*                        Gamepad;                                           // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalizedImage*                        Keyboard;                                          // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PressBuildControlSettingsWidget">();
	}
	static class UPressBuildControlSettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPressBuildControlSettingsWidget>();
	}
};
static_assert(alignof(UPressBuildControlSettingsWidget) == 0x000008, "Wrong alignment on UPressBuildControlSettingsWidget");
static_assert(sizeof(UPressBuildControlSettingsWidget) == 0x000288, "Wrong size on UPressBuildControlSettingsWidget");
static_assert(offsetof(UPressBuildControlSettingsWidget, Gamepad) == 0x000278, "Member 'UPressBuildControlSettingsWidget::Gamepad' has a wrong offset!");
static_assert(offsetof(UPressBuildControlSettingsWidget, Keyboard) == 0x000280, "Member 'UPressBuildControlSettingsWidget::Keyboard' has a wrong offset!");

// Class Stalker2.AnimNotify_WeaponAction
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_WeaponAction final : public UAnimNotifyBase
{
public:
	EWeaponAction                                 WeaponAction;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTwinMagazineShift;                          // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShutterState                                 ForcedIdle;                                        // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackActionType                             AttachIdleType;                                    // 0x0043(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowBulletMeshes;                                  // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnlocked;                                        // 0x0045(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_WeaponAction">();
	}
	static class UAnimNotify_WeaponAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_WeaponAction>();
	}
};
static_assert(alignof(UAnimNotify_WeaponAction) == 0x000008, "Wrong alignment on UAnimNotify_WeaponAction");
static_assert(sizeof(UAnimNotify_WeaponAction) == 0x000048, "Wrong size on UAnimNotify_WeaponAction");
static_assert(offsetof(UAnimNotify_WeaponAction, WeaponAction) == 0x000040, "Member 'UAnimNotify_WeaponAction::WeaponAction' has a wrong offset!");
static_assert(offsetof(UAnimNotify_WeaponAction, bEnableTwinMagazineShift) == 0x000041, "Member 'UAnimNotify_WeaponAction::bEnableTwinMagazineShift' has a wrong offset!");
static_assert(offsetof(UAnimNotify_WeaponAction, ForcedIdle) == 0x000042, "Member 'UAnimNotify_WeaponAction::ForcedIdle' has a wrong offset!");
static_assert(offsetof(UAnimNotify_WeaponAction, AttachIdleType) == 0x000043, "Member 'UAnimNotify_WeaponAction::AttachIdleType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_WeaponAction, ShowBulletMeshes) == 0x000044, "Member 'UAnimNotify_WeaponAction::ShowBulletMeshes' has a wrong offset!");
static_assert(offsetof(UAnimNotify_WeaponAction, IsUnlocked) == 0x000045, "Member 'UAnimNotify_WeaponAction::IsUnlocked' has a wrong offset!");

// Class Stalker2.CooldownZonesController
// 0x0020 (0x02B8 - 0x0298)
class ACooldownZonesController final : public AActor
{
public:
	class UBoxComponent*                          ControllerVolume;                                  // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class ACooldownZone>>   CooldownZones;                                     // 0x02A0(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CooldownZonesController">();
	}
	static class ACooldownZonesController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACooldownZonesController>();
	}
};
static_assert(alignof(ACooldownZonesController) == 0x000008, "Wrong alignment on ACooldownZonesController");
static_assert(sizeof(ACooldownZonesController) == 0x0002B8, "Wrong size on ACooldownZonesController");
static_assert(offsetof(ACooldownZonesController, ControllerVolume) == 0x000298, "Member 'ACooldownZonesController::ControllerVolume' has a wrong offset!");
static_assert(offsetof(ACooldownZonesController, CooldownZones) == 0x0002A0, "Member 'ACooldownZonesController::CooldownZones' has a wrong offset!");

// Class Stalker2.AnimNotify_ZombieWeaponEquipState
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_ZombieWeaponEquipState final : public UAnimNotifyBase
{
public:
	bool                                          bEquipped;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldToggleHandIK;                               // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ZombieWeaponEquipState">();
	}
	static class UAnimNotify_ZombieWeaponEquipState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ZombieWeaponEquipState>();
	}
};
static_assert(alignof(UAnimNotify_ZombieWeaponEquipState) == 0x000008, "Wrong alignment on UAnimNotify_ZombieWeaponEquipState");
static_assert(sizeof(UAnimNotify_ZombieWeaponEquipState) == 0x000048, "Wrong size on UAnimNotify_ZombieWeaponEquipState");
static_assert(offsetof(UAnimNotify_ZombieWeaponEquipState, bEquipped) == 0x000040, "Member 'UAnimNotify_ZombieWeaponEquipState::bEquipped' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ZombieWeaponEquipState, bShouldToggleHandIK) == 0x000041, "Member 'UAnimNotify_ZombieWeaponEquipState::bShouldToggleHandIK' has a wrong offset!");

// Class Stalker2.SettingsElementPercent
// 0x0050 (0x1DD0 - 0x1D80)
class USettingsElementPercent : public USettingElement
{
public:
	uint8                                         Pad_1D80[0x18];                                    // 0x1D80(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x1D98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x1D9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinValue;                                          // 0x1DA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Step;                                              // 0x1DA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowPercentSign;                                  // 0x1DA8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DA9[0x7];                                     // 0x1DA9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatValueLocalisationPair            ReplacedValue;                                     // 0x1DB0(0x0020)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)

public:
	void SetValue(const float InValue, const bool bForce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsElementPercent">();
	}
	static class USettingsElementPercent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsElementPercent>();
	}
};
static_assert(alignof(USettingsElementPercent) == 0x000010, "Wrong alignment on USettingsElementPercent");
static_assert(sizeof(USettingsElementPercent) == 0x001DD0, "Wrong size on USettingsElementPercent");
static_assert(offsetof(USettingsElementPercent, Value) == 0x001D98, "Member 'USettingsElementPercent::Value' has a wrong offset!");
static_assert(offsetof(USettingsElementPercent, MaxValue) == 0x001D9C, "Member 'USettingsElementPercent::MaxValue' has a wrong offset!");
static_assert(offsetof(USettingsElementPercent, MinValue) == 0x001DA0, "Member 'USettingsElementPercent::MinValue' has a wrong offset!");
static_assert(offsetof(USettingsElementPercent, Step) == 0x001DA4, "Member 'USettingsElementPercent::Step' has a wrong offset!");
static_assert(offsetof(USettingsElementPercent, bShowPercentSign) == 0x001DA8, "Member 'USettingsElementPercent::bShowPercentSign' has a wrong offset!");
static_assert(offsetof(USettingsElementPercent, ReplacedValue) == 0x001DB0, "Member 'USettingsElementPercent::ReplacedValue' has a wrong offset!");

// Class Stalker2.CreditsSubView
// 0x0008 (0x02D8 - 0x02D0)
class UCreditsSubView final : public UMenuSubViewBase
{
public:
	class UCreditsWidget*                         CreditsWidget;                                     // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreditsSubView">();
	}
	static class UCreditsSubView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreditsSubView>();
	}
};
static_assert(alignof(UCreditsSubView) == 0x000008, "Wrong alignment on UCreditsSubView");
static_assert(sizeof(UCreditsSubView) == 0x0002D8, "Wrong size on UCreditsSubView");
static_assert(offsetof(UCreditsSubView, CreditsWidget) == 0x0002D0, "Member 'UCreditsSubView::CreditsWidget' has a wrong offset!");

// Class Stalker2.PassiveDetectorComponent
// 0x0040 (0x00E0 - 0x00A0)
class UPassiveDetectorComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRtpc*                                DangerLevelSoundParameter;                         // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          DetectorWorkSFX;                                   // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DetectorWorkCurve;                                 // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            SignalCurve;                                       // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PassiveDetectorComponent">();
	}
	static class UPassiveDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassiveDetectorComponent>();
	}
};
static_assert(alignof(UPassiveDetectorComponent) == 0x000008, "Wrong alignment on UPassiveDetectorComponent");
static_assert(sizeof(UPassiveDetectorComponent) == 0x0000E0, "Wrong size on UPassiveDetectorComponent");
static_assert(offsetof(UPassiveDetectorComponent, DangerLevelSoundParameter) == 0x0000A8, "Member 'UPassiveDetectorComponent::DangerLevelSoundParameter' has a wrong offset!");
static_assert(offsetof(UPassiveDetectorComponent, DetectorWorkSFX) == 0x0000B0, "Member 'UPassiveDetectorComponent::DetectorWorkSFX' has a wrong offset!");
static_assert(offsetof(UPassiveDetectorComponent, DetectorWorkCurve) == 0x0000B8, "Member 'UPassiveDetectorComponent::DetectorWorkCurve' has a wrong offset!");
static_assert(offsetof(UPassiveDetectorComponent, SignalCurve) == 0x0000C0, "Member 'UPassiveDetectorComponent::SignalCurve' has a wrong offset!");

// Class Stalker2.CustomConsoleManagerRK
// 0x0020 (0x00C8 - 0x00A8)
class UCustomConsoleManagerRK final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TransformUID(int32 UID);
	void XApplyEffectOnInteractNPC(const class FString& EffectPrototypeSID);
	void XApplyEffectOnNPCByUID(const class FString& EffectPrototypeSID, const int32 UID);
	void XApplyEffectOnPlayer(const class FString& EffectPrototypeSID);
	void XDisableFrictionForPlayerInBulb(bool bInDrawBulbDebug);
	void XDrawPsyFieldVolumes(bool bInDrawPsyField);
	void XIncreaseEnsuresLimit(int32 IncreaseLimit);
	void XSetGlobalBool(const class FString& SID, bool InValue);
	void XSetGlobalObjectPath(const class FString& SID, const class FString& InValue);
	void XSetPsyNPCFilterParams(const bool bIsPsyPhantom, const EAgentType AgentType1, const EAgentType AgentType2, const class FString& ObjPrototypeFilter1, const class FString& ObjPrototypeFilter2, const class FString& ObjPrototypeFilter3);
	void XSetWeatherLocked(const bool bNowLocked);
	void XSpawnPsyNPC(const bool bIsPsyPhantom, const class FString& ObjPrototypeSID, const ERank Rank, const int32 Count);
	void XStartBenchmark(float CameraHeight, float CircleRadius, float InitialPitch, float InitialYaw, int32 BenchRuns, bool bProfileCsv);
	void XStartGSCBackgroundProfiler(float MsecThreshold, float RamMBThreshold, uint32 InFramesToCaptureOnSpike, uint32 InFrameCountToComputeAverage);
	void XStopBenchmark();
	void XTeleportToObjUID(int32 ObjUID);
	void XToggleClickerJumpDebugMode();
	void XToggleDetailedVitalsStat(EVitalType VitalType);
	void XToggleDrawCurrentDiscounts();
	void XToggleDrawInteractNPCStats(const float ValueFontXSizeCoef, const float ValueFontYSizeCoef);
	void XToggleDrawPlayerStats(float ValueFontXSizeCoef, float ValueFontYSizeCoef);
	void XToggleFreeCamera();
	void XToggleHUDElements(EHUDElements ElementsToHide);
	void XToggleNPCFlashlight(int32 UID);
	void XTogglePlayerRadiationSphereVisibility();
	void XTogglePsyPhantomDebugMode();

	void XApplyUpgradeBySID(const class FString& ItemPrototypeSID, const class FString& UpgradePrototypeSID) const;
	void XCreateItemInInventoryByID(const class FString& PrototypeID, int32 ObjUID, int32 Count, float Durability) const;
	void XDealDamage(int32 TargetUID, float Damage, float ArmorDamage, float ArmorPiercing, float Bleeding, float BleedingChanceIncrement, EDamageType Type, const class FString& BoneHit) const;
	void XDealDurabilityDamage(int32 ItemUID, float DurabilityDamage) const;
	void XDisassemblyCurrentWeapon() const;
	void XFileExists(const class FString& FilePath) const;
	void XForceActorInteract(int32 ActorUID, int32 InteractableUID) const;
	void XModifyBleeding(int32 TargetUID, int32 AddBleeding) const;
	void XModifyStamina(int32 TargetUID, float FPSpent) const;
	void XObjRecalcAllCachedStats(int32 ObjUID) const;
	void XObjRecalcAllEquipment(int32 ObjUID) const;
	void XOpenDoor(int32 DoorUID) const;
	void XRevertUpgradeBySID(const class FString& ItemPrototypeSID, const class FString& UpgradePrototypeSID) const;
	void XSetFullGodMode(bool bGodMode) const;
	void XSetGodMode(bool bGodMode) const;
	void XSetGodModeForInteractObj(bool bGodMode) const;
	int32 XSpawnItemContainer(const class FString& PrototypeID, float Px, float Py, float Pz, int32 Gold, float Pitch, float Yaw, float Roll) const;
	void XSpawnObjBySID(const class FString& PrototypeSID, ERank Rank, bool bDestroyOnOffline, float Px, float Py, float Pz, float Pitch, float Yaw, float Roll) const;
	void XTeleportTo(float XCoord, float YCoord, float ZCoord) const;
	void XUnlockDoor(int32 DoorUID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerRK">();
	}
	static class UCustomConsoleManagerRK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerRK>();
	}
};
static_assert(alignof(UCustomConsoleManagerRK) == 0x000008, "Wrong alignment on UCustomConsoleManagerRK");
static_assert(sizeof(UCustomConsoleManagerRK) == 0x0000C8, "Wrong size on UCustomConsoleManagerRK");

// Class Stalker2.AnomalyDetectorComponent
// 0x0000 (0x00E0 - 0x00E0)
class UAnomalyDetectorComponent final : public UPassiveDetectorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnomalyDetectorComponent">();
	}
	static class UAnomalyDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnomalyDetectorComponent>();
	}
};
static_assert(alignof(UAnomalyDetectorComponent) == 0x000008, "Wrong alignment on UAnomalyDetectorComponent");
static_assert(sizeof(UAnomalyDetectorComponent) == 0x0000E0, "Wrong size on UAnomalyDetectorComponent");

// Class Stalker2.PauseMenuMainView
// 0x0000 (0x0338 - 0x0338)
class UPauseMenuMainView final : public UMenuMainViewBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseMenuMainView">();
	}
	static class UPauseMenuMainView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPauseMenuMainView>();
	}
};
static_assert(alignof(UPauseMenuMainView) == 0x000008, "Wrong alignment on UPauseMenuMainView");
static_assert(sizeof(UPauseMenuMainView) == 0x000338, "Wrong size on UPauseMenuMainView");

// Class Stalker2.AnomalyModelSpawner
// 0x0070 (0x0308 - 0x0298)
class AAnomalyModelSpawner final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrototypeSID                          PrototypeSID;                                      // 0x02C0(0x0040)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnOnBeginPlay;                                 // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnomalyModelSpawner">();
	}
	static class AAnomalyModelSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnomalyModelSpawner>();
	}
};
static_assert(alignof(AAnomalyModelSpawner) == 0x000008, "Wrong alignment on AAnomalyModelSpawner");
static_assert(sizeof(AAnomalyModelSpawner) == 0x000308, "Wrong size on AAnomalyModelSpawner");
static_assert(offsetof(AAnomalyModelSpawner, SceneComponent) == 0x0002A0, "Member 'AAnomalyModelSpawner::SceneComponent' has a wrong offset!");
static_assert(offsetof(AAnomalyModelSpawner, PrototypeSID) == 0x0002C0, "Member 'AAnomalyModelSpawner::PrototypeSID' has a wrong offset!");
static_assert(offsetof(AAnomalyModelSpawner, bSpawnOnBeginPlay) == 0x000300, "Member 'AAnomalyModelSpawner::bSpawnOnBeginPlay' has a wrong offset!");

// Class Stalker2.CrosshairWidgetBase
// 0x0050 (0x02C8 - 0x0278)
class UCrosshairWidgetBase : public UChildViewBase
{
public:
	float                                         DelayInterpol;                                     // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x14];                                     // 0x027C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       ShowCrosshairAnim;                                 // 0x0290(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HideCrosshairAnim;                                 // 0x0298(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableCrosshairAnimation;                         // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrosshairAnimationSpeed;                           // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x20];                                     // 0x02A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrosshairWidgetBase">();
	}
	static class UCrosshairWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrosshairWidgetBase>();
	}
};
static_assert(alignof(UCrosshairWidgetBase) == 0x000008, "Wrong alignment on UCrosshairWidgetBase");
static_assert(sizeof(UCrosshairWidgetBase) == 0x0002C8, "Wrong size on UCrosshairWidgetBase");
static_assert(offsetof(UCrosshairWidgetBase, DelayInterpol) == 0x000278, "Member 'UCrosshairWidgetBase::DelayInterpol' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetBase, ShowCrosshairAnim) == 0x000290, "Member 'UCrosshairWidgetBase::ShowCrosshairAnim' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetBase, HideCrosshairAnim) == 0x000298, "Member 'UCrosshairWidgetBase::HideCrosshairAnim' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetBase, bEnableCrosshairAnimation) == 0x0002A0, "Member 'UCrosshairWidgetBase::bEnableCrosshairAnimation' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetBase, CrosshairAnimationSpeed) == 0x0002A4, "Member 'UCrosshairWidgetBase::CrosshairAnimationSpeed' has a wrong offset!");

// Class Stalker2.CrosshairWidgetCross
// 0x0030 (0x02F8 - 0x02C8)
class UCrosshairWidgetCross final : public UCrosshairWidgetBase
{
public:
	float                                         shift;                                             // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDespersionLimit;                            // 0x02CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 DownLine;                                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeftLine;                                          // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RightLine;                                         // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 UpLine;                                            // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Point;                                             // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrosshairWidgetCross">();
	}
	static class UCrosshairWidgetCross* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrosshairWidgetCross>();
	}
};
static_assert(alignof(UCrosshairWidgetCross) == 0x000008, "Wrong alignment on UCrosshairWidgetCross");
static_assert(sizeof(UCrosshairWidgetCross) == 0x0002F8, "Wrong size on UCrosshairWidgetCross");
static_assert(offsetof(UCrosshairWidgetCross, shift) == 0x0002C8, "Member 'UCrosshairWidgetCross::shift' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetCross, bEnableDespersionLimit) == 0x0002CC, "Member 'UCrosshairWidgetCross::bEnableDespersionLimit' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetCross, DownLine) == 0x0002D0, "Member 'UCrosshairWidgetCross::DownLine' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetCross, LeftLine) == 0x0002D8, "Member 'UCrosshairWidgetCross::LeftLine' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetCross, RightLine) == 0x0002E0, "Member 'UCrosshairWidgetCross::RightLine' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetCross, UpLine) == 0x0002E8, "Member 'UCrosshairWidgetCross::UpLine' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetCross, Point) == 0x0002F0, "Member 'UCrosshairWidgetCross::Point' has a wrong offset!");

// Class Stalker2.ApplyEffectComponent
// 0x0018 (0x00B8 - 0x00A0)
class UApplyEffectComponent final : public UActorComponent
{
public:
	bool                                          bCanUseStackableEffects;                           // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInteractEffectData>            EffectsToApply;                                    // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void ApplyEffects();
	void RemoveEffects();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplyEffectComponent">();
	}
	static class UApplyEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplyEffectComponent>();
	}
};
static_assert(alignof(UApplyEffectComponent) == 0x000008, "Wrong alignment on UApplyEffectComponent");
static_assert(sizeof(UApplyEffectComponent) == 0x0000B8, "Wrong size on UApplyEffectComponent");
static_assert(offsetof(UApplyEffectComponent, bCanUseStackableEffects) == 0x0000A0, "Member 'UApplyEffectComponent::bCanUseStackableEffects' has a wrong offset!");
static_assert(offsetof(UApplyEffectComponent, EffectsToApply) == 0x0000A8, "Member 'UApplyEffectComponent::EffectsToApply' has a wrong offset!");

// Class Stalker2.ButtonBase
// 0x0048 (0x02C0 - 0x0278)
class UButtonBase : public UWidgetBase
{
public:
	TMulticastInlineDelegate<void(const class FName InButtonId)> OnButtonClicked;                    // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x20];                                     // 0x0288(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                Button;                                            // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEnableClick;                                // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEnableHover;                                // 0x02B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2[0x2];                                      // 0x02B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ButtonId;                                          // 0x02B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ButtonClicked();
	void ButtonPressed();
	void ButtonReleased();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonBase">();
	}
	static class UButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButtonBase>();
	}
};
static_assert(alignof(UButtonBase) == 0x000008, "Wrong alignment on UButtonBase");
static_assert(sizeof(UButtonBase) == 0x0002C0, "Wrong size on UButtonBase");
static_assert(offsetof(UButtonBase, OnButtonClicked) == 0x000278, "Member 'UButtonBase::OnButtonClicked' has a wrong offset!");
static_assert(offsetof(UButtonBase, Button) == 0x0002A8, "Member 'UButtonBase::Button' has a wrong offset!");
static_assert(offsetof(UButtonBase, bShouldEnableClick) == 0x0002B0, "Member 'UButtonBase::bShouldEnableClick' has a wrong offset!");
static_assert(offsetof(UButtonBase, bShouldEnableHover) == 0x0002B1, "Member 'UButtonBase::bShouldEnableHover' has a wrong offset!");
static_assert(offsetof(UButtonBase, ButtonId) == 0x0002B4, "Member 'UButtonBase::ButtonId' has a wrong offset!");

// Class Stalker2.PDAButtonBase
// 0x0060 (0x0320 - 0x02C0)
class UPDAButtonBase : public UButtonBase
{
public:
	class UImage*                                 Background;                                        // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BackgroundLeft;                                    // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BackgroundRight;                                   // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 NewPoint;                                          // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ButtonCollorEnable;                                // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ButtonCollorDisable;                               // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ButtonEnabledStyleId;                              // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ButtonDisabledStyleId;                             // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShoudHoverOpacity;                                // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoverOpacity;                                      // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnHoverOpacity;                                    // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldShowNewItem;                                // 0x031C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAButtonBase">();
	}
	static class UPDAButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAButtonBase>();
	}
};
static_assert(alignof(UPDAButtonBase) == 0x000008, "Wrong alignment on UPDAButtonBase");
static_assert(sizeof(UPDAButtonBase) == 0x000320, "Wrong size on UPDAButtonBase");
static_assert(offsetof(UPDAButtonBase, Background) == 0x0002C0, "Member 'UPDAButtonBase::Background' has a wrong offset!");
static_assert(offsetof(UPDAButtonBase, BackgroundLeft) == 0x0002C8, "Member 'UPDAButtonBase::BackgroundLeft' has a wrong offset!");
static_assert(offsetof(UPDAButtonBase, BackgroundRight) == 0x0002D0, "Member 'UPDAButtonBase::BackgroundRight' has a wrong offset!");
static_assert(offsetof(UPDAButtonBase, NewPoint) == 0x0002D8, "Member 'UPDAButtonBase::NewPoint' has a wrong offset!");
static_assert(offsetof(UPDAButtonBase, ButtonCollorEnable) == 0x0002E0, "Member 'UPDAButtonBase::ButtonCollorEnable' has a wrong offset!");
static_assert(offsetof(UPDAButtonBase, ButtonCollorDisable) == 0x0002F0, "Member 'UPDAButtonBase::ButtonCollorDisable' has a wrong offset!");
static_assert(offsetof(UPDAButtonBase, ButtonEnabledStyleId) == 0x000300, "Member 'UPDAButtonBase::ButtonEnabledStyleId' has a wrong offset!");
static_assert(offsetof(UPDAButtonBase, ButtonDisabledStyleId) == 0x000308, "Member 'UPDAButtonBase::ButtonDisabledStyleId' has a wrong offset!");
static_assert(offsetof(UPDAButtonBase, bShoudHoverOpacity) == 0x000310, "Member 'UPDAButtonBase::bShoudHoverOpacity' has a wrong offset!");
static_assert(offsetof(UPDAButtonBase, HoverOpacity) == 0x000314, "Member 'UPDAButtonBase::HoverOpacity' has a wrong offset!");
static_assert(offsetof(UPDAButtonBase, UnHoverOpacity) == 0x000318, "Member 'UPDAButtonBase::UnHoverOpacity' has a wrong offset!");
static_assert(offsetof(UPDAButtonBase, bShouldShowNewItem) == 0x00031C, "Member 'UPDAButtonBase::bShouldShowNewItem' has a wrong offset!");

// Class Stalker2.PDANotesButton
// 0x0020 (0x0340 - 0x0320)
class UPDANotesButton final : public UPDAButtonBase
{
public:
	class UImageWidget*                           ButtonIcon;                                        // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNoteFilterSettings                    FilterSettings;                                    // 0x0328(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ShouldEnableStailManager;                          // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDANotesButton">();
	}
	static class UPDANotesButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDANotesButton>();
	}
};
static_assert(alignof(UPDANotesButton) == 0x000008, "Wrong alignment on UPDANotesButton");
static_assert(sizeof(UPDANotesButton) == 0x000340, "Wrong size on UPDANotesButton");
static_assert(offsetof(UPDANotesButton, ButtonIcon) == 0x000320, "Member 'UPDANotesButton::ButtonIcon' has a wrong offset!");
static_assert(offsetof(UPDANotesButton, FilterSettings) == 0x000328, "Member 'UPDANotesButton::FilterSettings' has a wrong offset!");
static_assert(offsetof(UPDANotesButton, ShouldEnableStailManager) == 0x000330, "Member 'UPDANotesButton::ShouldEnableStailManager' has a wrong offset!");
static_assert(offsetof(UPDANotesButton, Icon) == 0x000338, "Member 'UPDANotesButton::Icon' has a wrong offset!");

// Class Stalker2.UIDActor_ItemContainer
// 0x0010 (0x02A8 - 0x0298)
class AUIDActor_ItemContainer : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActor_ItemContainer">();
	}
	static class AUIDActor_ItemContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDActor_ItemContainer>();
	}
};
static_assert(alignof(AUIDActor_ItemContainer) == 0x000008, "Wrong alignment on AUIDActor_ItemContainer");
static_assert(sizeof(AUIDActor_ItemContainer) == 0x0002A8, "Wrong size on AUIDActor_ItemContainer");

// Class Stalker2.CreditsImage
// 0x0008 (0x0280 - 0x0278)
class UCreditsImage final : public UUserWidget
{
public:
	class UImage*                                 Image;                                             // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreditsImage">();
	}
	static class UCreditsImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreditsImage>();
	}
};
static_assert(alignof(UCreditsImage) == 0x000008, "Wrong alignment on UCreditsImage");
static_assert(sizeof(UCreditsImage) == 0x000280, "Wrong size on UCreditsImage");
static_assert(offsetof(UCreditsImage, Image) == 0x000278, "Member 'UCreditsImage::Image' has a wrong offset!");

// Class Stalker2.Artifact
// 0x0158 (0x0400 - 0x02A8)
class AArtifact final : public AUIDActor_ItemContainer
{
public:
	uint8                                         Pad_2A8[0x20];                                     // 0x02A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SphereComponent;                                   // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      StrafeParticle;                                    // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArtifactInteractableComponent*         ArtifactInteractableComponent;                     // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsInteractionComponent*           PhysicsInteractionComponent;                       // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsSoundsComponent*                PhysicsSoundsComponent;                            // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDetectorRequired;                                 // 0x02F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F1[0x17];                                     // 0x02F1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ChargingEvent;                                     // 0x0308(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          JumpEvent;                                         // 0x0310(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          Sound;                                             // 0x0318(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          SoundStop;                                         // 0x0320(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          SoundStateTransitionOnHide;                        // 0x0328(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          SoundStateTransitionOnShow;                        // 0x0330(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         ArtifactTypeSwitchValue;                           // 0x0338(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFXSystemAsset*                         ParticleOnShow;                                    // 0x0340(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          FakeArtifactDistortionSound;                       // 0x0348(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFXSystemAsset*                         FakeArtifactDistortionVFX;                         // 0x0350(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          FakeArtifactDissolveSound;                         // 0x0358(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFXSystemAsset*                         FakeArtifactDissolveVFX;                           // 0x0360(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataLayerPhysicsComponent*             DataLayerPhysicsComponent;                         // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         ParticleStateTransitionFadeIn;                     // 0x0370(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         ParticleStateTransitionFadeOut;                    // 0x0378(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         ParticleOnImpact;                                  // 0x0380(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFXSystemAsset*                         FakeArtifactHaloVFX;                               // 0x0388(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x48];                                     // 0x0390(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemComponent*                     ActiveParticleOnShow;                              // 0x03D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFXSystemComponent*                     FakeParticleHalo;                                  // 0x03E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x18];                                     // 0x03E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Artifact">();
	}
	static class AArtifact* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArtifact>();
	}
};
static_assert(alignof(AArtifact) == 0x000008, "Wrong alignment on AArtifact");
static_assert(sizeof(AArtifact) == 0x000400, "Wrong size on AArtifact");
static_assert(offsetof(AArtifact, SphereComponent) == 0x0002C8, "Member 'AArtifact::SphereComponent' has a wrong offset!");
static_assert(offsetof(AArtifact, StrafeParticle) == 0x0002D0, "Member 'AArtifact::StrafeParticle' has a wrong offset!");
static_assert(offsetof(AArtifact, ArtifactInteractableComponent) == 0x0002D8, "Member 'AArtifact::ArtifactInteractableComponent' has a wrong offset!");
static_assert(offsetof(AArtifact, PhysicsInteractionComponent) == 0x0002E0, "Member 'AArtifact::PhysicsInteractionComponent' has a wrong offset!");
static_assert(offsetof(AArtifact, PhysicsSoundsComponent) == 0x0002E8, "Member 'AArtifact::PhysicsSoundsComponent' has a wrong offset!");
static_assert(offsetof(AArtifact, bDetectorRequired) == 0x0002F0, "Member 'AArtifact::bDetectorRequired' has a wrong offset!");
static_assert(offsetof(AArtifact, ChargingEvent) == 0x000308, "Member 'AArtifact::ChargingEvent' has a wrong offset!");
static_assert(offsetof(AArtifact, JumpEvent) == 0x000310, "Member 'AArtifact::JumpEvent' has a wrong offset!");
static_assert(offsetof(AArtifact, Sound) == 0x000318, "Member 'AArtifact::Sound' has a wrong offset!");
static_assert(offsetof(AArtifact, SoundStop) == 0x000320, "Member 'AArtifact::SoundStop' has a wrong offset!");
static_assert(offsetof(AArtifact, SoundStateTransitionOnHide) == 0x000328, "Member 'AArtifact::SoundStateTransitionOnHide' has a wrong offset!");
static_assert(offsetof(AArtifact, SoundStateTransitionOnShow) == 0x000330, "Member 'AArtifact::SoundStateTransitionOnShow' has a wrong offset!");
static_assert(offsetof(AArtifact, ArtifactTypeSwitchValue) == 0x000338, "Member 'AArtifact::ArtifactTypeSwitchValue' has a wrong offset!");
static_assert(offsetof(AArtifact, ParticleOnShow) == 0x000340, "Member 'AArtifact::ParticleOnShow' has a wrong offset!");
static_assert(offsetof(AArtifact, FakeArtifactDistortionSound) == 0x000348, "Member 'AArtifact::FakeArtifactDistortionSound' has a wrong offset!");
static_assert(offsetof(AArtifact, FakeArtifactDistortionVFX) == 0x000350, "Member 'AArtifact::FakeArtifactDistortionVFX' has a wrong offset!");
static_assert(offsetof(AArtifact, FakeArtifactDissolveSound) == 0x000358, "Member 'AArtifact::FakeArtifactDissolveSound' has a wrong offset!");
static_assert(offsetof(AArtifact, FakeArtifactDissolveVFX) == 0x000360, "Member 'AArtifact::FakeArtifactDissolveVFX' has a wrong offset!");
static_assert(offsetof(AArtifact, DataLayerPhysicsComponent) == 0x000368, "Member 'AArtifact::DataLayerPhysicsComponent' has a wrong offset!");
static_assert(offsetof(AArtifact, ParticleStateTransitionFadeIn) == 0x000370, "Member 'AArtifact::ParticleStateTransitionFadeIn' has a wrong offset!");
static_assert(offsetof(AArtifact, ParticleStateTransitionFadeOut) == 0x000378, "Member 'AArtifact::ParticleStateTransitionFadeOut' has a wrong offset!");
static_assert(offsetof(AArtifact, ParticleOnImpact) == 0x000380, "Member 'AArtifact::ParticleOnImpact' has a wrong offset!");
static_assert(offsetof(AArtifact, FakeArtifactHaloVFX) == 0x000388, "Member 'AArtifact::FakeArtifactHaloVFX' has a wrong offset!");
static_assert(offsetof(AArtifact, ActiveParticleOnShow) == 0x0003D8, "Member 'AArtifact::ActiveParticleOnShow' has a wrong offset!");
static_assert(offsetof(AArtifact, FakeParticleHalo) == 0x0003E0, "Member 'AArtifact::FakeParticleHalo' has a wrong offset!");

// Class Stalker2.ArtifactInteractableComponent
// 0x0000 (0x01F8 - 0x01F8)
class UArtifactInteractableComponent final : public USingleClickComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactInteractableComponent">();
	}
	static class UArtifactInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtifactInteractableComponent>();
	}
};
static_assert(alignof(UArtifactInteractableComponent) == 0x000008, "Wrong alignment on UArtifactInteractableComponent");
static_assert(sizeof(UArtifactInteractableComponent) == 0x0001F8, "Wrong size on UArtifactInteractableComponent");

// Class Stalker2.NicknameWidget
// 0x0018 (0x0290 - 0x0278)
class UNicknameWidget final : public UWidgetBase
{
public:
	class UTextWidget*                            Greeting;                                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            Nickname;                                          // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicknameWidget">();
	}
	static class UNicknameWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicknameWidget>();
	}
};
static_assert(alignof(UNicknameWidget) == 0x000008, "Wrong alignment on UNicknameWidget");
static_assert(sizeof(UNicknameWidget) == 0x000290, "Wrong size on UNicknameWidget");
static_assert(offsetof(UNicknameWidget, Greeting) == 0x000278, "Member 'UNicknameWidget::Greeting' has a wrong offset!");
static_assert(offsetof(UNicknameWidget, Nickname) == 0x000280, "Member 'UNicknameWidget::Nickname' has a wrong offset!");

// Class Stalker2.CurrentMainViewIndicator
// 0x0418 (0x0690 - 0x0278)
class UCurrentMainViewIndicator final : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTextSettings                          TextSettings;                                      // 0x0280(0x03C0)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class UTextWidget*                            MainViewText;                                      // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MainMenuSID;                                       // 0x0648(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PauseMenuSID;                                      // 0x0658(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GameOverMenuSID;                                   // 0x0668(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 UndefinedMenuSID;                                  // 0x0678(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrentMainViewIndicator">();
	}
	static class UCurrentMainViewIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurrentMainViewIndicator>();
	}
};
static_assert(alignof(UCurrentMainViewIndicator) == 0x000010, "Wrong alignment on UCurrentMainViewIndicator");
static_assert(sizeof(UCurrentMainViewIndicator) == 0x000690, "Wrong size on UCurrentMainViewIndicator");
static_assert(offsetof(UCurrentMainViewIndicator, TextSettings) == 0x000280, "Member 'UCurrentMainViewIndicator::TextSettings' has a wrong offset!");
static_assert(offsetof(UCurrentMainViewIndicator, MainViewText) == 0x000640, "Member 'UCurrentMainViewIndicator::MainViewText' has a wrong offset!");
static_assert(offsetof(UCurrentMainViewIndicator, MainMenuSID) == 0x000648, "Member 'UCurrentMainViewIndicator::MainMenuSID' has a wrong offset!");
static_assert(offsetof(UCurrentMainViewIndicator, PauseMenuSID) == 0x000658, "Member 'UCurrentMainViewIndicator::PauseMenuSID' has a wrong offset!");
static_assert(offsetof(UCurrentMainViewIndicator, GameOverMenuSID) == 0x000668, "Member 'UCurrentMainViewIndicator::GameOverMenuSID' has a wrong offset!");
static_assert(offsetof(UCurrentMainViewIndicator, UndefinedMenuSID) == 0x000678, "Member 'UCurrentMainViewIndicator::UndefinedMenuSID' has a wrong offset!");

// Class Stalker2.ArtifactSpawnerActivationComponent
// 0x0000 (0x00A0 - 0x00A0)
class UArtifactSpawnerActivationComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactSpawnerActivationComponent">();
	}
	static class UArtifactSpawnerActivationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtifactSpawnerActivationComponent>();
	}
};
static_assert(alignof(UArtifactSpawnerActivationComponent) == 0x000008, "Wrong alignment on UArtifactSpawnerActivationComponent");
static_assert(sizeof(UArtifactSpawnerActivationComponent) == 0x0000A0, "Wrong size on UArtifactSpawnerActivationComponent");

// Class Stalker2.ArtifactStrafeBehaviourComponent
// 0x0088 (0x0128 - 0x00A0)
class UArtifactStrafeBehaviourComponent final : public UActorComponent
{
public:
	bool                                          bHasScheduledJump;                                 // 0x00A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeTillJump;                                      // 0x00A4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x78];                                      // 0x00A8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OuterRadiusJumpChance;                             // 0x0120(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnotherAnomalyJumpChance;                          // 0x0124(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactStrafeBehaviourComponent">();
	}
	static class UArtifactStrafeBehaviourComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtifactStrafeBehaviourComponent>();
	}
};
static_assert(alignof(UArtifactStrafeBehaviourComponent) == 0x000008, "Wrong alignment on UArtifactStrafeBehaviourComponent");
static_assert(sizeof(UArtifactStrafeBehaviourComponent) == 0x000128, "Wrong size on UArtifactStrafeBehaviourComponent");
static_assert(offsetof(UArtifactStrafeBehaviourComponent, bHasScheduledJump) == 0x0000A0, "Member 'UArtifactStrafeBehaviourComponent::bHasScheduledJump' has a wrong offset!");
static_assert(offsetof(UArtifactStrafeBehaviourComponent, TimeTillJump) == 0x0000A4, "Member 'UArtifactStrafeBehaviourComponent::TimeTillJump' has a wrong offset!");
static_assert(offsetof(UArtifactStrafeBehaviourComponent, OuterRadiusJumpChance) == 0x000120, "Member 'UArtifactStrafeBehaviourComponent::OuterRadiusJumpChance' has a wrong offset!");
static_assert(offsetof(UArtifactStrafeBehaviourComponent, AnotherAnomalyJumpChance) == 0x000124, "Member 'UArtifactStrafeBehaviourComponent::AnotherAnomalyJumpChance' has a wrong offset!");

// Class Stalker2.SettingsElementResolutionSwitcher
// 0x0040 (0x1DC0 - 0x1D80)
class USettingsElementResolutionSwitcher final : public USettingElement
{
public:
	uint8                                         Pad_1D80[0x40];                                    // 0x1D80(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsElementResolutionSwitcher">();
	}
	static class USettingsElementResolutionSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsElementResolutionSwitcher>();
	}
};
static_assert(alignof(USettingsElementResolutionSwitcher) == 0x000010, "Wrong alignment on USettingsElementResolutionSwitcher");
static_assert(sizeof(USettingsElementResolutionSwitcher) == 0x001DC0, "Wrong size on USettingsElementResolutionSwitcher");

// Class Stalker2.AsyncHintBox
// 0x0038 (0x02B0 - 0x0278)
class UAsyncHintBox final : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpaceBetweenHints;                                 // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHorizontalBox*                         HorizontalBox;                                     // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHintControllerBase*>            LegendButtonList;                                  // 0x02A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncHintBox">();
	}
	static class UAsyncHintBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncHintBox>();
	}
};
static_assert(alignof(UAsyncHintBox) == 0x000008, "Wrong alignment on UAsyncHintBox");
static_assert(sizeof(UAsyncHintBox) == 0x0002B0, "Wrong size on UAsyncHintBox");
static_assert(offsetof(UAsyncHintBox, SpaceBetweenHints) == 0x000290, "Member 'UAsyncHintBox::SpaceBetweenHints' has a wrong offset!");
static_assert(offsetof(UAsyncHintBox, HorizontalBox) == 0x000298, "Member 'UAsyncHintBox::HorizontalBox' has a wrong offset!");
static_assert(offsetof(UAsyncHintBox, LegendButtonList) == 0x0002A0, "Member 'UAsyncHintBox::LegendButtonList' has a wrong offset!");

// Class Stalker2.PDARegionPanel
// 0x0030 (0x02A8 - 0x0278)
class UPDARegionPanel final : public UChildViewBase
{
public:
	class UProgressBar*                           Progress;                                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            RegionText;                                        // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ActiveColor;                                       // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DisactiveColor;                                    // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDARegionPanel">();
	}
	static class UPDARegionPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDARegionPanel>();
	}
};
static_assert(alignof(UPDARegionPanel) == 0x000008, "Wrong alignment on UPDARegionPanel");
static_assert(sizeof(UPDARegionPanel) == 0x0002A8, "Wrong size on UPDARegionPanel");
static_assert(offsetof(UPDARegionPanel, Progress) == 0x000278, "Member 'UPDARegionPanel::Progress' has a wrong offset!");
static_assert(offsetof(UPDARegionPanel, RegionText) == 0x000280, "Member 'UPDARegionPanel::RegionText' has a wrong offset!");
static_assert(offsetof(UPDARegionPanel, ActiveColor) == 0x000288, "Member 'UPDARegionPanel::ActiveColor' has a wrong offset!");
static_assert(offsetof(UPDARegionPanel, DisactiveColor) == 0x000298, "Member 'UPDARegionPanel::DisactiveColor' has a wrong offset!");

// Class Stalker2.AsyncMixin
// 0x0000 (0x0000 - 0x0000)
class IAsyncMixin final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncMixin">();
	}
	static class IAsyncMixin* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAsyncMixin>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAsyncMixin) == 0x000001, "Wrong alignment on IAsyncMixin");
static_assert(sizeof(IAsyncMixin) == 0x000001, "Wrong size on IAsyncMixin");

// Class Stalker2.UIDActor_DestructibleObject
// 0x0010 (0x02A8 - 0x0298)
class AUIDActor_DestructibleObject : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActor_DestructibleObject">();
	}
	static class AUIDActor_DestructibleObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDActor_DestructibleObject>();
	}
};
static_assert(alignof(AUIDActor_DestructibleObject) == 0x000008, "Wrong alignment on AUIDActor_DestructibleObject");
static_assert(sizeof(AUIDActor_DestructibleObject) == 0x0002A8, "Wrong size on AUIDActor_DestructibleObject");

// Class Stalker2.DestructibleObject
// 0x0118 (0x03C0 - 0x02A8)
class ADestructibleObject final : public AUIDActor_DestructibleObject
{
public:
	uint8                                         Pad_2A8[0x48];                                     // 0x02A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsInteractionComponent*           PhysicsInteractionComponent;                       // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsSoundsComponent*                PhysicsSoundsComponent;                            // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UExplosionComponent*                    ExplosionComponent;                                // 0x0308(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHittableComponent*                     HittableComponent;                                 // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataLayerPhysicsComponent*             DataLayerPhysicsComponent;                         // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x50];                                     // 0x0320(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, EDataLayerRuntimeState>     NeededLayers;                                      // 0x0370(0x0050)(NativeAccessSpecifierPublic)

public:
	void GSCFramework_OnPostTransition();
	void GSCFramework_OnPreTransition(const struct FHitResult& HitResult);
	void OnDataLayersUpdated(const class UDataLayerInstance* DataLayer, EDataLayerRuntimeState State);
	void OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void StartDestructActions();
	void TryAdjustPosition();

	int32 GetCurrentPhaseIndex() const;
	const struct FObjectPhaseSettings GSCFramework_GetCurrentPhase() const;
	const TArray<struct FObjectPhaseSettings> GSCFramework_GetObjectPhases() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleObject">();
	}
	static class ADestructibleObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADestructibleObject>();
	}
};
static_assert(alignof(ADestructibleObject) == 0x000008, "Wrong alignment on ADestructibleObject");
static_assert(sizeof(ADestructibleObject) == 0x0003C0, "Wrong size on ADestructibleObject");
static_assert(offsetof(ADestructibleObject, PhysicsInteractionComponent) == 0x0002F0, "Member 'ADestructibleObject::PhysicsInteractionComponent' has a wrong offset!");
static_assert(offsetof(ADestructibleObject, PhysicsSoundsComponent) == 0x0002F8, "Member 'ADestructibleObject::PhysicsSoundsComponent' has a wrong offset!");
static_assert(offsetof(ADestructibleObject, StaticMeshComponent) == 0x000300, "Member 'ADestructibleObject::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ADestructibleObject, ExplosionComponent) == 0x000308, "Member 'ADestructibleObject::ExplosionComponent' has a wrong offset!");
static_assert(offsetof(ADestructibleObject, HittableComponent) == 0x000310, "Member 'ADestructibleObject::HittableComponent' has a wrong offset!");
static_assert(offsetof(ADestructibleObject, DataLayerPhysicsComponent) == 0x000318, "Member 'ADestructibleObject::DataLayerPhysicsComponent' has a wrong offset!");
static_assert(offsetof(ADestructibleObject, NeededLayers) == 0x000370, "Member 'ADestructibleObject::NeededLayers' has a wrong offset!");

// Class Stalker2.AttachSelectorIPU
// 0x0000 (0x0058 - 0x0058)
class UAttachSelectorIPU final : public UBehaviorBasedIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachSelectorIPU">();
	}
	static class UAttachSelectorIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachSelectorIPU>();
	}
};
static_assert(alignof(UAttachSelectorIPU) == 0x000008, "Wrong alignment on UAttachSelectorIPU");
static_assert(sizeof(UAttachSelectorIPU) == 0x000058, "Wrong size on UAttachSelectorIPU");

// Class Stalker2.BookViewBase
// 0x0018 (0x02E0 - 0x02C8)
class UBookViewBase : public UViewBaseExtended
{
public:
	int32                                         DefaultPageIndex;                                  // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldOpenDefaultPage;                            // 0x02CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEnableNavigation;                           // 0x02CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEnableClick;                                // 0x02CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CF[0x1];                                      // 0x02CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        Switcher;                                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNavigationPanel*                       NavigationPanel;                                   // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeSelectButton();
	void ClickMenuButton(int32 InButtonIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BookViewBase">();
	}
	static class UBookViewBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBookViewBase>();
	}
};
static_assert(alignof(UBookViewBase) == 0x000008, "Wrong alignment on UBookViewBase");
static_assert(sizeof(UBookViewBase) == 0x0002E0, "Wrong size on UBookViewBase");
static_assert(offsetof(UBookViewBase, DefaultPageIndex) == 0x0002C8, "Member 'UBookViewBase::DefaultPageIndex' has a wrong offset!");
static_assert(offsetof(UBookViewBase, bShouldOpenDefaultPage) == 0x0002CC, "Member 'UBookViewBase::bShouldOpenDefaultPage' has a wrong offset!");
static_assert(offsetof(UBookViewBase, bShouldEnableNavigation) == 0x0002CD, "Member 'UBookViewBase::bShouldEnableNavigation' has a wrong offset!");
static_assert(offsetof(UBookViewBase, bShouldEnableClick) == 0x0002CE, "Member 'UBookViewBase::bShouldEnableClick' has a wrong offset!");
static_assert(offsetof(UBookViewBase, Switcher) == 0x0002D0, "Member 'UBookViewBase::Switcher' has a wrong offset!");
static_assert(offsetof(UBookViewBase, NavigationPanel) == 0x0002D8, "Member 'UBookViewBase::NavigationPanel' has a wrong offset!");

// Class Stalker2.PDAView
// 0x0070 (0x0350 - 0x02E0)
class UPDAView final : public UBookViewBase
{
public:
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               Container;                                         // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDATimePanel*                          TimeWidget;                                        // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDARegionPanel*                        RegionWidget;                                      // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       PDAFadeOutAnimation;                               // 0x0308(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       PDAFadeInAnimation;                                // 0x0310(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSholdShowInput;                                   // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PDATurnOnTimer;                                    // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x30];                                     // 0x0320(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseUpdateView();
	void HideAllWindows();
	void UpdateQuestList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAView">();
	}
	static class UPDAView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAView>();
	}
};
static_assert(alignof(UPDAView) == 0x000008, "Wrong alignment on UPDAView");
static_assert(sizeof(UPDAView) == 0x000350, "Wrong size on UPDAView");
static_assert(offsetof(UPDAView, Container) == 0x0002F0, "Member 'UPDAView::Container' has a wrong offset!");
static_assert(offsetof(UPDAView, TimeWidget) == 0x0002F8, "Member 'UPDAView::TimeWidget' has a wrong offset!");
static_assert(offsetof(UPDAView, RegionWidget) == 0x000300, "Member 'UPDAView::RegionWidget' has a wrong offset!");
static_assert(offsetof(UPDAView, PDAFadeOutAnimation) == 0x000308, "Member 'UPDAView::PDAFadeOutAnimation' has a wrong offset!");
static_assert(offsetof(UPDAView, PDAFadeInAnimation) == 0x000310, "Member 'UPDAView::PDAFadeInAnimation' has a wrong offset!");
static_assert(offsetof(UPDAView, bSholdShowInput) == 0x000318, "Member 'UPDAView::bSholdShowInput' has a wrong offset!");
static_assert(offsetof(UPDAView, PDATurnOnTimer) == 0x00031C, "Member 'UPDAView::PDATurnOnTimer' has a wrong offset!");

// Class Stalker2.AttachSelectorSelectUnselectIPU
// 0x0008 (0x0048 - 0x0040)
class UAttachSelectorSelectUnselectIPU final : public UInputProcessingUnit
{
public:
	class UInputTrigger*                          TriggerWithBiggestTime;                            // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachSelectorSelectUnselectIPU">();
	}
	static class UAttachSelectorSelectUnselectIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachSelectorSelectUnselectIPU>();
	}
};
static_assert(alignof(UAttachSelectorSelectUnselectIPU) == 0x000008, "Wrong alignment on UAttachSelectorSelectUnselectIPU");
static_assert(sizeof(UAttachSelectorSelectUnselectIPU) == 0x000048, "Wrong size on UAttachSelectorSelectUnselectIPU");
static_assert(offsetof(UAttachSelectorSelectUnselectIPU, TriggerWithBiggestTime) == 0x000040, "Member 'UAttachSelectorSelectUnselectIPU::TriggerWithBiggestTime' has a wrong offset!");

// Class Stalker2.WeatherController
// 0x03F0 (0x0688 - 0x0298)
class AWeatherController final : public AActor
{
public:
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentRainIntensity;                              // 0x02B0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentWetnessState;                               // 0x02B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x78];                                     // 0x02B8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultRoot;                                       // 0x0330(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   SkySphere;                                         // 0x0338(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               SkySphereMID;                                      // 0x0340(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             Sun;                                               // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkyLightComponent*                     SkyLight;                                          // 0x0350(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkyAtmosphereComponent*                SkyAtmosphere;                                     // 0x0358(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVolumetricCloudComponent*              VolumetricCloud;                                   // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               CloudsMID;                                         // 0x0368(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UExponentialHeightFogComponent*         ExponentialHeightFog;                              // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveLinearColor*                      SunPositionCurve;                                  // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalVolumetricValue;                             // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalVolumetricValue;                              // 0x0384(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      Rain;                                              // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPostProcessComponent*                  PostProcess;                                       // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           EnvironmentMPC;                                    // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollectionInstance*   EnvironmentMPCInstance;                            // 0x03A0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                WetnessSoundParameter;                             // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                WindIntensitySoundParameter;                       // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          WeatherSound;                                      // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                RainIntensitySoundParameter;                       // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                DaytimeSoundParameter;                             // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                RazorWeatherFeedbackRTPC;                          // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeatherParameterNamesDataAsset*        WeatherParameterNamesDataAsset;                    // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UWeatherPresetDataAsset>> WeatherPresets;                            // 0x03E0(0x0010)(Edit, EditFixedSize, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     VolumetricCloudMaterial;                           // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SkySphereMaterial;                                 // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemoveKeyTolerance;                                // 0x0400(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SolarTime;                                         // 0x0404(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentWeatherDuration;                            // 0x0408(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequestedWeatherDuration;                          // 0x040C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionDuration;                                // 0x0410(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeatherTransitionTimeMultiplier;                   // 0x0414(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeatherChangeSpeed;                                // 0x0418(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeather                                      SourceWeather;                                     // 0x041C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeather                                      TargetWeather;                                     // 0x041D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41E[0x2];                                      // 0x041E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeatherHistoryData>            WeatherHistory;                                    // 0x0420(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x2C];                                     // 0x0430(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkySphereEmissive;                                 // 0x045C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SkySphereZenithColor;                              // 0x0460(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SkySphereHorizonColor;                             // 0x0470(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartSunRiseTime;                                  // 0x0480(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndSunRiseTime;                                    // 0x0484(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartSunSetTime;                                   // 0x0488(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndSunSetTime;                                     // 0x048C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShadowStepDaylight;                                // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowStepMoonlight;                               // 0x04A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x10];                                     // 0x04A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SimulationSpeed;                                   // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimulationDuration;                                // 0x04BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentSimulationDuration;                         // 0x04C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C4[0x4];                                      // 0x04C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrototypeSID                          SelectionPrototypeSID;                             // 0x04C8(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindIntensity;                                     // 0x0508(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterWindNormalMultiplier;                         // 0x050C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CloudShift;                                        // 0x0510(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterShift;                                        // 0x0520(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudShiftStep;                                    // 0x0524(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindDirectionChangeDelay;                          // 0x0528(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissionWindDirectionChangeDelay;                  // 0x052C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindDirectionChangeMinAngle;                       // 0x0530(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindDirectionChangeMaxAngle;                       // 0x0534(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_538[0x4];                                      // 0x0538(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShadowAmount;                                      // 0x053C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonOpacity;                                       // 0x0540(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower;                                        // 0x0544(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeatherPresetDataAsset*                SourcePreset;                                      // 0x0548(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeatherPresetDataAsset*                TargetPreset;                                      // 0x0550(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_558[0x10];                                     // 0x0558(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWind                                  Wind;                                              // 0x0568(0x0070)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0xB0];                                     // 0x05D8(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherController">();
	}
	static class AWeatherController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeatherController>();
	}
};
static_assert(alignof(AWeatherController) == 0x000008, "Wrong alignment on AWeatherController");
static_assert(sizeof(AWeatherController) == 0x000688, "Wrong size on AWeatherController");
static_assert(offsetof(AWeatherController, CurrentRainIntensity) == 0x0002B0, "Member 'AWeatherController::CurrentRainIntensity' has a wrong offset!");
static_assert(offsetof(AWeatherController, CurrentWetnessState) == 0x0002B4, "Member 'AWeatherController::CurrentWetnessState' has a wrong offset!");
static_assert(offsetof(AWeatherController, DefaultRoot) == 0x000330, "Member 'AWeatherController::DefaultRoot' has a wrong offset!");
static_assert(offsetof(AWeatherController, SkySphere) == 0x000338, "Member 'AWeatherController::SkySphere' has a wrong offset!");
static_assert(offsetof(AWeatherController, SkySphereMID) == 0x000340, "Member 'AWeatherController::SkySphereMID' has a wrong offset!");
static_assert(offsetof(AWeatherController, Sun) == 0x000348, "Member 'AWeatherController::Sun' has a wrong offset!");
static_assert(offsetof(AWeatherController, SkyLight) == 0x000350, "Member 'AWeatherController::SkyLight' has a wrong offset!");
static_assert(offsetof(AWeatherController, SkyAtmosphere) == 0x000358, "Member 'AWeatherController::SkyAtmosphere' has a wrong offset!");
static_assert(offsetof(AWeatherController, VolumetricCloud) == 0x000360, "Member 'AWeatherController::VolumetricCloud' has a wrong offset!");
static_assert(offsetof(AWeatherController, CloudsMID) == 0x000368, "Member 'AWeatherController::CloudsMID' has a wrong offset!");
static_assert(offsetof(AWeatherController, ExponentialHeightFog) == 0x000370, "Member 'AWeatherController::ExponentialHeightFog' has a wrong offset!");
static_assert(offsetof(AWeatherController, SunPositionCurve) == 0x000378, "Member 'AWeatherController::SunPositionCurve' has a wrong offset!");
static_assert(offsetof(AWeatherController, GlobalVolumetricValue) == 0x000380, "Member 'AWeatherController::GlobalVolumetricValue' has a wrong offset!");
static_assert(offsetof(AWeatherController, LocalVolumetricValue) == 0x000384, "Member 'AWeatherController::LocalVolumetricValue' has a wrong offset!");
static_assert(offsetof(AWeatherController, Rain) == 0x000388, "Member 'AWeatherController::Rain' has a wrong offset!");
static_assert(offsetof(AWeatherController, PostProcess) == 0x000390, "Member 'AWeatherController::PostProcess' has a wrong offset!");
static_assert(offsetof(AWeatherController, EnvironmentMPC) == 0x000398, "Member 'AWeatherController::EnvironmentMPC' has a wrong offset!");
static_assert(offsetof(AWeatherController, EnvironmentMPCInstance) == 0x0003A0, "Member 'AWeatherController::EnvironmentMPCInstance' has a wrong offset!");
static_assert(offsetof(AWeatherController, WetnessSoundParameter) == 0x0003A8, "Member 'AWeatherController::WetnessSoundParameter' has a wrong offset!");
static_assert(offsetof(AWeatherController, WindIntensitySoundParameter) == 0x0003B0, "Member 'AWeatherController::WindIntensitySoundParameter' has a wrong offset!");
static_assert(offsetof(AWeatherController, WeatherSound) == 0x0003B8, "Member 'AWeatherController::WeatherSound' has a wrong offset!");
static_assert(offsetof(AWeatherController, RainIntensitySoundParameter) == 0x0003C0, "Member 'AWeatherController::RainIntensitySoundParameter' has a wrong offset!");
static_assert(offsetof(AWeatherController, DaytimeSoundParameter) == 0x0003C8, "Member 'AWeatherController::DaytimeSoundParameter' has a wrong offset!");
static_assert(offsetof(AWeatherController, RazorWeatherFeedbackRTPC) == 0x0003D0, "Member 'AWeatherController::RazorWeatherFeedbackRTPC' has a wrong offset!");
static_assert(offsetof(AWeatherController, WeatherParameterNamesDataAsset) == 0x0003D8, "Member 'AWeatherController::WeatherParameterNamesDataAsset' has a wrong offset!");
static_assert(offsetof(AWeatherController, WeatherPresets) == 0x0003E0, "Member 'AWeatherController::WeatherPresets' has a wrong offset!");
static_assert(offsetof(AWeatherController, VolumetricCloudMaterial) == 0x0003F0, "Member 'AWeatherController::VolumetricCloudMaterial' has a wrong offset!");
static_assert(offsetof(AWeatherController, SkySphereMaterial) == 0x0003F8, "Member 'AWeatherController::SkySphereMaterial' has a wrong offset!");
static_assert(offsetof(AWeatherController, RemoveKeyTolerance) == 0x000400, "Member 'AWeatherController::RemoveKeyTolerance' has a wrong offset!");
static_assert(offsetof(AWeatherController, SolarTime) == 0x000404, "Member 'AWeatherController::SolarTime' has a wrong offset!");
static_assert(offsetof(AWeatherController, CurrentWeatherDuration) == 0x000408, "Member 'AWeatherController::CurrentWeatherDuration' has a wrong offset!");
static_assert(offsetof(AWeatherController, RequestedWeatherDuration) == 0x00040C, "Member 'AWeatherController::RequestedWeatherDuration' has a wrong offset!");
static_assert(offsetof(AWeatherController, TransitionDuration) == 0x000410, "Member 'AWeatherController::TransitionDuration' has a wrong offset!");
static_assert(offsetof(AWeatherController, WeatherTransitionTimeMultiplier) == 0x000414, "Member 'AWeatherController::WeatherTransitionTimeMultiplier' has a wrong offset!");
static_assert(offsetof(AWeatherController, WeatherChangeSpeed) == 0x000418, "Member 'AWeatherController::WeatherChangeSpeed' has a wrong offset!");
static_assert(offsetof(AWeatherController, SourceWeather) == 0x00041C, "Member 'AWeatherController::SourceWeather' has a wrong offset!");
static_assert(offsetof(AWeatherController, TargetWeather) == 0x00041D, "Member 'AWeatherController::TargetWeather' has a wrong offset!");
static_assert(offsetof(AWeatherController, WeatherHistory) == 0x000420, "Member 'AWeatherController::WeatherHistory' has a wrong offset!");
static_assert(offsetof(AWeatherController, SkySphereEmissive) == 0x00045C, "Member 'AWeatherController::SkySphereEmissive' has a wrong offset!");
static_assert(offsetof(AWeatherController, SkySphereZenithColor) == 0x000460, "Member 'AWeatherController::SkySphereZenithColor' has a wrong offset!");
static_assert(offsetof(AWeatherController, SkySphereHorizonColor) == 0x000470, "Member 'AWeatherController::SkySphereHorizonColor' has a wrong offset!");
static_assert(offsetof(AWeatherController, StartSunRiseTime) == 0x000480, "Member 'AWeatherController::StartSunRiseTime' has a wrong offset!");
static_assert(offsetof(AWeatherController, EndSunRiseTime) == 0x000484, "Member 'AWeatherController::EndSunRiseTime' has a wrong offset!");
static_assert(offsetof(AWeatherController, StartSunSetTime) == 0x000488, "Member 'AWeatherController::StartSunSetTime' has a wrong offset!");
static_assert(offsetof(AWeatherController, EndSunSetTime) == 0x00048C, "Member 'AWeatherController::EndSunSetTime' has a wrong offset!");
static_assert(offsetof(AWeatherController, ShadowStepDaylight) == 0x0004A0, "Member 'AWeatherController::ShadowStepDaylight' has a wrong offset!");
static_assert(offsetof(AWeatherController, ShadowStepMoonlight) == 0x0004A4, "Member 'AWeatherController::ShadowStepMoonlight' has a wrong offset!");
static_assert(offsetof(AWeatherController, SimulationSpeed) == 0x0004B8, "Member 'AWeatherController::SimulationSpeed' has a wrong offset!");
static_assert(offsetof(AWeatherController, SimulationDuration) == 0x0004BC, "Member 'AWeatherController::SimulationDuration' has a wrong offset!");
static_assert(offsetof(AWeatherController, CurrentSimulationDuration) == 0x0004C0, "Member 'AWeatherController::CurrentSimulationDuration' has a wrong offset!");
static_assert(offsetof(AWeatherController, SelectionPrototypeSID) == 0x0004C8, "Member 'AWeatherController::SelectionPrototypeSID' has a wrong offset!");
static_assert(offsetof(AWeatherController, WindIntensity) == 0x000508, "Member 'AWeatherController::WindIntensity' has a wrong offset!");
static_assert(offsetof(AWeatherController, WaterWindNormalMultiplier) == 0x00050C, "Member 'AWeatherController::WaterWindNormalMultiplier' has a wrong offset!");
static_assert(offsetof(AWeatherController, CloudShift) == 0x000510, "Member 'AWeatherController::CloudShift' has a wrong offset!");
static_assert(offsetof(AWeatherController, WaterShift) == 0x000520, "Member 'AWeatherController::WaterShift' has a wrong offset!");
static_assert(offsetof(AWeatherController, CloudShiftStep) == 0x000524, "Member 'AWeatherController::CloudShiftStep' has a wrong offset!");
static_assert(offsetof(AWeatherController, WindDirectionChangeDelay) == 0x000528, "Member 'AWeatherController::WindDirectionChangeDelay' has a wrong offset!");
static_assert(offsetof(AWeatherController, EmissionWindDirectionChangeDelay) == 0x00052C, "Member 'AWeatherController::EmissionWindDirectionChangeDelay' has a wrong offset!");
static_assert(offsetof(AWeatherController, WindDirectionChangeMinAngle) == 0x000530, "Member 'AWeatherController::WindDirectionChangeMinAngle' has a wrong offset!");
static_assert(offsetof(AWeatherController, WindDirectionChangeMaxAngle) == 0x000534, "Member 'AWeatherController::WindDirectionChangeMaxAngle' has a wrong offset!");
static_assert(offsetof(AWeatherController, ShadowAmount) == 0x00053C, "Member 'AWeatherController::ShadowAmount' has a wrong offset!");
static_assert(offsetof(AWeatherController, MoonOpacity) == 0x000540, "Member 'AWeatherController::MoonOpacity' has a wrong offset!");
static_assert(offsetof(AWeatherController, ColorPower) == 0x000544, "Member 'AWeatherController::ColorPower' has a wrong offset!");
static_assert(offsetof(AWeatherController, SourcePreset) == 0x000548, "Member 'AWeatherController::SourcePreset' has a wrong offset!");
static_assert(offsetof(AWeatherController, TargetPreset) == 0x000550, "Member 'AWeatherController::TargetPreset' has a wrong offset!");
static_assert(offsetof(AWeatherController, Wind) == 0x000568, "Member 'AWeatherController::Wind' has a wrong offset!");

// Class Stalker2.AttachSelectorSlot
// 0x0148 (0x03C0 - 0x0278)
class UAttachSelectorSlot final : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x30];                                     // 0x0278(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SlotSize;                                          // 0x02A8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlotDirection                                SlotDirection;                                     // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x17];                                     // 0x02B9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UImageWidget*                           AttachIcon;                                        // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                AttachButton;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 AttachBackground;                                  // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 DeactivateBackground;                              // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 AttachBackgroundHighlighted;                       // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 AttachBackgroundSelected;                          // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        AttachWidgetSwitcher;                              // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImageWidget*                           DefaultAttachIcon;                                 // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImageWidget*                           SelectedAttachIcon;                                // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AttachSlotIndex;                                   // 0x0318(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DetachSlotIndex;                                   // 0x031C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DefaultSlotIndex;                                  // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_324[0xC];                                      // 0x0324(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UAttachSelectorTip*                     SelectorTip;                                       // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAttachSlotState                              AttachSlotState;                                   // 0x0338(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         SlotStateFlagEditorOnly;                           // 0x0339(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33A[0x2];                                      // 0x033A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisabledOpacity;                                   // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SelectedHighlightedOpacity;                        // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FilledOpacity;                                     // 0x0344(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EmptyOpacity;                                      // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DetachHighlightIconScale;                          // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Shake;                                             // 0x0360(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       MoveRight;                                         // 0x0368(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       MoveLeft;                                          // 0x0370(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       MoveUp;                                            // 0x0378(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       MoveDown;                                          // 0x0380(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       MoveDownLeft;                                      // 0x0388(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       MoveDownRight;                                     // 0x0390(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       MoveUpRight;                                       // 0x0398(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       MoveUpLeft;                                        // 0x03A0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Select;                                            // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x10];                                     // 0x03B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonHover();
	void OnUnhoverSlot();
	void SelectAndEquipAttach();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachSelectorSlot">();
	}
	static class UAttachSelectorSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachSelectorSlot>();
	}
};
static_assert(alignof(UAttachSelectorSlot) == 0x000008, "Wrong alignment on UAttachSelectorSlot");
static_assert(sizeof(UAttachSelectorSlot) == 0x0003C0, "Wrong size on UAttachSelectorSlot");
static_assert(offsetof(UAttachSelectorSlot, SlotSize) == 0x0002A8, "Member 'UAttachSelectorSlot::SlotSize' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, SlotDirection) == 0x0002B8, "Member 'UAttachSelectorSlot::SlotDirection' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, AttachIcon) == 0x0002D0, "Member 'UAttachSelectorSlot::AttachIcon' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, AttachButton) == 0x0002D8, "Member 'UAttachSelectorSlot::AttachButton' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, AttachBackground) == 0x0002E0, "Member 'UAttachSelectorSlot::AttachBackground' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, DeactivateBackground) == 0x0002E8, "Member 'UAttachSelectorSlot::DeactivateBackground' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, AttachBackgroundHighlighted) == 0x0002F0, "Member 'UAttachSelectorSlot::AttachBackgroundHighlighted' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, AttachBackgroundSelected) == 0x0002F8, "Member 'UAttachSelectorSlot::AttachBackgroundSelected' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, AttachWidgetSwitcher) == 0x000300, "Member 'UAttachSelectorSlot::AttachWidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, DefaultAttachIcon) == 0x000308, "Member 'UAttachSelectorSlot::DefaultAttachIcon' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, SelectedAttachIcon) == 0x000310, "Member 'UAttachSelectorSlot::SelectedAttachIcon' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, AttachSlotIndex) == 0x000318, "Member 'UAttachSelectorSlot::AttachSlotIndex' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, DetachSlotIndex) == 0x00031C, "Member 'UAttachSelectorSlot::DetachSlotIndex' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, DefaultSlotIndex) == 0x000320, "Member 'UAttachSelectorSlot::DefaultSlotIndex' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, SelectorTip) == 0x000330, "Member 'UAttachSelectorSlot::SelectorTip' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, AttachSlotState) == 0x000338, "Member 'UAttachSelectorSlot::AttachSlotState' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, SlotStateFlagEditorOnly) == 0x000339, "Member 'UAttachSelectorSlot::SlotStateFlagEditorOnly' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, DisabledOpacity) == 0x00033C, "Member 'UAttachSelectorSlot::DisabledOpacity' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, SelectedHighlightedOpacity) == 0x000340, "Member 'UAttachSelectorSlot::SelectedHighlightedOpacity' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, FilledOpacity) == 0x000344, "Member 'UAttachSelectorSlot::FilledOpacity' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, EmptyOpacity) == 0x000348, "Member 'UAttachSelectorSlot::EmptyOpacity' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, DetachHighlightIconScale) == 0x000350, "Member 'UAttachSelectorSlot::DetachHighlightIconScale' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, Shake) == 0x000360, "Member 'UAttachSelectorSlot::Shake' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, MoveRight) == 0x000368, "Member 'UAttachSelectorSlot::MoveRight' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, MoveLeft) == 0x000370, "Member 'UAttachSelectorSlot::MoveLeft' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, MoveUp) == 0x000378, "Member 'UAttachSelectorSlot::MoveUp' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, MoveDown) == 0x000380, "Member 'UAttachSelectorSlot::MoveDown' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, MoveDownLeft) == 0x000388, "Member 'UAttachSelectorSlot::MoveDownLeft' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, MoveDownRight) == 0x000390, "Member 'UAttachSelectorSlot::MoveDownRight' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, MoveUpRight) == 0x000398, "Member 'UAttachSelectorSlot::MoveUpRight' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, MoveUpLeft) == 0x0003A0, "Member 'UAttachSelectorSlot::MoveUpLeft' has a wrong offset!");
static_assert(offsetof(UAttachSelectorSlot, Select) == 0x0003A8, "Member 'UAttachSelectorSlot::Select' has a wrong offset!");

// Class Stalker2.AttachSelectorTip
// 0x0020 (0x0298 - 0x0278)
class UAttachSelectorTip final : public UWidgetBase
{
public:
	class UTextWidget*                            Text;                                              // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TipPadding;                                        // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUniformGridSlot*                       ParentGridSlot;                                    // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           ParentPanelWidget;                                 // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Hide();
	void Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachSelectorTip">();
	}
	static class UAttachSelectorTip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachSelectorTip>();
	}
};
static_assert(alignof(UAttachSelectorTip) == 0x000008, "Wrong alignment on UAttachSelectorTip");
static_assert(sizeof(UAttachSelectorTip) == 0x000298, "Wrong size on UAttachSelectorTip");
static_assert(offsetof(UAttachSelectorTip, Text) == 0x000278, "Member 'UAttachSelectorTip::Text' has a wrong offset!");
static_assert(offsetof(UAttachSelectorTip, TipPadding) == 0x000280, "Member 'UAttachSelectorTip::TipPadding' has a wrong offset!");
static_assert(offsetof(UAttachSelectorTip, ParentGridSlot) == 0x000288, "Member 'UAttachSelectorTip::ParentGridSlot' has a wrong offset!");
static_assert(offsetof(UAttachSelectorTip, ParentPanelWidget) == 0x000290, "Member 'UAttachSelectorTip::ParentPanelWidget' has a wrong offset!");

// Class Stalker2.SimpleAxisIPU
// 0x00A0 (0x00E0 - 0x0040)
class USimpleAxisIPU final : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0xA0];                                      // 0x0040(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleAxisIPU">();
	}
	static class USimpleAxisIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleAxisIPU>();
	}
};
static_assert(alignof(USimpleAxisIPU) == 0x000008, "Wrong alignment on USimpleAxisIPU");
static_assert(sizeof(USimpleAxisIPU) == 0x0000E0, "Wrong size on USimpleAxisIPU");

// Class Stalker2.DialogDoFComponent
// 0x0018 (0x0040 - 0x0028)
class UDialogDoFComponent final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AWeatherController>      WeatherController;                                 // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UWorld>                  CachedWorld;                                       // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogDoFComponent">();
	}
	static class UDialogDoFComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogDoFComponent>();
	}
};
static_assert(alignof(UDialogDoFComponent) == 0x000008, "Wrong alignment on UDialogDoFComponent");
static_assert(sizeof(UDialogDoFComponent) == 0x000040, "Wrong size on UDialogDoFComponent");
static_assert(offsetof(UDialogDoFComponent, WeatherController) == 0x000030, "Member 'UDialogDoFComponent::WeatherController' has a wrong offset!");
static_assert(offsetof(UDialogDoFComponent, CachedWorld) == 0x000038, "Member 'UDialogDoFComponent::CachedWorld' has a wrong offset!");

// Class Stalker2.CoverUtilitiesBPFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UCoverUtilitiesBPFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverUtilitiesBPFunctionLibrary">();
	}
	static class UCoverUtilitiesBPFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverUtilitiesBPFunctionLibrary>();
	}
};
static_assert(alignof(UCoverUtilitiesBPFunctionLibrary) == 0x000008, "Wrong alignment on UCoverUtilitiesBPFunctionLibrary");
static_assert(sizeof(UCoverUtilitiesBPFunctionLibrary) == 0x000028, "Wrong size on UCoverUtilitiesBPFunctionLibrary");

// Class Stalker2.AttachSelectorView
// 0x00F0 (0x03B8 - 0x02C8)
class UAttachSelectorView final : public UViewBaseExtended
{
public:
	class UUniformGridPanel*                      SlotGridPanel;                                     // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAttachSelectorTip*                     AttachSelectorTip;                                 // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAttachSelectorSlot*>            LeftSlots;                                         // 0x02D8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAttachSelectorSlot*>            RightSlots;                                        // 0x02E8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAttachSelectorSlot*>            UpSlots;                                           // 0x02F8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAttachSelectorSlot*>            DownSlots;                                         // 0x0308(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAttachSelectorSlot*>            AllSlots;                                          // 0x0318(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x40];                                     // 0x0328(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FastChangeSlotTime;                                // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAttachSelectorSlot*                    DetachSlot;                                        // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESlotDirection                                CurrentChooseLine;                                 // 0x0378(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IndexCurrentSelectedSlot;                          // 0x037C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAttachSelectorSlot*                    SelectedSlot;                                      // 0x0380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAttachSelectorSlot*                    LastHoveredAttach;                                 // 0x03A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESlotDirection                                LastTriggeredDirection;                            // 0x03A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A9[0xF];                                      // 0x03A9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachSelectorDetachAll();
	void AttachSelectorSlotDown();
	void AttachSelectorSlotLeft();
	void AttachSelectorSlotRight();
	void AttachSelectorSlotSelect();
	void AttachSelectorSlotUp();
	void DetachAllAttachByDirection();
	void SetCurrentChooseLine(const ESlotDirection InCurrentChooseLine);
	void UIIterateDownSlots();
	void UIIterateLeftSlots();
	void UIIterateRightSlots();
	void UIIterateUpSlots();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachSelectorView">();
	}
	static class UAttachSelectorView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachSelectorView>();
	}
};
static_assert(alignof(UAttachSelectorView) == 0x000008, "Wrong alignment on UAttachSelectorView");
static_assert(sizeof(UAttachSelectorView) == 0x0003B8, "Wrong size on UAttachSelectorView");
static_assert(offsetof(UAttachSelectorView, SlotGridPanel) == 0x0002C8, "Member 'UAttachSelectorView::SlotGridPanel' has a wrong offset!");
static_assert(offsetof(UAttachSelectorView, AttachSelectorTip) == 0x0002D0, "Member 'UAttachSelectorView::AttachSelectorTip' has a wrong offset!");
static_assert(offsetof(UAttachSelectorView, LeftSlots) == 0x0002D8, "Member 'UAttachSelectorView::LeftSlots' has a wrong offset!");
static_assert(offsetof(UAttachSelectorView, RightSlots) == 0x0002E8, "Member 'UAttachSelectorView::RightSlots' has a wrong offset!");
static_assert(offsetof(UAttachSelectorView, UpSlots) == 0x0002F8, "Member 'UAttachSelectorView::UpSlots' has a wrong offset!");
static_assert(offsetof(UAttachSelectorView, DownSlots) == 0x000308, "Member 'UAttachSelectorView::DownSlots' has a wrong offset!");
static_assert(offsetof(UAttachSelectorView, AllSlots) == 0x000318, "Member 'UAttachSelectorView::AllSlots' has a wrong offset!");
static_assert(offsetof(UAttachSelectorView, FastChangeSlotTime) == 0x000368, "Member 'UAttachSelectorView::FastChangeSlotTime' has a wrong offset!");
static_assert(offsetof(UAttachSelectorView, DetachSlot) == 0x000370, "Member 'UAttachSelectorView::DetachSlot' has a wrong offset!");
static_assert(offsetof(UAttachSelectorView, CurrentChooseLine) == 0x000378, "Member 'UAttachSelectorView::CurrentChooseLine' has a wrong offset!");
static_assert(offsetof(UAttachSelectorView, IndexCurrentSelectedSlot) == 0x00037C, "Member 'UAttachSelectorView::IndexCurrentSelectedSlot' has a wrong offset!");
static_assert(offsetof(UAttachSelectorView, SelectedSlot) == 0x000380, "Member 'UAttachSelectorView::SelectedSlot' has a wrong offset!");
static_assert(offsetof(UAttachSelectorView, LastHoveredAttach) == 0x0003A0, "Member 'UAttachSelectorView::LastHoveredAttach' has a wrong offset!");
static_assert(offsetof(UAttachSelectorView, LastTriggeredDirection) == 0x0003A8, "Member 'UAttachSelectorView::LastTriggeredDirection' has a wrong offset!");

// Class Stalker2.PDAQuestDescription
// 0x0050 (0x02C8 - 0x0278)
class UPDAQuestDescription final : public UChildViewBase
{
public:
	class UTextWidget*                            DescriptionText;                                   // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScrollBox*                             DescriptionContainer;                              // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHoverIllumination;                          // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScrollSpeed;                                       // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsHovered)> OnHoverDescription;                              // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FLinearColor                           HoverScrollColor;                                  // 0x02A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           UnHoverScrollColor;                                // 0x02B0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAQuestDescription">();
	}
	static class UPDAQuestDescription* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAQuestDescription>();
	}
};
static_assert(alignof(UPDAQuestDescription) == 0x000008, "Wrong alignment on UPDAQuestDescription");
static_assert(sizeof(UPDAQuestDescription) == 0x0002C8, "Wrong size on UPDAQuestDescription");
static_assert(offsetof(UPDAQuestDescription, DescriptionText) == 0x000278, "Member 'UPDAQuestDescription::DescriptionText' has a wrong offset!");
static_assert(offsetof(UPDAQuestDescription, DescriptionContainer) == 0x000280, "Member 'UPDAQuestDescription::DescriptionContainer' has a wrong offset!");
static_assert(offsetof(UPDAQuestDescription, bEnableHoverIllumination) == 0x000288, "Member 'UPDAQuestDescription::bEnableHoverIllumination' has a wrong offset!");
static_assert(offsetof(UPDAQuestDescription, ScrollSpeed) == 0x00028C, "Member 'UPDAQuestDescription::ScrollSpeed' has a wrong offset!");
static_assert(offsetof(UPDAQuestDescription, OnHoverDescription) == 0x000290, "Member 'UPDAQuestDescription::OnHoverDescription' has a wrong offset!");
static_assert(offsetof(UPDAQuestDescription, HoverScrollColor) == 0x0002A0, "Member 'UPDAQuestDescription::HoverScrollColor' has a wrong offset!");
static_assert(offsetof(UPDAQuestDescription, UnHoverScrollColor) == 0x0002B0, "Member 'UPDAQuestDescription::UnHoverScrollColor' has a wrong offset!");

// Class Stalker2.AttackComponent
// 0x0070 (0x0110 - 0x00A0)
class UAttackComponent final : public UActorComponent
{
public:
	EAttackActionType                             ActiveState;                                       // 0x00A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x6F];                                      // 0x00A1(0x006F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackComponent">();
	}
	static class UAttackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackComponent>();
	}
};
static_assert(alignof(UAttackComponent) == 0x000008, "Wrong alignment on UAttackComponent");
static_assert(sizeof(UAttackComponent) == 0x000110, "Wrong size on UAttackComponent");
static_assert(offsetof(UAttackComponent, ActiveState) == 0x0000A0, "Member 'UAttackComponent::ActiveState' has a wrong offset!");

// Class Stalker2.AudioRoomBakedReflectionComponent
// 0x0008 (0x00A8 - 0x00A0)
class UAudioRoomBakedReflectionComponent final : public UActorComponent
{
public:
	class UAkSwitchValue*                         AudioRoomBakedReflection;                          // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioRoomBakedReflectionComponent">();
	}
	static class UAudioRoomBakedReflectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioRoomBakedReflectionComponent>();
	}
};
static_assert(alignof(UAudioRoomBakedReflectionComponent) == 0x000008, "Wrong alignment on UAudioRoomBakedReflectionComponent");
static_assert(sizeof(UAudioRoomBakedReflectionComponent) == 0x0000A8, "Wrong size on UAudioRoomBakedReflectionComponent");
static_assert(offsetof(UAudioRoomBakedReflectionComponent, AudioRoomBakedReflection) == 0x0000A0, "Member 'UAudioRoomBakedReflectionComponent::AudioRoomBakedReflection' has a wrong offset!");

// Class Stalker2.NavArea_Door
// 0x0000 (0x0048 - 0x0048)
class UNavArea_Door final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Door">();
	}
	static class UNavArea_Door* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Door>();
	}
};
static_assert(alignof(UNavArea_Door) == 0x000008, "Wrong alignment on UNavArea_Door");
static_assert(sizeof(UNavArea_Door) == 0x000048, "Wrong size on UNavArea_Door");

// Class Stalker2.AudioRoomBandwidthComponent
// 0x0008 (0x00A8 - 0x00A0)
class UAudioRoomBandwidthComponent final : public UActorComponent
{
public:
	class UAkStateValue*                          AudioRoomBandwidth;                                // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioRoomBandwidthComponent">();
	}
	static class UAudioRoomBandwidthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioRoomBandwidthComponent>();
	}
};
static_assert(alignof(UAudioRoomBandwidthComponent) == 0x000008, "Wrong alignment on UAudioRoomBandwidthComponent");
static_assert(sizeof(UAudioRoomBandwidthComponent) == 0x0000A8, "Wrong size on UAudioRoomBandwidthComponent");
static_assert(offsetof(UAudioRoomBandwidthComponent, AudioRoomBandwidth) == 0x0000A0, "Member 'UAudioRoomBandwidthComponent::AudioRoomBandwidth' has a wrong offset!");

// Class Stalker2.CustomConsoleManager
// 0x0018 (0x00C0 - 0x00A8)
class UCustomConsoleManager final : public UBaseConsoleManager
{
public:
	TArray<class UBaseConsoleManager*>            PersonalConsoleManagers;                           // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExecuteScripts(const TArray<class FString>& ScriptArray);
	void XExecuteAdditionalScript(const class FString& ScriptKeyName);
	void XExecuteFromFile(const class FString& PathToFile);
	void XRunEngineCommand(const class FString& Command);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManager">();
	}
	static class UCustomConsoleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManager>();
	}
};
static_assert(alignof(UCustomConsoleManager) == 0x000008, "Wrong alignment on UCustomConsoleManager");
static_assert(sizeof(UCustomConsoleManager) == 0x0000C0, "Wrong size on UCustomConsoleManager");
static_assert(offsetof(UCustomConsoleManager, PersonalConsoleManagers) == 0x0000A8, "Member 'UCustomConsoleManager::PersonalConsoleManagers' has a wrong offset!");

// Class Stalker2.AudioScattererDataAsset
// 0x0028 (0x0058 - 0x0030)
class UAudioScattererDataAsset final : public UDataAsset
{
public:
	class UTileBitmapAdapter*                     TileBitmap;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldTopLeftCoords;                                // 0x0038(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldWidth;                                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldHeight;                                       // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioScattererDataAsset">();
	}
	static class UAudioScattererDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioScattererDataAsset>();
	}
};
static_assert(alignof(UAudioScattererDataAsset) == 0x000008, "Wrong alignment on UAudioScattererDataAsset");
static_assert(sizeof(UAudioScattererDataAsset) == 0x000058, "Wrong size on UAudioScattererDataAsset");
static_assert(offsetof(UAudioScattererDataAsset, TileBitmap) == 0x000030, "Member 'UAudioScattererDataAsset::TileBitmap' has a wrong offset!");
static_assert(offsetof(UAudioScattererDataAsset, WorldTopLeftCoords) == 0x000038, "Member 'UAudioScattererDataAsset::WorldTopLeftCoords' has a wrong offset!");
static_assert(offsetof(UAudioScattererDataAsset, WorldWidth) == 0x000050, "Member 'UAudioScattererDataAsset::WorldWidth' has a wrong offset!");
static_assert(offsetof(UAudioScattererDataAsset, WorldHeight) == 0x000054, "Member 'UAudioScattererDataAsset::WorldHeight' has a wrong offset!");

// Class Stalker2.AudioSettingsWidget
// 0x0068 (0x02F8 - 0x0290)
class UAudioSettingsWidget final : public USettingsPage
{
public:
	class USettingsElementPercent*                MainVolume;                                        // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USettingElementOnOff*                   MuteAllVolume;                                     // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USettingsElementPercent*                MusicVolume;                                       // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USettingElementOnOff*                   PlayMusicInCombat;                                 // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USettingsElementPercent*                DialogueVolume;                                    // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USettingsElementPercent*                EffectsVolume;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USettingElementSwitcher*                AudioOutputDeviceId;                               // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USettingElementSwitcher*                TypeOfSoundDevice;                                 // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USettingElementOnOff*                   ForceMono;                                         // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USettingElementSwitcher*                DynamicRange;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USettingElementOnOff*                   HelmetEffects;                                     // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 DefaultAudioDeviceLocalizedSID;                    // 0x02E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioSettingsWidget">();
	}
	static class UAudioSettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioSettingsWidget>();
	}
};
static_assert(alignof(UAudioSettingsWidget) == 0x000008, "Wrong alignment on UAudioSettingsWidget");
static_assert(sizeof(UAudioSettingsWidget) == 0x0002F8, "Wrong size on UAudioSettingsWidget");
static_assert(offsetof(UAudioSettingsWidget, MainVolume) == 0x000290, "Member 'UAudioSettingsWidget::MainVolume' has a wrong offset!");
static_assert(offsetof(UAudioSettingsWidget, MuteAllVolume) == 0x000298, "Member 'UAudioSettingsWidget::MuteAllVolume' has a wrong offset!");
static_assert(offsetof(UAudioSettingsWidget, MusicVolume) == 0x0002A0, "Member 'UAudioSettingsWidget::MusicVolume' has a wrong offset!");
static_assert(offsetof(UAudioSettingsWidget, PlayMusicInCombat) == 0x0002A8, "Member 'UAudioSettingsWidget::PlayMusicInCombat' has a wrong offset!");
static_assert(offsetof(UAudioSettingsWidget, DialogueVolume) == 0x0002B0, "Member 'UAudioSettingsWidget::DialogueVolume' has a wrong offset!");
static_assert(offsetof(UAudioSettingsWidget, EffectsVolume) == 0x0002B8, "Member 'UAudioSettingsWidget::EffectsVolume' has a wrong offset!");
static_assert(offsetof(UAudioSettingsWidget, AudioOutputDeviceId) == 0x0002C0, "Member 'UAudioSettingsWidget::AudioOutputDeviceId' has a wrong offset!");
static_assert(offsetof(UAudioSettingsWidget, TypeOfSoundDevice) == 0x0002C8, "Member 'UAudioSettingsWidget::TypeOfSoundDevice' has a wrong offset!");
static_assert(offsetof(UAudioSettingsWidget, ForceMono) == 0x0002D0, "Member 'UAudioSettingsWidget::ForceMono' has a wrong offset!");
static_assert(offsetof(UAudioSettingsWidget, DynamicRange) == 0x0002D8, "Member 'UAudioSettingsWidget::DynamicRange' has a wrong offset!");
static_assert(offsetof(UAudioSettingsWidget, HelmetEffects) == 0x0002E0, "Member 'UAudioSettingsWidget::HelmetEffects' has a wrong offset!");
static_assert(offsetof(UAudioSettingsWidget, DefaultAudioDeviceLocalizedSID) == 0x0002E8, "Member 'UAudioSettingsWidget::DefaultAudioDeviceLocalizedSID' has a wrong offset!");

// Class Stalker2.PlayerThrowableItemAnimCollection
// 0x0318 (0x0340 - 0x0028)
class UPlayerThrowableItemAnimCollection final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerThrowableItemInternalAnimations InternalAnimations;                                // 0x0030(0x00C0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FPlayerWeaponAnimations                WeaponAnimations;                                  // 0x00F0(0x0230)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCharacterWeaponAnimations             ToggleFlashlight;                                  // 0x0320(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerThrowableItemAnimCollection">();
	}
	static class UPlayerThrowableItemAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerThrowableItemAnimCollection>();
	}
};
static_assert(alignof(UPlayerThrowableItemAnimCollection) == 0x000008, "Wrong alignment on UPlayerThrowableItemAnimCollection");
static_assert(sizeof(UPlayerThrowableItemAnimCollection) == 0x000340, "Wrong size on UPlayerThrowableItemAnimCollection");
static_assert(offsetof(UPlayerThrowableItemAnimCollection, InternalAnimations) == 0x000030, "Member 'UPlayerThrowableItemAnimCollection::InternalAnimations' has a wrong offset!");
static_assert(offsetof(UPlayerThrowableItemAnimCollection, WeaponAnimations) == 0x0000F0, "Member 'UPlayerThrowableItemAnimCollection::WeaponAnimations' has a wrong offset!");
static_assert(offsetof(UPlayerThrowableItemAnimCollection, ToggleFlashlight) == 0x000320, "Member 'UPlayerThrowableItemAnimCollection::ToggleFlashlight' has a wrong offset!");

// Class Stalker2.AutoInteractionComponent
// 0x0018 (0x01E0 - 0x01C8)
class UAutoInteractionComponent final : public UInteractionComponent
{
public:
	struct FAutoInteractionData                   InteractionData;                                   // 0x01C8(0x0018)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoInteractionComponent">();
	}
	static class UAutoInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoInteractionComponent>();
	}
};
static_assert(alignof(UAutoInteractionComponent) == 0x000008, "Wrong alignment on UAutoInteractionComponent");
static_assert(sizeof(UAutoInteractionComponent) == 0x0001E0, "Wrong size on UAutoInteractionComponent");
static_assert(offsetof(UAutoInteractionComponent, InteractionData) == 0x0001C8, "Member 'UAutoInteractionComponent::InteractionData' has a wrong offset!");

// Class Stalker2.AutoSaveManager
// 0x0028 (0x00A0 - 0x0078)
class UAutoSaveManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x28];                                      // 0x0078(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoSaveManager">();
	}
	static class UAutoSaveManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoSaveManager>();
	}
};
static_assert(alignof(UAutoSaveManager) == 0x000008, "Wrong alignment on UAutoSaveManager");
static_assert(sizeof(UAutoSaveManager) == 0x0000A0, "Wrong size on UAutoSaveManager");

// Class Stalker2.PlayerModeManager
// 0x0180 (0x0228 - 0x00A8)
class UPlayerModeManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x180];                                     // 0x00A8(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerModeManager">();
	}
	static class UPlayerModeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerModeManager>();
	}
};
static_assert(alignof(UPlayerModeManager) == 0x000008, "Wrong alignment on UPlayerModeManager");
static_assert(sizeof(UPlayerModeManager) == 0x000228, "Wrong size on UPlayerModeManager");

// Class Stalker2.CreditsSectionTitle
// 0x0008 (0x0280 - 0x0278)
class UCreditsSectionTitle final : public UUserWidget
{
public:
	class UTextWidget*                            RoleText;                                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreditsSectionTitle">();
	}
	static class UCreditsSectionTitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreditsSectionTitle>();
	}
};
static_assert(alignof(UCreditsSectionTitle) == 0x000008, "Wrong alignment on UCreditsSectionTitle");
static_assert(sizeof(UCreditsSectionTitle) == 0x000280, "Wrong size on UCreditsSectionTitle");
static_assert(offsetof(UCreditsSectionTitle, RoleText) == 0x000278, "Member 'UCreditsSectionTitle::RoleText' has a wrong offset!");

// Class Stalker2.BarbedWireComponent
// 0x0028 (0x00E0 - 0x00B8)
class UBarbedWireComponent final : public UUIDActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BarbedWirePrototypeSID;                            // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCompHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BarbedWireComponent">();
	}
	static class UBarbedWireComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBarbedWireComponent>();
	}
};
static_assert(alignof(UBarbedWireComponent) == 0x000008, "Wrong alignment on UBarbedWireComponent");
static_assert(sizeof(UBarbedWireComponent) == 0x0000E0, "Wrong size on UBarbedWireComponent");
static_assert(offsetof(UBarbedWireComponent, BarbedWirePrototypeSID) == 0x0000C8, "Member 'UBarbedWireComponent::BarbedWirePrototypeSID' has a wrong offset!");

// Class Stalker2.PlatformSwitcherBase
// 0x0070 (0x01F0 - 0x0180)
class UPlatformSwitcherBase : public UWidgetSwitcher
{
public:
	bool                                          bEnablePlatformAutoSwitch;                         // 0x0180(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGSCInputDeviceType, int32>              PlatformSettings;                                  // 0x0188(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x18];                                     // 0x01D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitWidget();
	void UpdateWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformSwitcherBase">();
	}
	static class UPlatformSwitcherBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformSwitcherBase>();
	}
};
static_assert(alignof(UPlatformSwitcherBase) == 0x000008, "Wrong alignment on UPlatformSwitcherBase");
static_assert(sizeof(UPlatformSwitcherBase) == 0x0001F0, "Wrong size on UPlatformSwitcherBase");
static_assert(offsetof(UPlatformSwitcherBase, bEnablePlatformAutoSwitch) == 0x000180, "Member 'UPlatformSwitcherBase::bEnablePlatformAutoSwitch' has a wrong offset!");
static_assert(offsetof(UPlatformSwitcherBase, PlatformSettings) == 0x000188, "Member 'UPlatformSwitcherBase::PlatformSettings' has a wrong offset!");

// Class Stalker2.BarkManager
// 0x0DC0 (0x0E68 - 0x00A8)
class UBarkManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0xDC0];                                     // 0x00A8(0x0DC0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BarkManager">();
	}
	static class UBarkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBarkManager>();
	}
};
static_assert(alignof(UBarkManager) == 0x000008, "Wrong alignment on UBarkManager");
static_assert(sizeof(UBarkManager) == 0x000E68, "Wrong size on UBarkManager");

// Class Stalker2.CustomConsoleManagerMH
// 0x0020 (0x00C8 - 0x00A8)
class UCustomConsoleManagerMH final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XRemoveEffectFromPlayer(const class FString& EffectPrototypeSID);
	void XSetFov(const float FOV);
	void XToggleCustomFov(const bool bEnable);
	void XToggleDrawAIShootingDebug();
	void XToggleDrawPlayerDispersionDebug();
	void XToggleDrawPlayerRecoilDebug();
	void XToggleDrawPlayerShootingDebug();
	void XToggleHubDoors(const bool bLocked, const float Radius);
	void XToggleSoapBubbleDebug();

	void XApplyMainHandWeaponUpgradeBySID(const class FString& UpgradePrototypeSID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerMH">();
	}
	static class UCustomConsoleManagerMH* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerMH>();
	}
};
static_assert(alignof(UCustomConsoleManagerMH) == 0x000008, "Wrong alignment on UCustomConsoleManagerMH");
static_assert(sizeof(UCustomConsoleManagerMH) == 0x0000C8, "Wrong size on UCustomConsoleManagerMH");

// Class Stalker2.NPCScheduleManager
// 0x0060 (0x0108 - 0x00A8)
class UNPCScheduleManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x60];                                      // 0x00A8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCScheduleManager">();
	}
	static class UNPCScheduleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCScheduleManager>();
	}
};
static_assert(alignof(UNPCScheduleManager) == 0x000008, "Wrong alignment on UNPCScheduleManager");
static_assert(sizeof(UNPCScheduleManager) == 0x000108, "Wrong size on UNPCScheduleManager");

// Class Stalker2.BaseDLCInstanceSubsystem
// 0x0010 (0x0040 - 0x0030)
class UBaseDLCInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseDLCInstanceSubsystem">();
	}
	static class UBaseDLCInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseDLCInstanceSubsystem>();
	}
};
static_assert(alignof(UBaseDLCInstanceSubsystem) == 0x000008, "Wrong alignment on UBaseDLCInstanceSubsystem");
static_assert(sizeof(UBaseDLCInstanceSubsystem) == 0x000040, "Wrong size on UBaseDLCInstanceSubsystem");

// Class Stalker2.PageViewBase
// 0x0018 (0x0290 - 0x0278)
class UPageViewBase : public UChildViewBase
{
public:
	bool                                          bShouldBindWidgetInputs;                           // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShoudIgnoreInputOnPouse;                          // 0x0279(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A[0xE];                                      // 0x027A(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOpenedFromDialog;                                 // 0x0288(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PageViewBase">();
	}
	static class UPageViewBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPageViewBase>();
	}
};
static_assert(alignof(UPageViewBase) == 0x000008, "Wrong alignment on UPageViewBase");
static_assert(sizeof(UPageViewBase) == 0x000290, "Wrong size on UPageViewBase");
static_assert(offsetof(UPageViewBase, bShouldBindWidgetInputs) == 0x000278, "Member 'UPageViewBase::bShouldBindWidgetInputs' has a wrong offset!");
static_assert(offsetof(UPageViewBase, bShoudIgnoreInputOnPouse) == 0x000279, "Member 'UPageViewBase::bShoudIgnoreInputOnPouse' has a wrong offset!");
static_assert(offsetof(UPageViewBase, bOpenedFromDialog) == 0x000288, "Member 'UPageViewBase::bOpenedFromDialog' has a wrong offset!");

// Class Stalker2.PDAPage
// 0x0008 (0x0298 - 0x0290)
class UPDAPage : public UPageViewBase
{
public:
	EPDAPageType                                  PDAPage;                                           // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAPage">();
	}
	static class UPDAPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAPage>();
	}
};
static_assert(alignof(UPDAPage) == 0x000008, "Wrong alignment on UPDAPage");
static_assert(sizeof(UPDAPage) == 0x000298, "Wrong size on UPDAPage");
static_assert(offsetof(UPDAPage, PDAPage) == 0x000290, "Member 'UPDAPage::PDAPage' has a wrong offset!");

// Class Stalker2.TutorialPage
// 0x00C8 (0x0360 - 0x0298)
class UTutorialPage final : public UPDAPage
{
public:
	class UPDATutorialDetails*                    TutorialDetails;                                   // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDATutorialButton*                     ButtonAll;                                         // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDATutorialButton*                     ButtonNavigation;                                  // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDATutorialButton*                     ButtonFight;                                       // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDATutorialButton*                     ButtonSurvival;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDATutorialButton*                     ButtonEarning;                                     // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDATutorialPanel*                      TutorialPanel;                                     // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultOpenFilter;                                 // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TutorialSlotListScrollTime;                        // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPDATutorialCategory, struct FBackgroundSettings> BackgroundSettings;                       // 0x02D8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x38];                                     // 0x0328(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClickButtonMenu(const class FName ButtonId);
	void ShowBlockListNavigation(const bool bBlock);
	void ShowDetails(const bool bEmpty);
	void UIPDANavigationButtonRelease();
	void UIPDANavigationDown();
	void UIPDANavigationLeft();
	void UIPDANavigationMouseDown();
	void UIPDANavigationMouseUp();
	void UIPDANavigationRight();
	void UIPDANavigationUp();
	void UIPDANavigatioTutorialDown();
	void UIPDANavigatioTutorialUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialPage">();
	}
	static class UTutorialPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialPage>();
	}
};
static_assert(alignof(UTutorialPage) == 0x000008, "Wrong alignment on UTutorialPage");
static_assert(sizeof(UTutorialPage) == 0x000360, "Wrong size on UTutorialPage");
static_assert(offsetof(UTutorialPage, TutorialDetails) == 0x000298, "Member 'UTutorialPage::TutorialDetails' has a wrong offset!");
static_assert(offsetof(UTutorialPage, ButtonAll) == 0x0002A0, "Member 'UTutorialPage::ButtonAll' has a wrong offset!");
static_assert(offsetof(UTutorialPage, ButtonNavigation) == 0x0002A8, "Member 'UTutorialPage::ButtonNavigation' has a wrong offset!");
static_assert(offsetof(UTutorialPage, ButtonFight) == 0x0002B0, "Member 'UTutorialPage::ButtonFight' has a wrong offset!");
static_assert(offsetof(UTutorialPage, ButtonSurvival) == 0x0002B8, "Member 'UTutorialPage::ButtonSurvival' has a wrong offset!");
static_assert(offsetof(UTutorialPage, ButtonEarning) == 0x0002C0, "Member 'UTutorialPage::ButtonEarning' has a wrong offset!");
static_assert(offsetof(UTutorialPage, TutorialPanel) == 0x0002C8, "Member 'UTutorialPage::TutorialPanel' has a wrong offset!");
static_assert(offsetof(UTutorialPage, DefaultOpenFilter) == 0x0002D0, "Member 'UTutorialPage::DefaultOpenFilter' has a wrong offset!");
static_assert(offsetof(UTutorialPage, TutorialSlotListScrollTime) == 0x0002D4, "Member 'UTutorialPage::TutorialSlotListScrollTime' has a wrong offset!");
static_assert(offsetof(UTutorialPage, BackgroundSettings) == 0x0002D8, "Member 'UTutorialPage::BackgroundSettings' has a wrong offset!");

// Class Stalker2.CustomConsoleManagerCamera
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerCamera final : public UBaseConsoleManager
{
public:
	void ForegroundDepthScale(const float DepthScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerCamera">();
	}
	static class UCustomConsoleManagerCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerCamera>();
	}
};
static_assert(alignof(UCustomConsoleManagerCamera) == 0x000008, "Wrong alignment on UCustomConsoleManagerCamera");
static_assert(sizeof(UCustomConsoleManagerCamera) == 0x0000A8, "Wrong size on UCustomConsoleManagerCamera");

// Class Stalker2.BaseInteractableAction
// 0x0000 (0x0028 - 0x0028)
class UBaseInteractableAction final : public UObject
{
public:
	bool CanInteract();
	void RunAction();
	void RunAlternativeAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseInteractableAction">();
	}
	static class UBaseInteractableAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseInteractableAction>();
	}
};
static_assert(alignof(UBaseInteractableAction) == 0x000008, "Wrong alignment on UBaseInteractableAction");
static_assert(sizeof(UBaseInteractableAction) == 0x000028, "Wrong size on UBaseInteractableAction");

// Class Stalker2.SignalReceiverComponent
// 0x0008 (0x00C0 - 0x00B8)
class USignalReceiverComponent final : public UGuidActorComponent
{
public:
	FMulticastSparseDelegateProperty_             OnSignalReceived;                                  // 0x00B8(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanBeUsedInQuests;                                // 0x00B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SignalReceiverComponent">();
	}
	static class USignalReceiverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USignalReceiverComponent>();
	}
};
static_assert(alignof(USignalReceiverComponent) == 0x000008, "Wrong alignment on USignalReceiverComponent");
static_assert(sizeof(USignalReceiverComponent) == 0x0000C0, "Wrong size on USignalReceiverComponent");
static_assert(offsetof(USignalReceiverComponent, OnSignalReceived) == 0x0000B8, "Member 'USignalReceiverComponent::OnSignalReceived' has a wrong offset!");
static_assert(offsetof(USignalReceiverComponent, bCanBeUsedInQuests) == 0x0000B9, "Member 'USignalReceiverComponent::bCanBeUsedInQuests' has a wrong offset!");

// Class Stalker2.BaseLoadingScreenWidget
// 0x0030 (0x02A8 - 0x0278)
class UBaseLoadingScreenWidget : public UUserWidget
{
public:
	uint8                                         Pad_278[0x30];                                     // 0x0278(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseLoadingScreenWidget">();
	}
	static class UBaseLoadingScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseLoadingScreenWidget>();
	}
};
static_assert(alignof(UBaseLoadingScreenWidget) == 0x000008, "Wrong alignment on UBaseLoadingScreenWidget");
static_assert(sizeof(UBaseLoadingScreenWidget) == 0x0002A8, "Wrong size on UBaseLoadingScreenWidget");

// Class Stalker2.GAPlayerActionProcessor
// 0x0140 (0x0168 - 0x0028)
class UGAPlayerActionProcessor final : public UGAPlayerProcessorInterface
{
public:
	uint8                                         Pad_28[0x140];                                     // 0x0028(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAPlayerActionProcessor">();
	}
	static class UGAPlayerActionProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAPlayerActionProcessor>();
	}
};
static_assert(alignof(UGAPlayerActionProcessor) == 0x000008, "Wrong alignment on UGAPlayerActionProcessor");
static_assert(sizeof(UGAPlayerActionProcessor) == 0x000168, "Wrong size on UGAPlayerActionProcessor");

// Class Stalker2.BaseVolumeComponent
// 0x0060 (0x0690 - 0x0630)
#pragma pack(push, 0x1)
class alignas(0x10) UBaseVolumeComponent : public UStaticMeshComponent
{
public:
	ECollisionFormType                            MeshType;                                          // 0x0630(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockNegativeScale;                               // 0x0631(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceRoundCylinderBase;                           // 0x0632(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceUniformSphereScale;                          // 0x0633(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_634[0x54];                                     // 0x0634(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseVolumeComponent">();
	}
	static class UBaseVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseVolumeComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBaseVolumeComponent) == 0x000010, "Wrong alignment on UBaseVolumeComponent");
static_assert(sizeof(UBaseVolumeComponent) == 0x000690, "Wrong size on UBaseVolumeComponent");
static_assert(offsetof(UBaseVolumeComponent, MeshType) == 0x000630, "Member 'UBaseVolumeComponent::MeshType' has a wrong offset!");
static_assert(offsetof(UBaseVolumeComponent, bBlockNegativeScale) == 0x000631, "Member 'UBaseVolumeComponent::bBlockNegativeScale' has a wrong offset!");
static_assert(offsetof(UBaseVolumeComponent, bForceRoundCylinderBase) == 0x000632, "Member 'UBaseVolumeComponent::bForceRoundCylinderBase' has a wrong offset!");
static_assert(offsetof(UBaseVolumeComponent, bForceUniformSphereScale) == 0x000633, "Member 'UBaseVolumeComponent::bForceUniformSphereScale' has a wrong offset!");

// Class Stalker2.BedHoldComponent
// 0x0000 (0x0230 - 0x0230)
class UBedHoldComponent final : public UHoldComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BedHoldComponent">();
	}
	static class UBedHoldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBedHoldComponent>();
	}
};
static_assert(alignof(UBedHoldComponent) == 0x000008, "Wrong alignment on UBedHoldComponent");
static_assert(sizeof(UBedHoldComponent) == 0x000230, "Wrong size on UBedHoldComponent");

// Class Stalker2.CustomConsoleManagerPS
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerPS final : public UBaseConsoleManager
{
public:
	void XChangeCompasMarkers(int32 Index_0) const;
	void XChangeInventoryScroll(int32 Index_0) const;
	void XShowInventoryDebugItmesStats(const bool bShow) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerPS">();
	}
	static class UCustomConsoleManagerPS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerPS>();
	}
};
static_assert(alignof(UCustomConsoleManagerPS) == 0x000008, "Wrong alignment on UCustomConsoleManagerPS");
static_assert(sizeof(UCustomConsoleManagerPS) == 0x0000A8, "Wrong size on UCustomConsoleManagerPS");

// Class Stalker2.UIDActor_Bed
// 0x0010 (0x02A8 - 0x0298)
class AUIDActor_Bed : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActor_Bed">();
	}
	static class AUIDActor_Bed* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDActor_Bed>();
	}
};
static_assert(alignof(AUIDActor_Bed) == 0x000008, "Wrong alignment on AUIDActor_Bed");
static_assert(sizeof(AUIDActor_Bed) == 0x0002A8, "Wrong size on AUIDActor_Bed");

// Class Stalker2.SignalProcessingSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class USignalProcessingSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0xB0];                                      // 0x0030(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SignalProcessingSubsystem">();
	}
	static class USignalProcessingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USignalProcessingSubsystem>();
	}
};
static_assert(alignof(USignalProcessingSubsystem) == 0x000008, "Wrong alignment on USignalProcessingSubsystem");
static_assert(sizeof(USignalProcessingSubsystem) == 0x0000E0, "Wrong size on USignalProcessingSubsystem");

// Class Stalker2.GAPlayerPositionProcessor
// 0x0008 (0x0050 - 0x0048)
class UGAPlayerPositionProcessor final : public UGAPlayerProcessorBase
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAPlayerPositionProcessor">();
	}
	static class UGAPlayerPositionProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAPlayerPositionProcessor>();
	}
};
static_assert(alignof(UGAPlayerPositionProcessor) == 0x000008, "Wrong alignment on UGAPlayerPositionProcessor");
static_assert(sizeof(UGAPlayerPositionProcessor) == 0x000050, "Wrong size on UGAPlayerPositionProcessor");

// Class Stalker2.BedView
// 0x0088 (0x0330 - 0x02A8)
class ABedView final : public AUIDActor_Bed
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBedHoldComponent*                      SleepComponent;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrototypeSID                          HappyHoursSID;                                     // 0x02C8(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   BedMeshComponent;                                  // 0x0308(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIgnoreSleepinessValue;                            // 0x0320(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreEmission;                                   // 0x0321(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_322[0xE];                                      // 0x0322(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Interact();
	void OnSleepEnded();
	void OnSleepStarted();
	void SetInteractiveState(const bool bInteractive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BedView">();
	}
	static class ABedView* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABedView>();
	}
};
static_assert(alignof(ABedView) == 0x000008, "Wrong alignment on ABedView");
static_assert(sizeof(ABedView) == 0x000330, "Wrong size on ABedView");
static_assert(offsetof(ABedView, Guid) == 0x0002B0, "Member 'ABedView::Guid' has a wrong offset!");
static_assert(offsetof(ABedView, SleepComponent) == 0x0002C0, "Member 'ABedView::SleepComponent' has a wrong offset!");
static_assert(offsetof(ABedView, HappyHoursSID) == 0x0002C8, "Member 'ABedView::HappyHoursSID' has a wrong offset!");
static_assert(offsetof(ABedView, BedMeshComponent) == 0x000308, "Member 'ABedView::BedMeshComponent' has a wrong offset!");
static_assert(offsetof(ABedView, bIgnoreSleepinessValue) == 0x000320, "Member 'ABedView::bIgnoreSleepinessValue' has a wrong offset!");
static_assert(offsetof(ABedView, bIgnoreEmission) == 0x000321, "Member 'ABedView::bIgnoreEmission' has a wrong offset!");

// Class Stalker2.CustomConsoleManagerIM
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerIM final : public UBaseConsoleManager
{
public:
	void XHighlightCovers(const class FString& NavMeshAgentName) const;
	void XHighlightDangerAreas(const class FString& NavMeshAgentName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerIM">();
	}
	static class UCustomConsoleManagerIM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerIM>();
	}
};
static_assert(alignof(UCustomConsoleManagerIM) == 0x000008, "Wrong alignment on UCustomConsoleManagerIM");
static_assert(sizeof(UCustomConsoleManagerIM) == 0x0000A8, "Wrong size on UCustomConsoleManagerIM");

// Class Stalker2.BestiaryIPU
// 0x0000 (0x0040 - 0x0040)
class UBestiaryIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BestiaryIPU">();
	}
	static class UBestiaryIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBestiaryIPU>();
	}
};
static_assert(alignof(UBestiaryIPU) == 0x000008, "Wrong alignment on UBestiaryIPU");
static_assert(sizeof(UBestiaryIPU) == 0x000040, "Wrong size on UBestiaryIPU");

// Class Stalker2.Bloodsucker
// 0x0000 (0x0B50 - 0x0B50)
class ABloodsucker final : public AAgent
{
public:
	class UNiagaraComponent*                      InvisibilityTransferParticles;                     // 0x0B48(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Bloodsucker">();
	}
	static class ABloodsucker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABloodsucker>();
	}
};
static_assert(alignof(ABloodsucker) == 0x000010, "Wrong alignment on ABloodsucker");
static_assert(sizeof(ABloodsucker) == 0x000B50, "Wrong size on ABloodsucker");
static_assert(offsetof(ABloodsucker, InvisibilityTransferParticles) == 0x000B48, "Member 'ABloodsucker::InvisibilityTransferParticles' has a wrong offset!");

// Class Stalker2.PDASlotBase
// 0x0088 (0x0300 - 0x0278)
class UPDASlotBase : public UWidgetBase
{
public:
	class UTextWidget*                            NameText;                                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckBoxWidget*                        SelectPoint;                                       // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 HoverBeckground;                                   // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SelectBeckground;                                  // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 NewPoint;                                          // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAutoCut;                                    // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ELocalizationLanguage, int32>            CultureCutPreference;                              // 0x02A8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSelectPointTint(const struct FLinearColor& InColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDASlotBase">();
	}
	static class UPDASlotBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDASlotBase>();
	}
};
static_assert(alignof(UPDASlotBase) == 0x000008, "Wrong alignment on UPDASlotBase");
static_assert(sizeof(UPDASlotBase) == 0x000300, "Wrong size on UPDASlotBase");
static_assert(offsetof(UPDASlotBase, NameText) == 0x000278, "Member 'UPDASlotBase::NameText' has a wrong offset!");
static_assert(offsetof(UPDASlotBase, SelectPoint) == 0x000280, "Member 'UPDASlotBase::SelectPoint' has a wrong offset!");
static_assert(offsetof(UPDASlotBase, HoverBeckground) == 0x000288, "Member 'UPDASlotBase::HoverBeckground' has a wrong offset!");
static_assert(offsetof(UPDASlotBase, SelectBeckground) == 0x000290, "Member 'UPDASlotBase::SelectBeckground' has a wrong offset!");
static_assert(offsetof(UPDASlotBase, NewPoint) == 0x000298, "Member 'UPDASlotBase::NewPoint' has a wrong offset!");
static_assert(offsetof(UPDASlotBase, bShouldAutoCut) == 0x0002A0, "Member 'UPDASlotBase::bShouldAutoCut' has a wrong offset!");
static_assert(offsetof(UPDASlotBase, CultureCutPreference) == 0x0002A8, "Member 'UPDASlotBase::CultureCutPreference' has a wrong offset!");

// Class Stalker2.CustomConsoleManagerSM
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerSM final : public UBaseConsoleManager
{
public:
	void XStartEmissionBySID(const class FString& PrototypeSID);

	void XGetEmissionState() const;
	void XPauseScheduledEmission() const;
	void XResumeScheduledEmission() const;
	void XShowProjectileTrajectory(bool bShow) const;
	void XStartEmission() const;
	void XStopEmission() const;
	void XSVFriendlyFire(bool bEnabled) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerSM">();
	}
	static class UCustomConsoleManagerSM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerSM>();
	}
};
static_assert(alignof(UCustomConsoleManagerSM) == 0x000008, "Wrong alignment on UCustomConsoleManagerSM");
static_assert(sizeof(UCustomConsoleManagerSM) == 0x0000A8, "Wrong size on UCustomConsoleManagerSM");

// Class Stalker2.BloodsuckerInvisibilityComponent
// 0x0030 (0x00D0 - 0x00A0)
class UBloodsuckerInvisibilityComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            InvisibilityChangeCurve;                           // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       DynamicMaterials;                                  // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodsuckerInvisibilityComponent">();
	}
	static class UBloodsuckerInvisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodsuckerInvisibilityComponent>();
	}
};
static_assert(alignof(UBloodsuckerInvisibilityComponent) == 0x000008, "Wrong alignment on UBloodsuckerInvisibilityComponent");
static_assert(sizeof(UBloodsuckerInvisibilityComponent) == 0x0000D0, "Wrong size on UBloodsuckerInvisibilityComponent");
static_assert(offsetof(UBloodsuckerInvisibilityComponent, InvisibilityChangeCurve) == 0x0000B0, "Member 'UBloodsuckerInvisibilityComponent::InvisibilityChangeCurve' has a wrong offset!");
static_assert(offsetof(UBloodsuckerInvisibilityComponent, DynamicMaterials) == 0x0000C0, "Member 'UBloodsuckerInvisibilityComponent::DynamicMaterials' has a wrong offset!");

// Class Stalker2.GATradeActionProcessor
// 0x0010 (0x0038 - 0x0028)
class UGATradeActionProcessor final : public UGAPlayerProcessorInterface
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATradeActionProcessor">();
	}
	static class UGATradeActionProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATradeActionProcessor>();
	}
};
static_assert(alignof(UGATradeActionProcessor) == 0x000008, "Wrong alignment on UGATradeActionProcessor");
static_assert(sizeof(UGATradeActionProcessor) == 0x000038, "Wrong size on UGATradeActionProcessor");

// Class Stalker2.Bolt
// 0x0060 (0x02F8 - 0x0298)
class ABolt final : public AActor
{
public:
	class UHittableComponent*                     HittableComponent;                                 // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsInteractionComponent*           PhysicsInteractionComponent;                       // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsSoundsComponent*                PhysicsSoundsComponent;                            // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   BoltComponent;                                     // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x28];                                     // 0x02B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PrototypeID;                                       // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Bolt">();
	}
	static class ABolt* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABolt>();
	}
};
static_assert(alignof(ABolt) == 0x000008, "Wrong alignment on ABolt");
static_assert(sizeof(ABolt) == 0x0002F8, "Wrong size on ABolt");
static_assert(offsetof(ABolt, HittableComponent) == 0x000298, "Member 'ABolt::HittableComponent' has a wrong offset!");
static_assert(offsetof(ABolt, PhysicsInteractionComponent) == 0x0002A0, "Member 'ABolt::PhysicsInteractionComponent' has a wrong offset!");
static_assert(offsetof(ABolt, PhysicsSoundsComponent) == 0x0002A8, "Member 'ABolt::PhysicsSoundsComponent' has a wrong offset!");
static_assert(offsetof(ABolt, BoltComponent) == 0x0002B0, "Member 'ABolt::BoltComponent' has a wrong offset!");
static_assert(offsetof(ABolt, PrototypeID) == 0x0002E0, "Member 'ABolt::PrototypeID' has a wrong offset!");

// Class Stalker2.CustomConsoleManagerAK
// 0x0008 (0x00B0 - 0x00A8)
class UCustomConsoleManagerAK final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XPrintModelCapacity();
	void XSaveObjListToFile();
	void XToggleAutoSaveEachFrame();

	void XKillThemAll() const;
	void XPrintInventory(int32 UnitUID) const;
	void XSuicide() const;
	void XTestDangling() const;
	void XTestST162667() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerAK">();
	}
	static class UCustomConsoleManagerAK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerAK>();
	}
};
static_assert(alignof(UCustomConsoleManagerAK) == 0x000008, "Wrong alignment on UCustomConsoleManagerAK");
static_assert(sizeof(UCustomConsoleManagerAK) == 0x0000B0, "Wrong size on UCustomConsoleManagerAK");

// Class Stalker2.StackSplitContextual
// 0x0208 (0x0480 - 0x0278)
class UStackSplitContextual : public UUserWidget
{
public:
	class UHintInputController*                   ConfirmHint;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   ConfirmAllHint;                                    // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   CancelHint;                                        // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            TitleText;                                         // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SignCaptionPressedColor;                           // 0x0298(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SignCaptionDefaultColor;                           // 0x02A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USlider*                                Slider_ItemSplit;                                  // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            SplitTextTest;                                     // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            ItemName;                                          // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBoxSlider;                                     // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OverlayNumbers;                                    // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OverlaySize;                                       // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SliderImage;                                       // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            MovementCurve;                                     // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ESplitStackTypeDirection, class FString> ConfirmHintType;                                   // 0x02F8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ESplitStackTypeDirection, class FString> ConfirmAllHintType;                                // 0x0348(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UButton*                                ArrowLeft;                                         // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ArrowRight;                                        // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformSwitcherBase*                  ArrowRightPlatformSwitcher;                        // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformSwitcherBase*                  ArrowLeftPlatformSwitcher;                         // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x20];                                     // 0x03B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               MainOverlay;                                       // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E0[0x70];                                     // 0x03E0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ActiveBarColor;                                    // 0x0450(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           NonActiveBarColor;                                 // 0x0460(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCancelButtonClicked();
	void OnDropAllButtonClicked();
	void OnHoldTimerTriggered();
	void OnMinusButtonClicked();
	void OnMinusButtonPressed();
	void OnMinusButtonReleased();
	void OnPlusButtonClicked();
	void OnPlusButtonPressed();
	void OnPlusButtonReleased();
	void OnSplitButtonClicked();
	void OnSplitValueChanged(float Value);
	void PressChangeAmmount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StackSplitContextual">();
	}
	static class UStackSplitContextual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStackSplitContextual>();
	}
};
static_assert(alignof(UStackSplitContextual) == 0x000008, "Wrong alignment on UStackSplitContextual");
static_assert(sizeof(UStackSplitContextual) == 0x000480, "Wrong size on UStackSplitContextual");
static_assert(offsetof(UStackSplitContextual, ConfirmHint) == 0x000278, "Member 'UStackSplitContextual::ConfirmHint' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, ConfirmAllHint) == 0x000280, "Member 'UStackSplitContextual::ConfirmAllHint' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, CancelHint) == 0x000288, "Member 'UStackSplitContextual::CancelHint' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, TitleText) == 0x000290, "Member 'UStackSplitContextual::TitleText' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, SignCaptionPressedColor) == 0x000298, "Member 'UStackSplitContextual::SignCaptionPressedColor' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, SignCaptionDefaultColor) == 0x0002A8, "Member 'UStackSplitContextual::SignCaptionDefaultColor' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, Slider_ItemSplit) == 0x0002B8, "Member 'UStackSplitContextual::Slider_ItemSplit' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, SplitTextTest) == 0x0002C0, "Member 'UStackSplitContextual::SplitTextTest' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, ItemName) == 0x0002C8, "Member 'UStackSplitContextual::ItemName' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, SizeBoxSlider) == 0x0002D0, "Member 'UStackSplitContextual::SizeBoxSlider' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, OverlayNumbers) == 0x0002D8, "Member 'UStackSplitContextual::OverlayNumbers' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, OverlaySize) == 0x0002E0, "Member 'UStackSplitContextual::OverlaySize' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, SliderImage) == 0x0002E8, "Member 'UStackSplitContextual::SliderImage' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, MovementCurve) == 0x0002F0, "Member 'UStackSplitContextual::MovementCurve' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, ConfirmHintType) == 0x0002F8, "Member 'UStackSplitContextual::ConfirmHintType' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, ConfirmAllHintType) == 0x000348, "Member 'UStackSplitContextual::ConfirmAllHintType' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, ArrowLeft) == 0x000398, "Member 'UStackSplitContextual::ArrowLeft' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, ArrowRight) == 0x0003A0, "Member 'UStackSplitContextual::ArrowRight' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, ArrowRightPlatformSwitcher) == 0x0003A8, "Member 'UStackSplitContextual::ArrowRightPlatformSwitcher' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, ArrowLeftPlatformSwitcher) == 0x0003B0, "Member 'UStackSplitContextual::ArrowLeftPlatformSwitcher' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, MainOverlay) == 0x0003D8, "Member 'UStackSplitContextual::MainOverlay' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, ActiveBarColor) == 0x000450, "Member 'UStackSplitContextual::ActiveBarColor' has a wrong offset!");
static_assert(offsetof(UStackSplitContextual, NonActiveBarColor) == 0x000460, "Member 'UStackSplitContextual::NonActiveBarColor' has a wrong offset!");

// Class Stalker2.PlayerPictureWidget
// 0x0010 (0x0288 - 0x0278)
class UPlayerPictureWidget final : public UWidgetBase
{
public:
	class UImage*                                 PlayerPicture;                                     // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPictureWidget">();
	}
	static class UPlayerPictureWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerPictureWidget>();
	}
};
static_assert(alignof(UPlayerPictureWidget) == 0x000008, "Wrong alignment on UPlayerPictureWidget");
static_assert(sizeof(UPlayerPictureWidget) == 0x000288, "Wrong size on UPlayerPictureWidget");
static_assert(offsetof(UPlayerPictureWidget, PlayerPicture) == 0x000278, "Member 'UPlayerPictureWidget::PlayerPicture' has a wrong offset!");

// Class Stalker2.BossInterface
// 0x0000 (0x0000 - 0x0000)
class IBossInterface final
{
public:
	void OnDashAbilityBegin();
	void OnDashAbilityEnd();
	void OnStunBegin();
	void OnStunEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BossInterface">();
	}
	static class IBossInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBossInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IBossInterface) == 0x000001, "Wrong alignment on IBossInterface");
static_assert(sizeof(IBossInterface) == 0x000001, "Wrong size on IBossInterface");

// Class Stalker2.ControlSettingsPopup
// 0x0028 (0x0388 - 0x0360)
class UControlSettingsPopup : public UPopupBase
{
public:
	class URichTextBlock*                         DescriptionLegendText;                             // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DescriptionSID;                                    // 0x0368(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ActionTextStyleID;                                 // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KeyImageIndex;                                     // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TextImageIndex;                                    // 0x0384(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlSettingsPopup">();
	}
	static class UControlSettingsPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlSettingsPopup>();
	}
};
static_assert(alignof(UControlSettingsPopup) == 0x000008, "Wrong alignment on UControlSettingsPopup");
static_assert(sizeof(UControlSettingsPopup) == 0x000388, "Wrong size on UControlSettingsPopup");
static_assert(offsetof(UControlSettingsPopup, DescriptionLegendText) == 0x000360, "Member 'UControlSettingsPopup::DescriptionLegendText' has a wrong offset!");
static_assert(offsetof(UControlSettingsPopup, DescriptionSID) == 0x000368, "Member 'UControlSettingsPopup::DescriptionSID' has a wrong offset!");
static_assert(offsetof(UControlSettingsPopup, ActionTextStyleID) == 0x000378, "Member 'UControlSettingsPopup::ActionTextStyleID' has a wrong offset!");
static_assert(offsetof(UControlSettingsPopup, KeyImageIndex) == 0x000380, "Member 'UControlSettingsPopup::KeyImageIndex' has a wrong offset!");
static_assert(offsetof(UControlSettingsPopup, TextImageIndex) == 0x000384, "Member 'UControlSettingsPopup::TextImageIndex' has a wrong offset!");

// Class Stalker2.GSCBPFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGSCBPFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void SetAffectNavigationForComponent(class UPrimitiveComponent* PrimitiveComponent, bool bCanAffect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCBPFunctionLibrary">();
	}
	static class UGSCBPFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSCBPFunctionLibrary>();
	}
};
static_assert(alignof(UGSCBPFunctionLibrary) == 0x000008, "Wrong alignment on UGSCBPFunctionLibrary");
static_assert(sizeof(UGSCBPFunctionLibrary) == 0x000028, "Wrong size on UGSCBPFunctionLibrary");

// Class Stalker2.Poltergeist
// 0x00A0 (0x0BF0 - 0x0B50)
class APoltergeist final : public AAgent
{
public:
	class UNiagaraComponent*                      BodyParticles;                                     // 0x0B48(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       BodyCollision;                                     // 0x0B50(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      DeathParticles;                                    // 0x0B58(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MeshSpawnOffset;                                   // 0x0B60(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDamageType, float>                      DeathImpulseScaleMap;                              // 0x0B78(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DeathBodyVisibilityDelay;                          // 0x0BC8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BCC[0x24];                                     // 0x0BCC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Poltergeist">();
	}
	static class APoltergeist* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoltergeist>();
	}
};
static_assert(alignof(APoltergeist) == 0x000010, "Wrong alignment on APoltergeist");
static_assert(sizeof(APoltergeist) == 0x000BF0, "Wrong size on APoltergeist");
static_assert(offsetof(APoltergeist, BodyParticles) == 0x000B48, "Member 'APoltergeist::BodyParticles' has a wrong offset!");
static_assert(offsetof(APoltergeist, BodyCollision) == 0x000B50, "Member 'APoltergeist::BodyCollision' has a wrong offset!");
static_assert(offsetof(APoltergeist, DeathParticles) == 0x000B58, "Member 'APoltergeist::DeathParticles' has a wrong offset!");
static_assert(offsetof(APoltergeist, MeshSpawnOffset) == 0x000B60, "Member 'APoltergeist::MeshSpawnOffset' has a wrong offset!");
static_assert(offsetof(APoltergeist, DeathImpulseScaleMap) == 0x000B78, "Member 'APoltergeist::DeathImpulseScaleMap' has a wrong offset!");
static_assert(offsetof(APoltergeist, DeathBodyVisibilityDelay) == 0x000BC8, "Member 'APoltergeist::DeathBodyVisibilityDelay' has a wrong offset!");

// Class Stalker2.VictoryBPFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVictoryBPFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GetAllWidgetsOfClass(class UObject* WorldContextObject, TSubclassOf<class UUserWidget> WidgetClass, TArray<class UUserWidget*>* FoundWidgets, bool TopLevelOnly);
	static class UUserWidget* GetFirstWidgetOfClass(class UObject* WorldContextObject, TSubclassOf<class UUserWidget> WidgetClass, bool TopLevelOnly);
	static class FName GetObjectPath(class UObject* Obj);
	static bool IsWidgetOfClassInViewport(class UObject* WorldContextObject, TSubclassOf<class UUserWidget> WidgetClass);
	static class UObject* LoadObjectFromAssetPath(TSubclassOf<class UObject> ObjectClass, class FName Path, bool* IsValid);
	static float MapRangeClamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB);
	static void RemoveAllWidgetsOfClass(class UObject* WorldContextObject, TSubclassOf<class UUserWidget> WidgetClass);
	static void SaveConfigToFile(const TArray<struct FVictoryInput>& VictoryInputs, const class FString& Filename);
	static void SaveGameObject_GetAllSaveSlotFileNames(TArray<class FString>* FileNames);
	static bool ScreenShots_Rename_Move_Most_Recent(class FString* OriginalFileName, const class FString& NewName, const class FString& NewAbsoluteFolderPath, bool HighResolution);
	static void VictoryGetAllActionKeyBindings(TArray<struct FVictoryInput>* Bindings);
	static void VictoryGetAllAxisAndActionMappingsForKey(const struct FKey& Key, TArray<struct FVictoryInput>* ActionBindings, TArray<struct FVictoryInputAxis>* AxisBindings);
	static void VictoryGetAllAxisKeyBindings(TArray<struct FVictoryInputAxis>* Bindings);
	static struct FVictoryInput VictoryGetVictoryInput(const struct FKeyEvent& KeyEvent);
	static struct FVictoryInputAxis VictoryGetVictoryInputAxis(const struct FKeyEvent& KeyEvent);
	static class FString VictoryPaths__SavedDir();
	static class FString VictoryPaths__ScreenShotsDir();
	static bool VictoryReBindActionKey(const struct FVictoryInput& Original, const struct FVictoryInput& NewBinding);
	static bool VictoryReBindAxisKey(const struct FVictoryInputAxis& Original, const struct FVictoryInputAxis& NewBinding);
	static void VictoryRemoveActionKeyBind(const struct FVictoryInput& ToRemove);
	static void VictoryRemoveAxisKeyBind(const struct FVictoryInputAxis& ToRemove);
	static bool VictorySoundVolumeChange(class USoundClass* SoundClassObject, float NewVolume);
	static bool Viewport__GetCenterOfViewport(const class APlayerController* ThePC, float* PosX, float* PosY);
	static class UUserWidget* WidgetGetParentOfClass(class UWidget* ChildWidget, TSubclassOf<class UUserWidget> WidgetClass);
	static bool WidgetIsChildOf(class UWidget* ChildWidget, class UWidget* PossibleParent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictoryBPFunctionLibrary">();
	}
	static class UVictoryBPFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictoryBPFunctionLibrary>();
	}
};
static_assert(alignof(UVictoryBPFunctionLibrary) == 0x000008, "Wrong alignment on UVictoryBPFunctionLibrary");
static_assert(sizeof(UVictoryBPFunctionLibrary) == 0x000028, "Wrong size on UVictoryBPFunctionLibrary");

// Class Stalker2.CustomConsoleManagerOP
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerOP final : public UBaseConsoleManager
{
public:
	void XNpcArraySetFaceBlendShapeState(const int32 StartNpcUID, const int32 EndNpcUID, const bool bEnabled) const;
	void XNpcFreezeRagdollPose(const int32 NpcUID) const;
	void XNpcSetFaceBlendShapeState(const int32 NpcUID, const bool bEnabled) const;
	void XNpcSetFaceBlockingBlendMask(const int32 NpcUID, const EFaceBlockingBlendMasks FaceBlockingMask, const float BlockingWeight) const;
	void XNpcSetStateTag(const int32 NpcUID, const EStateTag StateTag, const bool bEnabled) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerOP">();
	}
	static class UCustomConsoleManagerOP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerOP>();
	}
};
static_assert(alignof(UCustomConsoleManagerOP) == 0x000008, "Wrong alignment on UCustomConsoleManagerOP");
static_assert(sizeof(UCustomConsoleManagerOP) == 0x0000A8, "Wrong size on UCustomConsoleManagerOP");

// Class Stalker2.VehicleSoundPlacement
// 0x0010 (0x02B0 - 0x02A0)
class UVehicleSoundPlacement final : public USceneComponent
{
public:
	class UAkAudioEvent*                          VehiclePullSound;                                  // 0x02A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          VehicleReleaseSound;                               // 0x02A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleSoundPlacement">();
	}
	static class UVehicleSoundPlacement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleSoundPlacement>();
	}
};
static_assert(alignof(UVehicleSoundPlacement) == 0x000010, "Wrong alignment on UVehicleSoundPlacement");
static_assert(sizeof(UVehicleSoundPlacement) == 0x0002B0, "Wrong size on UVehicleSoundPlacement");
static_assert(offsetof(UVehicleSoundPlacement, VehiclePullSound) == 0x0002A0, "Member 'UVehicleSoundPlacement::VehiclePullSound' has a wrong offset!");
static_assert(offsetof(UVehicleSoundPlacement, VehicleReleaseSound) == 0x0002A8, "Member 'UVehicleSoundPlacement::VehicleReleaseSound' has a wrong offset!");

// Class Stalker2.BulbAnomaly
// 0x0128 (0x03C0 - 0x0298)
class ABulbAnomaly final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PullSound;                                         // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ReleaseSound;                                      // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          IdleSound;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       SphereComponent;                                   // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UVehicleSoundPlacement*>         VehicleSoundLocations;                             // 0x02C0(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            DamageCurve;                                       // 0x02D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            GravityCurve;                                      // 0x02D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelSequence*                         AnomalySequence;                                   // 0x02E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMovieSceneSequencePlaybackSettings    SequencePlaybackSettings;                          // 0x02E8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    LevelSequenceActor;                                // 0x0308(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           EnvironmentMPC;                                    // 0x0310(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FoliageParameterName;                              // 0x0318(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         InteractionEffectsSIDs;                            // 0x0320(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         EnduranceDamagePerSecond;                          // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GravityPower;                                      // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GravityFree;                                       // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CoveredMultiplier;                                 // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UncoveredMultiplier;                               // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CoverTraceDistance;                                // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CarsTag;                                           // 0x0348(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x4];                                      // 0x0350(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Cooldown;                                          // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35C[0x64];                                     // 0x035C(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulbAnomaly">();
	}
	static class ABulbAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulbAnomaly>();
	}
};
static_assert(alignof(ABulbAnomaly) == 0x000008, "Wrong alignment on ABulbAnomaly");
static_assert(sizeof(ABulbAnomaly) == 0x0003C0, "Wrong size on ABulbAnomaly");
static_assert(offsetof(ABulbAnomaly, PullSound) == 0x0002A0, "Member 'ABulbAnomaly::PullSound' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, ReleaseSound) == 0x0002A8, "Member 'ABulbAnomaly::ReleaseSound' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, IdleSound) == 0x0002B0, "Member 'ABulbAnomaly::IdleSound' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, SphereComponent) == 0x0002B8, "Member 'ABulbAnomaly::SphereComponent' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, VehicleSoundLocations) == 0x0002C0, "Member 'ABulbAnomaly::VehicleSoundLocations' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, DamageCurve) == 0x0002D0, "Member 'ABulbAnomaly::DamageCurve' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, GravityCurve) == 0x0002D8, "Member 'ABulbAnomaly::GravityCurve' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, AnomalySequence) == 0x0002E0, "Member 'ABulbAnomaly::AnomalySequence' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, SequencePlaybackSettings) == 0x0002E8, "Member 'ABulbAnomaly::SequencePlaybackSettings' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, LevelSequenceActor) == 0x000308, "Member 'ABulbAnomaly::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, EnvironmentMPC) == 0x000310, "Member 'ABulbAnomaly::EnvironmentMPC' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, FoliageParameterName) == 0x000318, "Member 'ABulbAnomaly::FoliageParameterName' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, InteractionEffectsSIDs) == 0x000320, "Member 'ABulbAnomaly::InteractionEffectsSIDs' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, EnduranceDamagePerSecond) == 0x000330, "Member 'ABulbAnomaly::EnduranceDamagePerSecond' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, GravityPower) == 0x000334, "Member 'ABulbAnomaly::GravityPower' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, GravityFree) == 0x000338, "Member 'ABulbAnomaly::GravityFree' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, CoveredMultiplier) == 0x00033C, "Member 'ABulbAnomaly::CoveredMultiplier' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, UncoveredMultiplier) == 0x000340, "Member 'ABulbAnomaly::UncoveredMultiplier' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, CoverTraceDistance) == 0x000344, "Member 'ABulbAnomaly::CoverTraceDistance' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, CarsTag) == 0x000348, "Member 'ABulbAnomaly::CarsTag' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, Duration) == 0x000354, "Member 'ABulbAnomaly::Duration' has a wrong offset!");
static_assert(offsetof(ABulbAnomaly, Cooldown) == 0x000358, "Member 'ABulbAnomaly::Cooldown' has a wrong offset!");

// Class Stalker2.StatisticIPU
// 0x0000 (0x0040 - 0x0040)
class UStatisticIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatisticIPU">();
	}
	static class UStatisticIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatisticIPU>();
	}
};
static_assert(alignof(UStatisticIPU) == 0x000008, "Wrong alignment on UStatisticIPU");
static_assert(sizeof(UStatisticIPU) == 0x000040, "Wrong size on UStatisticIPU");

// Class Stalker2.BusVolumeDataReceiver
// 0x0000 (0x0000 - 0x0000)
class IBusVolumeDataReceiver final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BusVolumeDataReceiver">();
	}
	static class IBusVolumeDataReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBusVolumeDataReceiver>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IBusVolumeDataReceiver) == 0x000001, "Wrong alignment on IBusVolumeDataReceiver");
static_assert(sizeof(IBusVolumeDataReceiver) == 0x000001, "Wrong size on IBusVolumeDataReceiver");

// Class Stalker2.BusVolumeInterpolatorComponent
// 0x0018 (0x00B8 - 0x00A0)
class UBusVolumeInterpolatorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BusVolumeInterpolatorComponent">();
	}
	static class UBusVolumeInterpolatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBusVolumeInterpolatorComponent>();
	}
};
static_assert(alignof(UBusVolumeInterpolatorComponent) == 0x000008, "Wrong alignment on UBusVolumeInterpolatorComponent");
static_assert(sizeof(UBusVolumeInterpolatorComponent) == 0x0000B8, "Wrong size on UBusVolumeInterpolatorComponent");

// Class Stalker2.CustomConsoleManagerDR
// 0x0008 (0x00B0 - 0x00A8)
class UCustomConsoleManagerDR final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XDisableCinematicMode();
	void XEnableCinematicMode();
	void XInitializeBenchmarkSequence(const class FString& AssetPath, const class FString& AssetName);

	void XForceWeather(const EWeather WeatherType) const;
	void XSwitchToWeather(const EWeather WeatherType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerDR">();
	}
	static class UCustomConsoleManagerDR* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerDR>();
	}
};
static_assert(alignof(UCustomConsoleManagerDR) == 0x000008, "Wrong alignment on UCustomConsoleManagerDR");
static_assert(sizeof(UCustomConsoleManagerDR) == 0x0000B0, "Wrong size on UCustomConsoleManagerDR");

// Class Stalker2.MenuButtonStateDefiner
// 0x0008 (0x0030 - 0x0028)
class UMenuButtonStateDefiner : public UObject
{
public:
	class UMenuButtonActionBase*                  OverrideBlockedAction;                             // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuButtonStateDefiner">();
	}
	static class UMenuButtonStateDefiner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuButtonStateDefiner>();
	}
};
static_assert(alignof(UMenuButtonStateDefiner) == 0x000008, "Wrong alignment on UMenuButtonStateDefiner");
static_assert(sizeof(UMenuButtonStateDefiner) == 0x000030, "Wrong size on UMenuButtonStateDefiner");
static_assert(offsetof(UMenuButtonStateDefiner, OverrideBlockedAction) == 0x000028, "Member 'UMenuButtonStateDefiner::OverrideBlockedAction' has a wrong offset!");

// Class Stalker2.CoversStorage
// 0x0010 (0x0088 - 0x0078)
class UCoversStorage final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoversStorage">();
	}
	static class UCoversStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoversStorage>();
	}
};
static_assert(alignof(UCoversStorage) == 0x000008, "Wrong alignment on UCoversStorage");
static_assert(sizeof(UCoversStorage) == 0x000088, "Wrong size on UCoversStorage");

// Class Stalker2.SaveButtonStateDefiner
// 0x0000 (0x0030 - 0x0030)
class USaveButtonStateDefiner final : public UMenuButtonStateDefiner
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveButtonStateDefiner">();
	}
	static class USaveButtonStateDefiner* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveButtonStateDefiner>();
	}
};
static_assert(alignof(USaveButtonStateDefiner) == 0x000008, "Wrong alignment on USaveButtonStateDefiner");
static_assert(sizeof(USaveButtonStateDefiner) == 0x000030, "Wrong size on USaveButtonStateDefiner");

// Class Stalker2.OpenSelectorIPU
// 0x0010 (0x0050 - 0x0040)
class UOpenSelectorIPU final : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenSelectorIPU">();
	}
	static class UOpenSelectorIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenSelectorIPU>();
	}
};
static_assert(alignof(UOpenSelectorIPU) == 0x000008, "Wrong alignment on UOpenSelectorIPU");
static_assert(sizeof(UOpenSelectorIPU) == 0x000050, "Wrong size on UOpenSelectorIPU");

// Class Stalker2.LoadButtonStateDefiner
// 0x0000 (0x0030 - 0x0030)
class ULoadButtonStateDefiner final : public UMenuButtonStateDefiner
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadButtonStateDefiner">();
	}
	static class ULoadButtonStateDefiner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadButtonStateDefiner>();
	}
};
static_assert(alignof(ULoadButtonStateDefiner) == 0x000008, "Wrong alignment on ULoadButtonStateDefiner");
static_assert(sizeof(ULoadButtonStateDefiner) == 0x000030, "Wrong size on ULoadButtonStateDefiner");

// Class Stalker2.CustomConsoleManagerVC
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerVC final : public UBaseConsoleManager
{
public:
	void DebugUIShowTextSize(bool bEnabled);
	void XAddItemDragToQuickSlot(int32 IndexSlot);
	void XAddNotesById(const class FString& InNotePrototypeID);
	void XAddPDATutorialsBySID(const class FString& InPDATutorialPrototypeSID);
	void XChangeLanguage(int32 LanguageIndex);
	void XChangeLanguageEN();
	void XChangeLanguageRU();
	void XDialogFontSizeAnswer(int32 InTextSize);
	void XDialogFontSizeSubtitle(int32 InTextSize);
	void XEnterRegion(const class FString& RegionSID);
	void XHideGameDataAndTime();
	void XShowCompassAngle(bool bEnabled);
	void XShowGameDataAndTime();
	void XShowHUD(bool bIsShow);
	void XShowPopupAttentionIcon();
	void XShowPopupBrokenIcon();
	void XShowPopupCurruptedSaveData();
	void XShowPopupDeleteSave();
	void XShowPopupDiscardChanges();
	void XShowPopupExitGame();
	void XShowPopupGameCannotBeSaveNow();
	void XShowPopupNoIcon();
	void XShowPopupNotEnoughSpace();
	void XShowPopupOverwriteCampaignSlot();
	void XShowPopupOverwriteSavedGame();
	void XShowPopupSaveIcon();
	void XShowPopupSaveSettings();
	void XShowPopupSaveSettinsRestart();
	void XShowStatProgres(bool bEnabled);
	void XShowUIDebugInput(bool bEnabled);
	void XTestJournal();
	void XTestJournalFinishQuest();
	void XTestPDA();
	void XTestSysNotification();
	void XTestSysNotificationAddAudilog();
	void XTestSysNotificationAddItem();
	void XTestSysNotificationAddMoney();
	void XTestSysNotificationAddStash();
	void XTestSysNotificationDiscoverRegion();
	void XTestSysNotificationInspectArtifact();
	void XTestSysNotificationRemoveItem();
	void XTestSysNotificationRemoveMoney();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerVC">();
	}
	static class UCustomConsoleManagerVC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerVC>();
	}
};
static_assert(alignof(UCustomConsoleManagerVC) == 0x000008, "Wrong alignment on UCustomConsoleManagerVC");
static_assert(sizeof(UCustomConsoleManagerVC) == 0x0000A8, "Wrong size on UCustomConsoleManagerVC");

// Class Stalker2.ShippingButtonStateDefiner
// 0x0000 (0x0030 - 0x0030)
class UShippingButtonStateDefiner final : public UMenuButtonStateDefiner
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShippingButtonStateDefiner">();
	}
	static class UShippingButtonStateDefiner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShippingButtonStateDefiner>();
	}
};
static_assert(alignof(UShippingButtonStateDefiner) == 0x000008, "Wrong alignment on UShippingButtonStateDefiner");
static_assert(sizeof(UShippingButtonStateDefiner) == 0x000030, "Wrong size on UShippingButtonStateDefiner");

// Class Stalker2.PlatformButtonStateDefiner
// 0x0008 (0x0038 - 0x0030)
class UPlatformButtonStateDefiner final : public UMenuButtonStateDefiner
{
public:
	uint32                                        AvailablePlatforms;                                // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformButtonStateDefiner">();
	}
	static class UPlatformButtonStateDefiner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformButtonStateDefiner>();
	}
};
static_assert(alignof(UPlatformButtonStateDefiner) == 0x000008, "Wrong alignment on UPlatformButtonStateDefiner");
static_assert(sizeof(UPlatformButtonStateDefiner) == 0x000038, "Wrong size on UPlatformButtonStateDefiner");
static_assert(offsetof(UPlatformButtonStateDefiner, AvailablePlatforms) == 0x000030, "Member 'UPlatformButtonStateDefiner::AvailablePlatforms' has a wrong offset!");

// Class Stalker2.NavArea_Lair
// 0x0000 (0x0048 - 0x0048)
class UNavArea_Lair final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Lair">();
	}
	static class UNavArea_Lair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Lair>();
	}
};
static_assert(alignof(UNavArea_Lair) == 0x000008, "Wrong alignment on UNavArea_Lair");
static_assert(sizeof(UNavArea_Lair) == 0x000048, "Wrong size on UNavArea_Lair");

// Class Stalker2.CrashAnalyticSubsystem
// 0x0050 (0x0090 - 0x0040)
class UCrashAnalyticSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrashAnalyticSubsystem">();
	}
	static class UCrashAnalyticSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrashAnalyticSubsystem>();
	}
};
static_assert(alignof(UCrashAnalyticSubsystem) == 0x000008, "Wrong alignment on UCrashAnalyticSubsystem");
static_assert(sizeof(UCrashAnalyticSubsystem) == 0x000090, "Wrong size on UCrashAnalyticSubsystem");

// Class Stalker2.ContinueButtonStateDefiner
// 0x0000 (0x0030 - 0x0030)
class UContinueButtonStateDefiner final : public UMenuButtonStateDefiner
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContinueButtonStateDefiner">();
	}
	static class UContinueButtonStateDefiner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContinueButtonStateDefiner>();
	}
};
static_assert(alignof(UContinueButtonStateDefiner) == 0x000008, "Wrong alignment on UContinueButtonStateDefiner");
static_assert(sizeof(UContinueButtonStateDefiner) == 0x000030, "Wrong size on UContinueButtonStateDefiner");

// Class Stalker2.StoreButtonStateDefiner
// 0x0010 (0x0040 - 0x0030)
class UStoreButtonStateDefiner final : public UMenuButtonStateDefiner
{
public:
	TArray<class FName>                           ExcludeSubsystems;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	TArray<class FName> GetSubsystemOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreButtonStateDefiner">();
	}
	static class UStoreButtonStateDefiner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreButtonStateDefiner>();
	}
};
static_assert(alignof(UStoreButtonStateDefiner) == 0x000008, "Wrong alignment on UStoreButtonStateDefiner");
static_assert(sizeof(UStoreButtonStateDefiner) == 0x000040, "Wrong size on UStoreButtonStateDefiner");
static_assert(offsetof(UStoreButtonStateDefiner, ExcludeSubsystems) == 0x000030, "Member 'UStoreButtonStateDefiner::ExcludeSubsystems' has a wrong offset!");

// Class Stalker2.CustomConsoleManagerMS
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerMS final : public UBaseConsoleManager
{
public:
	void XCommitSuicide(EDamageType DamageType) const;
	void XLaunchCustomAnimation(int32 ObjUID, const class FString& AnimPath, const class FString& AnimSlotName) const;
	void XSetAIStayGoal(const int32 ObjUID, const class FString& AnimPath) const;
	void XSetCameraShakeScale(float NewScale) const;
	void XShowMaterial(int32 ObjUID, int32 MaterialID, int32 LODId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerMS">();
	}
	static class UCustomConsoleManagerMS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerMS>();
	}
};
static_assert(alignof(UCustomConsoleManagerMS) == 0x000008, "Wrong alignment on UCustomConsoleManagerMS");
static_assert(sizeof(UCustomConsoleManagerMS) == 0x0000A8, "Wrong size on UCustomConsoleManagerMS");

// Class Stalker2.SecuritySettings
// 0x0018 (0x0050 - 0x0038)
class USecuritySettings final : public UDeveloperSettings
{
public:
	class FString                                 Watermark;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayWatermark;                                 // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SecuritySettings">();
	}
	static class USecuritySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USecuritySettings>();
	}
};
static_assert(alignof(USecuritySettings) == 0x000008, "Wrong alignment on USecuritySettings");
static_assert(sizeof(USecuritySettings) == 0x000050, "Wrong size on USecuritySettings");
static_assert(offsetof(USecuritySettings, Watermark) == 0x000038, "Member 'USecuritySettings::Watermark' has a wrong offset!");
static_assert(offsetof(USecuritySettings, bDisplayWatermark) == 0x000048, "Member 'USecuritySettings::bDisplayWatermark' has a wrong offset!");

// Class Stalker2.GameInstanceSubsystemButtonStateDefiner
// 0x0010 (0x0040 - 0x0030)
class UGameInstanceSubsystemButtonStateDefiner final : public UMenuButtonStateDefiner
{
public:
	TArray<TSubclassOf<class UGameInstanceSubsystem>> ExcludeSubsystems;                             // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameInstanceSubsystemButtonStateDefiner">();
	}
	static class UGameInstanceSubsystemButtonStateDefiner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameInstanceSubsystemButtonStateDefiner>();
	}
};
static_assert(alignof(UGameInstanceSubsystemButtonStateDefiner) == 0x000008, "Wrong alignment on UGameInstanceSubsystemButtonStateDefiner");
static_assert(sizeof(UGameInstanceSubsystemButtonStateDefiner) == 0x000040, "Wrong size on UGameInstanceSubsystemButtonStateDefiner");
static_assert(offsetof(UGameInstanceSubsystemButtonStateDefiner, ExcludeSubsystems) == 0x000030, "Member 'UGameInstanceSubsystemButtonStateDefiner::ExcludeSubsystems' has a wrong offset!");

// Class Stalker2.PopupManager
// 0x0038 (0x00B0 - 0x0078)
class alignas(0x10) UPopupManager final : public UBaseManager
{
public:
	class UPopupView*                             PopupView;                                         // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x30];                                      // 0x0080(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupManager">();
	}
	static class UPopupManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupManager>();
	}
};
static_assert(alignof(UPopupManager) == 0x000010, "Wrong alignment on UPopupManager");
static_assert(sizeof(UPopupManager) == 0x0000B0, "Wrong size on UPopupManager");
static_assert(offsetof(UPopupManager, PopupView) == 0x000078, "Member 'UPopupManager::PopupView' has a wrong offset!");

// Class Stalker2.CameraManager
// 0x0198 (0x0240 - 0x00A8)
class UCameraManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       CameraComponent;                                   // 0x00F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerCameraManager*                   PlayerCameraManager;                               // 0x0100(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0xD8];                                     // 0x0108(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraModifier_LookAt*                 CachedCameraLookAtMod;                             // 0x01E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x30];                                     // 0x01E8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollectionInstance*   FovMPC;                                            // 0x0218(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollectionInstance*   EnvironmentMPC;                                    // 0x0238(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraManager">();
	}
	static class UCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraManager>();
	}
};
static_assert(alignof(UCameraManager) == 0x000008, "Wrong alignment on UCameraManager");
static_assert(sizeof(UCameraManager) == 0x000240, "Wrong size on UCameraManager");
static_assert(offsetof(UCameraManager, CameraComponent) == 0x0000F8, "Member 'UCameraManager::CameraComponent' has a wrong offset!");
static_assert(offsetof(UCameraManager, PlayerCameraManager) == 0x000100, "Member 'UCameraManager::PlayerCameraManager' has a wrong offset!");
static_assert(offsetof(UCameraManager, CachedCameraLookAtMod) == 0x0001E0, "Member 'UCameraManager::CachedCameraLookAtMod' has a wrong offset!");
static_assert(offsetof(UCameraManager, FovMPC) == 0x000218, "Member 'UCameraManager::FovMPC' has a wrong offset!");
static_assert(offsetof(UCameraManager, EnvironmentMPC) == 0x000238, "Member 'UCameraManager::EnvironmentMPC' has a wrong offset!");

// Class Stalker2.DamageVoiceoverComponent
// 0x0198 (0x0238 - 0x00A0)
class UDamageVoiceoverComponent final : public UActorComponent
{
public:
	class APC*                                    Owner;                                             // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x190];                                     // 0x00A8(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageVoiceoverComponent">();
	}
	static class UDamageVoiceoverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageVoiceoverComponent>();
	}
};
static_assert(alignof(UDamageVoiceoverComponent) == 0x000008, "Wrong alignment on UDamageVoiceoverComponent");
static_assert(sizeof(UDamageVoiceoverComponent) == 0x000238, "Wrong size on UDamageVoiceoverComponent");
static_assert(offsetof(UDamageVoiceoverComponent, Owner) == 0x0000A0, "Member 'UDamageVoiceoverComponent::Owner' has a wrong offset!");

// Class Stalker2.CameraModifier_AbilityCamModifier
// 0x00B8 (0x0100 - 0x0048)
class UCameraModifier_AbilityCamModifier final : public UCameraModifier
{
public:
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 NewTargetStageIndex)> OnStageChanged;                        // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x80];                                      // 0x0070(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAbilityCamModifierStage>       Stages;                                            // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void ResetCameraTargetLocation();
	void UpdateCameraTargetLocation(const struct FVector& NewLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifier_AbilityCamModifier">();
	}
	static class UCameraModifier_AbilityCamModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModifier_AbilityCamModifier>();
	}
};
static_assert(alignof(UCameraModifier_AbilityCamModifier) == 0x000008, "Wrong alignment on UCameraModifier_AbilityCamModifier");
static_assert(sizeof(UCameraModifier_AbilityCamModifier) == 0x000100, "Wrong size on UCameraModifier_AbilityCamModifier");
static_assert(offsetof(UCameraModifier_AbilityCamModifier, OnStageChanged) == 0x000060, "Member 'UCameraModifier_AbilityCamModifier::OnStageChanged' has a wrong offset!");
static_assert(offsetof(UCameraModifier_AbilityCamModifier, Stages) == 0x0000F0, "Member 'UCameraModifier_AbilityCamModifier::Stages' has a wrong offset!");

// Class Stalker2.ScenarioManager
// 0x0530 (0x05D8 - 0x00A8)
class UScenarioManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x480];                                     // 0x00A8(0x0480)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPlaySoundQuestNodeListener*>    PlaySoundQuestNodeListeners;                       // 0x0528(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0xA0];                                     // 0x0538(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioManager">();
	}
	static class UScenarioManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioManager>();
	}
};
static_assert(alignof(UScenarioManager) == 0x000008, "Wrong alignment on UScenarioManager");
static_assert(sizeof(UScenarioManager) == 0x0005D8, "Wrong size on UScenarioManager");
static_assert(offsetof(UScenarioManager, PlaySoundQuestNodeListeners) == 0x000528, "Member 'UScenarioManager::PlaySoundQuestNodeListeners' has a wrong offset!");

// Class Stalker2.CameraModifier_LookAt
// 0x0110 (0x0158 - 0x0048)
class UCameraModifier_LookAt final : public UCameraModifier
{
public:
	uint8                                         Pad_48[0xC0];                                      // 0x0048(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      PlayerController;                                  // 0x0108(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x48];                                     // 0x0110(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifier_LookAt">();
	}
	static class UCameraModifier_LookAt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModifier_LookAt>();
	}
};
static_assert(alignof(UCameraModifier_LookAt) == 0x000008, "Wrong alignment on UCameraModifier_LookAt");
static_assert(sizeof(UCameraModifier_LookAt) == 0x000158, "Wrong size on UCameraModifier_LookAt");
static_assert(offsetof(UCameraModifier_LookAt, PlayerController) == 0x000108, "Member 'UCameraModifier_LookAt::PlayerController' has a wrong offset!");

// Class Stalker2.CustomGrid
// 0x03D8 (0x0650 - 0x0278)
class UCustomGrid final : public UUserWidget
{
public:
	class UCanvasPanel*                           CanvasPanel;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTilingGridBack*                        TilingBack;                                        // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SizeY;                                             // 0x0288(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SizeX;                                             // 0x028C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class UCustomGridSlot*>           Widgets;                                           // 0x0290(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UCustomGridSlot*>                CachedWidgets;                                     // 0x02E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         GamepadCurrPosX;                                   // 0x02F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GamepadCurrPosY;                                   // 0x02F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           ItemPlacementPanel;                                // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            OwnerMoney;                                        // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScrollBox*                             GridScrollBox;                                     // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            HeaderText;                                        // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               GridSizeBox;                                       // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                ItemPlaceBorder;                                   // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           ScrollCanvasPanel;                                 // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                NavBorder;                                         // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           VerticalBoxScroll;                                 // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         MoneyBox;                                          // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 InfinityMoneyIcon;                                 // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDefaultScrollEnd;                                 // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowHeader;                                       // 0x0351(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_352[0x6];                                      // 0x0352(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeaderLocSID;                                      // 0x0358(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x68];                                     // 0x0368(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomGridSlot*                        CurrPickedWidget;                                  // 0x03D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryNew*                          InventoryNew;                                      // 0x03D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeightBar*                             WeightBar;                                         // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               WeightBarOverlay;                                  // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            WeightText;                                        // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            MaxWeightText;                                     // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            WeightUnits;                                       // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            LootSeparator;                                     // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 WeightIcon;                                        // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PositiveHighlight;                                 // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 NegativeHighlight;                                 // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BeforeGamepadNavigationDelay;                      // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadNavigationThreshold;                        // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadNavigationDelay;                            // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebugNavigationLines;                         // 0x043C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43D[0x3];                                      // 0x043D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            NavCurve;                                          // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VisibleCells;                                      // 0x0448(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PositiveHighlightTexture;                          // 0x0458(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              NegativeHighlightTexture;                          // 0x0488(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScrollMovementSpeed;                               // 0x04B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                ItemSlotWidgetClass;                               // 0x04C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryScrollChangeConsole;                      // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CellSize;                                          // 0x04CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D0[0x10];                                     // 0x04D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemDragWidget*                        CurrMovingWidget;                                  // 0x04E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            MousePosTargetWidget;                              // 0x04E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x158];                                    // 0x04F0(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavPosChangeAnimSpeed;                             // 0x0648(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64C[0x4];                                      // 0x064C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnScrollBarScrolled(float Offset);
	void SetCurrentCellDelayed();
	void SetTargetCellDelayed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomGrid">();
	}
	static class UCustomGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomGrid>();
	}
};
static_assert(alignof(UCustomGrid) == 0x000008, "Wrong alignment on UCustomGrid");
static_assert(sizeof(UCustomGrid) == 0x000650, "Wrong size on UCustomGrid");
static_assert(offsetof(UCustomGrid, CanvasPanel) == 0x000278, "Member 'UCustomGrid::CanvasPanel' has a wrong offset!");
static_assert(offsetof(UCustomGrid, TilingBack) == 0x000280, "Member 'UCustomGrid::TilingBack' has a wrong offset!");
static_assert(offsetof(UCustomGrid, SizeY) == 0x000288, "Member 'UCustomGrid::SizeY' has a wrong offset!");
static_assert(offsetof(UCustomGrid, SizeX) == 0x00028C, "Member 'UCustomGrid::SizeX' has a wrong offset!");
static_assert(offsetof(UCustomGrid, Widgets) == 0x000290, "Member 'UCustomGrid::Widgets' has a wrong offset!");
static_assert(offsetof(UCustomGrid, CachedWidgets) == 0x0002E0, "Member 'UCustomGrid::CachedWidgets' has a wrong offset!");
static_assert(offsetof(UCustomGrid, GamepadCurrPosX) == 0x0002F0, "Member 'UCustomGrid::GamepadCurrPosX' has a wrong offset!");
static_assert(offsetof(UCustomGrid, GamepadCurrPosY) == 0x0002F4, "Member 'UCustomGrid::GamepadCurrPosY' has a wrong offset!");
static_assert(offsetof(UCustomGrid, ItemPlacementPanel) == 0x0002F8, "Member 'UCustomGrid::ItemPlacementPanel' has a wrong offset!");
static_assert(offsetof(UCustomGrid, OwnerMoney) == 0x000300, "Member 'UCustomGrid::OwnerMoney' has a wrong offset!");
static_assert(offsetof(UCustomGrid, GridScrollBox) == 0x000308, "Member 'UCustomGrid::GridScrollBox' has a wrong offset!");
static_assert(offsetof(UCustomGrid, HeaderText) == 0x000310, "Member 'UCustomGrid::HeaderText' has a wrong offset!");
static_assert(offsetof(UCustomGrid, GridSizeBox) == 0x000318, "Member 'UCustomGrid::GridSizeBox' has a wrong offset!");
static_assert(offsetof(UCustomGrid, ItemPlaceBorder) == 0x000320, "Member 'UCustomGrid::ItemPlaceBorder' has a wrong offset!");
static_assert(offsetof(UCustomGrid, ScrollCanvasPanel) == 0x000328, "Member 'UCustomGrid::ScrollCanvasPanel' has a wrong offset!");
static_assert(offsetof(UCustomGrid, NavBorder) == 0x000330, "Member 'UCustomGrid::NavBorder' has a wrong offset!");
static_assert(offsetof(UCustomGrid, VerticalBoxScroll) == 0x000338, "Member 'UCustomGrid::VerticalBoxScroll' has a wrong offset!");
static_assert(offsetof(UCustomGrid, MoneyBox) == 0x000340, "Member 'UCustomGrid::MoneyBox' has a wrong offset!");
static_assert(offsetof(UCustomGrid, InfinityMoneyIcon) == 0x000348, "Member 'UCustomGrid::InfinityMoneyIcon' has a wrong offset!");
static_assert(offsetof(UCustomGrid, bDefaultScrollEnd) == 0x000350, "Member 'UCustomGrid::bDefaultScrollEnd' has a wrong offset!");
static_assert(offsetof(UCustomGrid, bShowHeader) == 0x000351, "Member 'UCustomGrid::bShowHeader' has a wrong offset!");
static_assert(offsetof(UCustomGrid, HeaderLocSID) == 0x000358, "Member 'UCustomGrid::HeaderLocSID' has a wrong offset!");
static_assert(offsetof(UCustomGrid, CurrPickedWidget) == 0x0003D0, "Member 'UCustomGrid::CurrPickedWidget' has a wrong offset!");
static_assert(offsetof(UCustomGrid, InventoryNew) == 0x0003D8, "Member 'UCustomGrid::InventoryNew' has a wrong offset!");
static_assert(offsetof(UCustomGrid, WeightBar) == 0x0003E0, "Member 'UCustomGrid::WeightBar' has a wrong offset!");
static_assert(offsetof(UCustomGrid, WeightBarOverlay) == 0x0003E8, "Member 'UCustomGrid::WeightBarOverlay' has a wrong offset!");
static_assert(offsetof(UCustomGrid, WeightText) == 0x0003F0, "Member 'UCustomGrid::WeightText' has a wrong offset!");
static_assert(offsetof(UCustomGrid, MaxWeightText) == 0x0003F8, "Member 'UCustomGrid::MaxWeightText' has a wrong offset!");
static_assert(offsetof(UCustomGrid, WeightUnits) == 0x000400, "Member 'UCustomGrid::WeightUnits' has a wrong offset!");
static_assert(offsetof(UCustomGrid, LootSeparator) == 0x000408, "Member 'UCustomGrid::LootSeparator' has a wrong offset!");
static_assert(offsetof(UCustomGrid, WeightIcon) == 0x000410, "Member 'UCustomGrid::WeightIcon' has a wrong offset!");
static_assert(offsetof(UCustomGrid, PositiveHighlight) == 0x000418, "Member 'UCustomGrid::PositiveHighlight' has a wrong offset!");
static_assert(offsetof(UCustomGrid, NegativeHighlight) == 0x000420, "Member 'UCustomGrid::NegativeHighlight' has a wrong offset!");
static_assert(offsetof(UCustomGrid, BeforeGamepadNavigationDelay) == 0x000430, "Member 'UCustomGrid::BeforeGamepadNavigationDelay' has a wrong offset!");
static_assert(offsetof(UCustomGrid, GamepadNavigationThreshold) == 0x000434, "Member 'UCustomGrid::GamepadNavigationThreshold' has a wrong offset!");
static_assert(offsetof(UCustomGrid, GamepadNavigationDelay) == 0x000438, "Member 'UCustomGrid::GamepadNavigationDelay' has a wrong offset!");
static_assert(offsetof(UCustomGrid, bDrawDebugNavigationLines) == 0x00043C, "Member 'UCustomGrid::bDrawDebugNavigationLines' has a wrong offset!");
static_assert(offsetof(UCustomGrid, NavCurve) == 0x000440, "Member 'UCustomGrid::NavCurve' has a wrong offset!");
static_assert(offsetof(UCustomGrid, VisibleCells) == 0x000448, "Member 'UCustomGrid::VisibleCells' has a wrong offset!");
static_assert(offsetof(UCustomGrid, PositiveHighlightTexture) == 0x000458, "Member 'UCustomGrid::PositiveHighlightTexture' has a wrong offset!");
static_assert(offsetof(UCustomGrid, NegativeHighlightTexture) == 0x000488, "Member 'UCustomGrid::NegativeHighlightTexture' has a wrong offset!");
static_assert(offsetof(UCustomGrid, ScrollMovementSpeed) == 0x0004B8, "Member 'UCustomGrid::ScrollMovementSpeed' has a wrong offset!");
static_assert(offsetof(UCustomGrid, ItemSlotWidgetClass) == 0x0004C0, "Member 'UCustomGrid::ItemSlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UCustomGrid, InventoryScrollChangeConsole) == 0x0004C8, "Member 'UCustomGrid::InventoryScrollChangeConsole' has a wrong offset!");
static_assert(offsetof(UCustomGrid, CellSize) == 0x0004CC, "Member 'UCustomGrid::CellSize' has a wrong offset!");
static_assert(offsetof(UCustomGrid, CurrMovingWidget) == 0x0004E0, "Member 'UCustomGrid::CurrMovingWidget' has a wrong offset!");
static_assert(offsetof(UCustomGrid, MousePosTargetWidget) == 0x0004E8, "Member 'UCustomGrid::MousePosTargetWidget' has a wrong offset!");
static_assert(offsetof(UCustomGrid, NavPosChangeAnimSpeed) == 0x000648, "Member 'UCustomGrid::NavPosChangeAnimSpeed' has a wrong offset!");

// Class Stalker2.CameraModifier_PsyAttackFocusTarget
// 0x0058 (0x00A0 - 0x0048)
class UCameraModifier_PsyAttackFocusTarget final : public UCameraModifier
{
public:
	uint8                                         Pad_48[0x58];                                      // 0x0048(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifier_PsyAttackFocusTarget">();
	}
	static class UCameraModifier_PsyAttackFocusTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModifier_PsyAttackFocusTarget>();
	}
};
static_assert(alignof(UCameraModifier_PsyAttackFocusTarget) == 0x000008, "Wrong alignment on UCameraModifier_PsyAttackFocusTarget");
static_assert(sizeof(UCameraModifier_PsyAttackFocusTarget) == 0x0000A0, "Wrong size on UCameraModifier_PsyAttackFocusTarget");

// Class Stalker2.CameraModifier_ResetRelativeRotation
// 0x0008 (0x0050 - 0x0048)
class UCameraModifier_ResetRelativeRotation final : public UCameraModifier
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifier_ResetRelativeRotation">();
	}
	static class UCameraModifier_ResetRelativeRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModifier_ResetRelativeRotation>();
	}
};
static_assert(alignof(UCameraModifier_ResetRelativeRotation) == 0x000008, "Wrong alignment on UCameraModifier_ResetRelativeRotation");
static_assert(sizeof(UCameraModifier_ResetRelativeRotation) == 0x000050, "Wrong size on UCameraModifier_ResetRelativeRotation");

// Class Stalker2.MutantAnimCollection
// 0x0108 (0x0130 - 0x0028)
class UMutantAnimCollection final : public UObject
{
public:
	TArray<class UAnimMontage*>                   ClawAttacks;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UAnimMontage*>                   JumpAttacks;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EAttackDirection, class UAnimMontage*>   RunAttacks;                                        // 0x0048(0x0050)(Edit, BlueprintVisible, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UAnimMontage*                           Sleep;                                             // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      ReactionOnEmission;                                // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      Idle;                                              // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EAnomalyAnimInteraction, class UAnimMontage*> AnomalyInteractions;                          // 0x00B0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FPoseSearchLocomotionAnimCollectionData PoseSearchLocomotionAnimCollectionData;           // 0x0100(0x0030)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MutantAnimCollection">();
	}
	static class UMutantAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMutantAnimCollection>();
	}
};
static_assert(alignof(UMutantAnimCollection) == 0x000008, "Wrong alignment on UMutantAnimCollection");
static_assert(sizeof(UMutantAnimCollection) == 0x000130, "Wrong size on UMutantAnimCollection");
static_assert(offsetof(UMutantAnimCollection, ClawAttacks) == 0x000028, "Member 'UMutantAnimCollection::ClawAttacks' has a wrong offset!");
static_assert(offsetof(UMutantAnimCollection, JumpAttacks) == 0x000038, "Member 'UMutantAnimCollection::JumpAttacks' has a wrong offset!");
static_assert(offsetof(UMutantAnimCollection, RunAttacks) == 0x000048, "Member 'UMutantAnimCollection::RunAttacks' has a wrong offset!");
static_assert(offsetof(UMutantAnimCollection, Sleep) == 0x000098, "Member 'UMutantAnimCollection::Sleep' has a wrong offset!");
static_assert(offsetof(UMutantAnimCollection, ReactionOnEmission) == 0x0000A0, "Member 'UMutantAnimCollection::ReactionOnEmission' has a wrong offset!");
static_assert(offsetof(UMutantAnimCollection, Idle) == 0x0000A8, "Member 'UMutantAnimCollection::Idle' has a wrong offset!");
static_assert(offsetof(UMutantAnimCollection, AnomalyInteractions) == 0x0000B0, "Member 'UMutantAnimCollection::AnomalyInteractions' has a wrong offset!");
static_assert(offsetof(UMutantAnimCollection, PoseSearchLocomotionAnimCollectionData) == 0x000100, "Member 'UMutantAnimCollection::PoseSearchLocomotionAnimCollectionData' has a wrong offset!");

// Class Stalker2.DealDamageComponent
// 0x0010 (0x00B0 - 0x00A0)
class UDealDamageComponent final : public UActorComponent
{
public:
	float                                         Damage;                                            // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ArmorDamage;                                       // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ArmorPiercing;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDamageType                                   DamageType;                                        // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDamageSource                                 DamageSource;                                      // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DealDamage(const class AActor* InTargetActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DealDamageComponent">();
	}
	static class UDealDamageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDealDamageComponent>();
	}
};
static_assert(alignof(UDealDamageComponent) == 0x000008, "Wrong alignment on UDealDamageComponent");
static_assert(sizeof(UDealDamageComponent) == 0x0000B0, "Wrong size on UDealDamageComponent");
static_assert(offsetof(UDealDamageComponent, Damage) == 0x0000A0, "Member 'UDealDamageComponent::Damage' has a wrong offset!");
static_assert(offsetof(UDealDamageComponent, ArmorDamage) == 0x0000A4, "Member 'UDealDamageComponent::ArmorDamage' has a wrong offset!");
static_assert(offsetof(UDealDamageComponent, ArmorPiercing) == 0x0000A8, "Member 'UDealDamageComponent::ArmorPiercing' has a wrong offset!");
static_assert(offsetof(UDealDamageComponent, DamageType) == 0x0000AC, "Member 'UDealDamageComponent::DamageType' has a wrong offset!");
static_assert(offsetof(UDealDamageComponent, DamageSource) == 0x0000AD, "Member 'UDealDamageComponent::DamageSource' has a wrong offset!");

// Class Stalker2.CampaignManager
// 0x00C0 (0x0138 - 0x0078)
class UCampaignManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0xB0];                                      // 0x0078(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class USaveLoadIO*                            SaveLoadIO;                                        // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampaignManager">();
	}
	static class UCampaignManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCampaignManager>();
	}
};
static_assert(alignof(UCampaignManager) == 0x000008, "Wrong alignment on UCampaignManager");
static_assert(sizeof(UCampaignManager) == 0x000138, "Wrong size on UCampaignManager");
static_assert(offsetof(UCampaignManager, SaveLoadIO) == 0x000128, "Member 'UCampaignManager::SaveLoadIO' has a wrong offset!");

// Class Stalker2.PDAOpenIPU
// 0x0000 (0x0040 - 0x0040)
class UPDAOpenIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAOpenIPU">();
	}
	static class UPDAOpenIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAOpenIPU>();
	}
};
static_assert(alignof(UPDAOpenIPU) == 0x000008, "Wrong alignment on UPDAOpenIPU");
static_assert(sizeof(UPDAOpenIPU) == 0x000040, "Wrong size on UPDAOpenIPU");

// Class Stalker2.DifficultyButton
// 0x0018 (0x0318 - 0x0300)
class UDifficultyButton final : public UMenuButtonBase
{
public:
	class UImage*                                 DifficultyImage;                                   // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            DifficultyName;                                    // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            DifficultyDescription;                             // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DifficultyButton">();
	}
	static class UDifficultyButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDifficultyButton>();
	}
};
static_assert(alignof(UDifficultyButton) == 0x000008, "Wrong alignment on UDifficultyButton");
static_assert(sizeof(UDifficultyButton) == 0x000318, "Wrong size on UDifficultyButton");
static_assert(offsetof(UDifficultyButton, DifficultyImage) == 0x000300, "Member 'UDifficultyButton::DifficultyImage' has a wrong offset!");
static_assert(offsetof(UDifficultyButton, DifficultyName) == 0x000308, "Member 'UDifficultyButton::DifficultyName' has a wrong offset!");
static_assert(offsetof(UDifficultyButton, DifficultyDescription) == 0x000310, "Member 'UDifficultyButton::DifficultyDescription' has a wrong offset!");

// Class Stalker2.CampaignSlotButton
// 0x0088 (0x0388 - 0x0300)
class UCampaignSlotButton final : public UMenuButtonBase
{
public:
	class UTextWidget*                            SlotIndex;                                         // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            LastSaveName;                                      // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            LastSaveDateTime;                                  // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            LastSaveLocationName;                              // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            LastSaveDifficulty;                                // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LastSaveThumbnail;                                 // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Background;                                        // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            DifficultyPrefix;                                  // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            DifficultyDots;                                    // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            RegionPrefix;                                      // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            RegionDots;                                        // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DateTimeFormat;                                    // 0x0358(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 EmptySlotNameSID;                                  // 0x0368(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UTexture2D>>      SaveIcons;                                         // 0x0378(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampaignSlotButton">();
	}
	static class UCampaignSlotButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCampaignSlotButton>();
	}
};
static_assert(alignof(UCampaignSlotButton) == 0x000008, "Wrong alignment on UCampaignSlotButton");
static_assert(sizeof(UCampaignSlotButton) == 0x000388, "Wrong size on UCampaignSlotButton");
static_assert(offsetof(UCampaignSlotButton, SlotIndex) == 0x000300, "Member 'UCampaignSlotButton::SlotIndex' has a wrong offset!");
static_assert(offsetof(UCampaignSlotButton, LastSaveName) == 0x000308, "Member 'UCampaignSlotButton::LastSaveName' has a wrong offset!");
static_assert(offsetof(UCampaignSlotButton, LastSaveDateTime) == 0x000310, "Member 'UCampaignSlotButton::LastSaveDateTime' has a wrong offset!");
static_assert(offsetof(UCampaignSlotButton, LastSaveLocationName) == 0x000318, "Member 'UCampaignSlotButton::LastSaveLocationName' has a wrong offset!");
static_assert(offsetof(UCampaignSlotButton, LastSaveDifficulty) == 0x000320, "Member 'UCampaignSlotButton::LastSaveDifficulty' has a wrong offset!");
static_assert(offsetof(UCampaignSlotButton, LastSaveThumbnail) == 0x000328, "Member 'UCampaignSlotButton::LastSaveThumbnail' has a wrong offset!");
static_assert(offsetof(UCampaignSlotButton, Background) == 0x000330, "Member 'UCampaignSlotButton::Background' has a wrong offset!");
static_assert(offsetof(UCampaignSlotButton, DifficultyPrefix) == 0x000338, "Member 'UCampaignSlotButton::DifficultyPrefix' has a wrong offset!");
static_assert(offsetof(UCampaignSlotButton, DifficultyDots) == 0x000340, "Member 'UCampaignSlotButton::DifficultyDots' has a wrong offset!");
static_assert(offsetof(UCampaignSlotButton, RegionPrefix) == 0x000348, "Member 'UCampaignSlotButton::RegionPrefix' has a wrong offset!");
static_assert(offsetof(UCampaignSlotButton, RegionDots) == 0x000350, "Member 'UCampaignSlotButton::RegionDots' has a wrong offset!");
static_assert(offsetof(UCampaignSlotButton, DateTimeFormat) == 0x000358, "Member 'UCampaignSlotButton::DateTimeFormat' has a wrong offset!");
static_assert(offsetof(UCampaignSlotButton, EmptySlotNameSID) == 0x000368, "Member 'UCampaignSlotButton::EmptySlotNameSID' has a wrong offset!");
static_assert(offsetof(UCampaignSlotButton, SaveIcons) == 0x000378, "Member 'UCampaignSlotButton::SaveIcons' has a wrong offset!");

// Class Stalker2.PlaySoundQuestNodeListener
// 0x0008 (0x0030 - 0x0028)
class UPlaySoundQuestNodeListener final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSoundFinished(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaySoundQuestNodeListener">();
	}
	static class UPlaySoundQuestNodeListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaySoundQuestNodeListener>();
	}
};
static_assert(alignof(UPlaySoundQuestNodeListener) == 0x000008, "Wrong alignment on UPlaySoundQuestNodeListener");
static_assert(sizeof(UPlaySoundQuestNodeListener) == 0x000030, "Wrong size on UPlaySoundQuestNodeListener");

// Class Stalker2.DebugHUDView
// 0x0050 (0x0310 - 0x02C0)
class UDebugHUDView final : public UViewBase
{
public:
	class UTextBlock*                             HourText;                                          // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             MinutesText;                                       // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             DataText;                                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         MiniMapPanel;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         DataTimePanel;                                     // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStatPanelDebug*                        StatPanelDebug;                                    // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x20];                                     // 0x02F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugHUDView">();
	}
	static class UDebugHUDView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugHUDView>();
	}
};
static_assert(alignof(UDebugHUDView) == 0x000008, "Wrong alignment on UDebugHUDView");
static_assert(sizeof(UDebugHUDView) == 0x000310, "Wrong size on UDebugHUDView");
static_assert(offsetof(UDebugHUDView, HourText) == 0x0002C0, "Member 'UDebugHUDView::HourText' has a wrong offset!");
static_assert(offsetof(UDebugHUDView, MinutesText) == 0x0002C8, "Member 'UDebugHUDView::MinutesText' has a wrong offset!");
static_assert(offsetof(UDebugHUDView, DataText) == 0x0002D0, "Member 'UDebugHUDView::DataText' has a wrong offset!");
static_assert(offsetof(UDebugHUDView, MiniMapPanel) == 0x0002D8, "Member 'UDebugHUDView::MiniMapPanel' has a wrong offset!");
static_assert(offsetof(UDebugHUDView, DataTimePanel) == 0x0002E0, "Member 'UDebugHUDView::DataTimePanel' has a wrong offset!");
static_assert(offsetof(UDebugHUDView, StatPanelDebug) == 0x0002E8, "Member 'UDebugHUDView::StatPanelDebug' has a wrong offset!");

// Class Stalker2.CampaignSlotsSubView
// 0x0040 (0x0310 - 0x02D0)
class UCampaignSlotsSubView final : public UMenuSubViewBase
{
public:
	TSubclassOf<class UCampaignSlotButton>        CampaignSlotButtonClass;                           // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCampaignSlotButton>        EmptyCampaignSlotButtonClass;                      // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuButtonActionBase*                  EmptyCampaignSlotButtonAction;                     // 0x02E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuButtonActionBase*                  CampaignSlotButtonAction;                          // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FShortcutData>                  CampaignSlotButtonShortcuts;                       // 0x02F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FShortcutData>                  EmptyCampaignSlotButtonShortcuts;                  // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampaignSlotsSubView">();
	}
	static class UCampaignSlotsSubView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCampaignSlotsSubView>();
	}
};
static_assert(alignof(UCampaignSlotsSubView) == 0x000008, "Wrong alignment on UCampaignSlotsSubView");
static_assert(sizeof(UCampaignSlotsSubView) == 0x000310, "Wrong size on UCampaignSlotsSubView");
static_assert(offsetof(UCampaignSlotsSubView, CampaignSlotButtonClass) == 0x0002D0, "Member 'UCampaignSlotsSubView::CampaignSlotButtonClass' has a wrong offset!");
static_assert(offsetof(UCampaignSlotsSubView, EmptyCampaignSlotButtonClass) == 0x0002D8, "Member 'UCampaignSlotsSubView::EmptyCampaignSlotButtonClass' has a wrong offset!");
static_assert(offsetof(UCampaignSlotsSubView, EmptyCampaignSlotButtonAction) == 0x0002E0, "Member 'UCampaignSlotsSubView::EmptyCampaignSlotButtonAction' has a wrong offset!");
static_assert(offsetof(UCampaignSlotsSubView, CampaignSlotButtonAction) == 0x0002E8, "Member 'UCampaignSlotsSubView::CampaignSlotButtonAction' has a wrong offset!");
static_assert(offsetof(UCampaignSlotsSubView, CampaignSlotButtonShortcuts) == 0x0002F0, "Member 'UCampaignSlotsSubView::CampaignSlotButtonShortcuts' has a wrong offset!");
static_assert(offsetof(UCampaignSlotsSubView, EmptyCampaignSlotButtonShortcuts) == 0x000300, "Member 'UCampaignSlotsSubView::EmptyCampaignSlotButtonShortcuts' has a wrong offset!");

// Class Stalker2.ModelCharacterMovementComponent
// 0x0000 (0x0F00 - 0x0F00)
class UModelCharacterMovementComponent : public UCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModelCharacterMovementComponent">();
	}
	static class UModelCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModelCharacterMovementComponent>();
	}
};
static_assert(alignof(UModelCharacterMovementComponent) == 0x000010, "Wrong alignment on UModelCharacterMovementComponent");
static_assert(sizeof(UModelCharacterMovementComponent) == 0x000F00, "Wrong size on UModelCharacterMovementComponent");

// Class Stalker2.PoseSearchLocomotionCharacterMovementComponent
// 0x02C0 (0x11C0 - 0x0F00)
class UPoseSearchLocomotionCharacterMovementComponent final : public UModelCharacterMovementComponent
{
public:
	float                                         NavWalkingSearchFloorScale;                        // 0x0F00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNavWalkingOrientToSlope;                          // 0x0F04(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F05[0x3];                                      // 0x0F05(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavWalkingOrientToSlopeInterpolationSpeed;         // 0x0F08(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0C[0x10];                                     // 0x0F0C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FutureLocationPredictionTime;                      // 0x0F1C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PredictionBlockedAngle;                            // 0x0F20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F24[0x29C];                                    // 0x0F24(0x029C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoseSearchLocomotionCharacterMovementComponent">();
	}
	static class UPoseSearchLocomotionCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoseSearchLocomotionCharacterMovementComponent>();
	}
};
static_assert(alignof(UPoseSearchLocomotionCharacterMovementComponent) == 0x000010, "Wrong alignment on UPoseSearchLocomotionCharacterMovementComponent");
static_assert(sizeof(UPoseSearchLocomotionCharacterMovementComponent) == 0x0011C0, "Wrong size on UPoseSearchLocomotionCharacterMovementComponent");
static_assert(offsetof(UPoseSearchLocomotionCharacterMovementComponent, NavWalkingSearchFloorScale) == 0x000F00, "Member 'UPoseSearchLocomotionCharacterMovementComponent::NavWalkingSearchFloorScale' has a wrong offset!");
static_assert(offsetof(UPoseSearchLocomotionCharacterMovementComponent, bNavWalkingOrientToSlope) == 0x000F04, "Member 'UPoseSearchLocomotionCharacterMovementComponent::bNavWalkingOrientToSlope' has a wrong offset!");
static_assert(offsetof(UPoseSearchLocomotionCharacterMovementComponent, NavWalkingOrientToSlopeInterpolationSpeed) == 0x000F08, "Member 'UPoseSearchLocomotionCharacterMovementComponent::NavWalkingOrientToSlopeInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UPoseSearchLocomotionCharacterMovementComponent, FutureLocationPredictionTime) == 0x000F1C, "Member 'UPoseSearchLocomotionCharacterMovementComponent::FutureLocationPredictionTime' has a wrong offset!");
static_assert(offsetof(UPoseSearchLocomotionCharacterMovementComponent, PredictionBlockedAngle) == 0x000F20, "Member 'UPoseSearchLocomotionCharacterMovementComponent::PredictionBlockedAngle' has a wrong offset!");

// Class Stalker2.CarouselAnomaly
// 0x00F8 (0x0490 - 0x0398)
class ACarouselAnomaly final : public AAnomaly
{
public:
	class UStaticMeshComponent*                   CollisionMeshPtr;                                  // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      IdleParticle;                                      // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ActivateParticle;                                  // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         InteractionParticle;                               // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         ActionDamagePlayerParticle;                        // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         ActionDamageNPCParticle;                           // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         WaterContactParticle;                              // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraSystem>          BodyExplodeParticle;                               // 0x03D0(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrototypeSID                          BodyExplodeStashSID;                               // 0x0400(0x0040)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           InteractionSoundEvent;                             // 0x0440(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x20];                                     // 0x0470(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CarouselAnomaly">();
	}
	static class ACarouselAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACarouselAnomaly>();
	}
};
static_assert(alignof(ACarouselAnomaly) == 0x000008, "Wrong alignment on ACarouselAnomaly");
static_assert(sizeof(ACarouselAnomaly) == 0x000490, "Wrong size on ACarouselAnomaly");
static_assert(offsetof(ACarouselAnomaly, CollisionMeshPtr) == 0x000398, "Member 'ACarouselAnomaly::CollisionMeshPtr' has a wrong offset!");
static_assert(offsetof(ACarouselAnomaly, IdleParticle) == 0x0003A0, "Member 'ACarouselAnomaly::IdleParticle' has a wrong offset!");
static_assert(offsetof(ACarouselAnomaly, ActivateParticle) == 0x0003A8, "Member 'ACarouselAnomaly::ActivateParticle' has a wrong offset!");
static_assert(offsetof(ACarouselAnomaly, InteractionParticle) == 0x0003B0, "Member 'ACarouselAnomaly::InteractionParticle' has a wrong offset!");
static_assert(offsetof(ACarouselAnomaly, ActionDamagePlayerParticle) == 0x0003B8, "Member 'ACarouselAnomaly::ActionDamagePlayerParticle' has a wrong offset!");
static_assert(offsetof(ACarouselAnomaly, ActionDamageNPCParticle) == 0x0003C0, "Member 'ACarouselAnomaly::ActionDamageNPCParticle' has a wrong offset!");
static_assert(offsetof(ACarouselAnomaly, WaterContactParticle) == 0x0003C8, "Member 'ACarouselAnomaly::WaterContactParticle' has a wrong offset!");
static_assert(offsetof(ACarouselAnomaly, BodyExplodeParticle) == 0x0003D0, "Member 'ACarouselAnomaly::BodyExplodeParticle' has a wrong offset!");
static_assert(offsetof(ACarouselAnomaly, BodyExplodeStashSID) == 0x000400, "Member 'ACarouselAnomaly::BodyExplodeStashSID' has a wrong offset!");
static_assert(offsetof(ACarouselAnomaly, InteractionSoundEvent) == 0x000440, "Member 'ACarouselAnomaly::InteractionSoundEvent' has a wrong offset!");

// Class Stalker2.CutsceneTurnIPU
// 0x0000 (0x0040 - 0x0040)
class UCutsceneTurnIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CutsceneTurnIPU">();
	}
	static class UCutsceneTurnIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCutsceneTurnIPU>();
	}
};
static_assert(alignof(UCutsceneTurnIPU) == 0x000008, "Wrong alignment on UCutsceneTurnIPU");
static_assert(sizeof(UCutsceneTurnIPU) == 0x000040, "Wrong size on UCutsceneTurnIPU");

// Class Stalker2.ChangeMagazineToRoundIPU
// 0x0000 (0x0040 - 0x0040)
class UChangeMagazineToRoundIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeMagazineToRoundIPU">();
	}
	static class UChangeMagazineToRoundIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeMagazineToRoundIPU>();
	}
};
static_assert(alignof(UChangeMagazineToRoundIPU) == 0x000008, "Wrong alignment on UChangeMagazineToRoundIPU");
static_assert(sizeof(UChangeMagazineToRoundIPU) == 0x000040, "Wrong size on UChangeMagazineToRoundIPU");

// Class Stalker2.ChangeMagazineToTwinIPU
// 0x0000 (0x0040 - 0x0040)
class UChangeMagazineToTwinIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeMagazineToTwinIPU">();
	}
	static class UChangeMagazineToTwinIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeMagazineToTwinIPU>();
	}
};
static_assert(alignof(UChangeMagazineToTwinIPU) == 0x000008, "Wrong alignment on UChangeMagazineToTwinIPU");
static_assert(sizeof(UChangeMagazineToTwinIPU) == 0x000040, "Wrong size on UChangeMagazineToTwinIPU");

// Class Stalker2.PlayerCodelockAnimCollection
// 0x0008 (0x0030 - 0x0028)
class UPlayerCodelockAnimCollection final : public UObject
{
public:
	struct FCodelockInteractionAnimations         CodelockInteractionAnimations;                     // 0x0028(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCodelockAnimCollection">();
	}
	static class UPlayerCodelockAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCodelockAnimCollection>();
	}
};
static_assert(alignof(UPlayerCodelockAnimCollection) == 0x000008, "Wrong alignment on UPlayerCodelockAnimCollection");
static_assert(sizeof(UPlayerCodelockAnimCollection) == 0x000030, "Wrong size on UPlayerCodelockAnimCollection");
static_assert(offsetof(UPlayerCodelockAnimCollection, CodelockInteractionAnimations) == 0x000028, "Member 'UPlayerCodelockAnimCollection::CodelockInteractionAnimations' has a wrong offset!");

// Class Stalker2.DebugTextLineWidget
// 0x0010 (0x02B8 - 0x02A8)
class UDebugTextLineWidget final : public UDebugTextWidgetBase
{
public:
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetIndecRowSettings(int32 CurrentRow, const TArray<struct FRengeSettings>& RowSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugTextLineWidget">();
	}
	static class UDebugTextLineWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugTextLineWidget>();
	}
};
static_assert(alignof(UDebugTextLineWidget) == 0x000008, "Wrong alignment on UDebugTextLineWidget");
static_assert(sizeof(UDebugTextLineWidget) == 0x0002B8, "Wrong size on UDebugTextLineWidget");

// Class Stalker2.ChangeScopeZoomIPU
// 0x0000 (0x0040 - 0x0040)
class UChangeScopeZoomIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeScopeZoomIPU">();
	}
	static class UChangeScopeZoomIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeScopeZoomIPU>();
	}
};
static_assert(alignof(UChangeScopeZoomIPU) == 0x000008, "Wrong alignment on UChangeScopeZoomIPU");
static_assert(sizeof(UChangeScopeZoomIPU) == 0x000040, "Wrong size on UChangeScopeZoomIPU");

// Class Stalker2.ChangeWidgetSwitcher
// 0x0010 (0x0190 - 0x0180)
class UChangeWidgetSwitcher final : public UWidgetSwitcher
{
public:
	class FName                                   SwitcherId;                                        // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PreConstructUpdate();
	void PreDestructUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeWidgetSwitcher">();
	}
	static class UChangeWidgetSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeWidgetSwitcher>();
	}
};
static_assert(alignof(UChangeWidgetSwitcher) == 0x000008, "Wrong alignment on UChangeWidgetSwitcher");
static_assert(sizeof(UChangeWidgetSwitcher) == 0x000190, "Wrong size on UChangeWidgetSwitcher");
static_assert(offsetof(UChangeWidgetSwitcher, SwitcherId) == 0x000180, "Member 'UChangeWidgetSwitcher::SwitcherId' has a wrong offset!");

// Class Stalker2.PillowAnomaly
// 0x0080 (0x0418 - 0x0398)
class APillowAnomaly final : public AAnomaly
{
public:
	class UStaticMeshComponent*                   CollisionMesh;                                     // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      IdleParticle;                                      // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         InteractParticle;                                  // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPillowAnomalyBiomeType, TSoftObjectPtr<class UNiagaraSystem>> BiomeParticles;              // 0x03B0(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x18];                                     // 0x0400(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PillowAnomaly">();
	}
	static class APillowAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<APillowAnomaly>();
	}
};
static_assert(alignof(APillowAnomaly) == 0x000008, "Wrong alignment on APillowAnomaly");
static_assert(sizeof(APillowAnomaly) == 0x000418, "Wrong size on APillowAnomaly");
static_assert(offsetof(APillowAnomaly, CollisionMesh) == 0x000398, "Member 'APillowAnomaly::CollisionMesh' has a wrong offset!");
static_assert(offsetof(APillowAnomaly, IdleParticle) == 0x0003A0, "Member 'APillowAnomaly::IdleParticle' has a wrong offset!");
static_assert(offsetof(APillowAnomaly, InteractParticle) == 0x0003A8, "Member 'APillowAnomaly::InteractParticle' has a wrong offset!");
static_assert(offsetof(APillowAnomaly, BiomeParticles) == 0x0003B0, "Member 'APillowAnomaly::BiomeParticles' has a wrong offset!");

// Class Stalker2.CustomConsoleManagerWP
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerWP final : public UBaseConsoleManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerWP">();
	}
	static class UCustomConsoleManagerWP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerWP>();
	}
};
static_assert(alignof(UCustomConsoleManagerWP) == 0x000008, "Wrong alignment on UCustomConsoleManagerWP");
static_assert(sizeof(UCustomConsoleManagerWP) == 0x0000A8, "Wrong size on UCustomConsoleManagerWP");

// Class Stalker2.CharacterStatSlot
// 0x0028 (0x02A0 - 0x0278)
class UCharacterStatSlot final : public UWidgetBase
{
public:
	class UImage*                                 StatImage;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ProgressImage;                                     // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ProgressBeckground;                                // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldShowProgress;                               // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             StatIcon;                                          // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStatSlot">();
	}
	static class UCharacterStatSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStatSlot>();
	}
};
static_assert(alignof(UCharacterStatSlot) == 0x000008, "Wrong alignment on UCharacterStatSlot");
static_assert(sizeof(UCharacterStatSlot) == 0x0002A0, "Wrong size on UCharacterStatSlot");
static_assert(offsetof(UCharacterStatSlot, StatImage) == 0x000278, "Member 'UCharacterStatSlot::StatImage' has a wrong offset!");
static_assert(offsetof(UCharacterStatSlot, ProgressImage) == 0x000280, "Member 'UCharacterStatSlot::ProgressImage' has a wrong offset!");
static_assert(offsetof(UCharacterStatSlot, ProgressBeckground) == 0x000288, "Member 'UCharacterStatSlot::ProgressBeckground' has a wrong offset!");
static_assert(offsetof(UCharacterStatSlot, bShouldShowProgress) == 0x000290, "Member 'UCharacterStatSlot::bShouldShowProgress' has a wrong offset!");
static_assert(offsetof(UCharacterStatSlot, StatIcon) == 0x000298, "Member 'UCharacterStatSlot::StatIcon' has a wrong offset!");

// Class Stalker2.PrototypeBasedForceFeedbackProcessor
// 0x00A8 (0x0110 - 0x0068)
class UPrototypeBasedForceFeedbackProcessor final : public UForceFeedbackProcessorBase
{
public:
	class UForceFeedbackEffect*                   DefaultFeedback;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class UForceFeedbackEffect*> PrototypeToFeedback;                            // 0x0070(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, AdvancedDisplay, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FString, ERumbleType>              PrototypeToRumble;                                 // 0x00C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrototypeBasedForceFeedbackProcessor">();
	}
	static class UPrototypeBasedForceFeedbackProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrototypeBasedForceFeedbackProcessor>();
	}
};
static_assert(alignof(UPrototypeBasedForceFeedbackProcessor) == 0x000008, "Wrong alignment on UPrototypeBasedForceFeedbackProcessor");
static_assert(sizeof(UPrototypeBasedForceFeedbackProcessor) == 0x000110, "Wrong size on UPrototypeBasedForceFeedbackProcessor");
static_assert(offsetof(UPrototypeBasedForceFeedbackProcessor, DefaultFeedback) == 0x000068, "Member 'UPrototypeBasedForceFeedbackProcessor::DefaultFeedback' has a wrong offset!");
static_assert(offsetof(UPrototypeBasedForceFeedbackProcessor, PrototypeToFeedback) == 0x000070, "Member 'UPrototypeBasedForceFeedbackProcessor::PrototypeToFeedback' has a wrong offset!");
static_assert(offsetof(UPrototypeBasedForceFeedbackProcessor, PrototypeToRumble) == 0x0000C0, "Member 'UPrototypeBasedForceFeedbackProcessor::PrototypeToRumble' has a wrong offset!");

// Class Stalker2.CheckBoxWidget
// 0x0068 (0x02E0 - 0x0278)
class UCheckBoxWidget final : public UWidgetBase
{
public:
	class UImageWidget*                           ImageObj;                                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldStartChecked;                               // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMouseEvent;                                 // 0x0281(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHoverRecolor;                               // 0x0282(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_283[0x1];                                      // 0x0283(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           HoverTint;                                         // 0x0284(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NormalTint;                                        // 0x0294(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStyleManager;                               // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CheckedStyleId;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnCheckedStyleId;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bOutChecked)> OnChangeCheck;                                  // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bOutChecked)> OnCheckBoxClick;                                // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetChecked(const bool bInChecked, const bool bBrodcastOnChangeCheck);

	bool GetChecked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckBoxWidget">();
	}
	static class UCheckBoxWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckBoxWidget>();
	}
};
static_assert(alignof(UCheckBoxWidget) == 0x000008, "Wrong alignment on UCheckBoxWidget");
static_assert(sizeof(UCheckBoxWidget) == 0x0002E0, "Wrong size on UCheckBoxWidget");
static_assert(offsetof(UCheckBoxWidget, ImageObj) == 0x000278, "Member 'UCheckBoxWidget::ImageObj' has a wrong offset!");
static_assert(offsetof(UCheckBoxWidget, bShouldStartChecked) == 0x000280, "Member 'UCheckBoxWidget::bShouldStartChecked' has a wrong offset!");
static_assert(offsetof(UCheckBoxWidget, bEnableMouseEvent) == 0x000281, "Member 'UCheckBoxWidget::bEnableMouseEvent' has a wrong offset!");
static_assert(offsetof(UCheckBoxWidget, bEnableHoverRecolor) == 0x000282, "Member 'UCheckBoxWidget::bEnableHoverRecolor' has a wrong offset!");
static_assert(offsetof(UCheckBoxWidget, HoverTint) == 0x000284, "Member 'UCheckBoxWidget::HoverTint' has a wrong offset!");
static_assert(offsetof(UCheckBoxWidget, NormalTint) == 0x000294, "Member 'UCheckBoxWidget::NormalTint' has a wrong offset!");
static_assert(offsetof(UCheckBoxWidget, bEnableStyleManager) == 0x0002A4, "Member 'UCheckBoxWidget::bEnableStyleManager' has a wrong offset!");
static_assert(offsetof(UCheckBoxWidget, CheckedStyleId) == 0x0002A8, "Member 'UCheckBoxWidget::CheckedStyleId' has a wrong offset!");
static_assert(offsetof(UCheckBoxWidget, UnCheckedStyleId) == 0x0002B0, "Member 'UCheckBoxWidget::UnCheckedStyleId' has a wrong offset!");
static_assert(offsetof(UCheckBoxWidget, OnChangeCheck) == 0x0002B8, "Member 'UCheckBoxWidget::OnChangeCheck' has a wrong offset!");
static_assert(offsetof(UCheckBoxWidget, OnCheckBoxClick) == 0x0002C8, "Member 'UCheckBoxWidget::OnCheckBoxClick' has a wrong offset!");

// Class Stalker2.FaustBossComponent
// 0x00B8 (0x0158 - 0x00A0)
class UFaustBossComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityPrototypeSID                   WoundedPsyStrikeSID;                               // 0x00A8(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)
	class UPhysicalMaterial*                      InvulnerablePhysicalMaterial;                      // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicalMaterial*                      OriginalPhysicalMaterial;                          // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 WoundedDialogPrototypeSID;                         // 0x0100(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfPhases;                                    // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114[0x44];                                     // 0x0114(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void WoundedBark();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FaustBossComponent">();
	}
	static class UFaustBossComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFaustBossComponent>();
	}
};
static_assert(alignof(UFaustBossComponent) == 0x000008, "Wrong alignment on UFaustBossComponent");
static_assert(sizeof(UFaustBossComponent) == 0x000158, "Wrong size on UFaustBossComponent");
static_assert(offsetof(UFaustBossComponent, WoundedPsyStrikeSID) == 0x0000A8, "Member 'UFaustBossComponent::WoundedPsyStrikeSID' has a wrong offset!");
static_assert(offsetof(UFaustBossComponent, InvulnerablePhysicalMaterial) == 0x0000F0, "Member 'UFaustBossComponent::InvulnerablePhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UFaustBossComponent, OriginalPhysicalMaterial) == 0x0000F8, "Member 'UFaustBossComponent::OriginalPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UFaustBossComponent, WoundedDialogPrototypeSID) == 0x000100, "Member 'UFaustBossComponent::WoundedDialogPrototypeSID' has a wrong offset!");
static_assert(offsetof(UFaustBossComponent, NumberOfPhases) == 0x000110, "Member 'UFaustBossComponent::NumberOfPhases' has a wrong offset!");

// Class Stalker2.ChemicalAnomaly
// 0x0020 (0x03B8 - 0x0398)
class AChemicalAnomaly final : public AAnomaly
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   CollisionMeshPtr;                                  // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         SplashImpact;                                      // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         GrenadeExplosion;                                  // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDecalSpawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChemicalAnomaly">();
	}
	static class AChemicalAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChemicalAnomaly>();
	}
};
static_assert(alignof(AChemicalAnomaly) == 0x000008, "Wrong alignment on AChemicalAnomaly");
static_assert(sizeof(AChemicalAnomaly) == 0x0003B8, "Wrong size on AChemicalAnomaly");
static_assert(offsetof(AChemicalAnomaly, CollisionMeshPtr) == 0x0003A0, "Member 'AChemicalAnomaly::CollisionMeshPtr' has a wrong offset!");
static_assert(offsetof(AChemicalAnomaly, SplashImpact) == 0x0003A8, "Member 'AChemicalAnomaly::SplashImpact' has a wrong offset!");
static_assert(offsetof(AChemicalAnomaly, GrenadeExplosion) == 0x0003B0, "Member 'AChemicalAnomaly::GrenadeExplosion' has a wrong offset!");

// Class Stalker2.PsyVolumeComponent
// 0x0120 (0x07B0 - 0x0690)
class UPsyVolumeComponent final : public UBaseVolumeComponent
{
public:
	TArray<class FString>                         PsyEffectPrototypeSIDs;                            // 0x0688(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         EndOverlapPsyEffectPrototypeSIDs;                  // 0x0698(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         PsyTimerMin;                                       // 0x06A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PsyTimerMax;                                       // 0x06AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B0[0x100];                                    // 0x06B0(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsyVolumeComponent">();
	}
	static class UPsyVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsyVolumeComponent>();
	}
};
static_assert(alignof(UPsyVolumeComponent) == 0x000010, "Wrong alignment on UPsyVolumeComponent");
static_assert(sizeof(UPsyVolumeComponent) == 0x0007B0, "Wrong size on UPsyVolumeComponent");
static_assert(offsetof(UPsyVolumeComponent, PsyEffectPrototypeSIDs) == 0x000688, "Member 'UPsyVolumeComponent::PsyEffectPrototypeSIDs' has a wrong offset!");
static_assert(offsetof(UPsyVolumeComponent, EndOverlapPsyEffectPrototypeSIDs) == 0x000698, "Member 'UPsyVolumeComponent::EndOverlapPsyEffectPrototypeSIDs' has a wrong offset!");
static_assert(offsetof(UPsyVolumeComponent, PsyTimerMin) == 0x0006A8, "Member 'UPsyVolumeComponent::PsyTimerMin' has a wrong offset!");
static_assert(offsetof(UPsyVolumeComponent, PsyTimerMax) == 0x0006AC, "Member 'UPsyVolumeComponent::PsyTimerMax' has a wrong offset!");

// Class Stalker2.CinematicManager
// 0x0150 (0x01C8 - 0x0078)
class UCinematicManager final : public UBaseManager
{
public:
	struct FCinematicSectionParams                CinematicSectionParams;                            // 0x0078(0x0034)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x8C];                                      // 0x00AC(0x008C)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollectionInstance*   PlayerParametersMPC;                               // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x88];                                     // 0x0140(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCinematicStarted();
	void OnCinematicStopped();
	void OnFadeScreenEnd(bool bFadeOut, const struct FLinearColor& FadeTargetColor, float FadeAmount, float FadeTime);
	void OnKeyFrameSectionEnd(class FName SectionName);
	void OnKeyFrameSectionStart(const struct FCinematicSectionParams& InCinematicSectionParams);
	void OnSubtitleSectionEnd();
	void OnSubtitleSectionStart(const class FString& NPCSID, const class FString& DialogSID);

	void OnHapticFeedbackEnd(const struct FGameplayTag& ForceFeeedbackEffectTag) const;
	void OnHapticFeedbackStart(const struct FGameplayTag& ForceFeeedbackEffectTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicManager">();
	}
	static class UCinematicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCinematicManager>();
	}
};
static_assert(alignof(UCinematicManager) == 0x000008, "Wrong alignment on UCinematicManager");
static_assert(sizeof(UCinematicManager) == 0x0001C8, "Wrong size on UCinematicManager");
static_assert(offsetof(UCinematicManager, CinematicSectionParams) == 0x000078, "Member 'UCinematicManager::CinematicSectionParams' has a wrong offset!");
static_assert(offsetof(UCinematicManager, PlayerParametersMPC) == 0x000138, "Member 'UCinematicManager::PlayerParametersMPC' has a wrong offset!");

// Class Stalker2.ClassicFireAnomaly
// 0x0020 (0x03B8 - 0x0398)
class AClassicFireAnomaly final : public AAnomaly
{
public:
	class UStaticMeshComponent*                   CollisionMeshPtr;                                  // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      FlamePillarCapsule;                                // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      IdleVFX;                                           // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDecalComponent*                        DecalComponent;                                    // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnStateChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassicFireAnomaly">();
	}
	static class AClassicFireAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClassicFireAnomaly>();
	}
};
static_assert(alignof(AClassicFireAnomaly) == 0x000008, "Wrong alignment on AClassicFireAnomaly");
static_assert(sizeof(AClassicFireAnomaly) == 0x0003B8, "Wrong size on AClassicFireAnomaly");
static_assert(offsetof(AClassicFireAnomaly, CollisionMeshPtr) == 0x000398, "Member 'AClassicFireAnomaly::CollisionMeshPtr' has a wrong offset!");
static_assert(offsetof(AClassicFireAnomaly, FlamePillarCapsule) == 0x0003A0, "Member 'AClassicFireAnomaly::FlamePillarCapsule' has a wrong offset!");
static_assert(offsetof(AClassicFireAnomaly, IdleVFX) == 0x0003A8, "Member 'AClassicFireAnomaly::IdleVFX' has a wrong offset!");
static_assert(offsetof(AClassicFireAnomaly, DecalComponent) == 0x0003B0, "Member 'AClassicFireAnomaly::DecalComponent' has a wrong offset!");

// Class Stalker2.ClickerAnomaly
// 0x0088 (0x0420 - 0x0398)
class AClickerAnomaly final : public AAnomaly
{
public:
	class UStaticMeshComponent*                   RootComponentPtr;                                  // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CollisionMeshPtr;                                  // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ChargeParticle;                                    // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ExplosionParticle;                                 // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ChargeSoundEvent;                                  // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ExplosionSoundEvent;                               // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DamageCurve;                                       // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x50];                                     // 0x03D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginParticleOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClickerAnomaly">();
	}
	static class AClickerAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClickerAnomaly>();
	}
};
static_assert(alignof(AClickerAnomaly) == 0x000008, "Wrong alignment on AClickerAnomaly");
static_assert(sizeof(AClickerAnomaly) == 0x000420, "Wrong size on AClickerAnomaly");
static_assert(offsetof(AClickerAnomaly, RootComponentPtr) == 0x000398, "Member 'AClickerAnomaly::RootComponentPtr' has a wrong offset!");
static_assert(offsetof(AClickerAnomaly, CollisionMeshPtr) == 0x0003A0, "Member 'AClickerAnomaly::CollisionMeshPtr' has a wrong offset!");
static_assert(offsetof(AClickerAnomaly, ChargeParticle) == 0x0003A8, "Member 'AClickerAnomaly::ChargeParticle' has a wrong offset!");
static_assert(offsetof(AClickerAnomaly, ExplosionParticle) == 0x0003B0, "Member 'AClickerAnomaly::ExplosionParticle' has a wrong offset!");
static_assert(offsetof(AClickerAnomaly, ChargeSoundEvent) == 0x0003B8, "Member 'AClickerAnomaly::ChargeSoundEvent' has a wrong offset!");
static_assert(offsetof(AClickerAnomaly, ExplosionSoundEvent) == 0x0003C0, "Member 'AClickerAnomaly::ExplosionSoundEvent' has a wrong offset!");
static_assert(offsetof(AClickerAnomaly, DamageCurve) == 0x0003C8, "Member 'AClickerAnomaly::DamageCurve' has a wrong offset!");

// Class Stalker2.NavRebuildVolume
// 0x0000 (0x02D8 - 0x02D8)
class ANavRebuildVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavRebuildVolume">();
	}
	static class ANavRebuildVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavRebuildVolume>();
	}
};
static_assert(alignof(ANavRebuildVolume) == 0x000008, "Wrong alignment on ANavRebuildVolume");
static_assert(sizeof(ANavRebuildVolume) == 0x0002D8, "Wrong size on ANavRebuildVolume");

// Class Stalker2.FinalCreditsWithVideo
// 0x00A8 (0x0320 - 0x0278)
class UFinalCreditsWithVideo final : public UUserWidget
{
public:
	uint8                                         Pad_278[0x38];                                     // 0x0278(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UCreditsWidget*                         CreditsWidget;                                     // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBinkMediaPlayer*                       BinkMediaPlayer;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Border;                                            // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EBorderType, TSoftObjectPtr<class UTexture2D>> BorderImages;                                // 0x02C8(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndVideo();
	void PlayVideo(class UMediaSource* VideoToPlay);

	float GetVideoDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FinalCreditsWithVideo">();
	}
	static class UFinalCreditsWithVideo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFinalCreditsWithVideo>();
	}
};
static_assert(alignof(UFinalCreditsWithVideo) == 0x000008, "Wrong alignment on UFinalCreditsWithVideo");
static_assert(sizeof(UFinalCreditsWithVideo) == 0x000320, "Wrong size on UFinalCreditsWithVideo");
static_assert(offsetof(UFinalCreditsWithVideo, CreditsWidget) == 0x0002B0, "Member 'UFinalCreditsWithVideo::CreditsWidget' has a wrong offset!");
static_assert(offsetof(UFinalCreditsWithVideo, BinkMediaPlayer) == 0x0002B8, "Member 'UFinalCreditsWithVideo::BinkMediaPlayer' has a wrong offset!");
static_assert(offsetof(UFinalCreditsWithVideo, Border) == 0x0002C0, "Member 'UFinalCreditsWithVideo::Border' has a wrong offset!");
static_assert(offsetof(UFinalCreditsWithVideo, BorderImages) == 0x0002C8, "Member 'UFinalCreditsWithVideo::BorderImages' has a wrong offset!");

// Class Stalker2.ClothSimulationManager
// 0x0058 (0x0100 - 0x00A8)
class UClothSimulationManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x58];                                      // 0x00A8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothSimulationManager">();
	}
	static class UClothSimulationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClothSimulationManager>();
	}
};
static_assert(alignof(UClothSimulationManager) == 0x000008, "Wrong alignment on UClothSimulationManager");
static_assert(sizeof(UClothSimulationManager) == 0x000100, "Wrong size on UClothSimulationManager");

// Class Stalker2.CodeComponent
// 0x0038 (0x00F0 - 0x00B8)
class UCodeComponent final : public UGuidActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CorrectCode;                                       // 0x00C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaximumCodeLength;                                 // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x1C];                                      // 0x00D4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetCode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodeComponent">();
	}
	static class UCodeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodeComponent>();
	}
};
static_assert(alignof(UCodeComponent) == 0x000008, "Wrong alignment on UCodeComponent");
static_assert(sizeof(UCodeComponent) == 0x0000F0, "Wrong size on UCodeComponent");
static_assert(offsetof(UCodeComponent, CorrectCode) == 0x0000C0, "Member 'UCodeComponent::CorrectCode' has a wrong offset!");
static_assert(offsetof(UCodeComponent, MaximumCodeLength) == 0x0000D0, "Member 'UCodeComponent::MaximumCodeLength' has a wrong offset!");

// Class Stalker2.NavArea_SafeZone
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SafeZone final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SafeZone">();
	}
	static class UNavArea_SafeZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SafeZone>();
	}
};
static_assert(alignof(UNavArea_SafeZone) == 0x000008, "Wrong alignment on UNavArea_SafeZone");
static_assert(sizeof(UNavArea_SafeZone) == 0x000048, "Wrong size on UNavArea_SafeZone");

// Class Stalker2.CustomSimplifiedGrid
// 0x0260 (0x04D8 - 0x0278)
class UCustomSimplifiedGrid final : public UUserWidget
{
public:
	class UCanvasPanel*                           CanvasPanel;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTilingGridBack*                        TilingBack;                                        // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SizeY;                                             // 0x0288(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SizeX;                                             // 0x028C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class UCustomSimplifiedGridSlot*> Widgets;                                           // 0x0290(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UCustomSimplifiedGridSlot*>      CachedWidgets;                                     // 0x02E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         GamepadCurrPosX;                                   // 0x02F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GamepadCurrPosY;                                   // 0x02F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           ItemPlacementPanel;                                // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            OwnerMoney;                                        // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScrollBox*                             GridScrollBox;                                     // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            HeaderText;                                        // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               GridSizeBox;                                       // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                ItemPlaceBorder;                                   // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           ScrollCanvasPanel;                                 // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                NavBorder;                                         // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           VerticalBoxScroll;                                 // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDefaultScrollEnd;                                 // 0x0340(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowHeader;                                       // 0x0341(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_342[0x6];                                      // 0x0342(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeaderLocSID;                                      // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextWidget*                            WeightText;                                        // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            MaxWeightText;                                     // 0x0368(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            WeightUnits;                                       // 0x0370(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            LootSeparator;                                     // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 WeightIcon;                                        // 0x0380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BeforeGamepadNavigationDelay;                      // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadNavigationThreshold;                        // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadNavigationDelay;                            // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebugNavigationLines;                         // 0x039C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39D[0x3];                                      // 0x039D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            NavCurve;                                          // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VisibleCells;                                      // 0x03A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                ItemSlotWidgetClass;                               // 0x03B8(0x0008)(Edit, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CellSize;                                          // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemDragWidget*                        CurrMovingWidget;                                  // 0x03C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            MousePosTargetWidget;                              // 0x03D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0xF8];                                     // 0x03D8(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavPosChangeAnimSpeed;                             // 0x04D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D4[0x4];                                      // 0x04D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnScrollBarScrolled(float Offset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomSimplifiedGrid">();
	}
	static class UCustomSimplifiedGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomSimplifiedGrid>();
	}
};
static_assert(alignof(UCustomSimplifiedGrid) == 0x000008, "Wrong alignment on UCustomSimplifiedGrid");
static_assert(sizeof(UCustomSimplifiedGrid) == 0x0004D8, "Wrong size on UCustomSimplifiedGrid");
static_assert(offsetof(UCustomSimplifiedGrid, CanvasPanel) == 0x000278, "Member 'UCustomSimplifiedGrid::CanvasPanel' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, TilingBack) == 0x000280, "Member 'UCustomSimplifiedGrid::TilingBack' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, SizeY) == 0x000288, "Member 'UCustomSimplifiedGrid::SizeY' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, SizeX) == 0x00028C, "Member 'UCustomSimplifiedGrid::SizeX' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, Widgets) == 0x000290, "Member 'UCustomSimplifiedGrid::Widgets' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, CachedWidgets) == 0x0002E0, "Member 'UCustomSimplifiedGrid::CachedWidgets' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, GamepadCurrPosX) == 0x0002F0, "Member 'UCustomSimplifiedGrid::GamepadCurrPosX' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, GamepadCurrPosY) == 0x0002F4, "Member 'UCustomSimplifiedGrid::GamepadCurrPosY' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, ItemPlacementPanel) == 0x0002F8, "Member 'UCustomSimplifiedGrid::ItemPlacementPanel' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, OwnerMoney) == 0x000300, "Member 'UCustomSimplifiedGrid::OwnerMoney' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, GridScrollBox) == 0x000308, "Member 'UCustomSimplifiedGrid::GridScrollBox' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, HeaderText) == 0x000310, "Member 'UCustomSimplifiedGrid::HeaderText' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, GridSizeBox) == 0x000318, "Member 'UCustomSimplifiedGrid::GridSizeBox' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, ItemPlaceBorder) == 0x000320, "Member 'UCustomSimplifiedGrid::ItemPlaceBorder' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, ScrollCanvasPanel) == 0x000328, "Member 'UCustomSimplifiedGrid::ScrollCanvasPanel' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, NavBorder) == 0x000330, "Member 'UCustomSimplifiedGrid::NavBorder' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, VerticalBoxScroll) == 0x000338, "Member 'UCustomSimplifiedGrid::VerticalBoxScroll' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, bDefaultScrollEnd) == 0x000340, "Member 'UCustomSimplifiedGrid::bDefaultScrollEnd' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, bShowHeader) == 0x000341, "Member 'UCustomSimplifiedGrid::bShowHeader' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, HeaderLocSID) == 0x000348, "Member 'UCustomSimplifiedGrid::HeaderLocSID' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, WeightText) == 0x000360, "Member 'UCustomSimplifiedGrid::WeightText' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, MaxWeightText) == 0x000368, "Member 'UCustomSimplifiedGrid::MaxWeightText' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, WeightUnits) == 0x000370, "Member 'UCustomSimplifiedGrid::WeightUnits' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, LootSeparator) == 0x000378, "Member 'UCustomSimplifiedGrid::LootSeparator' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, WeightIcon) == 0x000380, "Member 'UCustomSimplifiedGrid::WeightIcon' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, BeforeGamepadNavigationDelay) == 0x000390, "Member 'UCustomSimplifiedGrid::BeforeGamepadNavigationDelay' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, GamepadNavigationThreshold) == 0x000394, "Member 'UCustomSimplifiedGrid::GamepadNavigationThreshold' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, GamepadNavigationDelay) == 0x000398, "Member 'UCustomSimplifiedGrid::GamepadNavigationDelay' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, bDrawDebugNavigationLines) == 0x00039C, "Member 'UCustomSimplifiedGrid::bDrawDebugNavigationLines' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, NavCurve) == 0x0003A0, "Member 'UCustomSimplifiedGrid::NavCurve' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, VisibleCells) == 0x0003A8, "Member 'UCustomSimplifiedGrid::VisibleCells' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, ItemSlotWidgetClass) == 0x0003B8, "Member 'UCustomSimplifiedGrid::ItemSlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, CellSize) == 0x0003C0, "Member 'UCustomSimplifiedGrid::CellSize' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, CurrMovingWidget) == 0x0003C8, "Member 'UCustomSimplifiedGrid::CurrMovingWidget' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, MousePosTargetWidget) == 0x0003D0, "Member 'UCustomSimplifiedGrid::MousePosTargetWidget' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGrid, NavPosChangeAnimSpeed) == 0x0004D0, "Member 'UCustomSimplifiedGrid::NavPosChangeAnimSpeed' has a wrong offset!");

// Class Stalker2.PresentationSettings
// 0x0060 (0x0098 - 0x0038)
class UPresentationSettings final : public UDeveloperSettings
{
public:
	bool                                          bEnablePresentationSubsystem;                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DemoPopupTitleSID;                                 // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DemoPopupDescriptionSID;                           // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 QuestNodeToStopPresentation;                       // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DemoPopupContinuePlaySID;                          // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DemoPopupToMainMenuSID;                            // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PresentationTimer;                                 // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowEndPopup;                                     // 0x0094(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentationSettings">();
	}
	static class UPresentationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresentationSettings>();
	}
};
static_assert(alignof(UPresentationSettings) == 0x000008, "Wrong alignment on UPresentationSettings");
static_assert(sizeof(UPresentationSettings) == 0x000098, "Wrong size on UPresentationSettings");
static_assert(offsetof(UPresentationSettings, bEnablePresentationSubsystem) == 0x000038, "Member 'UPresentationSettings::bEnablePresentationSubsystem' has a wrong offset!");
static_assert(offsetof(UPresentationSettings, DemoPopupTitleSID) == 0x000040, "Member 'UPresentationSettings::DemoPopupTitleSID' has a wrong offset!");
static_assert(offsetof(UPresentationSettings, DemoPopupDescriptionSID) == 0x000050, "Member 'UPresentationSettings::DemoPopupDescriptionSID' has a wrong offset!");
static_assert(offsetof(UPresentationSettings, QuestNodeToStopPresentation) == 0x000060, "Member 'UPresentationSettings::QuestNodeToStopPresentation' has a wrong offset!");
static_assert(offsetof(UPresentationSettings, DemoPopupContinuePlaySID) == 0x000070, "Member 'UPresentationSettings::DemoPopupContinuePlaySID' has a wrong offset!");
static_assert(offsetof(UPresentationSettings, DemoPopupToMainMenuSID) == 0x000080, "Member 'UPresentationSettings::DemoPopupToMainMenuSID' has a wrong offset!");
static_assert(offsetof(UPresentationSettings, PresentationTimer) == 0x000090, "Member 'UPresentationSettings::PresentationTimer' has a wrong offset!");
static_assert(offsetof(UPresentationSettings, bShowEndPopup) == 0x000094, "Member 'UPresentationSettings::bShowEndPopup' has a wrong offset!");

// Class Stalker2.FireTypeWidget
// 0x0028 (0x02A0 - 0x0278)
class UFireTypeWidget final : public UWidgetBase
{
public:
	class UImage*                                 Background;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Icon;                                              // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadedOpacity;                                      // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectedOpacity;                                   // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeSpeed;                                         // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0xC];                                      // 0x0294(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireTypeWidget">();
	}
	static class UFireTypeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireTypeWidget>();
	}
};
static_assert(alignof(UFireTypeWidget) == 0x000008, "Wrong alignment on UFireTypeWidget");
static_assert(sizeof(UFireTypeWidget) == 0x0002A0, "Wrong size on UFireTypeWidget");
static_assert(offsetof(UFireTypeWidget, Background) == 0x000278, "Member 'UFireTypeWidget::Background' has a wrong offset!");
static_assert(offsetof(UFireTypeWidget, Icon) == 0x000280, "Member 'UFireTypeWidget::Icon' has a wrong offset!");
static_assert(offsetof(UFireTypeWidget, FadedOpacity) == 0x000288, "Member 'UFireTypeWidget::FadedOpacity' has a wrong offset!");
static_assert(offsetof(UFireTypeWidget, SelectedOpacity) == 0x00028C, "Member 'UFireTypeWidget::SelectedOpacity' has a wrong offset!");
static_assert(offsetof(UFireTypeWidget, FadeSpeed) == 0x000290, "Member 'UFireTypeWidget::FadeSpeed' has a wrong offset!");

// Class Stalker2.Codelock
// 0x0218 (0x0500 - 0x02E8)
class alignas(0x10) ACodelock final : public AInteractableObject
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCodelockSingleClickComponent*          InteractComponent;                                 // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCodeComponent*                         CodeComponent;                                     // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CodeLockDistance;                                  // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CodeLockZoomInTime;                                // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CodeLockZoomOutTime;                               // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CodeLockForceZoomOutTime;                          // 0x030C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FailDisplayTimerRate;                              // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideKeyMap;                                   // 0x0314(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, ECodelockKeyType>           KeyMap;                                            // 0x0318(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x198];                                    // 0x0368(0x0198)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInputCodeFailed();
	void OnInputCodePassed();
	void OnKeyPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Codelock">();
	}
	static class ACodelock* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACodelock>();
	}
};
static_assert(alignof(ACodelock) == 0x000010, "Wrong alignment on ACodelock");
static_assert(sizeof(ACodelock) == 0x000500, "Wrong size on ACodelock");
static_assert(offsetof(ACodelock, Mesh) == 0x0002E8, "Member 'ACodelock::Mesh' has a wrong offset!");
static_assert(offsetof(ACodelock, InteractComponent) == 0x0002F0, "Member 'ACodelock::InteractComponent' has a wrong offset!");
static_assert(offsetof(ACodelock, CodeComponent) == 0x0002F8, "Member 'ACodelock::CodeComponent' has a wrong offset!");
static_assert(offsetof(ACodelock, CodeLockDistance) == 0x000300, "Member 'ACodelock::CodeLockDistance' has a wrong offset!");
static_assert(offsetof(ACodelock, CodeLockZoomInTime) == 0x000304, "Member 'ACodelock::CodeLockZoomInTime' has a wrong offset!");
static_assert(offsetof(ACodelock, CodeLockZoomOutTime) == 0x000308, "Member 'ACodelock::CodeLockZoomOutTime' has a wrong offset!");
static_assert(offsetof(ACodelock, CodeLockForceZoomOutTime) == 0x00030C, "Member 'ACodelock::CodeLockForceZoomOutTime' has a wrong offset!");
static_assert(offsetof(ACodelock, FailDisplayTimerRate) == 0x000310, "Member 'ACodelock::FailDisplayTimerRate' has a wrong offset!");
static_assert(offsetof(ACodelock, bOverrideKeyMap) == 0x000314, "Member 'ACodelock::bOverrideKeyMap' has a wrong offset!");
static_assert(offsetof(ACodelock, KeyMap) == 0x000318, "Member 'ACodelock::KeyMap' has a wrong offset!");

// Class Stalker2.PDATimePanel
// 0x0038 (0x02B0 - 0x0278)
class UPDATimePanel final : public UChildViewBase
{
public:
	class UTextWidget*                            HourText;                                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            MinutesText;                                       // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       PointAnim;                                         // 0x0288(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointAnimSpeed;                                    // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x1C];                                     // 0x0294(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDATimePanel">();
	}
	static class UPDATimePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDATimePanel>();
	}
};
static_assert(alignof(UPDATimePanel) == 0x000008, "Wrong alignment on UPDATimePanel");
static_assert(sizeof(UPDATimePanel) == 0x0002B0, "Wrong size on UPDATimePanel");
static_assert(offsetof(UPDATimePanel, HourText) == 0x000278, "Member 'UPDATimePanel::HourText' has a wrong offset!");
static_assert(offsetof(UPDATimePanel, MinutesText) == 0x000280, "Member 'UPDATimePanel::MinutesText' has a wrong offset!");
static_assert(offsetof(UPDATimePanel, PointAnim) == 0x000288, "Member 'UPDATimePanel::PointAnim' has a wrong offset!");
static_assert(offsetof(UPDATimePanel, PointAnimSpeed) == 0x000290, "Member 'UPDATimePanel::PointAnimSpeed' has a wrong offset!");

// Class Stalker2.CodelockClearAllIPU
// 0x0000 (0x0040 - 0x0040)
class UCodelockClearAllIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodelockClearAllIPU">();
	}
	static class UCodelockClearAllIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodelockClearAllIPU>();
	}
};
static_assert(alignof(UCodelockClearAllIPU) == 0x000008, "Wrong alignment on UCodelockClearAllIPU");
static_assert(sizeof(UCodelockClearAllIPU) == 0x000040, "Wrong size on UCodelockClearAllIPU");

// Class Stalker2.DestructabilityMetaInfoComponent
// 0x0008 (0x00A8 - 0x00A0)
class UDestructabilityMetaInfoComponent final : public UActorComponent
{
public:
	bool                                          bAllowConvertionToDestructibleObject;              // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructabilityMetaInfoComponent">();
	}
	static class UDestructabilityMetaInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructabilityMetaInfoComponent>();
	}
};
static_assert(alignof(UDestructabilityMetaInfoComponent) == 0x000008, "Wrong alignment on UDestructabilityMetaInfoComponent");
static_assert(sizeof(UDestructabilityMetaInfoComponent) == 0x0000A8, "Wrong size on UDestructabilityMetaInfoComponent");
static_assert(offsetof(UDestructabilityMetaInfoComponent, bAllowConvertionToDestructibleObject) == 0x0000A0, "Member 'UDestructabilityMetaInfoComponent::bAllowConvertionToDestructibleObject' has a wrong offset!");

// Class Stalker2.CodelockClearOneIPU
// 0x0000 (0x0040 - 0x0040)
class UCodelockClearOneIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodelockClearOneIPU">();
	}
	static class UCodelockClearOneIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodelockClearOneIPU>();
	}
};
static_assert(alignof(UCodelockClearOneIPU) == 0x000008, "Wrong alignment on UCodelockClearOneIPU");
static_assert(sizeof(UCodelockClearOneIPU) == 0x000040, "Wrong size on UCodelockClearOneIPU");

// Class Stalker2.CodelockConfirmIPU
// 0x0000 (0x0040 - 0x0040)
class UCodelockConfirmIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodelockConfirmIPU">();
	}
	static class UCodelockConfirmIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodelockConfirmIPU>();
	}
};
static_assert(alignof(UCodelockConfirmIPU) == 0x000008, "Wrong alignment on UCodelockConfirmIPU");
static_assert(sizeof(UCodelockConfirmIPU) == 0x000040, "Wrong size on UCodelockConfirmIPU");

// Class Stalker2.RazorAnomaly
// 0x0088 (0x0420 - 0x0398)
class ARazorAnomaly final : public AAnomaly
{
public:
	class UStaticMeshComponent*                   RootComponentPtr;                                  // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkRtpc>                 RazorIntensityRTPCPtr;                             // 0x03A0(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CollisionMeshPtr;                                  // 0x03D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         DamageVFX;                                         // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         AIDamageVFX;                                       // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         ProjectileDestructionVFX;                          // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         ThrowableDestructionVFX;                           // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      RazorActiveVFX;                                    // 0x03F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                RazorIntensityRTPC;                                // 0x0400(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x18];                                     // 0x0408(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RazorAnomaly">();
	}
	static class ARazorAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARazorAnomaly>();
	}
};
static_assert(alignof(ARazorAnomaly) == 0x000008, "Wrong alignment on ARazorAnomaly");
static_assert(sizeof(ARazorAnomaly) == 0x000420, "Wrong size on ARazorAnomaly");
static_assert(offsetof(ARazorAnomaly, RootComponentPtr) == 0x000398, "Member 'ARazorAnomaly::RootComponentPtr' has a wrong offset!");
static_assert(offsetof(ARazorAnomaly, RazorIntensityRTPCPtr) == 0x0003A0, "Member 'ARazorAnomaly::RazorIntensityRTPCPtr' has a wrong offset!");
static_assert(offsetof(ARazorAnomaly, CollisionMeshPtr) == 0x0003D0, "Member 'ARazorAnomaly::CollisionMeshPtr' has a wrong offset!");
static_assert(offsetof(ARazorAnomaly, DamageVFX) == 0x0003D8, "Member 'ARazorAnomaly::DamageVFX' has a wrong offset!");
static_assert(offsetof(ARazorAnomaly, AIDamageVFX) == 0x0003E0, "Member 'ARazorAnomaly::AIDamageVFX' has a wrong offset!");
static_assert(offsetof(ARazorAnomaly, ProjectileDestructionVFX) == 0x0003E8, "Member 'ARazorAnomaly::ProjectileDestructionVFX' has a wrong offset!");
static_assert(offsetof(ARazorAnomaly, ThrowableDestructionVFX) == 0x0003F0, "Member 'ARazorAnomaly::ThrowableDestructionVFX' has a wrong offset!");
static_assert(offsetof(ARazorAnomaly, RazorActiveVFX) == 0x0003F8, "Member 'ARazorAnomaly::RazorActiveVFX' has a wrong offset!");
static_assert(offsetof(ARazorAnomaly, RazorIntensityRTPC) == 0x000400, "Member 'ARazorAnomaly::RazorIntensityRTPC' has a wrong offset!");

// Class Stalker2.FogActor
// 0x0048 (0x02E0 - 0x0298)
class AFogActor final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   FogMesh;                                           // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFogParams>                     FogPresets;                                        // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   DensityParamName;                                  // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HeightMinParamName;                                // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HeightMaxParamName;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x02D0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FFogParams GetFogParamsForCurrentWeather() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FogActor">();
	}
	static class AFogActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFogActor>();
	}
};
static_assert(alignof(AFogActor) == 0x000008, "Wrong alignment on AFogActor");
static_assert(sizeof(AFogActor) == 0x0002E0, "Wrong size on AFogActor");
static_assert(offsetof(AFogActor, FogMesh) == 0x0002A0, "Member 'AFogActor::FogMesh' has a wrong offset!");
static_assert(offsetof(AFogActor, FogPresets) == 0x0002A8, "Member 'AFogActor::FogPresets' has a wrong offset!");
static_assert(offsetof(AFogActor, DensityParamName) == 0x0002B8, "Member 'AFogActor::DensityParamName' has a wrong offset!");
static_assert(offsetof(AFogActor, HeightMinParamName) == 0x0002C0, "Member 'AFogActor::HeightMinParamName' has a wrong offset!");
static_assert(offsetof(AFogActor, HeightMaxParamName) == 0x0002C8, "Member 'AFogActor::HeightMaxParamName' has a wrong offset!");
static_assert(offsetof(AFogActor, DynamicMaterial) == 0x0002D0, "Member 'AFogActor::DynamicMaterial' has a wrong offset!");

// Class Stalker2.CodelockDirectionBaseIPU
// 0x0008 (0x0048 - 0x0040)
class UCodelockDirectionBaseIPU : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodelockDirectionBaseIPU">();
	}
	static class UCodelockDirectionBaseIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodelockDirectionBaseIPU>();
	}
};
static_assert(alignof(UCodelockDirectionBaseIPU) == 0x000008, "Wrong alignment on UCodelockDirectionBaseIPU");
static_assert(sizeof(UCodelockDirectionBaseIPU) == 0x000048, "Wrong size on UCodelockDirectionBaseIPU");

// Class Stalker2.CodelockDownIPU
// 0x0000 (0x0048 - 0x0048)
class UCodelockDownIPU final : public UCodelockDirectionBaseIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodelockDownIPU">();
	}
	static class UCodelockDownIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodelockDownIPU>();
	}
};
static_assert(alignof(UCodelockDownIPU) == 0x000008, "Wrong alignment on UCodelockDownIPU");
static_assert(sizeof(UCodelockDownIPU) == 0x000048, "Wrong size on UCodelockDownIPU");

// Class Stalker2.RazerChromaEventTracker
// 0x01D0 (0x01F8 - 0x0028)
class URazerChromaEventTracker final : public UObject
{
public:
	uint8                                         Pad_28[0x1C8];                                     // 0x0028(0x01C8)(Fixing Size After Last Property [ Dumper-7 ])
	class URazerChromaSubsystem*                  Subsystem;                                         // 0x01F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RazerChromaEventTracker">();
	}
	static class URazerChromaEventTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<URazerChromaEventTracker>();
	}
};
static_assert(alignof(URazerChromaEventTracker) == 0x000008, "Wrong alignment on URazerChromaEventTracker");
static_assert(sizeof(URazerChromaEventTracker) == 0x0001F8, "Wrong size on URazerChromaEventTracker");
static_assert(offsetof(URazerChromaEventTracker, Subsystem) == 0x0001F0, "Member 'URazerChromaEventTracker::Subsystem' has a wrong offset!");

// Class Stalker2.DeadBody
// 0x0018 (0x0210 - 0x01F8)
class UDeadBody final : public USingleClickComponent
{
public:
	uint8                                         Pad_1F8[0x18];                                     // 0x01F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AObj* GetInteractedActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeadBody">();
	}
	static class UDeadBody* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeadBody>();
	}
};
static_assert(alignof(UDeadBody) == 0x000008, "Wrong alignment on UDeadBody");
static_assert(sizeof(UDeadBody) == 0x000210, "Wrong size on UDeadBody");

// Class Stalker2.CodelockExitIPU
// 0x0000 (0x0040 - 0x0040)
class UCodelockExitIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodelockExitIPU">();
	}
	static class UCodelockExitIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodelockExitIPU>();
	}
};
static_assert(alignof(UCodelockExitIPU) == 0x000008, "Wrong alignment on UCodelockExitIPU");
static_assert(sizeof(UCodelockExitIPU) == 0x000040, "Wrong size on UCodelockExitIPU");

// Class Stalker2.QuestVFXActor
// 0x0018 (0x02B0 - 0x0298)
class AQuestVFXActor final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestVFXActor">();
	}
	static class AQuestVFXActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AQuestVFXActor>();
	}
};
static_assert(alignof(AQuestVFXActor) == 0x000008, "Wrong alignment on AQuestVFXActor");
static_assert(sizeof(AQuestVFXActor) == 0x0002B0, "Wrong size on AQuestVFXActor");
static_assert(offsetof(AQuestVFXActor, Guid) == 0x0002A0, "Member 'AQuestVFXActor::Guid' has a wrong offset!");

// Class Stalker2.CodelockLeftIPU
// 0x0000 (0x0048 - 0x0048)
class UCodelockLeftIPU final : public UCodelockDirectionBaseIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodelockLeftIPU">();
	}
	static class UCodelockLeftIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodelockLeftIPU>();
	}
};
static_assert(alignof(UCodelockLeftIPU) == 0x000008, "Wrong alignment on UCodelockLeftIPU");
static_assert(sizeof(UCodelockLeftIPU) == 0x000048, "Wrong size on UCodelockLeftIPU");

// Class Stalker2.DialogProtector
// 0x0010 (0x02A8 - 0x0298)
class ADialogProtector final : public AActor
{
public:
	class UGSCNavModifierComponent*               SpaceRestrictor;                                   // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          SpaceRestrictorShape;                              // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogProtector">();
	}
	static class ADialogProtector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADialogProtector>();
	}
};
static_assert(alignof(ADialogProtector) == 0x000008, "Wrong alignment on ADialogProtector");
static_assert(sizeof(ADialogProtector) == 0x0002A8, "Wrong size on ADialogProtector");
static_assert(offsetof(ADialogProtector, SpaceRestrictor) == 0x000298, "Member 'ADialogProtector::SpaceRestrictor' has a wrong offset!");
static_assert(offsetof(ADialogProtector, SpaceRestrictorShape) == 0x0002A0, "Member 'ADialogProtector::SpaceRestrictorShape' has a wrong offset!");

// Class Stalker2.CodelockMousePressIPU
// 0x0000 (0x0040 - 0x0040)
class UCodelockMousePressIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodelockMousePressIPU">();
	}
	static class UCodelockMousePressIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodelockMousePressIPU>();
	}
};
static_assert(alignof(UCodelockMousePressIPU) == 0x000008, "Wrong alignment on UCodelockMousePressIPU");
static_assert(sizeof(UCodelockMousePressIPU) == 0x000040, "Wrong size on UCodelockMousePressIPU");

// Class Stalker2.PlayerIdentityWidget
// 0x0028 (0x02A0 - 0x0278)
class UPlayerIdentityWidget final : public UWidgetBase
{
public:
	class UHorizontalBox*                         IdentityContainer;                                 // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           IdentityList;                                      // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerIdentityWidget">();
	}
	static class UPlayerIdentityWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerIdentityWidget>();
	}
};
static_assert(alignof(UPlayerIdentityWidget) == 0x000008, "Wrong alignment on UPlayerIdentityWidget");
static_assert(sizeof(UPlayerIdentityWidget) == 0x0002A0, "Wrong size on UPlayerIdentityWidget");
static_assert(offsetof(UPlayerIdentityWidget, IdentityContainer) == 0x000278, "Member 'UPlayerIdentityWidget::IdentityContainer' has a wrong offset!");
static_assert(offsetof(UPlayerIdentityWidget, IdentityList) == 0x000280, "Member 'UPlayerIdentityWidget::IdentityList' has a wrong offset!");

// Class Stalker2.CodelockNumBaseIPU
// 0x0008 (0x0048 - 0x0040)
class UCodelockNumBaseIPU final : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodelockNumBaseIPU">();
	}
	static class UCodelockNumBaseIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodelockNumBaseIPU>();
	}
};
static_assert(alignof(UCodelockNumBaseIPU) == 0x000008, "Wrong alignment on UCodelockNumBaseIPU");
static_assert(sizeof(UCodelockNumBaseIPU) == 0x000048, "Wrong size on UCodelockNumBaseIPU");

// Class Stalker2.WorldMapMarkerZone
// 0x0038 (0x02B0 - 0x0278)
class UWorldMapMarkerZone final : public UWidgetBase
{
public:
	class UImage*                                 ZoneMaterial;                                      // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBox;                                           // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MaterialScaleFieldName;                            // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MaterialColorFieldName;                            // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanelSlot*                       ParentCanvasSlot;                                  // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           ZoneCanvas;                                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapMarkerZone">();
	}
	static class UWorldMapMarkerZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMapMarkerZone>();
	}
};
static_assert(alignof(UWorldMapMarkerZone) == 0x000008, "Wrong alignment on UWorldMapMarkerZone");
static_assert(sizeof(UWorldMapMarkerZone) == 0x0002B0, "Wrong size on UWorldMapMarkerZone");
static_assert(offsetof(UWorldMapMarkerZone, ZoneMaterial) == 0x000278, "Member 'UWorldMapMarkerZone::ZoneMaterial' has a wrong offset!");
static_assert(offsetof(UWorldMapMarkerZone, SizeBox) == 0x000280, "Member 'UWorldMapMarkerZone::SizeBox' has a wrong offset!");
static_assert(offsetof(UWorldMapMarkerZone, MaterialScaleFieldName) == 0x000288, "Member 'UWorldMapMarkerZone::MaterialScaleFieldName' has a wrong offset!");
static_assert(offsetof(UWorldMapMarkerZone, MaterialColorFieldName) == 0x000290, "Member 'UWorldMapMarkerZone::MaterialColorFieldName' has a wrong offset!");
static_assert(offsetof(UWorldMapMarkerZone, ParentCanvasSlot) == 0x0002A0, "Member 'UWorldMapMarkerZone::ParentCanvasSlot' has a wrong offset!");
static_assert(offsetof(UWorldMapMarkerZone, ZoneCanvas) == 0x0002A8, "Member 'UWorldMapMarkerZone::ZoneCanvas' has a wrong offset!");

// Class Stalker2.DialogLightSubsystem
// 0x0358 (0x0388 - 0x0030)
class UDialogLightSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x358];                                     // 0x0030(0x0358)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogLightSubsystem">();
	}
	static class UDialogLightSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogLightSubsystem>();
	}
};
static_assert(alignof(UDialogLightSubsystem) == 0x000008, "Wrong alignment on UDialogLightSubsystem");
static_assert(sizeof(UDialogLightSubsystem) == 0x000388, "Wrong size on UDialogLightSubsystem");

// Class Stalker2.CodelockPressIPU
// 0x0000 (0x0040 - 0x0040)
class UCodelockPressIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodelockPressIPU">();
	}
	static class UCodelockPressIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodelockPressIPU>();
	}
};
static_assert(alignof(UCodelockPressIPU) == 0x000008, "Wrong alignment on UCodelockPressIPU");
static_assert(sizeof(UCodelockPressIPU) == 0x000040, "Wrong size on UCodelockPressIPU");

// Class Stalker2.CodelockRightIPU
// 0x0000 (0x0048 - 0x0048)
class UCodelockRightIPU final : public UCodelockDirectionBaseIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodelockRightIPU">();
	}
	static class UCodelockRightIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodelockRightIPU>();
	}
};
static_assert(alignof(UCodelockRightIPU) == 0x000008, "Wrong alignment on UCodelockRightIPU");
static_assert(sizeof(UCodelockRightIPU) == 0x000048, "Wrong size on UCodelockRightIPU");

// Class Stalker2.WetnessComponent
// 0x0040 (0x00E0 - 0x00A0)
class UWetnessComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x40];                                      // 0x00A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WetnessComponent">();
	}
	static class UWetnessComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWetnessComponent>();
	}
};
static_assert(alignof(UWetnessComponent) == 0x000008, "Wrong alignment on UWetnessComponent");
static_assert(sizeof(UWetnessComponent) == 0x0000E0, "Wrong size on UWetnessComponent");

// Class Stalker2.NPCWetnessComponent
// 0x0028 (0x0108 - 0x00E0)
class UNPCWetnessComponent final : public UWetnessComponent
{
public:
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      Niagara;                                           // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SplashSpawnRateParamName;                          // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DropSpawnRateParamName;                            // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCWetnessComponent">();
	}
	static class UNPCWetnessComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCWetnessComponent>();
	}
};
static_assert(alignof(UNPCWetnessComponent) == 0x000008, "Wrong alignment on UNPCWetnessComponent");
static_assert(sizeof(UNPCWetnessComponent) == 0x000108, "Wrong size on UNPCWetnessComponent");
static_assert(offsetof(UNPCWetnessComponent, Niagara) == 0x0000F0, "Member 'UNPCWetnessComponent::Niagara' has a wrong offset!");
static_assert(offsetof(UNPCWetnessComponent, SplashSpawnRateParamName) == 0x0000F8, "Member 'UNPCWetnessComponent::SplashSpawnRateParamName' has a wrong offset!");
static_assert(offsetof(UNPCWetnessComponent, DropSpawnRateParamName) == 0x000100, "Member 'UNPCWetnessComponent::DropSpawnRateParamName' has a wrong offset!");

// Class Stalker2.DialogueButton
// 0x0058 (0x0318 - 0x02C0)
class UDialogueButton final : public UButtonBase
{
public:
	class UTextWidget*                            Text;                                              // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextWidget*                        RichTextWidget;                                    // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStyleManager;                               // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StylePrefix;                                       // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HoverStyleId;                                      // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NormalStyleId;                                     // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionId;                                          // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ButtonText;                                        // 0x0300(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueButton">();
	}
	static class UDialogueButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueButton>();
	}
};
static_assert(alignof(UDialogueButton) == 0x000008, "Wrong alignment on UDialogueButton");
static_assert(sizeof(UDialogueButton) == 0x000318, "Wrong size on UDialogueButton");
static_assert(offsetof(UDialogueButton, Text) == 0x0002C0, "Member 'UDialogueButton::Text' has a wrong offset!");
static_assert(offsetof(UDialogueButton, RichTextWidget) == 0x0002C8, "Member 'UDialogueButton::RichTextWidget' has a wrong offset!");
static_assert(offsetof(UDialogueButton, bEnableStyleManager) == 0x0002D0, "Member 'UDialogueButton::bEnableStyleManager' has a wrong offset!");
static_assert(offsetof(UDialogueButton, StylePrefix) == 0x0002D8, "Member 'UDialogueButton::StylePrefix' has a wrong offset!");
static_assert(offsetof(UDialogueButton, HoverStyleId) == 0x0002E8, "Member 'UDialogueButton::HoverStyleId' has a wrong offset!");
static_assert(offsetof(UDialogueButton, NormalStyleId) == 0x0002F0, "Member 'UDialogueButton::NormalStyleId' has a wrong offset!");
static_assert(offsetof(UDialogueButton, ActionId) == 0x0002F8, "Member 'UDialogueButton::ActionId' has a wrong offset!");
static_assert(offsetof(UDialogueButton, ButtonText) == 0x000300, "Member 'UDialogueButton::ButtonText' has a wrong offset!");

// Class Stalker2.CodelockSingleClickComponent
// 0x0020 (0x0218 - 0x01F8)
class UCodelockSingleClickComponent final : public USingleClickComponent
{
public:
	uint8                                         Pad_1F8[0x20];                                     // 0x01F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Interact(class AObj* InteractedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodelockSingleClickComponent">();
	}
	static class UCodelockSingleClickComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodelockSingleClickComponent>();
	}
};
static_assert(alignof(UCodelockSingleClickComponent) == 0x000008, "Wrong alignment on UCodelockSingleClickComponent");
static_assert(sizeof(UCodelockSingleClickComponent) == 0x000218, "Wrong size on UCodelockSingleClickComponent");

// Class Stalker2.CodelockUpIPU
// 0x0000 (0x0048 - 0x0048)
class UCodelockUpIPU final : public UCodelockDirectionBaseIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CodelockUpIPU">();
	}
	static class UCodelockUpIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCodelockUpIPU>();
	}
};
static_assert(alignof(UCodelockUpIPU) == 0x000008, "Wrong alignment on UCodelockUpIPU");
static_assert(sizeof(UCodelockUpIPU) == 0x000048, "Wrong size on UCodelockUpIPU");

// Class Stalker2.CrosshairWidgetSwitcher
// 0x00E8 (0x0360 - 0x0278)
class UCrosshairWidgetSwitcher final : public UChildViewBase
{
public:
	class UWidgetSwitcher*                        CrosshairSwitcher;                                 // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ShowCrosshairAnim;                                 // 0x0280(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HideCrosshairAnim;                                 // 0x0288(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       BlockHideCrosshairAnim;                            // 0x0290(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x48];                                     // 0x0298(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseDiffirentCrosshairType;                        // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrosshairType                                DefaultCrosshairType;                              // 0x02E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E2[0x6];                                      // 0x02E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECrosshairTypeSetting, bool>             CrosshairType;                                     // 0x02E8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         CrosshairAnimationAimSpeed;                        // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrosshairWidgetBase*                   CurrCrosshairWidget;                               // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x18];                                     // 0x0348(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrosshairWidgetSwitcher">();
	}
	static class UCrosshairWidgetSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrosshairWidgetSwitcher>();
	}
};
static_assert(alignof(UCrosshairWidgetSwitcher) == 0x000008, "Wrong alignment on UCrosshairWidgetSwitcher");
static_assert(sizeof(UCrosshairWidgetSwitcher) == 0x000360, "Wrong size on UCrosshairWidgetSwitcher");
static_assert(offsetof(UCrosshairWidgetSwitcher, CrosshairSwitcher) == 0x000278, "Member 'UCrosshairWidgetSwitcher::CrosshairSwitcher' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetSwitcher, ShowCrosshairAnim) == 0x000280, "Member 'UCrosshairWidgetSwitcher::ShowCrosshairAnim' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetSwitcher, HideCrosshairAnim) == 0x000288, "Member 'UCrosshairWidgetSwitcher::HideCrosshairAnim' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetSwitcher, BlockHideCrosshairAnim) == 0x000290, "Member 'UCrosshairWidgetSwitcher::BlockHideCrosshairAnim' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetSwitcher, bUseDiffirentCrosshairType) == 0x0002E0, "Member 'UCrosshairWidgetSwitcher::bUseDiffirentCrosshairType' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetSwitcher, DefaultCrosshairType) == 0x0002E1, "Member 'UCrosshairWidgetSwitcher::DefaultCrosshairType' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetSwitcher, CrosshairType) == 0x0002E8, "Member 'UCrosshairWidgetSwitcher::CrosshairType' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetSwitcher, CrosshairAnimationAimSpeed) == 0x000338, "Member 'UCrosshairWidgetSwitcher::CrosshairAnimationAimSpeed' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetSwitcher, CurrCrosshairWidget) == 0x000340, "Member 'UCrosshairWidgetSwitcher::CurrCrosshairWidget' has a wrong offset!");

// Class Stalker2.Collar
// 0x0020 (0x02B8 - 0x0298)
class ACollar final : public AActor
{
public:
	class FString                                 CollarSID;                                         // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           HissingComp;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 CollarSK;                                          // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Collar">();
	}
	static class ACollar* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollar>();
	}
};
static_assert(alignof(ACollar) == 0x000008, "Wrong alignment on ACollar");
static_assert(sizeof(ACollar) == 0x0002B8, "Wrong size on ACollar");
static_assert(offsetof(ACollar, CollarSID) == 0x000298, "Member 'ACollar::CollarSID' has a wrong offset!");
static_assert(offsetof(ACollar, HissingComp) == 0x0002A8, "Member 'ACollar::HissingComp' has a wrong offset!");
static_assert(offsetof(ACollar, CollarSK) == 0x0002B0, "Member 'ACollar::CollarSK' has a wrong offset!");

// Class Stalker2.NavArea_Shelter
// 0x0000 (0x0048 - 0x0048)
class UNavArea_Shelter final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Shelter">();
	}
	static class UNavArea_Shelter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Shelter>();
	}
};
static_assert(alignof(UNavArea_Shelter) == 0x000008, "Wrong alignment on UNavArea_Shelter");
static_assert(sizeof(UNavArea_Shelter) == 0x000048, "Wrong size on UNavArea_Shelter");

// Class Stalker2.CombatMusicOverrideVolume
// 0x0010 (0x02E8 - 0x02D8)
class ACombatMusicOverrideVolume final : public AVolume
{
public:
	TArray<TSoftObjectPtr<class UAkSwitchValue>>  CombatTracks;                                      // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombatMusicOverrideVolume">();
	}
	static class ACombatMusicOverrideVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACombatMusicOverrideVolume>();
	}
};
static_assert(alignof(ACombatMusicOverrideVolume) == 0x000008, "Wrong alignment on ACombatMusicOverrideVolume");
static_assert(sizeof(ACombatMusicOverrideVolume) == 0x0002E8, "Wrong size on ACombatMusicOverrideVolume");
static_assert(offsetof(ACombatMusicOverrideVolume, CombatTracks) == 0x0002D8, "Member 'ACombatMusicOverrideVolume::CombatTracks' has a wrong offset!");

// Class Stalker2.DiamondAnomaly
// 0x0008 (0x03A0 - 0x0398)
class ADiamondAnomaly final : public AAnomaly
{
public:
	class UStaticMeshComponent*                   CollisionMesh;                                     // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiamondAnomaly">();
	}
	static class ADiamondAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADiamondAnomaly>();
	}
};
static_assert(alignof(ADiamondAnomaly) == 0x000008, "Wrong alignment on ADiamondAnomaly");
static_assert(sizeof(ADiamondAnomaly) == 0x0003A0, "Wrong size on ADiamondAnomaly");
static_assert(offsetof(ADiamondAnomaly, CollisionMesh) == 0x000398, "Member 'ADiamondAnomaly::CollisionMesh' has a wrong offset!");

// Class Stalker2.CombatSubsystem
// 0x0000 (0x0078 - 0x0078)
class UCombatSubsystem final : public UBaseManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombatSubsystem">();
	}
	static class UCombatSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCombatSubsystem>();
	}
};
static_assert(alignof(UCombatSubsystem) == 0x000008, "Wrong alignment on UCombatSubsystem");
static_assert(sizeof(UCombatSubsystem) == 0x000078, "Wrong size on UCombatSubsystem");

// Class Stalker2.NiagaraTimeOfDayNormalizedProvider
// 0x0000 (0x0100 - 0x0100)
class UNiagaraTimeOfDayNormalizedProvider final : public UNiagaraParameterProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraTimeOfDayNormalizedProvider">();
	}
	static class UNiagaraTimeOfDayNormalizedProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraTimeOfDayNormalizedProvider>();
	}
};
static_assert(alignof(UNiagaraTimeOfDayNormalizedProvider) == 0x000008, "Wrong alignment on UNiagaraTimeOfDayNormalizedProvider");
static_assert(sizeof(UNiagaraTimeOfDayNormalizedProvider) == 0x000100, "Wrong size on UNiagaraTimeOfDayNormalizedProvider");

// Class Stalker2.CombatSynchronizerSubsystem
// 0x0100 (0x0130 - 0x0030)
class UCombatSynchronizerSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x100];                                     // 0x0030(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombatSynchronizerSubsystem">();
	}
	static class UCombatSynchronizerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCombatSynchronizerSubsystem>();
	}
};
static_assert(alignof(UCombatSynchronizerSubsystem) == 0x000008, "Wrong alignment on UCombatSynchronizerSubsystem");
static_assert(sizeof(UCombatSynchronizerSubsystem) == 0x000130, "Wrong size on UCombatSynchronizerSubsystem");

// Class Stalker2.DialogManager
// 0x0308 (0x03B0 - 0x00A8)
class UDialogManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x308];                                     // 0x00A8(0x0308)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnToggleAudiolog(const bool bPlayAudiolog);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogManager">();
	}
	static class UDialogManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogManager>();
	}
};
static_assert(alignof(UDialogManager) == 0x000008, "Wrong alignment on UDialogManager");
static_assert(sizeof(UDialogManager) == 0x0003B0, "Wrong size on UDialogManager");

// Class Stalker2.InteractableComponent
// 0x00F0 (0x01A8 - 0x00B8)
class UInteractableComponent : public UUIDActorComponent
{
public:
	FMulticastSparseDelegateProperty_             OnStartQuestNode;                                  // 0x00B8(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnFinishQuestNode;                                 // 0x00B9(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnExcludeQuestNode;                                // 0x00BA(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnRunAction;                                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRunAlternativeAction;                            // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEndInteract;                                     // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnUpdateInteract;                                  // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EInteractionType InteractableType, float Progress)> OnUpdateProgress; // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBaseInteractableAction*>        InteractableActions;                               // 0x0130(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         TriggerActorsList;                                 // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         AlternativeTriggerActorsList;                      // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         TriggerUserData;                                   // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TriggerAlternativeUserData;                        // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionType                              InteractionType;                                   // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDisplayPriority                              DisplayPriority;                                   // 0x0169(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16A[0x2];                                      // 0x016A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionProgressDurationTime;                   // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractionProgressIncreasingSpeed;                // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionProgressFillTimeInSeconds;              // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OverrideInteractionPromptText;                     // 0x0180(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTickableInteractable;                             // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInteractableWithDeadBody;                         // 0x0191(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_192[0x6];                                      // 0x0192(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentInteractingActor;                           // 0x0198(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A0[0x8];                                      // 0x01A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDisplayPriority(const EDisplayPriority& NewPriority);
	void SetEnabled(const bool bInEnabled);

	const EDisplayPriority GetDisplayPriority() const;
	const EInteractionType GetInteractionType() const;
	const bool GetPreventDefaultInteract() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableComponent">();
	}
	static class UInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableComponent>();
	}
};
static_assert(alignof(UInteractableComponent) == 0x000008, "Wrong alignment on UInteractableComponent");
static_assert(sizeof(UInteractableComponent) == 0x0001A8, "Wrong size on UInteractableComponent");
static_assert(offsetof(UInteractableComponent, OnStartQuestNode) == 0x0000B8, "Member 'UInteractableComponent::OnStartQuestNode' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnFinishQuestNode) == 0x0000B9, "Member 'UInteractableComponent::OnFinishQuestNode' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnExcludeQuestNode) == 0x0000BA, "Member 'UInteractableComponent::OnExcludeQuestNode' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnRunAction) == 0x0000C0, "Member 'UInteractableComponent::OnRunAction' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnRunAlternativeAction) == 0x0000D0, "Member 'UInteractableComponent::OnRunAlternativeAction' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnEndInteract) == 0x0000E0, "Member 'UInteractableComponent::OnEndInteract' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnUpdateInteract) == 0x000108, "Member 'UInteractableComponent::OnUpdateInteract' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnUpdateProgress) == 0x000118, "Member 'UInteractableComponent::OnUpdateProgress' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bEnabled) == 0x000128, "Member 'UInteractableComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractableActions) == 0x000130, "Member 'UInteractableComponent::InteractableActions' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, TriggerActorsList) == 0x000140, "Member 'UInteractableComponent::TriggerActorsList' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, AlternativeTriggerActorsList) == 0x000150, "Member 'UInteractableComponent::AlternativeTriggerActorsList' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, TriggerUserData) == 0x000160, "Member 'UInteractableComponent::TriggerUserData' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, TriggerAlternativeUserData) == 0x000164, "Member 'UInteractableComponent::TriggerAlternativeUserData' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractionType) == 0x000168, "Member 'UInteractableComponent::InteractionType' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, DisplayPriority) == 0x000169, "Member 'UInteractableComponent::DisplayPriority' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractionProgressDurationTime) == 0x00016C, "Member 'UInteractableComponent::InteractionProgressDurationTime' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractionProgressIncreasingSpeed) == 0x000170, "Member 'UInteractableComponent::InteractionProgressIncreasingSpeed' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractionProgressFillTimeInSeconds) == 0x000178, "Member 'UInteractableComponent::InteractionProgressFillTimeInSeconds' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OverrideInteractionPromptText) == 0x000180, "Member 'UInteractableComponent::OverrideInteractionPromptText' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bTickableInteractable) == 0x000190, "Member 'UInteractableComponent::bTickableInteractable' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bInteractableWithDeadBody) == 0x000191, "Member 'UInteractableComponent::bInteractableWithDeadBody' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, CurrentInteractingActor) == 0x000198, "Member 'UInteractableComponent::CurrentInteractingActor' has a wrong offset!");

// Class Stalker2.CombinationLock
// 0x0010 (0x01B8 - 0x01A8)
class UCombinationLock final : public UInteractableComponent
{
public:
	bool                                          bAvailableToPlayer;                                // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Code;                                              // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Opened;                                            // 0x01B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombinationLock">();
	}
	static class UCombinationLock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCombinationLock>();
	}
};
static_assert(alignof(UCombinationLock) == 0x000008, "Wrong alignment on UCombinationLock");
static_assert(sizeof(UCombinationLock) == 0x0001B8, "Wrong size on UCombinationLock");
static_assert(offsetof(UCombinationLock, bAvailableToPlayer) == 0x0001A8, "Member 'UCombinationLock::bAvailableToPlayer' has a wrong offset!");
static_assert(offsetof(UCombinationLock, Code) == 0x0001AC, "Member 'UCombinationLock::Code' has a wrong offset!");
static_assert(offsetof(UCombinationLock, Opened) == 0x0001B0, "Member 'UCombinationLock::Opened' has a wrong offset!");

// Class Stalker2.PossessedObjectEventData
// 0x0008 (0x0030 - 0x0028)
class UPossessedObjectEventData final : public UGameplayEventData
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetPossessedObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PossessedObjectEventData">();
	}
	static class UPossessedObjectEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPossessedObjectEventData>();
	}
};
static_assert(alignof(UPossessedObjectEventData) == 0x000008, "Wrong alignment on UPossessedObjectEventData");
static_assert(sizeof(UPossessedObjectEventData) == 0x000030, "Wrong size on UPossessedObjectEventData");

// Class Stalker2.DisplaySettingsWidget
// 0x0130 (0x03C0 - 0x0290)
class UDisplaySettingsWidget final : public USettingsPage
{
public:
	TMulticastInlineDelegate<void(const bool InSelected)> OnDisplayGammaSelected;                    // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USettingElementSwitcher*                GPUAdapter;                                        // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                Monitor;                                           // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                AspectRatio;                                       // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementResolutionSwitcher*     ScreenResolution;                                  // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                WindowMode;                                        // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementValueLocSwitcher*        FrameRate;                                         // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementOnOff*                   Vsync;                                             // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                FOV;                                               // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementOnOff*                   hdr;                                               // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            HDRCategory;                                       // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                Gamma;                                             // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                Brightness;                                        // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                HDRMinLuminance;                                   // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                HDRMaxLuminance;                                   // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                HDRBaseLuminance;                                  // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                HDRUILuminance;                                    // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementValueLocSwitcher*        HDRScheme;                                         // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                Contrast;                                          // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementButton*                  SafeZone;                                          // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementOnOff*                   NVIDIAReflex;                                      // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        PCSpecificElements;                                // 0x0340(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        ConsoleSpecificElements;                           // 0x0350(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SafeZoneViewWidgetClass;                           // 0x0360(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x30];                                     // 0x0390(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplaySettingsWidget">();
	}
	static class UDisplaySettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplaySettingsWidget>();
	}
};
static_assert(alignof(UDisplaySettingsWidget) == 0x000008, "Wrong alignment on UDisplaySettingsWidget");
static_assert(sizeof(UDisplaySettingsWidget) == 0x0003C0, "Wrong size on UDisplaySettingsWidget");
static_assert(offsetof(UDisplaySettingsWidget, OnDisplayGammaSelected) == 0x000290, "Member 'UDisplaySettingsWidget::OnDisplayGammaSelected' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, GPUAdapter) == 0x0002A0, "Member 'UDisplaySettingsWidget::GPUAdapter' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, Monitor) == 0x0002A8, "Member 'UDisplaySettingsWidget::Monitor' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, AspectRatio) == 0x0002B0, "Member 'UDisplaySettingsWidget::AspectRatio' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, ScreenResolution) == 0x0002B8, "Member 'UDisplaySettingsWidget::ScreenResolution' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, WindowMode) == 0x0002C0, "Member 'UDisplaySettingsWidget::WindowMode' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, FrameRate) == 0x0002C8, "Member 'UDisplaySettingsWidget::FrameRate' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, Vsync) == 0x0002D0, "Member 'UDisplaySettingsWidget::Vsync' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, FOV) == 0x0002D8, "Member 'UDisplaySettingsWidget::FOV' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, hdr) == 0x0002E0, "Member 'UDisplaySettingsWidget::hdr' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, HDRCategory) == 0x0002E8, "Member 'UDisplaySettingsWidget::HDRCategory' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, Gamma) == 0x0002F0, "Member 'UDisplaySettingsWidget::Gamma' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, Brightness) == 0x0002F8, "Member 'UDisplaySettingsWidget::Brightness' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, HDRMinLuminance) == 0x000300, "Member 'UDisplaySettingsWidget::HDRMinLuminance' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, HDRMaxLuminance) == 0x000308, "Member 'UDisplaySettingsWidget::HDRMaxLuminance' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, HDRBaseLuminance) == 0x000310, "Member 'UDisplaySettingsWidget::HDRBaseLuminance' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, HDRUILuminance) == 0x000318, "Member 'UDisplaySettingsWidget::HDRUILuminance' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, HDRScheme) == 0x000320, "Member 'UDisplaySettingsWidget::HDRScheme' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, Contrast) == 0x000328, "Member 'UDisplaySettingsWidget::Contrast' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, SafeZone) == 0x000330, "Member 'UDisplaySettingsWidget::SafeZone' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, NVIDIAReflex) == 0x000338, "Member 'UDisplaySettingsWidget::NVIDIAReflex' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, PCSpecificElements) == 0x000340, "Member 'UDisplaySettingsWidget::PCSpecificElements' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, ConsoleSpecificElements) == 0x000350, "Member 'UDisplaySettingsWidget::ConsoleSpecificElements' has a wrong offset!");
static_assert(offsetof(UDisplaySettingsWidget, SafeZoneViewWidgetClass) == 0x000360, "Member 'UDisplaySettingsWidget::SafeZoneViewWidgetClass' has a wrong offset!");

// Class Stalker2.HintBase
// 0x0098 (0x0310 - 0x0278)
class UHintBase : public UWidgetBase
{
public:
	EInteractionType                              InteractionType;                                   // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DefaultStylePrefix;                                // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StylePrefix;                                       // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x02A0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   FirstPlanStyle;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BackgroundStyle;                                   // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStyleManager;                               // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckInputKey;                                    // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGamepadKey;                                       // 0x02CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB[0x5];                                      // 0x02CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InputActionName;                                   // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InputMappingName;                                  // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HintFontStyle;                                     // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HintActionStyle;                                   // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Background;                                        // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HoverChangeHintTextColor(const bool bShow, const class FString& InStylePrefix);
	void PostShowHover(bool bInShow);
	void SetStylePrefix(const class FString& InStylePrefix);
	void SetText(const class FText& InText);
	void UpdateHintWidget();

	const TArray<struct FHoverAction> GetHoverSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintBase">();
	}
	static class UHintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintBase>();
	}
};
static_assert(alignof(UHintBase) == 0x000008, "Wrong alignment on UHintBase");
static_assert(sizeof(UHintBase) == 0x000310, "Wrong size on UHintBase");
static_assert(offsetof(UHintBase, InteractionType) == 0x000278, "Member 'UHintBase::InteractionType' has a wrong offset!");
static_assert(offsetof(UHintBase, DefaultStylePrefix) == 0x000280, "Member 'UHintBase::DefaultStylePrefix' has a wrong offset!");
static_assert(offsetof(UHintBase, StylePrefix) == 0x000290, "Member 'UHintBase::StylePrefix' has a wrong offset!");
static_assert(offsetof(UHintBase, Text) == 0x0002A0, "Member 'UHintBase::Text' has a wrong offset!");
static_assert(offsetof(UHintBase, FirstPlanStyle) == 0x0002B8, "Member 'UHintBase::FirstPlanStyle' has a wrong offset!");
static_assert(offsetof(UHintBase, BackgroundStyle) == 0x0002C0, "Member 'UHintBase::BackgroundStyle' has a wrong offset!");
static_assert(offsetof(UHintBase, bEnableStyleManager) == 0x0002C8, "Member 'UHintBase::bEnableStyleManager' has a wrong offset!");
static_assert(offsetof(UHintBase, bCheckInputKey) == 0x0002C9, "Member 'UHintBase::bCheckInputKey' has a wrong offset!");
static_assert(offsetof(UHintBase, bGamepadKey) == 0x0002CA, "Member 'UHintBase::bGamepadKey' has a wrong offset!");
static_assert(offsetof(UHintBase, InputActionName) == 0x0002D0, "Member 'UHintBase::InputActionName' has a wrong offset!");
static_assert(offsetof(UHintBase, InputMappingName) == 0x0002E0, "Member 'UHintBase::InputMappingName' has a wrong offset!");
static_assert(offsetof(UHintBase, HintFontStyle) == 0x0002E8, "Member 'UHintBase::HintFontStyle' has a wrong offset!");
static_assert(offsetof(UHintBase, HintActionStyle) == 0x0002F8, "Member 'UHintBase::HintActionStyle' has a wrong offset!");
static_assert(offsetof(UHintBase, Background) == 0x000308, "Member 'UHintBase::Background' has a wrong offset!");

// Class Stalker2.CommonHint
// 0x0030 (0x0340 - 0x0310)
class UCommonHint : public UHintBase
{
public:
	class ULocalizationWidget*                    LocalizationWidget;                                // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintSwitcher*                          HintSwitcherWidget;                                // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextWidget*                        RichTextWidget;                                    // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateLocalization;                               // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LocalizationSID;                                   // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonHint">();
	}
	static class UCommonHint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonHint>();
	}
};
static_assert(alignof(UCommonHint) == 0x000008, "Wrong alignment on UCommonHint");
static_assert(sizeof(UCommonHint) == 0x000340, "Wrong size on UCommonHint");
static_assert(offsetof(UCommonHint, LocalizationWidget) == 0x000310, "Member 'UCommonHint::LocalizationWidget' has a wrong offset!");
static_assert(offsetof(UCommonHint, HintSwitcherWidget) == 0x000318, "Member 'UCommonHint::HintSwitcherWidget' has a wrong offset!");
static_assert(offsetof(UCommonHint, RichTextWidget) == 0x000320, "Member 'UCommonHint::RichTextWidget' has a wrong offset!");
static_assert(offsetof(UCommonHint, bUpdateLocalization) == 0x000328, "Member 'UCommonHint::bUpdateLocalization' has a wrong offset!");
static_assert(offsetof(UCommonHint, LocalizationSID) == 0x000330, "Member 'UCommonHint::LocalizationSID' has a wrong offset!");

// Class Stalker2.PoppyFieldAnomalyBehaviorComponent
// 0x0320 (0x05C0 - 0x02A0)
class UPoppyFieldAnomalyBehaviorComponent final : public USceneComponent
{
public:
	struct FPrototypeSID                          InsideSleepinessEffectSID;                         // 0x02A0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrototypeSID                          OutsideSleepinessEffectSID;                        // 0x02E0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrototypeSID                          CriticalSleepinessEffectSID;                       // 0x0320(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FEffectPrototypeSID>            FallAsleepEffectSIDs;                              // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTransform>                     TeleportPoints;                                    // 0x0370(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 SleepThresholds;                                   // 0x0380(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         SleepTeleportMinDistance;                          // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SleepDuration;                                     // 0x0394(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           FlowerSoundEvent;                                  // 0x0398(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           AmbientSoundEvent;                                 // 0x03C8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           SleepinessSoundEventPlay;                          // 0x03F8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           SleepinessSoundEventStop;                          // 0x0428(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           EyelidsMovementSoundEvent;                         // 0x0458(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           BlinkSoundEvent;                                   // 0x0488(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkRtpc>                 BlinkParameter;                                    // 0x04B8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrototypeSID                          BlinkValueProviderSID;                             // 0x04E8(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0x30];                                     // 0x0528(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UShapeComponent*>                Collisions;                                        // 0x0558(0x0010)(ExportObject, ZeroConstructor, SaveGame, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UFlowerParticleComponent*>       FlowerParticleComponents;                          // 0x0568(0x0010)(ExportObject, ZeroConstructor, SaveGame, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_578[0x48];                                     // 0x0578(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnBeginOverlapFlowers(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnEndOverlapFlowers(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoppyFieldAnomalyBehaviorComponent">();
	}
	static class UPoppyFieldAnomalyBehaviorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoppyFieldAnomalyBehaviorComponent>();
	}
};
static_assert(alignof(UPoppyFieldAnomalyBehaviorComponent) == 0x000010, "Wrong alignment on UPoppyFieldAnomalyBehaviorComponent");
static_assert(sizeof(UPoppyFieldAnomalyBehaviorComponent) == 0x0005C0, "Wrong size on UPoppyFieldAnomalyBehaviorComponent");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, InsideSleepinessEffectSID) == 0x0002A0, "Member 'UPoppyFieldAnomalyBehaviorComponent::InsideSleepinessEffectSID' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, OutsideSleepinessEffectSID) == 0x0002E0, "Member 'UPoppyFieldAnomalyBehaviorComponent::OutsideSleepinessEffectSID' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, CriticalSleepinessEffectSID) == 0x000320, "Member 'UPoppyFieldAnomalyBehaviorComponent::CriticalSleepinessEffectSID' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, FallAsleepEffectSIDs) == 0x000360, "Member 'UPoppyFieldAnomalyBehaviorComponent::FallAsleepEffectSIDs' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, TeleportPoints) == 0x000370, "Member 'UPoppyFieldAnomalyBehaviorComponent::TeleportPoints' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, SleepThresholds) == 0x000380, "Member 'UPoppyFieldAnomalyBehaviorComponent::SleepThresholds' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, SleepTeleportMinDistance) == 0x000390, "Member 'UPoppyFieldAnomalyBehaviorComponent::SleepTeleportMinDistance' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, SleepDuration) == 0x000394, "Member 'UPoppyFieldAnomalyBehaviorComponent::SleepDuration' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, FlowerSoundEvent) == 0x000398, "Member 'UPoppyFieldAnomalyBehaviorComponent::FlowerSoundEvent' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, AmbientSoundEvent) == 0x0003C8, "Member 'UPoppyFieldAnomalyBehaviorComponent::AmbientSoundEvent' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, SleepinessSoundEventPlay) == 0x0003F8, "Member 'UPoppyFieldAnomalyBehaviorComponent::SleepinessSoundEventPlay' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, SleepinessSoundEventStop) == 0x000428, "Member 'UPoppyFieldAnomalyBehaviorComponent::SleepinessSoundEventStop' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, EyelidsMovementSoundEvent) == 0x000458, "Member 'UPoppyFieldAnomalyBehaviorComponent::EyelidsMovementSoundEvent' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, BlinkSoundEvent) == 0x000488, "Member 'UPoppyFieldAnomalyBehaviorComponent::BlinkSoundEvent' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, BlinkParameter) == 0x0004B8, "Member 'UPoppyFieldAnomalyBehaviorComponent::BlinkParameter' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, BlinkValueProviderSID) == 0x0004E8, "Member 'UPoppyFieldAnomalyBehaviorComponent::BlinkValueProviderSID' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, Collisions) == 0x000558, "Member 'UPoppyFieldAnomalyBehaviorComponent::Collisions' has a wrong offset!");
static_assert(offsetof(UPoppyFieldAnomalyBehaviorComponent, FlowerParticleComponents) == 0x000568, "Member 'UPoppyFieldAnomalyBehaviorComponent::FlowerParticleComponents' has a wrong offset!");

// Class Stalker2.RazerChromaSubsystem
// 0x00C8 (0x00F8 - 0x0030)
class URazerChromaSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x98];                                      // 0x0030(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class URazerChromaEventTracker*               EventTracker;                                      // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URazerChromaCinematicEventTracker*      CinematicEventTracker;                             // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RazerChromaSubsystem">();
	}
	static class URazerChromaSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URazerChromaSubsystem>();
	}
};
static_assert(alignof(URazerChromaSubsystem) == 0x000008, "Wrong alignment on URazerChromaSubsystem");
static_assert(sizeof(URazerChromaSubsystem) == 0x0000F8, "Wrong size on URazerChromaSubsystem");
static_assert(offsetof(URazerChromaSubsystem, EventTracker) == 0x0000C8, "Member 'URazerChromaSubsystem::EventTracker' has a wrong offset!");
static_assert(offsetof(URazerChromaSubsystem, CinematicEventTracker) == 0x0000D0, "Member 'URazerChromaSubsystem::CinematicEventTracker' has a wrong offset!");

// Class Stalker2.CommonVerticalBox
// 0x0000 (0x0178 - 0x0178)
class UCommonVerticalBox final : public UVerticalBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonVerticalBox">();
	}
	static class UCommonVerticalBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonVerticalBox>();
	}
};
static_assert(alignof(UCommonVerticalBox) == 0x000008, "Wrong alignment on UCommonVerticalBox");
static_assert(sizeof(UCommonVerticalBox) == 0x000178, "Wrong size on UCommonVerticalBox");

// Class Stalker2.CustomConsoleManagerVP
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerVP final : public UBaseConsoleManager
{
public:
	void XResurrectNPCAsZombie(const int32 NpcUID);
	void XWoundNpcByUID(const int32 NpcUID);

	void XKnockDownNpc(const int32 NpcUID) const;
	void XKnockDownNpcByAnotherNpc(const int32 NpcUID, const int32 AttackerNpcUID) const;
	void XLaunchFacialAnimation(const int32 ObjUID, const class FString& AnimPath) const;
	void XLimitNpcBodyPartRotation(const int32 NpcUID, const float LimitAngle, ERotationPartType RotationPartType) const;
	void XNpcLookAt(const int32 NpcUID, const float X, const float Y, const float Z) const;
	void XNpcLookAtNPC(const int32 NpcUID, const int32 TargetNpcUID) const;
	void XNpcSetLookAtOwnerState(const int32 NpcUID, ELookAtOwnerState LookAtOwnerState) const;
	void XReloadAttach() const;
	void XReloadAttachTactical() const;
	void XShootAttach() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerVP">();
	}
	static class UCustomConsoleManagerVP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerVP>();
	}
};
static_assert(alignof(UCustomConsoleManagerVP) == 0x000008, "Wrong alignment on UCustomConsoleManagerVP");
static_assert(sizeof(UCustomConsoleManagerVP) == 0x0000A8, "Wrong size on UCustomConsoleManagerVP");

// Class Stalker2.CompassManager
// 0x0000 (0x00A8 - 0x00A8)
class UCompassManager final : public UBaseTickableManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompassManager">();
	}
	static class UCompassManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompassManager>();
	}
};
static_assert(alignof(UCompassManager) == 0x000008, "Wrong alignment on UCompassManager");
static_assert(sizeof(UCompassManager) == 0x0000A8, "Wrong size on UCompassManager");

// Class Stalker2.RichTextBlockWidgetDecorator
// 0x0018 (0x0040 - 0x0028)
class URichTextBlockWidgetDecorator : public URichTextBlockDecorator
{
public:
	TArray<class UUserWidget*>                    ChachedWidgetsCreatedByDecorator;                  // 0x0028(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UDataTable*                             WidgetSet;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextBlockWidgetDecorator">();
	}
	static class URichTextBlockWidgetDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextBlockWidgetDecorator>();
	}
};
static_assert(alignof(URichTextBlockWidgetDecorator) == 0x000008, "Wrong alignment on URichTextBlockWidgetDecorator");
static_assert(sizeof(URichTextBlockWidgetDecorator) == 0x000040, "Wrong size on URichTextBlockWidgetDecorator");
static_assert(offsetof(URichTextBlockWidgetDecorator, ChachedWidgetsCreatedByDecorator) == 0x000028, "Member 'URichTextBlockWidgetDecorator::ChachedWidgetsCreatedByDecorator' has a wrong offset!");
static_assert(offsetof(URichTextBlockWidgetDecorator, WidgetSet) == 0x000038, "Member 'URichTextBlockWidgetDecorator::WidgetSet' has a wrong offset!");

// Class Stalker2.CompassWidget
// 0x0178 (0x03F0 - 0x0278)
class UCompassWidget final : public UChildViewBase
{
public:
	class UImage*                                 StealthNoiseIndicator;                             // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BackgroundImage;                                   // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 CompassCardinalDirectionImage;                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BodyCompassLine;                                   // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 LineRight;                                         // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 LineLeft;                                          // 0x02A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           NoiseProgress;                                     // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           NoiseProgressBottomLines;                          // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Arrow;                                             // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           MarkerContainer;                                   // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               CompassSize;                                       // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               LineSizeBox;                                       // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiplyBodyLineSpeedPercent;                      // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterZoneWidth;                                   // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaskZoneWidth;                                     // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HiddeMarkerZone;                                   // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterCompassBorder;                               // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateBackgroundTime;                              // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TopMarkerHeight;                                   // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BottomMarkerHeigth;                                // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEnableAutoUpdate;                           // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoiseBarFillSpeed;                                 // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseBarReduceSpeed;                               // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEnableAutoHideCompaas;                      // 0x0304(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_305[0x3];                                      // 0x0305(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeUpdateHideCompaasMax;                          // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeUpdateHideCompaas;                             // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEnableTurnAngleAutoHide;                    // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerTurnAngleMax;                                // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApproximationPlayerLocation;                       // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorInRadiasMain;                                 // 0x031C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorInRadiasSecondary;                            // 0x032C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorForBattleModAnimation;                        // 0x033C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorForQuestZoneSearchAnimation;                  // 0x034C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableNoiseIndicator;                            // 0x035C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       ShowAnimation;                                     // 0x0360(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowShowAnimationSpeedMultiplier;                  // 0x0368(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastShowAnimationSpeedMultiplier;                  // 0x036C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       StealthNoiseWavingAnimation;                       // 0x0370(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x78];                                     // 0x0378(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompassWidget">();
	}
	static class UCompassWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompassWidget>();
	}
};
static_assert(alignof(UCompassWidget) == 0x000008, "Wrong alignment on UCompassWidget");
static_assert(sizeof(UCompassWidget) == 0x0003F0, "Wrong size on UCompassWidget");
static_assert(offsetof(UCompassWidget, StealthNoiseIndicator) == 0x000278, "Member 'UCompassWidget::StealthNoiseIndicator' has a wrong offset!");
static_assert(offsetof(UCompassWidget, BackgroundImage) == 0x000280, "Member 'UCompassWidget::BackgroundImage' has a wrong offset!");
static_assert(offsetof(UCompassWidget, CompassCardinalDirectionImage) == 0x000288, "Member 'UCompassWidget::CompassCardinalDirectionImage' has a wrong offset!");
static_assert(offsetof(UCompassWidget, BodyCompassLine) == 0x000290, "Member 'UCompassWidget::BodyCompassLine' has a wrong offset!");
static_assert(offsetof(UCompassWidget, LineRight) == 0x000298, "Member 'UCompassWidget::LineRight' has a wrong offset!");
static_assert(offsetof(UCompassWidget, LineLeft) == 0x0002A0, "Member 'UCompassWidget::LineLeft' has a wrong offset!");
static_assert(offsetof(UCompassWidget, NoiseProgress) == 0x0002A8, "Member 'UCompassWidget::NoiseProgress' has a wrong offset!");
static_assert(offsetof(UCompassWidget, NoiseProgressBottomLines) == 0x0002B0, "Member 'UCompassWidget::NoiseProgressBottomLines' has a wrong offset!");
static_assert(offsetof(UCompassWidget, Arrow) == 0x0002B8, "Member 'UCompassWidget::Arrow' has a wrong offset!");
static_assert(offsetof(UCompassWidget, MarkerContainer) == 0x0002C0, "Member 'UCompassWidget::MarkerContainer' has a wrong offset!");
static_assert(offsetof(UCompassWidget, CompassSize) == 0x0002C8, "Member 'UCompassWidget::CompassSize' has a wrong offset!");
static_assert(offsetof(UCompassWidget, LineSizeBox) == 0x0002D0, "Member 'UCompassWidget::LineSizeBox' has a wrong offset!");
static_assert(offsetof(UCompassWidget, MultiplyBodyLineSpeedPercent) == 0x0002D8, "Member 'UCompassWidget::MultiplyBodyLineSpeedPercent' has a wrong offset!");
static_assert(offsetof(UCompassWidget, CenterZoneWidth) == 0x0002DC, "Member 'UCompassWidget::CenterZoneWidth' has a wrong offset!");
static_assert(offsetof(UCompassWidget, MaskZoneWidth) == 0x0002E0, "Member 'UCompassWidget::MaskZoneWidth' has a wrong offset!");
static_assert(offsetof(UCompassWidget, HiddeMarkerZone) == 0x0002E4, "Member 'UCompassWidget::HiddeMarkerZone' has a wrong offset!");
static_assert(offsetof(UCompassWidget, CenterCompassBorder) == 0x0002E8, "Member 'UCompassWidget::CenterCompassBorder' has a wrong offset!");
static_assert(offsetof(UCompassWidget, UpdateBackgroundTime) == 0x0002EC, "Member 'UCompassWidget::UpdateBackgroundTime' has a wrong offset!");
static_assert(offsetof(UCompassWidget, TopMarkerHeight) == 0x0002F0, "Member 'UCompassWidget::TopMarkerHeight' has a wrong offset!");
static_assert(offsetof(UCompassWidget, BottomMarkerHeigth) == 0x0002F4, "Member 'UCompassWidget::BottomMarkerHeigth' has a wrong offset!");
static_assert(offsetof(UCompassWidget, bShouldEnableAutoUpdate) == 0x0002F8, "Member 'UCompassWidget::bShouldEnableAutoUpdate' has a wrong offset!");
static_assert(offsetof(UCompassWidget, NoiseBarFillSpeed) == 0x0002FC, "Member 'UCompassWidget::NoiseBarFillSpeed' has a wrong offset!");
static_assert(offsetof(UCompassWidget, NoiseBarReduceSpeed) == 0x000300, "Member 'UCompassWidget::NoiseBarReduceSpeed' has a wrong offset!");
static_assert(offsetof(UCompassWidget, bShouldEnableAutoHideCompaas) == 0x000304, "Member 'UCompassWidget::bShouldEnableAutoHideCompaas' has a wrong offset!");
static_assert(offsetof(UCompassWidget, TimeUpdateHideCompaasMax) == 0x000308, "Member 'UCompassWidget::TimeUpdateHideCompaasMax' has a wrong offset!");
static_assert(offsetof(UCompassWidget, TimeUpdateHideCompaas) == 0x00030C, "Member 'UCompassWidget::TimeUpdateHideCompaas' has a wrong offset!");
static_assert(offsetof(UCompassWidget, bShouldEnableTurnAngleAutoHide) == 0x000310, "Member 'UCompassWidget::bShouldEnableTurnAngleAutoHide' has a wrong offset!");
static_assert(offsetof(UCompassWidget, PlayerTurnAngleMax) == 0x000314, "Member 'UCompassWidget::PlayerTurnAngleMax' has a wrong offset!");
static_assert(offsetof(UCompassWidget, ApproximationPlayerLocation) == 0x000318, "Member 'UCompassWidget::ApproximationPlayerLocation' has a wrong offset!");
static_assert(offsetof(UCompassWidget, ColorInRadiasMain) == 0x00031C, "Member 'UCompassWidget::ColorInRadiasMain' has a wrong offset!");
static_assert(offsetof(UCompassWidget, ColorInRadiasSecondary) == 0x00032C, "Member 'UCompassWidget::ColorInRadiasSecondary' has a wrong offset!");
static_assert(offsetof(UCompassWidget, ColorForBattleModAnimation) == 0x00033C, "Member 'UCompassWidget::ColorForBattleModAnimation' has a wrong offset!");
static_assert(offsetof(UCompassWidget, ColorForQuestZoneSearchAnimation) == 0x00034C, "Member 'UCompassWidget::ColorForQuestZoneSearchAnimation' has a wrong offset!");
static_assert(offsetof(UCompassWidget, bDisableNoiseIndicator) == 0x00035C, "Member 'UCompassWidget::bDisableNoiseIndicator' has a wrong offset!");
static_assert(offsetof(UCompassWidget, ShowAnimation) == 0x000360, "Member 'UCompassWidget::ShowAnimation' has a wrong offset!");
static_assert(offsetof(UCompassWidget, SlowShowAnimationSpeedMultiplier) == 0x000368, "Member 'UCompassWidget::SlowShowAnimationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UCompassWidget, FastShowAnimationSpeedMultiplier) == 0x00036C, "Member 'UCompassWidget::FastShowAnimationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UCompassWidget, StealthNoiseWavingAnimation) == 0x000370, "Member 'UCompassWidget::StealthNoiseWavingAnimation' has a wrong offset!");

// Class Stalker2.DialogueView
// 0x0428 (0x06F0 - 0x02C8)
class UDialogueView : public UViewBaseExtended
{
public:
	struct FDialogAnswersStyles                   AswersStyles;                                      // 0x02C8(0x0380)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShouldShowAnimation;                              // 0x0648(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_649[0x7];                                      // 0x0649(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       ShowAnimation;                                     // 0x0650(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DialogTimeDelay;                                   // 0x0658(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65C[0x94];                                     // 0x065C(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueView">();
	}
	static class UDialogueView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueView>();
	}
};
static_assert(alignof(UDialogueView) == 0x000008, "Wrong alignment on UDialogueView");
static_assert(sizeof(UDialogueView) == 0x0006F0, "Wrong size on UDialogueView");
static_assert(offsetof(UDialogueView, AswersStyles) == 0x0002C8, "Member 'UDialogueView::AswersStyles' has a wrong offset!");
static_assert(offsetof(UDialogueView, bShouldShowAnimation) == 0x000648, "Member 'UDialogueView::bShouldShowAnimation' has a wrong offset!");
static_assert(offsetof(UDialogueView, ShowAnimation) == 0x000650, "Member 'UDialogueView::ShowAnimation' has a wrong offset!");
static_assert(offsetof(UDialogueView, DialogTimeDelay) == 0x000658, "Member 'UDialogueView::DialogTimeDelay' has a wrong offset!");

// Class Stalker2.ConfirmUpgradePopup
// 0x0020 (0x0298 - 0x0278)
class UConfirmUpgradePopup final : public UWidgetBase
{
public:
	class UTextWidget*                            Title;                                             // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextWidget*                        RichDescription;                                   // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   ConfirmHint;                                       // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   CancelHint;                                        // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfirmUpgradePopup">();
	}
	static class UConfirmUpgradePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfirmUpgradePopup>();
	}
};
static_assert(alignof(UConfirmUpgradePopup) == 0x000008, "Wrong alignment on UConfirmUpgradePopup");
static_assert(sizeof(UConfirmUpgradePopup) == 0x000298, "Wrong size on UConfirmUpgradePopup");
static_assert(offsetof(UConfirmUpgradePopup, Title) == 0x000278, "Member 'UConfirmUpgradePopup::Title' has a wrong offset!");
static_assert(offsetof(UConfirmUpgradePopup, RichDescription) == 0x000280, "Member 'UConfirmUpgradePopup::RichDescription' has a wrong offset!");
static_assert(offsetof(UConfirmUpgradePopup, ConfirmHint) == 0x000288, "Member 'UConfirmUpgradePopup::ConfirmHint' has a wrong offset!");
static_assert(offsetof(UConfirmUpgradePopup, CancelHint) == 0x000290, "Member 'UConfirmUpgradePopup::CancelHint' has a wrong offset!");

// Class Stalker2.SaveLoadIO
// 0x0000 (0x0028 - 0x0028)
class USaveLoadIO : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadIO">();
	}
	static class USaveLoadIO* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadIO>();
	}
};
static_assert(alignof(USaveLoadIO) == 0x000008, "Wrong alignment on USaveLoadIO");
static_assert(sizeof(USaveLoadIO) == 0x000028, "Wrong size on USaveLoadIO");

// Class Stalker2.PCSaveLoadIO
// 0x0000 (0x0028 - 0x0028)
class UPCSaveLoadIO final : public USaveLoadIO
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCSaveLoadIO">();
	}
	static class UPCSaveLoadIO* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCSaveLoadIO>();
	}
};
static_assert(alignof(UPCSaveLoadIO) == 0x000008, "Wrong alignment on UPCSaveLoadIO");
static_assert(sizeof(UPCSaveLoadIO) == 0x000028, "Wrong size on UPCSaveLoadIO");

// Class Stalker2.CustomConsoleManagerYS
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerYS final : public UBaseConsoleManager
{
public:
	void XSpawnALifeDirectorScenario(const class FString& ScenarioSID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerYS">();
	}
	static class UCustomConsoleManagerYS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerYS>();
	}
};
static_assert(alignof(UCustomConsoleManagerYS) == 0x000008, "Wrong alignment on UCustomConsoleManagerYS");
static_assert(sizeof(UCustomConsoleManagerYS) == 0x0000A8, "Wrong size on UCustomConsoleManagerYS");

// Class Stalker2.UIDActor_ContextualAction
// 0x0008 (0x02A8 - 0x02A0)
class AUIDActor_ContextualAction : public AUIDActorOwnsModel
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActor_ContextualAction">();
	}
	static class AUIDActor_ContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDActor_ContextualAction>();
	}
};
static_assert(alignof(AUIDActor_ContextualAction) == 0x000008, "Wrong alignment on AUIDActor_ContextualAction");
static_assert(sizeof(AUIDActor_ContextualAction) == 0x0002A8, "Wrong size on AUIDActor_ContextualAction");

// Class Stalker2.ContextualAction
// 0x0030 (0x02D8 - 0x02A8)
class AContextualAction final : public AUIDActor_ContextualAction
{
public:
	uint8                                         Pad_2A8[0x30];                                     // 0x02A8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAction">();
	}
	static class AContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AContextualAction>();
	}
};
static_assert(alignof(AContextualAction) == 0x000008, "Wrong alignment on AContextualAction");
static_assert(sizeof(AContextualAction) == 0x0002D8, "Wrong size on AContextualAction");

// Class Stalker2.PauseGameView
// 0x0090 (0x0358 - 0x02C8)
class UPauseGameView final : public UViewBaseExtended
{
public:
	class UGameMenuElement*                       Continue;                                          // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameMenuElement*                       Play;                                              // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameMenuElement*                       Save;                                              // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameMenuElement*                       Load;                                              // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameMenuElement*                       Online;                                            // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameMenuElement*                       Options;                                           // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameMenuElement*                       Back;                                              // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameMenuElement*                       Exit;                                              // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameMenuElement*                       DebugMaps;                                         // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameMenuElement*                       BackToMainMenu;                                    // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameMenuElement*                       DebugBenchmark;                                    // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           ButtonContainer;                                   // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Background;                                        // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               MenuOverlay;                                       // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               OptionsOverlay;                                    // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x18];                                     // 0x0340(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClickBack();
	void OnClickBackToMainMenu();
	void OnClickContinue();
	void OnClickDebugMaps();
	void OnClickExit();
	void OnClickLoad();
	void OnClickOnline();
	void OnClickOptions();
	void OnClickPlay();
	void OnClickSave();
	void OnItemHovered();
	void UIMenuBack();
	void UIMenuConfirm();
	void UIMenuMoveDown();
	void UIMenuMoveUp();
	void UIOptionsBack();
	void UpdateShowDebugMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseGameView">();
	}
	static class UPauseGameView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPauseGameView>();
	}
};
static_assert(alignof(UPauseGameView) == 0x000008, "Wrong alignment on UPauseGameView");
static_assert(sizeof(UPauseGameView) == 0x000358, "Wrong size on UPauseGameView");
static_assert(offsetof(UPauseGameView, Continue) == 0x0002C8, "Member 'UPauseGameView::Continue' has a wrong offset!");
static_assert(offsetof(UPauseGameView, Play) == 0x0002D0, "Member 'UPauseGameView::Play' has a wrong offset!");
static_assert(offsetof(UPauseGameView, Save) == 0x0002D8, "Member 'UPauseGameView::Save' has a wrong offset!");
static_assert(offsetof(UPauseGameView, Load) == 0x0002E0, "Member 'UPauseGameView::Load' has a wrong offset!");
static_assert(offsetof(UPauseGameView, Online) == 0x0002E8, "Member 'UPauseGameView::Online' has a wrong offset!");
static_assert(offsetof(UPauseGameView, Options) == 0x0002F0, "Member 'UPauseGameView::Options' has a wrong offset!");
static_assert(offsetof(UPauseGameView, Back) == 0x0002F8, "Member 'UPauseGameView::Back' has a wrong offset!");
static_assert(offsetof(UPauseGameView, Exit) == 0x000300, "Member 'UPauseGameView::Exit' has a wrong offset!");
static_assert(offsetof(UPauseGameView, DebugMaps) == 0x000308, "Member 'UPauseGameView::DebugMaps' has a wrong offset!");
static_assert(offsetof(UPauseGameView, BackToMainMenu) == 0x000310, "Member 'UPauseGameView::BackToMainMenu' has a wrong offset!");
static_assert(offsetof(UPauseGameView, DebugBenchmark) == 0x000318, "Member 'UPauseGameView::DebugBenchmark' has a wrong offset!");
static_assert(offsetof(UPauseGameView, ButtonContainer) == 0x000320, "Member 'UPauseGameView::ButtonContainer' has a wrong offset!");
static_assert(offsetof(UPauseGameView, Background) == 0x000328, "Member 'UPauseGameView::Background' has a wrong offset!");
static_assert(offsetof(UPauseGameView, MenuOverlay) == 0x000330, "Member 'UPauseGameView::MenuOverlay' has a wrong offset!");
static_assert(offsetof(UPauseGameView, OptionsOverlay) == 0x000338, "Member 'UPauseGameView::OptionsOverlay' has a wrong offset!");

// Class Stalker2.ContextualActionAssetDataShared
// 0x00B0 (0x0128 - 0x0078)
class UContextualActionAssetDataShared final : public UBaseManager
{
public:
	uint8                                         Pad_78[0xB0];                                      // 0x0078(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualActionAssetDataShared">();
	}
	static class UContextualActionAssetDataShared* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualActionAssetDataShared>();
	}
};
static_assert(alignof(UContextualActionAssetDataShared) == 0x000008, "Wrong alignment on UContextualActionAssetDataShared");
static_assert(sizeof(UContextualActionAssetDataShared) == 0x000128, "Wrong size on UContextualActionAssetDataShared");

// Class Stalker2.NotificationWidget
// 0x00F8 (0x0370 - 0x0278)
class UNotificationWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x70];                                     // 0x0278(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UQuestNotification*                     MainQuest;                                         // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQuestNotification*                     SecondaryQuest;                                    // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           QuestVerticalBox;                                  // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQuestNotificationDataAsset*            Settings;                                          // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x30];                                     // 0x0308(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UQuestNotification*                     NotificationWithActiveHint;                        // 0x0338(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x30];                                     // 0x0340(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideNotificationMain();
	void HideNotificationSecondary();
	void TryShowNextNotify();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotificationWidget">();
	}
	static class UNotificationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotificationWidget>();
	}
};
static_assert(alignof(UNotificationWidget) == 0x000008, "Wrong alignment on UNotificationWidget");
static_assert(sizeof(UNotificationWidget) == 0x000370, "Wrong size on UNotificationWidget");
static_assert(offsetof(UNotificationWidget, MainQuest) == 0x0002E8, "Member 'UNotificationWidget::MainQuest' has a wrong offset!");
static_assert(offsetof(UNotificationWidget, SecondaryQuest) == 0x0002F0, "Member 'UNotificationWidget::SecondaryQuest' has a wrong offset!");
static_assert(offsetof(UNotificationWidget, QuestVerticalBox) == 0x0002F8, "Member 'UNotificationWidget::QuestVerticalBox' has a wrong offset!");
static_assert(offsetof(UNotificationWidget, Settings) == 0x000300, "Member 'UNotificationWidget::Settings' has a wrong offset!");
static_assert(offsetof(UNotificationWidget, NotificationWithActiveHint) == 0x000338, "Member 'UNotificationWidget::NotificationWithActiveHint' has a wrong offset!");

// Class Stalker2.ContextualActionCommunicationManager
// 0x01C0 (0x0268 - 0x00A8)
class UContextualActionCommunicationManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x1C0];                                     // 0x00A8(0x01C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualActionCommunicationManager">();
	}
	static class UContextualActionCommunicationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualActionCommunicationManager>();
	}
};
static_assert(alignof(UContextualActionCommunicationManager) == 0x000008, "Wrong alignment on UContextualActionCommunicationManager");
static_assert(sizeof(UContextualActionCommunicationManager) == 0x000268, "Wrong size on UContextualActionCommunicationManager");

// Class Stalker2.ContextualActionComponent
// 0x0008 (0x00C0 - 0x00B8)
class UContextualActionComponent final : public UUIDActorComponent
{
public:
	EAttachmentRule                               AttachmentItemRule;                                // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetachmentRule                               DetachmentItemLocationRule;                        // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetachmentRule                               DetachmentItemRotationRule;                        // 0x00BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualActionComponent">();
	}
	static class UContextualActionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualActionComponent>();
	}
};
static_assert(alignof(UContextualActionComponent) == 0x000008, "Wrong alignment on UContextualActionComponent");
static_assert(sizeof(UContextualActionComponent) == 0x0000C0, "Wrong size on UContextualActionComponent");
static_assert(offsetof(UContextualActionComponent, AttachmentItemRule) == 0x0000B8, "Member 'UContextualActionComponent::AttachmentItemRule' has a wrong offset!");
static_assert(offsetof(UContextualActionComponent, DetachmentItemLocationRule) == 0x0000B9, "Member 'UContextualActionComponent::DetachmentItemLocationRule' has a wrong offset!");
static_assert(offsetof(UContextualActionComponent, DetachmentItemRotationRule) == 0x0000BA, "Member 'UContextualActionComponent::DetachmentItemRotationRule' has a wrong offset!");

// Class Stalker2.PlayerStorageData
// 0x0010 (0x0288 - 0x0278)
class UPlayerStorageData final : public UWidgetBase
{
public:
	class UTooltipRecord*                         ItemsAmount;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTooltipRecord*                         ItemsWeight;                                       // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStorageData">();
	}
	static class UPlayerStorageData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStorageData>();
	}
};
static_assert(alignof(UPlayerStorageData) == 0x000008, "Wrong alignment on UPlayerStorageData");
static_assert(sizeof(UPlayerStorageData) == 0x000288, "Wrong size on UPlayerStorageData");
static_assert(offsetof(UPlayerStorageData, ItemsAmount) == 0x000278, "Member 'UPlayerStorageData::ItemsAmount' has a wrong offset!");
static_assert(offsetof(UPlayerStorageData, ItemsWeight) == 0x000280, "Member 'UPlayerStorageData::ItemsWeight' has a wrong offset!");

// Class Stalker2.ContextualActionEffect
// 0x0000 (0x0028 - 0x0028)
class UContextualActionEffect : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualActionEffect">();
	}
	static class UContextualActionEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualActionEffect>();
	}
};
static_assert(alignof(UContextualActionEffect) == 0x000008, "Wrong alignment on UContextualActionEffect");
static_assert(sizeof(UContextualActionEffect) == 0x000028, "Wrong size on UContextualActionEffect");

// Class Stalker2.door
// 0x0048 (0x02C0 - 0x0278)
class Udoor final : public ULockableComponent
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDoorMovableData>               Doors;                                             // 0x0280(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bShouldRestoreAngle;                               // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTaskCanBeInterrupted;                             // 0x0291(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoorCanBePushed;                                  // 0x0292(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_293[0x1];                                      // 0x0293(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialPushImpulseMultiplier;                      // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleRestoreSpeed;                                 // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleRestoreDelay;                                 // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorState                                    CurrentState;                                      // 0x02A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x1F];                                     // 0x02A1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDoorMeshHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"door">();
	}
	static class Udoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<Udoor>();
	}
};
static_assert(alignof(Udoor) == 0x000008, "Wrong alignment on Udoor");
static_assert(sizeof(Udoor) == 0x0002C0, "Wrong size on Udoor");
static_assert(offsetof(Udoor, Doors) == 0x000280, "Member 'Udoor::Doors' has a wrong offset!");
static_assert(offsetof(Udoor, bShouldRestoreAngle) == 0x000290, "Member 'Udoor::bShouldRestoreAngle' has a wrong offset!");
static_assert(offsetof(Udoor, bTaskCanBeInterrupted) == 0x000291, "Member 'Udoor::bTaskCanBeInterrupted' has a wrong offset!");
static_assert(offsetof(Udoor, bDoorCanBePushed) == 0x000292, "Member 'Udoor::bDoorCanBePushed' has a wrong offset!");
static_assert(offsetof(Udoor, InitialPushImpulseMultiplier) == 0x000294, "Member 'Udoor::InitialPushImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(Udoor, AngleRestoreSpeed) == 0x000298, "Member 'Udoor::AngleRestoreSpeed' has a wrong offset!");
static_assert(offsetof(Udoor, AngleRestoreDelay) == 0x00029C, "Member 'Udoor::AngleRestoreDelay' has a wrong offset!");
static_assert(offsetof(Udoor, CurrentState) == 0x0002A0, "Member 'Udoor::CurrentState' has a wrong offset!");

// Class Stalker2.ContextualActionNeedEffect
// 0x0008 (0x0030 - 0x0028)
class UContextualActionNeedEffect final : public UContextualActionEffect
{
public:
	EContextualActionNeeds                        ContextualActionNeed;                              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeValuePerSelector;                            // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualActionNeedEffect">();
	}
	static class UContextualActionNeedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualActionNeedEffect>();
	}
};
static_assert(alignof(UContextualActionNeedEffect) == 0x000008, "Wrong alignment on UContextualActionNeedEffect");
static_assert(sizeof(UContextualActionNeedEffect) == 0x000030, "Wrong size on UContextualActionNeedEffect");
static_assert(offsetof(UContextualActionNeedEffect, ContextualActionNeed) == 0x000028, "Member 'UContextualActionNeedEffect::ContextualActionNeed' has a wrong offset!");
static_assert(offsetof(UContextualActionNeedEffect, ChangeValuePerSelector) == 0x00002C, "Member 'UContextualActionNeedEffect::ChangeValuePerSelector' has a wrong offset!");

// Class Stalker2.AddNeedEffect
// 0x0008 (0x0030 - 0x0028)
class UAddNeedEffect final : public UContextualActionEffect
{
public:
	EContextualActionNeeds                        ContextualActionNeedForAdd;                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddNeedEffect">();
	}
	static class UAddNeedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddNeedEffect>();
	}
};
static_assert(alignof(UAddNeedEffect) == 0x000008, "Wrong alignment on UAddNeedEffect");
static_assert(sizeof(UAddNeedEffect) == 0x000030, "Wrong size on UAddNeedEffect");
static_assert(offsetof(UAddNeedEffect, ContextualActionNeedForAdd) == 0x000028, "Member 'UAddNeedEffect::ContextualActionNeedForAdd' has a wrong offset!");

// Class Stalker2.PDATutorialDetails
// 0x0170 (0x0400 - 0x0290)
class UPDATutorialDetails final : public UHoverIndicator
{
public:
	class UVerticalBox*                           TutorialBox;                                       // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextBlock*                         TitleText;                                         // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextBlock*                         RichText;                                          // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScrollBox*                             TextScroll;                                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumWidgetsInLine;                                  // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScrollMoveSpeed;                                   // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommonVerticalBox*                     ParentVerticalBox;                                 // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x140];                                    // 0x02C0(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDATutorialDetails">();
	}
	static class UPDATutorialDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDATutorialDetails>();
	}
};
static_assert(alignof(UPDATutorialDetails) == 0x000008, "Wrong alignment on UPDATutorialDetails");
static_assert(sizeof(UPDATutorialDetails) == 0x000400, "Wrong size on UPDATutorialDetails");
static_assert(offsetof(UPDATutorialDetails, TutorialBox) == 0x000290, "Member 'UPDATutorialDetails::TutorialBox' has a wrong offset!");
static_assert(offsetof(UPDATutorialDetails, TitleText) == 0x000298, "Member 'UPDATutorialDetails::TitleText' has a wrong offset!");
static_assert(offsetof(UPDATutorialDetails, RichText) == 0x0002A0, "Member 'UPDATutorialDetails::RichText' has a wrong offset!");
static_assert(offsetof(UPDATutorialDetails, TextScroll) == 0x0002A8, "Member 'UPDATutorialDetails::TextScroll' has a wrong offset!");
static_assert(offsetof(UPDATutorialDetails, NumWidgetsInLine) == 0x0002B0, "Member 'UPDATutorialDetails::NumWidgetsInLine' has a wrong offset!");
static_assert(offsetof(UPDATutorialDetails, ScrollMoveSpeed) == 0x0002B4, "Member 'UPDATutorialDetails::ScrollMoveSpeed' has a wrong offset!");
static_assert(offsetof(UPDATutorialDetails, ParentVerticalBox) == 0x0002B8, "Member 'UPDATutorialDetails::ParentVerticalBox' has a wrong offset!");

// Class Stalker2.CutsceneLookUpIPU
// 0x0000 (0x0040 - 0x0040)
class UCutsceneLookUpIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CutsceneLookUpIPU">();
	}
	static class UCutsceneLookUpIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCutsceneLookUpIPU>();
	}
};
static_assert(alignof(UCutsceneLookUpIPU) == 0x000008, "Wrong alignment on UCutsceneLookUpIPU");
static_assert(sizeof(UCutsceneLookUpIPU) == 0x000040, "Wrong size on UCutsceneLookUpIPU");

// Class Stalker2.RemoveNeedEffect
// 0x0008 (0x0030 - 0x0028)
class URemoveNeedEffect final : public UContextualActionEffect
{
public:
	EContextualActionNeeds                        ContextualActionNeedForRemove;                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveNeedEffect">();
	}
	static class URemoveNeedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveNeedEffect>();
	}
};
static_assert(alignof(URemoveNeedEffect) == 0x000008, "Wrong alignment on URemoveNeedEffect");
static_assert(sizeof(URemoveNeedEffect) == 0x000030, "Wrong size on URemoveNeedEffect");
static_assert(offsetof(URemoveNeedEffect, ContextualActionNeedForRemove) == 0x000028, "Member 'URemoveNeedEffect::ContextualActionNeedForRemove' has a wrong offset!");

// Class Stalker2.ContextualActionSubsystem
// 0x0180 (0x01C0 - 0x0040)
class UContextualActionSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x180];                                     // 0x0040(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualActionSubsystem">();
	}
	static class UContextualActionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualActionSubsystem>();
	}
};
static_assert(alignof(UContextualActionSubsystem) == 0x000008, "Wrong alignment on UContextualActionSubsystem");
static_assert(sizeof(UContextualActionSubsystem) == 0x0001C0, "Wrong size on UContextualActionSubsystem");

// Class Stalker2.PDAQuestTaskSlot
// 0x00B0 (0x0328 - 0x0278)
class UPDAQuestTaskSlot final : public UWidgetBase
{
public:
	class UImage*                                 ImageTask;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                HoverImage;                                        // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextBlock*                         RichText;                                          // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ClickAnim;                                         // 0x0290(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NotNecessaryStyleId;                               // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NotNecessaryLocalizationSID;                       // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClickAnimSpeed;                                    // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x24];                                     // 0x02BC(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UPDAQuestTaskSlot* StageSlotWidget)> OnTrackingStage;        // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsHovered, int32 InIndexOnParent)> OnHoverTaskSlot;          // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTaskStatusSettings                    SlotData;                                          // 0x0308(0x0020)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAQuestTaskSlot">();
	}
	static class UPDAQuestTaskSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAQuestTaskSlot>();
	}
};
static_assert(alignof(UPDAQuestTaskSlot) == 0x000008, "Wrong alignment on UPDAQuestTaskSlot");
static_assert(sizeof(UPDAQuestTaskSlot) == 0x000328, "Wrong size on UPDAQuestTaskSlot");
static_assert(offsetof(UPDAQuestTaskSlot, ImageTask) == 0x000278, "Member 'UPDAQuestTaskSlot::ImageTask' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskSlot, HoverImage) == 0x000280, "Member 'UPDAQuestTaskSlot::HoverImage' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskSlot, RichText) == 0x000288, "Member 'UPDAQuestTaskSlot::RichText' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskSlot, ClickAnim) == 0x000290, "Member 'UPDAQuestTaskSlot::ClickAnim' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskSlot, NotNecessaryStyleId) == 0x000298, "Member 'UPDAQuestTaskSlot::NotNecessaryStyleId' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskSlot, NotNecessaryLocalizationSID) == 0x0002A8, "Member 'UPDAQuestTaskSlot::NotNecessaryLocalizationSID' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskSlot, ClickAnimSpeed) == 0x0002B8, "Member 'UPDAQuestTaskSlot::ClickAnimSpeed' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskSlot, OnTrackingStage) == 0x0002E0, "Member 'UPDAQuestTaskSlot::OnTrackingStage' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskSlot, OnHoverTaskSlot) == 0x0002F0, "Member 'UPDAQuestTaskSlot::OnHoverTaskSlot' has a wrong offset!");
static_assert(offsetof(UPDAQuestTaskSlot, SlotData) == 0x000308, "Member 'UPDAQuestTaskSlot::SlotData' has a wrong offset!");

// Class Stalker2.SafeZoneNavModifierVolume
// 0x0000 (0x0308 - 0x0308)
class ASafeZoneNavModifierVolume final : public ASystemicNavModifierVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SafeZoneNavModifierVolume">();
	}
	static class ASafeZoneNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASafeZoneNavModifierVolume>();
	}
};
static_assert(alignof(ASafeZoneNavModifierVolume) == 0x000008, "Wrong alignment on ASafeZoneNavModifierVolume");
static_assert(sizeof(ASafeZoneNavModifierVolume) == 0x000308, "Wrong size on ASafeZoneNavModifierVolume");

// Class Stalker2.ContextualNavLinkProxy
// 0x0000 (0x02E8 - 0x02E8)
class AContextualNavLinkProxy final : public ANavLinkProxy
{
public:
	void OnStartUsingCustomLink(class AActor* MovingActor, const struct FVector& DestinationPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualNavLinkProxy">();
	}
	static class AContextualNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AContextualNavLinkProxy>();
	}
};
static_assert(alignof(AContextualNavLinkProxy) == 0x000008, "Wrong alignment on AContextualNavLinkProxy");
static_assert(sizeof(AContextualNavLinkProxy) == 0x0002E8, "Wrong size on AContextualNavLinkProxy");

// Class Stalker2.ControlsSettingsWidget
// 0x00B0 (0x0340 - 0x0290)
class UControlsSettingsWidget final : public USettingsPage
{
public:
	class USettingElementOnOff*                   VerticalInversion;                                 // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementOnOff*                   HorizontalInversion;                               // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                CursorSensitivity;                                 // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                MouseAimSensitivity;                               // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementButton*                  OpenKeyboardMappingButton;                         // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementOnOff*                   VibrationFeedback;                                 // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementOnOff*                   GamepadVerticalInversion;                          // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementOnOff*                   GamepadHorizontalInversion;                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                GamepadSensitivity;                                // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                GamepadAimSensitivity;                             // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                AimAssistType;                                     // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                AimAssistStickiness;                               // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                AimAssistTracking;                                 // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                AimOnHold;                                         // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                HoldBreathOnHold;                                  // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                CrouchOnHold;                                      // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                ItemSelectorOnHold;                                // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                SprintOnHold;                                      // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                WalkOnHold;                                        // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                AttachSelectorOnHold;                              // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                LeanOnHold;                                        // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                LadderOnHold;                                      // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlsSettingsWidget">();
	}
	static class UControlsSettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlsSettingsWidget>();
	}
};
static_assert(alignof(UControlsSettingsWidget) == 0x000008, "Wrong alignment on UControlsSettingsWidget");
static_assert(sizeof(UControlsSettingsWidget) == 0x000340, "Wrong size on UControlsSettingsWidget");
static_assert(offsetof(UControlsSettingsWidget, VerticalInversion) == 0x000290, "Member 'UControlsSettingsWidget::VerticalInversion' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, HorizontalInversion) == 0x000298, "Member 'UControlsSettingsWidget::HorizontalInversion' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, CursorSensitivity) == 0x0002A0, "Member 'UControlsSettingsWidget::CursorSensitivity' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, MouseAimSensitivity) == 0x0002A8, "Member 'UControlsSettingsWidget::MouseAimSensitivity' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, OpenKeyboardMappingButton) == 0x0002B0, "Member 'UControlsSettingsWidget::OpenKeyboardMappingButton' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, VibrationFeedback) == 0x0002B8, "Member 'UControlsSettingsWidget::VibrationFeedback' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, GamepadVerticalInversion) == 0x0002C0, "Member 'UControlsSettingsWidget::GamepadVerticalInversion' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, GamepadHorizontalInversion) == 0x0002C8, "Member 'UControlsSettingsWidget::GamepadHorizontalInversion' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, GamepadSensitivity) == 0x0002D0, "Member 'UControlsSettingsWidget::GamepadSensitivity' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, GamepadAimSensitivity) == 0x0002D8, "Member 'UControlsSettingsWidget::GamepadAimSensitivity' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, AimAssistType) == 0x0002E0, "Member 'UControlsSettingsWidget::AimAssistType' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, AimAssistStickiness) == 0x0002E8, "Member 'UControlsSettingsWidget::AimAssistStickiness' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, AimAssistTracking) == 0x0002F0, "Member 'UControlsSettingsWidget::AimAssistTracking' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, AimOnHold) == 0x0002F8, "Member 'UControlsSettingsWidget::AimOnHold' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, HoldBreathOnHold) == 0x000300, "Member 'UControlsSettingsWidget::HoldBreathOnHold' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, CrouchOnHold) == 0x000308, "Member 'UControlsSettingsWidget::CrouchOnHold' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, ItemSelectorOnHold) == 0x000310, "Member 'UControlsSettingsWidget::ItemSelectorOnHold' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, SprintOnHold) == 0x000318, "Member 'UControlsSettingsWidget::SprintOnHold' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, WalkOnHold) == 0x000320, "Member 'UControlsSettingsWidget::WalkOnHold' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, AttachSelectorOnHold) == 0x000328, "Member 'UControlsSettingsWidget::AttachSelectorOnHold' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, LeanOnHold) == 0x000330, "Member 'UControlsSettingsWidget::LeanOnHold' has a wrong offset!");
static_assert(offsetof(UControlsSettingsWidget, LadderOnHold) == 0x000338, "Member 'UControlsSettingsWidget::LadderOnHold' has a wrong offset!");

// Class Stalker2.CooldownZone
// 0x0018 (0x0320 - 0x0308)
class ACooldownZone final : public AGSCNavModifierVolume
{
public:
	TSubclassOf<class UNavArea>                   RestrictionArea;                                   // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownTime;                                      // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0xC];                                      // 0x0314(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CooldownZone">();
	}
	static class ACooldownZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACooldownZone>();
	}
};
static_assert(alignof(ACooldownZone) == 0x000008, "Wrong alignment on ACooldownZone");
static_assert(sizeof(ACooldownZone) == 0x000320, "Wrong size on ACooldownZone");
static_assert(offsetof(ACooldownZone, RestrictionArea) == 0x000308, "Member 'ACooldownZone::RestrictionArea' has a wrong offset!");
static_assert(offsetof(ACooldownZone, CooldownTime) == 0x000310, "Member 'ACooldownZone::CooldownTime' has a wrong offset!");

// Class Stalker2.CoverGenerator
// 0x0008 (0x02A0 - 0x0298)
class ACoverGenerator final : public AActor
{
public:
	class USmartCoverRenderingComponent*          DebugRenderingComp;                                // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverGenerator">();
	}
	static class ACoverGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoverGenerator>();
	}
};
static_assert(alignof(ACoverGenerator) == 0x000008, "Wrong alignment on ACoverGenerator");
static_assert(sizeof(ACoverGenerator) == 0x0002A0, "Wrong size on ACoverGenerator");
static_assert(offsetof(ACoverGenerator, DebugRenderingComp) == 0x000298, "Member 'ACoverGenerator::DebugRenderingComp' has a wrong offset!");

// Class Stalker2.SmartCoverRenderingComponent
// 0x0000 (0x05B0 - 0x05B0)
class USmartCoverRenderingComponent final : public UDebugDrawComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartCoverRenderingComponent">();
	}
	static class USmartCoverRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmartCoverRenderingComponent>();
	}
};
static_assert(alignof(USmartCoverRenderingComponent) == 0x000010, "Wrong alignment on USmartCoverRenderingComponent");
static_assert(sizeof(USmartCoverRenderingComponent) == 0x0005B0, "Wrong size on USmartCoverRenderingComponent");

// Class Stalker2.CppMediator
// 0x0000 (0x0028 - 0x0028)
class UCppMediator final : public UBlueprintFunctionLibrary
{
public:
	static void BindInteractPaintMaterial(class AActor* AffectedActor);
	static bool CanPlayAudiolog();
	static void CreateAIEvent(const class AObj* SenderObj, const struct FVector& Location, const ESoundEventType EventType);
	static void CreateAIVoiceEvent(const class AObj* SenderObj, const struct FVector& Location, const struct FVector& Direction);
	static void DespawnSearchPoint(const class AObj* Obj);
	static TArray<struct FJournalQuest> GetActiveMainQuests();
	static TArray<struct FJournalQuest> GetActiveSecondaryQuests();
	static class AActor* GetActorByGuid(const struct FGuid& TargetGUID);
	static float GetAnomalyCullingRadius();
	static double GetAudiologAudioTimeSeconds();
	static float GetCurrentAudiologDuration();
	static float GetCurrentAudiologPlayedTime();
	static struct FVector GetEmissionLocation();
	static TArray<struct FJournalQuest> GetFailedQuests();
	static TArray<struct FJournalQuest> GetFinishedQuests();
	static class AObj* GetFocusedEnemy(const class AObj* Obj);
	static int32 GetGUID(const class AObj* Actor);
	static int32 GetItemsCountInInventory(const class AObj* Obj, const class FString& ItemName);
	static TArray<class UMeshGeneratorEditor*> GetMeshGenerators();
	static TArray<class FString> GetNotePrototypeIDs();
	static float GetNotificationAudiologDelay();
	static int32 GetPrototypeID(const class AObj* Actor);
	static float GetSkyLightUpdateDeltaTime();
	static bool HasAnySignal(class AActor* Actor);
	static bool HasValidGUID(const class AObj* Actor);
	static bool IsActorInGameWorld(class AActor* ActorToCheck);
	static bool IsEmissionActive();
	static bool IsFarAwayFromPlayer(const struct FVector& Location);
	static bool IsGamePlaying();
	static bool IsInteractionPaintEnabled();
	static bool IsMoving(const class AObj* Actor);
	static bool IsNaniteEnabledForMesh(const class UStaticMesh* Mesh);
	static bool IsObjAlive(const class AObj* Obj);
	static bool IsPendingLoadQuickSave();
	static bool IsQuestSelected(const struct FJournalQuest& JournalQuest);
	static bool IsRunningWorldPartitionMigrationFromCommandlet();
	static bool IsSoundInProximity(const struct FVector& Location, const class UAkAudioEvent* AudioEvent);
	static bool IsWalking(const class AObj* Actor);
	static void LerpPlayerToLocationAndRotation(const struct FVector& Location, const struct FRotator& Rotation);
	static void LogError(class AActor* Sender, const class FString& errorMessage);
	static int32 MakeInvalidGUID();
	static void MakeInvulnerable(const class AObj* Obj);
	static struct FItemContainerUID MakeItemContainerUID(int32 RawInt32);
	static struct FItemUID MakeItemUID(int32 RawInt32);
	static float ObjGetHP(const class AObj* Obj);
	static void OnToggleAudiolog(const bool bPlayAudiolog);
	static void QuestInteractionComponentFinishAction(class UInteractionComponent* InteractionComponent, const class FString& LauncherName);
	static void ReloadConfigPrototypes();
	static void RequestSaveSettings();
	static void ResetComponentVelocity(const class USceneComponent* Component);
	static void ResetInvulnerable(const class AObj* Obj);
	static void ResetSelectedSettings();
	static class UWorld* RuntimeGetWorld();
	static void SaveCharacter(const class FString& CharacterSID, const class UMeshGeneratorEditor* MeshGenerator, const bool bSaveObj, const bool bSaveItemGenerator, const class FString& SaveObjConfigPath, const class FString& ParentItemGenerator, const class FString& NewRank);
	static void SelectCurrentSettings(ESettingCategoryType SettingCategoryType);
	static void SerializeCoverOffsetsToConfig(const class UHumanDefaultAnimCollection* HumanDefaultAnimCollection);
	static void SetAimMouseSensitivityCoef(float InAimMouseSensitivityCoef);
	static void SetDialogueVolume(float InDialogueVolume);
	static void SetEffectsVolume(float InEffectsVolume);
	static void SetMainVolume(float InVolume);
	static void SetMeshNaniteSettings(const class UStaticMesh* Mesh, const bool bEnable);
	static void SetMouseSensitivityCoef(float InMouseSensitivityCoef);
	static void SetMusicVolume(float InMusicVolume);
	static void SetMuteAllVolume(bool bInMuteAllVolume);
	static void SetSelectedAudioLanguage(ELocalizationLanguage InSelectedLanguage);
	static void SetSelectedLanguage(ELocalizationLanguage InSelectedLanguage);
	static void SetSelectedTextLanguage(ELocalizationLanguage InSelectedLanguage);
	static void SettingsManagerApplySettings();
	static void SettingsManagerCacheCurrentSettings();
	static void SettingsManagerRestoreCachedSettings();
	static void SetupMaterialForInteractPaint(class UMeshComponent* AffectedMesh, TSoftObjectPtr<class UMaterialInterface> YellowPaintMaterial, TSoftObjectPtr<class UMaterialInterface> DefaultMaterial, const bool bPaintEnabled, const int32 MaterialSlot);
	static bool ShouldUpdateSolarTime(float PrevSolarTime, float SolarTime, float UpdateSunDeltaTime);
	static void SpawnSearchPoint(const class AObj* Obj, const bool bShowOnMap, const bool bShowOnCompass);
	static class UTriplanarDecalComponent* SpawnTriplanarDecalAtLocation(const class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan);
	static void StartQuestNode(const struct FPrototypeSID& SID);
	static class FString UIManagerGenerateAndGetDefaultNameSave();
	static void UIManagerOnQuestDeselected(const class FString& PrototypeID);
	static void UnbindInteractPaintMaterial(class AActor* AffectedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CppMediator">();
	}
	static class UCppMediator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCppMediator>();
	}
};
static_assert(alignof(UCppMediator) == 0x000008, "Wrong alignment on UCppMediator");
static_assert(sizeof(UCppMediator) == 0x000028, "Wrong size on UCppMediator");

// Class Stalker2.SearchpointDetectorComponent
// 0x0000 (0x00E0 - 0x00E0)
class USearchpointDetectorComponent final : public UPassiveDetectorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchpointDetectorComponent">();
	}
	static class USearchpointDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchpointDetectorComponent>();
	}
};
static_assert(alignof(USearchpointDetectorComponent) == 0x000008, "Wrong alignment on USearchpointDetectorComponent");
static_assert(sizeof(USearchpointDetectorComponent) == 0x0000E0, "Wrong size on USearchpointDetectorComponent");

// Class Stalker2.Creator
// 0x0198 (0x0210 - 0x0078)
class UCreator final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x198];                                     // 0x0078(0x0198)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Creator">();
	}
	static class UCreator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreator>();
	}
};
static_assert(alignof(UCreator) == 0x000008, "Wrong alignment on UCreator");
static_assert(sizeof(UCreator) == 0x000210, "Wrong size on UCreator");

// Class Stalker2.CreditsName
// 0x0008 (0x0280 - 0x0278)
class UCreditsName final : public UUserWidget
{
public:
	class UTextWidget*                            NameText;                                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreditsName">();
	}
	static class UCreditsName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreditsName>();
	}
};
static_assert(alignof(UCreditsName) == 0x000008, "Wrong alignment on UCreditsName");
static_assert(sizeof(UCreditsName) == 0x000280, "Wrong size on UCreditsName");
static_assert(offsetof(UCreditsName, NameText) == 0x000278, "Member 'UCreditsName::NameText' has a wrong offset!");

// Class Stalker2.CreditsRoleWidget
// 0x0038 (0x02B0 - 0x0278)
class UCreditsRoleWidget final : public UUserWidget
{
public:
	class UHorizontalBox*                         RoleHorizontalBox;                                 // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            RoleText;                                          // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCreditsNamesWidget>        CreditsNamesClass;                                 // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNamesWidgetDisplaySettings            NamesDisplaySettings;                              // 0x0290(0x001C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreditsRoleWidget">();
	}
	static class UCreditsRoleWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreditsRoleWidget>();
	}
};
static_assert(alignof(UCreditsRoleWidget) == 0x000008, "Wrong alignment on UCreditsRoleWidget");
static_assert(sizeof(UCreditsRoleWidget) == 0x0002B0, "Wrong size on UCreditsRoleWidget");
static_assert(offsetof(UCreditsRoleWidget, RoleHorizontalBox) == 0x000278, "Member 'UCreditsRoleWidget::RoleHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCreditsRoleWidget, RoleText) == 0x000280, "Member 'UCreditsRoleWidget::RoleText' has a wrong offset!");
static_assert(offsetof(UCreditsRoleWidget, CreditsNamesClass) == 0x000288, "Member 'UCreditsRoleWidget::CreditsNamesClass' has a wrong offset!");
static_assert(offsetof(UCreditsRoleWidget, NamesDisplaySettings) == 0x000290, "Member 'UCreditsRoleWidget::NamesDisplaySettings' has a wrong offset!");

// Class Stalker2.CreditsSpacer
// 0x0008 (0x0280 - 0x0278)
class UCreditsSpacer final : public UUserWidget
{
public:
	class USpacer*                                Spacer;                                            // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreditsSpacer">();
	}
	static class UCreditsSpacer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreditsSpacer>();
	}
};
static_assert(alignof(UCreditsSpacer) == 0x000008, "Wrong alignment on UCreditsSpacer");
static_assert(sizeof(UCreditsSpacer) == 0x000280, "Wrong size on UCreditsSpacer");
static_assert(offsetof(UCreditsSpacer, Spacer) == 0x000278, "Member 'UCreditsSpacer::Spacer' has a wrong offset!");

// Class Stalker2.CreditsWidget
// 0x00D0 (0x0348 - 0x0278)
class UCreditsWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x30];                                     // 0x0278(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerticalBox*                           ItemsContainer;                                    // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScrollBox*                             CreditsScroll;                                     // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               CreditsOverlay;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCreditsSpacer>             SpacerClass;                                       // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCreditsSectionTitle>       CreditsSectionTitleClass;                          // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCreditsRoleWidget>         CreditsRoleTitleClass;                             // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCreditsNamesWidget>        CreditsNamesClass;                                 // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AppearAnimation;                                   // 0x02E0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSectionTitleDisplaySettings           SectionTitleDisplaySettings;                       // 0x02E8(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRoleDisplaySettings                   FirstRoleDisplaySettings;                          // 0x02FC(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRoleDisplaySettings                   RoleDisplaySettings;                               // 0x030C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         CreditsScrollMultiplier;                           // 0x031C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CreditsScrollUserMultiplier;                       // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_324[0xC];                                      // 0x0324(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             WwiseLogoTexture;                                  // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           WwiseLogoColor;                                    // 0x0338(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreditsWidget">();
	}
	static class UCreditsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreditsWidget>();
	}
};
static_assert(alignof(UCreditsWidget) == 0x000008, "Wrong alignment on UCreditsWidget");
static_assert(sizeof(UCreditsWidget) == 0x000348, "Wrong size on UCreditsWidget");
static_assert(offsetof(UCreditsWidget, ItemsContainer) == 0x0002A8, "Member 'UCreditsWidget::ItemsContainer' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, CreditsScroll) == 0x0002B0, "Member 'UCreditsWidget::CreditsScroll' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, CreditsOverlay) == 0x0002B8, "Member 'UCreditsWidget::CreditsOverlay' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, SpacerClass) == 0x0002C0, "Member 'UCreditsWidget::SpacerClass' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, CreditsSectionTitleClass) == 0x0002C8, "Member 'UCreditsWidget::CreditsSectionTitleClass' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, CreditsRoleTitleClass) == 0x0002D0, "Member 'UCreditsWidget::CreditsRoleTitleClass' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, CreditsNamesClass) == 0x0002D8, "Member 'UCreditsWidget::CreditsNamesClass' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, AppearAnimation) == 0x0002E0, "Member 'UCreditsWidget::AppearAnimation' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, SectionTitleDisplaySettings) == 0x0002E8, "Member 'UCreditsWidget::SectionTitleDisplaySettings' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, FirstRoleDisplaySettings) == 0x0002FC, "Member 'UCreditsWidget::FirstRoleDisplaySettings' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, RoleDisplaySettings) == 0x00030C, "Member 'UCreditsWidget::RoleDisplaySettings' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, CreditsScrollMultiplier) == 0x00031C, "Member 'UCreditsWidget::CreditsScrollMultiplier' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, CreditsScrollUserMultiplier) == 0x000320, "Member 'UCreditsWidget::CreditsScrollUserMultiplier' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, WwiseLogoTexture) == 0x000330, "Member 'UCreditsWidget::WwiseLogoTexture' has a wrong offset!");
static_assert(offsetof(UCreditsWidget, WwiseLogoColor) == 0x000338, "Member 'UCreditsWidget::WwiseLogoColor' has a wrong offset!");

// Class Stalker2.CrosshairWidgetCircle
// 0x0038 (0x0300 - 0x02C8)
class UCrosshairWidgetCircle final : public UCrosshairWidgetBase
{
public:
	class UImage*                                 Point;                                             // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 circle;                                            // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Container;                                         // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               CircleMaterial;                                    // 0x02E0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableDespersionLimit;                            // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RadiuseParametr;                                   // 0x02EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RadiuseParametrMax;                                // 0x02F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrosshairWidgetCircle">();
	}
	static class UCrosshairWidgetCircle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrosshairWidgetCircle>();
	}
};
static_assert(alignof(UCrosshairWidgetCircle) == 0x000008, "Wrong alignment on UCrosshairWidgetCircle");
static_assert(sizeof(UCrosshairWidgetCircle) == 0x000300, "Wrong size on UCrosshairWidgetCircle");
static_assert(offsetof(UCrosshairWidgetCircle, Point) == 0x0002C8, "Member 'UCrosshairWidgetCircle::Point' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetCircle, circle) == 0x0002D0, "Member 'UCrosshairWidgetCircle::circle' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetCircle, Container) == 0x0002D8, "Member 'UCrosshairWidgetCircle::Container' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetCircle, CircleMaterial) == 0x0002E0, "Member 'UCrosshairWidgetCircle::CircleMaterial' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetCircle, bEnableDespersionLimit) == 0x0002E8, "Member 'UCrosshairWidgetCircle::bEnableDespersionLimit' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetCircle, RadiuseParametr) == 0x0002EC, "Member 'UCrosshairWidgetCircle::RadiuseParametr' has a wrong offset!");
static_assert(offsetof(UCrosshairWidgetCircle, RadiuseParametrMax) == 0x0002F4, "Member 'UCrosshairWidgetCircle::RadiuseParametrMax' has a wrong offset!");

// Class Stalker2.CrosshairWidgetPoint
// 0x0008 (0x02D0 - 0x02C8)
class UCrosshairWidgetPoint final : public UCrosshairWidgetBase
{
public:
	class UImage*                                 Point;                                             // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrosshairWidgetPoint">();
	}
	static class UCrosshairWidgetPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrosshairWidgetPoint>();
	}
};
static_assert(alignof(UCrosshairWidgetPoint) == 0x000008, "Wrong alignment on UCrosshairWidgetPoint");
static_assert(sizeof(UCrosshairWidgetPoint) == 0x0002D0, "Wrong size on UCrosshairWidgetPoint");
static_assert(offsetof(UCrosshairWidgetPoint, Point) == 0x0002C8, "Member 'UCrosshairWidgetPoint::Point' has a wrong offset!");

// Class Stalker2.CrouchIPU
// 0x0000 (0x0058 - 0x0058)
class UCrouchIPU final : public UBehaviorBasedIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrouchIPU">();
	}
	static class UCrouchIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrouchIPU>();
	}
};
static_assert(alignof(UCrouchIPU) == 0x000008, "Wrong alignment on UCrouchIPU");
static_assert(sizeof(UCrouchIPU) == 0x000058, "Wrong size on UCrouchIPU");

// Class Stalker2.SettingsElementRefreshRateSwitcher
// 0x0040 (0x1DC0 - 0x1D80)
class USettingsElementRefreshRateSwitcher final : public USettingElement
{
public:
	uint8                                         Pad_1D80[0x40];                                    // 0x1D80(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsElementRefreshRateSwitcher">();
	}
	static class USettingsElementRefreshRateSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsElementRefreshRateSwitcher>();
	}
};
static_assert(alignof(USettingsElementRefreshRateSwitcher) == 0x000010, "Wrong alignment on USettingsElementRefreshRateSwitcher");
static_assert(sizeof(USettingsElementRefreshRateSwitcher) == 0x001DC0, "Wrong size on USettingsElementRefreshRateSwitcher");

// Class Stalker2.CustomButton
// 0x0030 (0x06A0 - 0x0670)
class UCustomButton final : public UButton
{
public:
	int32                                         Tag;                                               // 0x0668(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomIntParam1;                                   // 0x066C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomIntParam2;                                   // 0x0670(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomFloatParam3;                                 // 0x0674(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomFloatParam4;                                 // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67C[0x4];                                      // 0x067C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringTag;                                         // 0x0680(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatTag;                                          // 0x0690(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_694[0xC];                                      // 0x0694(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClick();
	void OnPress();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomButton">();
	}
	static class UCustomButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomButton>();
	}
};
static_assert(alignof(UCustomButton) == 0x000010, "Wrong alignment on UCustomButton");
static_assert(sizeof(UCustomButton) == 0x0006A0, "Wrong size on UCustomButton");
static_assert(offsetof(UCustomButton, Tag) == 0x000668, "Member 'UCustomButton::Tag' has a wrong offset!");
static_assert(offsetof(UCustomButton, CustomIntParam1) == 0x00066C, "Member 'UCustomButton::CustomIntParam1' has a wrong offset!");
static_assert(offsetof(UCustomButton, CustomIntParam2) == 0x000670, "Member 'UCustomButton::CustomIntParam2' has a wrong offset!");
static_assert(offsetof(UCustomButton, CustomFloatParam3) == 0x000674, "Member 'UCustomButton::CustomFloatParam3' has a wrong offset!");
static_assert(offsetof(UCustomButton, CustomFloatParam4) == 0x000678, "Member 'UCustomButton::CustomFloatParam4' has a wrong offset!");
static_assert(offsetof(UCustomButton, StringTag) == 0x000680, "Member 'UCustomButton::StringTag' has a wrong offset!");
static_assert(offsetof(UCustomButton, FloatTag) == 0x000690, "Member 'UCustomButton::FloatTag' has a wrong offset!");

// Class Stalker2.CustomConsoleManagerAA
// 0x0008 (0x00B0 - 0x00A8)
class UCustomConsoleManagerAA final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XSetAkVisualizationRadius(float NewValue);
	void XSimulateWaitForProfileSettingUp(const float SetupDuration);
	void XToggleAkVisualization(const class FString& Types);
	void XTryReceiveSignal(const class FString& Guid);

	void OnWaitForProfileSimulationFinished() const;
	void XAddAllNotes() const;
	void XAddMoneyToPlayer(int32 Value) const;
	void XCheckGamedata() const;
	void XClearDialogQueue() const;
	void XDebugAddHelloDialogsToQueue(const int32 TargetUID, const int32 DialogsCount) const;
	void XDespawnAliveNPCsAtRadius(float Radius) const;
	void XDespawnDeadNPCsAtRadius(float Radius) const;
	void XDespawnNPCsAtRadius(float Radius) const;
	void XDiscoverAllMarkers() const;
	void XDiscoverMarker(const class FString& MarkerSID) const;
	void XEndQuest(const class FString& ID) const;
	void XEndQuestBySID(const class FString& SID) const;
	void XEndQuestNode(const class FString& ID) const;
	void XEndQuestNodeBySID(const class FString& SID) const;
	void XExcludeQuest(const class FString& ID) const;
	void XExcludeQuestBySID(const class FString& SID) const;
	void XExcludeQuestNode(const class FString& ID) const;
	void XExcludeQuestNodeBySID(const class FString& SID) const;
	void XFindNonEndingDialogs() const;
	void XKillNPCInRadius(float Radius, const int32 MinimalReputationToKill, int32 MaxReputationToKill) const;
	void XListMapMarkers(const class FString& MarkerType) const;
	void XPlayCommentFromPool(const class FString& DialogEventTypeName, int32 NPCUIDValue) const;
	void XPlayDialogFromPool(const class FString& DialogEventTypeName, int32 NPCUIDValue1, int32 NPCUIDValue2) const;
	void XPlayDialogLine(const int32 SpeakerUID, const class FString& DialogPrototypeSID) const;
	void XPrintGlobalVariable(const class FString& SID) const;
	void XResetQuestBySID(const class FString& SID) const;
	void XResetRandomNode(const class FString& ID) const;
	void XResetRandomNodeBySID(const class FString& SID) const;
	void XRestartCurrentDialog() const;
	void XRevealAllMarkers() const;
	void XSetAudioLanguage(const class FString& LocaleString) const;
	void XSetDifficultySID(const class FString& DifficultySID) const;
	void XSetGameTime(const int32 Hour, const int32 Minute, const int32 Second) const;
	void XSetRandomNodeDefinedPin(const class FString& ID, int32 PinNumber) const;
	void XSetRandomNodeDefinedPinBySID(const class FString& SID, int32 PinNumber) const;
	void XSetRelationsInRadius(float Radius, int32 RelationValue) const;
	void XSetSearchpointDebugState(bool bState) const;
	void XSetTextLanguage(const class FString& LocaleString) const;
	void XSetTimeSpeed(float Speed) const;
	void XSetWeatherTime(const int32 Hour, const int32 Minute, const int32 Second) const;
	void XShowCurrentImportantChoices() const;
	void XShowCurrentLocation() const;
	void XShowHubOwner(const class FString& HubSID) const;
	void XShowQuestTriggers(const bool bShow) const;
	void XShowSpawnDebugInfo(const bool Show) const;
	void XSkipInfotopicRefreshCooldown() const;
	void XSkipToQuestNode(const class FString& SID) const;
	void XStartQuest(const class FString& ID) const;
	void XStartQuestBySID(const class FString& SID) const;
	void XStartQuestNode(const class FString& ID) const;
	void XStartQuestNodeBySID(const class FString& SID) const;
	void XTeleportNPCToPlayer(const class FString& NPCSID) const;
	void XTeleportNPCToSpawn(const class FString& NPCSID) const;
	void XTestJournalQuestRewardCategory(const class FString& QuestSID) const;
	void XToggleArtifactSpawnerDebugInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerAA">();
	}
	static class UCustomConsoleManagerAA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerAA>();
	}
};
static_assert(alignof(UCustomConsoleManagerAA) == 0x000008, "Wrong alignment on UCustomConsoleManagerAA");
static_assert(sizeof(UCustomConsoleManagerAA) == 0x0000B0, "Wrong size on UCustomConsoleManagerAA");

// Class Stalker2.CustomConsoleManagerAI2
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerAI2 final : public UBaseConsoleManager
{
public:
	void XSetRelation(const int32 FirstUID, const int32 SecondUID, const int32 Relation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerAI2">();
	}
	static class UCustomConsoleManagerAI2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerAI2>();
	}
};
static_assert(alignof(UCustomConsoleManagerAI2) == 0x000008, "Wrong alignment on UCustomConsoleManagerAI2");
static_assert(sizeof(UCustomConsoleManagerAI2) == 0x0000A8, "Wrong size on UCustomConsoleManagerAI2");

// Class Stalker2.SettingElementSwitcher
// 0x0100 (0x1E80 - 0x1D80)
class USettingElementSwitcher : public USettingElement
{
public:
	uint8                                         Pad_1D80[0x18];                                    // 0x1D80(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class FString>                    ValuesToLocSID;                                    // 0x1D98(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<int32>                                 AvailableValues;                                   // 0x1DE8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x1DF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLocalizeValues;                                   // 0x1DFC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DFD[0x3];                                     // 0x1DFD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DisableDependenciesWhenValueIs;                    // 0x1E00(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E04[0x4];                                     // 0x1E04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DisableDependenciesValues;                         // 0x1E08(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	bool                                          bWrapValueAround;                                  // 0x1E18(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E19[0x7];                                     // 0x1E19(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUpdateDescriptionOnValueChange;                   // 0x1E20(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E21[0x7];                                     // 0x1E21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class FString>                    ValuesToDescriptionSID;                            // 0x1E28(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bReverseValues;                                    // 0x1E78(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E79[0x7];                                     // 0x1E79(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SortValues();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingElementSwitcher">();
	}
	static class USettingElementSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingElementSwitcher>();
	}
};
static_assert(alignof(USettingElementSwitcher) == 0x000010, "Wrong alignment on USettingElementSwitcher");
static_assert(sizeof(USettingElementSwitcher) == 0x001E80, "Wrong size on USettingElementSwitcher");
static_assert(offsetof(USettingElementSwitcher, ValuesToLocSID) == 0x001D98, "Member 'USettingElementSwitcher::ValuesToLocSID' has a wrong offset!");
static_assert(offsetof(USettingElementSwitcher, AvailableValues) == 0x001DE8, "Member 'USettingElementSwitcher::AvailableValues' has a wrong offset!");
static_assert(offsetof(USettingElementSwitcher, Value) == 0x001DF8, "Member 'USettingElementSwitcher::Value' has a wrong offset!");
static_assert(offsetof(USettingElementSwitcher, bLocalizeValues) == 0x001DFC, "Member 'USettingElementSwitcher::bLocalizeValues' has a wrong offset!");
static_assert(offsetof(USettingElementSwitcher, DisableDependenciesWhenValueIs) == 0x001E00, "Member 'USettingElementSwitcher::DisableDependenciesWhenValueIs' has a wrong offset!");
static_assert(offsetof(USettingElementSwitcher, DisableDependenciesValues) == 0x001E08, "Member 'USettingElementSwitcher::DisableDependenciesValues' has a wrong offset!");
static_assert(offsetof(USettingElementSwitcher, bWrapValueAround) == 0x001E18, "Member 'USettingElementSwitcher::bWrapValueAround' has a wrong offset!");
static_assert(offsetof(USettingElementSwitcher, bUpdateDescriptionOnValueChange) == 0x001E20, "Member 'USettingElementSwitcher::bUpdateDescriptionOnValueChange' has a wrong offset!");
static_assert(offsetof(USettingElementSwitcher, ValuesToDescriptionSID) == 0x001E28, "Member 'USettingElementSwitcher::ValuesToDescriptionSID' has a wrong offset!");
static_assert(offsetof(USettingElementSwitcher, bReverseValues) == 0x001E78, "Member 'USettingElementSwitcher::bReverseValues' has a wrong offset!");

// Class Stalker2.CustomConsoleManagerAM
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerAM final : public UBaseConsoleManager
{
public:
	void GetRelationBetween(const int32 LHS, const int32 RHS);
	void StartFollowing(const int32 TargetUID, const bool bLockOrientation, const double ZOffset);
	void StopFollowing();
	void XActivateAIFeature(const EAIFeature Feature);
	void XAddMoveTo(int32 UID);
	void XCallQuickLoad(float Angular);
	void XCallQuickSave(float Angular);
	void XDeactivateAIFeature(const EAIFeature Feature);
	void XMoveToPlayer(int32 NPC_UID, EMovementBehaviour Behaviour);
	void XResetAI(int32 UID);
	void XToggleDebugTool();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerAM">();
	}
	static class UCustomConsoleManagerAM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerAM>();
	}
};
static_assert(alignof(UCustomConsoleManagerAM) == 0x000008, "Wrong alignment on UCustomConsoleManagerAM");
static_assert(sizeof(UCustomConsoleManagerAM) == 0x0000A8, "Wrong size on UCustomConsoleManagerAM");

// Class Stalker2.CustomConsoleManagerBuild
// 0x0010 (0x00B8 - 0x00A8)
class UCustomConsoleManagerBuild final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XDisplayFocusingPlayerEnemiesCount();
	void XRepairCurrentWeapon();
	void XResetCurrentBodyArmorDurabilityToZero();
	void XResetCurrentWeaponDurabilityToZero();
	void XSetFreeCameraSpeedMultiplier(float SpeedMultiplier);
	void XSetNoClipGSC(bool bNoClipGSC, float Speed);
	void XSetPlayerSpeedMultiplier(float SpeedMultiplier);

	void XSetEntityUnkillableByUID(int32 EntityUID, bool bGodModeState) const;
	void XSetFactionGodMode(const class FString& CurrentFactionSelector, bool bGodModeState) const;
	void XSetGodModeAllFactions(bool bGodModeState) const;
	void XSetGodModeByUID(int32 EntityUID, bool bGodModeState) const;
	void XShowPlayerCoordinates() const;
	void XSpawnItemInCoordinatesBySID(const class FString& ItemPrototypeSID, float Px, float Py, float Pz) const;
	void XSpawnItemNearPlayerBySID(const class FString& ItemPrototypeSID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerBuild">();
	}
	static class UCustomConsoleManagerBuild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerBuild>();
	}
};
static_assert(alignof(UCustomConsoleManagerBuild) == 0x000008, "Wrong alignment on UCustomConsoleManagerBuild");
static_assert(sizeof(UCustomConsoleManagerBuild) == 0x0000B8, "Wrong size on UCustomConsoleManagerBuild");

// Class Stalker2.CustomConsoleManagerDC
// 0x0058 (0x0100 - 0x00A8)
class UCustomConsoleManagerDC final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x58];                                      // 0x00A8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XChangeDropBodyMethod(bool bShouldDrop);
	void XKillNpcByUID(const int32 NpcUID);
	void XNPCAddAbility(const int32 NpcUID, const class FString& AbilityTag);
	void XNPCRemoveAbility(const int32 NpcUID, const class FString& AbilityTag);
	void XRegenerateItemsInStashes();
	void XSetCurrentCode(const class FString& InCurrentCode);
	void XSetWeatherTransitionTimeMultiplier(const float WeatherTransitionTimeMultiplier);
	void XShowDebugInfoForStash(const class FString& InStashIdentifier);
	void XShowIntroductionLogo();
	void XTeleportPlayerInForwardDirection(const float Distance, const float Delay);
	void XTeleportPlayerWithFade(const float Distance);
	void XToggleDebugBulletDistanceScaling();
	void XToggleDebugCodeLock();
	void XToggleDebugDrawOverlapWithAnomalyObjects();
	void XToggleDebugLightningBallNavigation();
	void XToggleDebugPlayerArmorInfo();
	void XToggleDrawDebugDiamondAnomaly();
	void XVideoTeleportPlayerWithFade(const float Distance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerDC">();
	}
	static class UCustomConsoleManagerDC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerDC>();
	}
};
static_assert(alignof(UCustomConsoleManagerDC) == 0x000008, "Wrong alignment on UCustomConsoleManagerDC");
static_assert(sizeof(UCustomConsoleManagerDC) == 0x000100, "Wrong size on UCustomConsoleManagerDC");

// Class Stalker2.CustomConsoleManagerDP
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerDP final : public UBaseConsoleManager
{
public:
	void XInitializeLocalizationManager() const;
	void XPrintLocalizedTextByKey(const class FString& StringKey) const;
	void XTestCrashCheckFalse() const;
	void XTestCrashLambda() const;
	void XTestCrashNullptr() const;
	void XTestCrashNullptrRT() const;
	void XTestCrashRandomAddress() const;
	void XTestCrashReturnIfFalse() const;
	void XTestCrashStackOverflow(int32 Counter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerDP">();
	}
	static class UCustomConsoleManagerDP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerDP>();
	}
};
static_assert(alignof(UCustomConsoleManagerDP) == 0x000008, "Wrong alignment on UCustomConsoleManagerDP");
static_assert(sizeof(UCustomConsoleManagerDP) == 0x0000A8, "Wrong size on UCustomConsoleManagerDP");

// Class Stalker2.CustomConsoleManagerEG
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerEG final : public UBaseConsoleManager
{
public:
	void XGarbageCollector() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerEG">();
	}
	static class UCustomConsoleManagerEG* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerEG>();
	}
};
static_assert(alignof(UCustomConsoleManagerEG) == 0x000008, "Wrong alignment on UCustomConsoleManagerEG");
static_assert(sizeof(UCustomConsoleManagerEG) == 0x0000A8, "Wrong size on UCustomConsoleManagerEG");

// Class Stalker2.SimpleForceFeedbackProcessor
// 0x0008 (0x0070 - 0x0068)
class USimpleForceFeedbackProcessor final : public UForceFeedbackProcessorBase
{
public:
	class UForceFeedbackEffect*                   Feedback;                                          // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleForceFeedbackProcessor">();
	}
	static class USimpleForceFeedbackProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleForceFeedbackProcessor>();
	}
};
static_assert(alignof(USimpleForceFeedbackProcessor) == 0x000008, "Wrong alignment on USimpleForceFeedbackProcessor");
static_assert(sizeof(USimpleForceFeedbackProcessor) == 0x000070, "Wrong size on USimpleForceFeedbackProcessor");
static_assert(offsetof(USimpleForceFeedbackProcessor, Feedback) == 0x000068, "Member 'USimpleForceFeedbackProcessor::Feedback' has a wrong offset!");

// Class Stalker2.CustomConsoleManagerIK
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerIK final : public UBaseConsoleManager
{
public:
	void XBluePrintSearch() const;
	void XInputActionBlock(const class FString& IAName, const class FString& IMCName) const;
	void XInputActionUnlock(const class FString& IAName, const class FString& IMCName) const;
	void XSetTwelveHourTime(const bool bSet) const;
	void XSignalStrengthTest() const;
	void XSkipTimeHours(const float Hours) const;
	void XSwitchPlayerRank(const ERank Rank) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerIK">();
	}
	static class UCustomConsoleManagerIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerIK>();
	}
};
static_assert(alignof(UCustomConsoleManagerIK) == 0x000008, "Wrong alignment on UCustomConsoleManagerIK");
static_assert(sizeof(UCustomConsoleManagerIK) == 0x0000A8, "Wrong size on UCustomConsoleManagerIK");

// Class Stalker2.CustomConsoleManagerMB
// 0x0010 (0x00B8 - 0x00A8)
class UCustomConsoleManagerMB final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XSetDrawDebugExplosion(const bool bDebug, const float DebugTime);
	void XSwitchAnomalySpawnerPreset();
	void XToggleShowLightningBallAnomalyDebugInfo();
	void XToggleShowModels();
	void XToggleShowPlayerLastHeldItem();
	void XToggleShowPlayerLocation();
	void XToggleShowPlayerRequestedMainHandWeaponType();
	void XToggleShowProtection();

	void XToggleDebugExpulsionAnomaly() const;
	void XToggleShowTriggerCapsuleView() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerMB">();
	}
	static class UCustomConsoleManagerMB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerMB>();
	}
};
static_assert(alignof(UCustomConsoleManagerMB) == 0x000008, "Wrong alignment on UCustomConsoleManagerMB");
static_assert(sizeof(UCustomConsoleManagerMB) == 0x0000B8, "Wrong size on UCustomConsoleManagerMB");

// Class Stalker2.CustomConsoleManagerMP
// 0x0070 (0x0118 - 0x00A8)
class UCustomConsoleManagerMP final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x70];                                      // 0x00A8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XDisableLegsIK();
	void XDisplayArtifactSpawnLuckStatus(const class FString& ArtifactSpawnerSID);
	void XEnableLegsIK();
	void XSetAimAssistEnabled(const bool bEnabled);
	void XSetArtifactSpawnLuck(const float LuckValue);
	void XSetClosestFaustCloneSwitchValue(const float SearchRadius, const float SwitchValue);
	void XToggleDebugAimAssist();
	void XWeaponDrag(const int32 ModelUID, const float Delay);

	void XLoadLastSave() const;
	void XStartSleep() const;
	void XToggleLogLoadingProgress() const;
	void XToggleShowDebugStealthKill() const;
	void XTriggerAutoSave() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerMP">();
	}
	static class UCustomConsoleManagerMP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerMP>();
	}
};
static_assert(alignof(UCustomConsoleManagerMP) == 0x000008, "Wrong alignment on UCustomConsoleManagerMP");
static_assert(sizeof(UCustomConsoleManagerMP) == 0x000118, "Wrong size on UCustomConsoleManagerMP");

// Class Stalker2.SignalReceiverActor
// 0x0000 (0x0298 - 0x0298)
class ASignalReceiverActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SignalReceiverActor">();
	}
	static class ASignalReceiverActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASignalReceiverActor>();
	}
};
static_assert(alignof(ASignalReceiverActor) == 0x000008, "Wrong alignment on ASignalReceiverActor");
static_assert(sizeof(ASignalReceiverActor) == 0x000298, "Wrong size on ASignalReceiverActor");

// Class Stalker2.CustomConsoleManagerMY
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerMY final : public UBaseConsoleManager
{
public:
	void XEnsureAllRelevantCollisionStreamed();
	void XSetDebugMode();

	void XPossessToCharacterByUID(int32 UID) const;
	void XSetXRayMode(bool bEnabled) const;
	void XSimulatePhysicsOnBoneForObj(int32 ObjUID, const class FString& BoneName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerMY">();
	}
	static class UCustomConsoleManagerMY* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerMY>();
	}
};
static_assert(alignof(UCustomConsoleManagerMY) == 0x000008, "Wrong alignment on UCustomConsoleManagerMY");
static_assert(sizeof(UCustomConsoleManagerMY) == 0x0000A8, "Wrong size on UCustomConsoleManagerMY");

// Class Stalker2.SpeechComponent
// 0x0058 (0x0080 - 0x0028)
class USpeechComponent : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpeechComponent">();
	}
	static class USpeechComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpeechComponent>();
	}
};
static_assert(alignof(USpeechComponent) == 0x000008, "Wrong alignment on USpeechComponent");
static_assert(sizeof(USpeechComponent) == 0x000080, "Wrong size on USpeechComponent");

// Class Stalker2.CustomConsoleManagerOA
// 0x0408 (0x04B0 - 0x00A8)
class UCustomConsoleManagerOA final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x408];                                     // 0x00A8(0x0408)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XDebugAudioScattererEvents(const bool bEnabled, const float DrawTime);
	void XDebugAudioScattererMap(const bool bEnabled);

	void XGetActiveDLC() const;
	void XHasDLC(const class FName DLCName) const;
	void XIsHDREnabled() const;
	void XNewDLCAvailable() const;
	void XPlayVideo(const class FString& Path) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerOA">();
	}
	static class UCustomConsoleManagerOA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerOA>();
	}
};
static_assert(alignof(UCustomConsoleManagerOA) == 0x000008, "Wrong alignment on UCustomConsoleManagerOA");
static_assert(sizeof(UCustomConsoleManagerOA) == 0x0004B0, "Wrong size on UCustomConsoleManagerOA");

// Class Stalker2.CustomConsoleManagerOM
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerOM final : public UBaseConsoleManager
{
public:
	void XSetCarouselAngle(float Angle) const;
	void XSetCarouselDebugTrajectory(bool bEnable) const;
	void XSetCarouselDuration(float Duration) const;
	void XSetCarouselForce(float Force) const;
	void XSetCarouselLiftUpTime(float Time) const;
	void XSetCarouselRotation(float Rotation) const;
	void XSetCarouselTimeToCenter(float Time) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerOM">();
	}
	static class UCustomConsoleManagerOM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerOM>();
	}
};
static_assert(alignof(UCustomConsoleManagerOM) == 0x000008, "Wrong alignment on UCustomConsoleManagerOM");
static_assert(sizeof(UCustomConsoleManagerOM) == 0x0000A8, "Wrong size on UCustomConsoleManagerOM");

// Class Stalker2.CustomConsoleManagerPA
// 0x0008 (0x00B0 - 0x00A8)
class UCustomConsoleManagerPA final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XToggleHoldBreathDebug();
	void XTogglePhysicalMaterialDebug(float Distance);

	void XChangePlayerMovementFXPrototype(const class FString& PrototypeSID) const;
	void XToggleGrenadeDebug(EGrenadeDebugFlag FlagValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerPA">();
	}
	static class UCustomConsoleManagerPA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerPA>();
	}
};
static_assert(alignof(UCustomConsoleManagerPA) == 0x000008, "Wrong alignment on UCustomConsoleManagerPA");
static_assert(sizeof(UCustomConsoleManagerPA) == 0x0000B0, "Wrong size on UCustomConsoleManagerPA");

// Class Stalker2.CustomConsoleManagerPU
// 0x0008 (0x00B0 - 0x00A8)
class UCustomConsoleManagerPU final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XShowDemoPopup();
	void XShowPopup(const int32 ButtonsNum);
	void XStartProcPopup();
	void XStopProcPopup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerPU">();
	}
	static class UCustomConsoleManagerPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerPU>();
	}
};
static_assert(alignof(UCustomConsoleManagerPU) == 0x000008, "Wrong alignment on UCustomConsoleManagerPU");
static_assert(sizeof(UCustomConsoleManagerPU) == 0x0000B0, "Wrong size on UCustomConsoleManagerPU");

// Class Stalker2.CustomConsoleManagerSD
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerSD final : public UBaseConsoleManager
{
public:
	void XBeginPlay() const;
	void XGetActorNameByUID(int32 UID) const;
	void XHideAllWidget() const;
	void XHideCompass() const;
	void XShowAllWidget() const;
	void XShowCompass() const;
	void XTeleportToPlacesOfInterest(const class FString& SID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerSD">();
	}
	static class UCustomConsoleManagerSD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerSD>();
	}
};
static_assert(alignof(UCustomConsoleManagerSD) == 0x000008, "Wrong alignment on UCustomConsoleManagerSD");
static_assert(sizeof(UCustomConsoleManagerSD) == 0x0000A8, "Wrong size on UCustomConsoleManagerSD");

// Class Stalker2.SprintIPU
// 0x0000 (0x0058 - 0x0058)
class USprintIPU final : public UBehaviorBasedIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SprintIPU">();
	}
	static class USprintIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<USprintIPU>();
	}
};
static_assert(alignof(USprintIPU) == 0x000008, "Wrong alignment on USprintIPU");
static_assert(sizeof(USprintIPU) == 0x000058, "Wrong size on USprintIPU");

// Class Stalker2.CustomConsoleManagerSS
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerSS final : public UBaseConsoleManager
{
public:
	void XALifeDisable() const;
	void XALifeEnable() const;
	void XALifeKillAll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerSS">();
	}
	static class UCustomConsoleManagerSS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerSS>();
	}
};
static_assert(alignof(UCustomConsoleManagerSS) == 0x000008, "Wrong alignment on UCustomConsoleManagerSS");
static_assert(sizeof(UCustomConsoleManagerSS) == 0x0000A8, "Wrong size on UCustomConsoleManagerSS");

// Class Stalker2.CustomConsoleManagerVD
// 0x0000 (0x00A8 - 0x00A8)
class UCustomConsoleManagerVD final : public UBaseConsoleManager
{
public:
	void XProtectItemContainer(const class FString& ContainerUID, bool bProtect) const;
	void XProtectSquad(const class FString& SquadUID, bool bProtect) const;
	void XShowUnitAndSquadUIDs(float Radius) const;
	void XSpawnDeadNpc() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerVD">();
	}
	static class UCustomConsoleManagerVD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerVD>();
	}
};
static_assert(alignof(UCustomConsoleManagerVD) == 0x000008, "Wrong alignment on UCustomConsoleManagerVD");
static_assert(sizeof(UCustomConsoleManagerVD) == 0x0000A8, "Wrong size on UCustomConsoleManagerVD");

// Class Stalker2.CustomConsoleManagerVV
// 0x0010 (0x00B8 - 0x00A8)
class UCustomConsoleManagerVV final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XCheckAllJournalQuestPrototypes();
	void XGiveWeaponWithAttaches();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerVV">();
	}
	static class UCustomConsoleManagerVV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerVV>();
	}
};
static_assert(alignof(UCustomConsoleManagerVV) == 0x000008, "Wrong alignment on UCustomConsoleManagerVV");
static_assert(sizeof(UCustomConsoleManagerVV) == 0x0000B8, "Wrong size on UCustomConsoleManagerVV");

// Class Stalker2.CustomConsoleManagerYK
// 0x0008 (0x00B0 - 0x00A8)
class UCustomConsoleManagerYK final : public UBaseConsoleManager
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XTestSetDiscount(const bool InbDiscount);

	void XBlockItemSelectorSlot(const bool InBlock, const int32 InSlotNum) const;
	void XBlockItemSelectorSlots(const bool InBlock) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomConsoleManagerYK">();
	}
	static class UCustomConsoleManagerYK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomConsoleManagerYK>();
	}
};
static_assert(alignof(UCustomConsoleManagerYK) == 0x000008, "Wrong alignment on UCustomConsoleManagerYK");
static_assert(sizeof(UCustomConsoleManagerYK) == 0x0000B0, "Wrong size on UCustomConsoleManagerYK");

// Class Stalker2.CustomDamageHandleComponent
// 0x0000 (0x0000 - 0x0000)
class ICustomDamageHandleComponent final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomDamageHandleComponent">();
	}
	static class ICustomDamageHandleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICustomDamageHandleComponent>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICustomDamageHandleComponent) == 0x000001, "Wrong alignment on ICustomDamageHandleComponent");
static_assert(sizeof(ICustomDamageHandleComponent) == 0x000001, "Wrong size on ICustomDamageHandleComponent");

// Class Stalker2.StatSlot
// 0x0060 (0x02D8 - 0x0278)
class UStatSlot final : public UWidgetBase
{
public:
	class UImage*                                 Icon;                                              // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Shadow;                                            // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              size;                                              // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldShowProgress;                               // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             IconTexture;                                       // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeakStateOpacityPercent;                           // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlinkingAnimSpeed;                                 // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatSlotStates                               CurrState;                                         // 0x02B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TextureID;                                         // 0x02B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       ShowAnim;                                          // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HideAnim;                                          // 0x02C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       BlinkingAnim;                                      // 0x02D0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatSlot">();
	}
	static class UStatSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatSlot>();
	}
};
static_assert(alignof(UStatSlot) == 0x000008, "Wrong alignment on UStatSlot");
static_assert(sizeof(UStatSlot) == 0x0002D8, "Wrong size on UStatSlot");
static_assert(offsetof(UStatSlot, Icon) == 0x000278, "Member 'UStatSlot::Icon' has a wrong offset!");
static_assert(offsetof(UStatSlot, Shadow) == 0x000280, "Member 'UStatSlot::Shadow' has a wrong offset!");
static_assert(offsetof(UStatSlot, size) == 0x000288, "Member 'UStatSlot::size' has a wrong offset!");
static_assert(offsetof(UStatSlot, bShouldShowProgress) == 0x000298, "Member 'UStatSlot::bShouldShowProgress' has a wrong offset!");
static_assert(offsetof(UStatSlot, IconTexture) == 0x0002A0, "Member 'UStatSlot::IconTexture' has a wrong offset!");
static_assert(offsetof(UStatSlot, WeakStateOpacityPercent) == 0x0002A8, "Member 'UStatSlot::WeakStateOpacityPercent' has a wrong offset!");
static_assert(offsetof(UStatSlot, BlinkingAnimSpeed) == 0x0002AC, "Member 'UStatSlot::BlinkingAnimSpeed' has a wrong offset!");
static_assert(offsetof(UStatSlot, CurrState) == 0x0002B0, "Member 'UStatSlot::CurrState' has a wrong offset!");
static_assert(offsetof(UStatSlot, TextureID) == 0x0002B4, "Member 'UStatSlot::TextureID' has a wrong offset!");
static_assert(offsetof(UStatSlot, ShowAnim) == 0x0002C0, "Member 'UStatSlot::ShowAnim' has a wrong offset!");
static_assert(offsetof(UStatSlot, HideAnim) == 0x0002C8, "Member 'UStatSlot::HideAnim' has a wrong offset!");
static_assert(offsetof(UStatSlot, BlinkingAnim) == 0x0002D0, "Member 'UStatSlot::BlinkingAnim' has a wrong offset!");

// Class Stalker2.CustomGridSlot
// 0x0060 (0x0580 - 0x0520)
#pragma pack(push, 0x1)
class alignas(0x10) UCustomGridSlot : public UInteractableItemSlotBaseWidget
{
public:
	class USizeBox*                               ItemImageSizeBox;                                  // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Background;                                        // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            StackAmount;                                       // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Broken;                                            // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Attach;                                            // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinSlotSize;                                       // 0x0540(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_544[0x34];                                     // 0x0544(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomGridSlot">();
	}
	static class UCustomGridSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomGridSlot>();
	}
};
#pragma pack(pop)
static_assert(alignof(UCustomGridSlot) == 0x000010, "Wrong alignment on UCustomGridSlot");
static_assert(sizeof(UCustomGridSlot) == 0x000580, "Wrong size on UCustomGridSlot");
static_assert(offsetof(UCustomGridSlot, ItemImageSizeBox) == 0x000518, "Member 'UCustomGridSlot::ItemImageSizeBox' has a wrong offset!");
static_assert(offsetof(UCustomGridSlot, Background) == 0x000520, "Member 'UCustomGridSlot::Background' has a wrong offset!");
static_assert(offsetof(UCustomGridSlot, StackAmount) == 0x000528, "Member 'UCustomGridSlot::StackAmount' has a wrong offset!");
static_assert(offsetof(UCustomGridSlot, Broken) == 0x000530, "Member 'UCustomGridSlot::Broken' has a wrong offset!");
static_assert(offsetof(UCustomGridSlot, Attach) == 0x000538, "Member 'UCustomGridSlot::Attach' has a wrong offset!");
static_assert(offsetof(UCustomGridSlot, MinSlotSize) == 0x000540, "Member 'UCustomGridSlot::MinSlotSize' has a wrong offset!");

// Class Stalker2.CustomSimplifiedGridSlot
// 0x0070 (0x0480 - 0x0410)
class UCustomSimplifiedGridSlot final : public UItemSlotBaseWidget
{
public:
	class USizeBox*                               ItemImageSizeBox;                                  // 0x0410(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Background;                                        // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            StackAmount;                                       // 0x0420(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Broken;                                            // 0x0428(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Attach;                                            // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Quest;                                             // 0x0438(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinSlotSize;                                       // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_444[0x3C];                                     // 0x0444(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomSimplifiedGridSlot">();
	}
	static class UCustomSimplifiedGridSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomSimplifiedGridSlot>();
	}
};
static_assert(alignof(UCustomSimplifiedGridSlot) == 0x000010, "Wrong alignment on UCustomSimplifiedGridSlot");
static_assert(sizeof(UCustomSimplifiedGridSlot) == 0x000480, "Wrong size on UCustomSimplifiedGridSlot");
static_assert(offsetof(UCustomSimplifiedGridSlot, ItemImageSizeBox) == 0x000410, "Member 'UCustomSimplifiedGridSlot::ItemImageSizeBox' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGridSlot, Background) == 0x000418, "Member 'UCustomSimplifiedGridSlot::Background' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGridSlot, StackAmount) == 0x000420, "Member 'UCustomSimplifiedGridSlot::StackAmount' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGridSlot, Broken) == 0x000428, "Member 'UCustomSimplifiedGridSlot::Broken' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGridSlot, Attach) == 0x000430, "Member 'UCustomSimplifiedGridSlot::Attach' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGridSlot, Quest) == 0x000438, "Member 'UCustomSimplifiedGridSlot::Quest' has a wrong offset!");
static_assert(offsetof(UCustomSimplifiedGridSlot, MinSlotSize) == 0x000440, "Member 'UCustomSimplifiedGridSlot::MinSlotSize' has a wrong offset!");

// Class Stalker2.CutscenesLocalizationConfig
// 0x0060 (0x0098 - 0x0038)
class UCutscenesLocalizationConfig final : public UDeveloperSettings
{
public:
	TMap<ELocalizationLanguage, uint32>           VoiceoverLanguageToTrackIndexMap;                  // 0x0038(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	class FString                                 LocalizedBinkPostfix;                              // 0x0088(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CutscenesLocalizationConfig">();
	}
	static class UCutscenesLocalizationConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCutscenesLocalizationConfig>();
	}
};
static_assert(alignof(UCutscenesLocalizationConfig) == 0x000008, "Wrong alignment on UCutscenesLocalizationConfig");
static_assert(sizeof(UCutscenesLocalizationConfig) == 0x000098, "Wrong size on UCutscenesLocalizationConfig");
static_assert(offsetof(UCutscenesLocalizationConfig, VoiceoverLanguageToTrackIndexMap) == 0x000038, "Member 'UCutscenesLocalizationConfig::VoiceoverLanguageToTrackIndexMap' has a wrong offset!");
static_assert(offsetof(UCutscenesLocalizationConfig, LocalizedBinkPostfix) == 0x000088, "Member 'UCutscenesLocalizationConfig::LocalizedBinkPostfix' has a wrong offset!");

// Class Stalker2.DataLayerPhysicsComponent
// 0x0058 (0x00F8 - 0x00A0)
class UDataLayerPhysicsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x58];                                      // 0x00A0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDataLayersUpdated(const class UDataLayerInstance* DataLayer, EDataLayerRuntimeState State);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataLayerPhysicsComponent">();
	}
	static class UDataLayerPhysicsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataLayerPhysicsComponent>();
	}
};
static_assert(alignof(UDataLayerPhysicsComponent) == 0x000008, "Wrong alignment on UDataLayerPhysicsComponent");
static_assert(sizeof(UDataLayerPhysicsComponent) == 0x0000F8, "Wrong size on UDataLayerPhysicsComponent");

// Class Stalker2.TooltipRecord
// 0x0020 (0x0298 - 0x0278)
class UTooltipRecord final : public UWidgetBase
{
public:
	class FString                                 FieldNameSID;                                      // 0x0278(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            FieldName;                                         // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            FieldValue;                                        // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TooltipRecord">();
	}
	static class UTooltipRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTooltipRecord>();
	}
};
static_assert(alignof(UTooltipRecord) == 0x000008, "Wrong alignment on UTooltipRecord");
static_assert(sizeof(UTooltipRecord) == 0x000298, "Wrong size on UTooltipRecord");
static_assert(offsetof(UTooltipRecord, FieldNameSID) == 0x000278, "Member 'UTooltipRecord::FieldNameSID' has a wrong offset!");
static_assert(offsetof(UTooltipRecord, FieldName) == 0x000288, "Member 'UTooltipRecord::FieldName' has a wrong offset!");
static_assert(offsetof(UTooltipRecord, FieldValue) == 0x000290, "Member 'UTooltipRecord::FieldValue' has a wrong offset!");

// Class Stalker2.DeathCounter
// 0x0008 (0x0280 - 0x0278)
class UDeathCounter final : public UWidgetBase
{
public:
	class UTextWidget*                            DeathCounterText;                                  // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathCounter">();
	}
	static class UDeathCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathCounter>();
	}
};
static_assert(alignof(UDeathCounter) == 0x000008, "Wrong alignment on UDeathCounter");
static_assert(sizeof(UDeathCounter) == 0x000280, "Wrong size on UDeathCounter");
static_assert(offsetof(UDeathCounter, DeathCounterText) == 0x000278, "Member 'UDeathCounter::DeathCounterText' has a wrong offset!");

// Class Stalker2.DebugWorldSubsystem
// 0x0008 (0x0038 - 0x0030)
class UDebugWorldSubsystem final : public UWorldSubsystem
{
public:
	class AGSCDebugDrawer*                        Drawer;                                            // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugWorldSubsystem">();
	}
	static class UDebugWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugWorldSubsystem>();
	}
};
static_assert(alignof(UDebugWorldSubsystem) == 0x000008, "Wrong alignment on UDebugWorldSubsystem");
static_assert(sizeof(UDebugWorldSubsystem) == 0x000038, "Wrong size on UDebugWorldSubsystem");
static_assert(offsetof(UDebugWorldSubsystem, Drawer) == 0x000030, "Member 'UDebugWorldSubsystem::Drawer' has a wrong offset!");

// Class Stalker2.DestructibleWindow
// 0x0098 (0x0330 - 0x0298)
class ADestructibleWindow final : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   WindowMesh;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHittableComponent*                     HittableComponent;                                 // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UNiagaraSystem>          DestructionFX;                                     // 0x02C8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           DestructSound;                                     // 0x02F8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleWindow">();
	}
	static class ADestructibleWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADestructibleWindow>();
	}
};
static_assert(alignof(ADestructibleWindow) == 0x000008, "Wrong alignment on ADestructibleWindow");
static_assert(sizeof(ADestructibleWindow) == 0x000330, "Wrong size on ADestructibleWindow");
static_assert(offsetof(ADestructibleWindow, Guid) == 0x0002A8, "Member 'ADestructibleWindow::Guid' has a wrong offset!");
static_assert(offsetof(ADestructibleWindow, WindowMesh) == 0x0002B8, "Member 'ADestructibleWindow::WindowMesh' has a wrong offset!");
static_assert(offsetof(ADestructibleWindow, HittableComponent) == 0x0002C0, "Member 'ADestructibleWindow::HittableComponent' has a wrong offset!");
static_assert(offsetof(ADestructibleWindow, DestructionFX) == 0x0002C8, "Member 'ADestructibleWindow::DestructionFX' has a wrong offset!");
static_assert(offsetof(ADestructibleWindow, DestructSound) == 0x0002F8, "Member 'ADestructibleWindow::DestructSound' has a wrong offset!");

// Class Stalker2.DeveloperSpectator
// 0x0030 (0x0660 - 0x0630)
class ADeveloperSpectator final : public ACharacter
{
public:
	float                                         BaseTurnRate;                                      // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseLookUpRate;                                    // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedMultiplier;                                   // 0x0630(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       CameraComponent;                                   // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_640[0x20];                                     // 0x0640(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeveloperSpectator">();
	}
	static class ADeveloperSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeveloperSpectator>();
	}
};
static_assert(alignof(ADeveloperSpectator) == 0x000010, "Wrong alignment on ADeveloperSpectator");
static_assert(sizeof(ADeveloperSpectator) == 0x000660, "Wrong size on ADeveloperSpectator");
static_assert(offsetof(ADeveloperSpectator, BaseTurnRate) == 0x000628, "Member 'ADeveloperSpectator::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(ADeveloperSpectator, BaseLookUpRate) == 0x00062C, "Member 'ADeveloperSpectator::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(ADeveloperSpectator, SpeedMultiplier) == 0x000630, "Member 'ADeveloperSpectator::SpeedMultiplier' has a wrong offset!");
static_assert(offsetof(ADeveloperSpectator, CameraComponent) == 0x000638, "Member 'ADeveloperSpectator::CameraComponent' has a wrong offset!");

// Class Stalker2.DialogActionWidget
// 0x0018 (0x0290 - 0x0278)
class UDialogActionWidget final : public UWidgetBase
{
public:
	class UImageWidget*                           Icon;                                              // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogActionWidget">();
	}
	static class UDialogActionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogActionWidget>();
	}
};
static_assert(alignof(UDialogActionWidget) == 0x000008, "Wrong alignment on UDialogActionWidget");
static_assert(sizeof(UDialogActionWidget) == 0x000290, "Wrong size on UDialogActionWidget");
static_assert(offsetof(UDialogActionWidget, Icon) == 0x000278, "Member 'UDialogActionWidget::Icon' has a wrong offset!");

// Class Stalker2.DialogFolder
// 0x0078 (0x02F0 - 0x0278)
class UDialogFolder final : public UWidgetBase
{
public:
	TSubclassOf<class UDialogueAnswer>            AnswerSlotClass;                                   // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HoverFolderStyleId;                                // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnhoverFolderStyleId;                              // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            NameText;                                          // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           AnswerContainer;                                   // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBarWidget*                     WFRTimer;                                          // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlider*                                WFRSlider;                                         // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0[0x40];                                     // 0x02B0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogFolder">();
	}
	static class UDialogFolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogFolder>();
	}
};
static_assert(alignof(UDialogFolder) == 0x000008, "Wrong alignment on UDialogFolder");
static_assert(sizeof(UDialogFolder) == 0x0002F0, "Wrong size on UDialogFolder");
static_assert(offsetof(UDialogFolder, AnswerSlotClass) == 0x000278, "Member 'UDialogFolder::AnswerSlotClass' has a wrong offset!");
static_assert(offsetof(UDialogFolder, HoverFolderStyleId) == 0x000280, "Member 'UDialogFolder::HoverFolderStyleId' has a wrong offset!");
static_assert(offsetof(UDialogFolder, UnhoverFolderStyleId) == 0x000288, "Member 'UDialogFolder::UnhoverFolderStyleId' has a wrong offset!");
static_assert(offsetof(UDialogFolder, NameText) == 0x000290, "Member 'UDialogFolder::NameText' has a wrong offset!");
static_assert(offsetof(UDialogFolder, AnswerContainer) == 0x000298, "Member 'UDialogFolder::AnswerContainer' has a wrong offset!");
static_assert(offsetof(UDialogFolder, WFRTimer) == 0x0002A0, "Member 'UDialogFolder::WFRTimer' has a wrong offset!");
static_assert(offsetof(UDialogFolder, WFRSlider) == 0x0002A8, "Member 'UDialogFolder::WFRSlider' has a wrong offset!");

// Class Stalker2.DialogPointLightComponent
// 0x0010 (0x0450 - 0x0440)
class UDialogPointLightComponent final : public UPointLightComponent
{
public:
	uint8                                         Pad_440[0x10];                                     // 0x0440(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogPointLightComponent">();
	}
	static class UDialogPointLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogPointLightComponent>();
	}
};
static_assert(alignof(UDialogPointLightComponent) == 0x000010, "Wrong alignment on UDialogPointLightComponent");
static_assert(sizeof(UDialogPointLightComponent) == 0x000450, "Wrong size on UDialogPointLightComponent");

// Class Stalker2.DialogSpotLightComponent
// 0x0000 (0x0450 - 0x0450)
class UDialogSpotLightComponent final : public USpotLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogSpotLightComponent">();
	}
	static class UDialogSpotLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogSpotLightComponent>();
	}
};
static_assert(alignof(UDialogSpotLightComponent) == 0x000010, "Wrong alignment on UDialogSpotLightComponent");
static_assert(sizeof(UDialogSpotLightComponent) == 0x000450, "Wrong size on UDialogSpotLightComponent");

// Class Stalker2.DialogProtectionManager
// 0x0028 (0x00A0 - 0x0078)
class UDialogProtectionManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADialogProtector*                       DialogProtector;                                   // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogProtectionManager">();
	}
	static class UDialogProtectionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogProtectionManager>();
	}
};
static_assert(alignof(UDialogProtectionManager) == 0x000008, "Wrong alignment on UDialogProtectionManager");
static_assert(sizeof(UDialogProtectionManager) == 0x0000A0, "Wrong size on UDialogProtectionManager");
static_assert(offsetof(UDialogProtectionManager, DialogProtector) == 0x000088, "Member 'UDialogProtectionManager::DialogProtector' has a wrong offset!");

// Class Stalker2.DialogSelectAnswerIPU
// 0x0000 (0x0040 - 0x0040)
class UDialogSelectAnswerIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogSelectAnswerIPU">();
	}
	static class UDialogSelectAnswerIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogSelectAnswerIPU>();
	}
};
static_assert(alignof(UDialogSelectAnswerIPU) == 0x000008, "Wrong alignment on UDialogSelectAnswerIPU");
static_assert(sizeof(UDialogSelectAnswerIPU) == 0x000040, "Wrong size on UDialogSelectAnswerIPU");

// Class Stalker2.DialogueSpeaker
// 0x0038 (0x02B0 - 0x0278)
class UDialogueSpeaker : public UWidgetBase
{
public:
	class URichTextWidget*                        SpeakerText;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Background;                                        // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldResetTexture;                               // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             BackgrounTexture;                                  // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MoveWidgetOffset;                                  // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueSpeaker">();
	}
	static class UDialogueSpeaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueSpeaker>();
	}
};
static_assert(alignof(UDialogueSpeaker) == 0x000008, "Wrong alignment on UDialogueSpeaker");
static_assert(sizeof(UDialogueSpeaker) == 0x0002B0, "Wrong size on UDialogueSpeaker");
static_assert(offsetof(UDialogueSpeaker, SpeakerText) == 0x000278, "Member 'UDialogueSpeaker::SpeakerText' has a wrong offset!");
static_assert(offsetof(UDialogueSpeaker, Background) == 0x000280, "Member 'UDialogueSpeaker::Background' has a wrong offset!");
static_assert(offsetof(UDialogueSpeaker, bShouldResetTexture) == 0x000288, "Member 'UDialogueSpeaker::bShouldResetTexture' has a wrong offset!");
static_assert(offsetof(UDialogueSpeaker, BackgrounTexture) == 0x000290, "Member 'UDialogueSpeaker::BackgrounTexture' has a wrong offset!");
static_assert(offsetof(UDialogueSpeaker, MoveWidgetOffset) == 0x000298, "Member 'UDialogueSpeaker::MoveWidgetOffset' has a wrong offset!");

// Class Stalker2.DialogueAnswer
// 0x0088 (0x0338 - 0x02B0)
class UDialogueAnswer : public UDialogueSpeaker
{
public:
	class UButton*                                Button;                                            // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogActionWidget*                    Action;                                            // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Back;                                              // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Line;                                              // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       HoverAnimation;                                    // 0x02D0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ColorStyle;                                        // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnabledHoverEvents;                             // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BorderPadding;                                     // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugTextWidgetBase*                   DebugTextLen;                                      // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugTextWidgetBase*                   DebugTextRow;                                      // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HoverStyleId;                                      // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NormalStyleId;                                     // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x30];                                     // 0x0308(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnswerWidgetClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueAnswer">();
	}
	static class UDialogueAnswer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueAnswer>();
	}
};
static_assert(alignof(UDialogueAnswer) == 0x000008, "Wrong alignment on UDialogueAnswer");
static_assert(sizeof(UDialogueAnswer) == 0x000338, "Wrong size on UDialogueAnswer");
static_assert(offsetof(UDialogueAnswer, Button) == 0x0002B0, "Member 'UDialogueAnswer::Button' has a wrong offset!");
static_assert(offsetof(UDialogueAnswer, Action) == 0x0002B8, "Member 'UDialogueAnswer::Action' has a wrong offset!");
static_assert(offsetof(UDialogueAnswer, Back) == 0x0002C0, "Member 'UDialogueAnswer::Back' has a wrong offset!");
static_assert(offsetof(UDialogueAnswer, Line) == 0x0002C8, "Member 'UDialogueAnswer::Line' has a wrong offset!");
static_assert(offsetof(UDialogueAnswer, HoverAnimation) == 0x0002D0, "Member 'UDialogueAnswer::HoverAnimation' has a wrong offset!");
static_assert(offsetof(UDialogueAnswer, ColorStyle) == 0x0002D8, "Member 'UDialogueAnswer::ColorStyle' has a wrong offset!");
static_assert(offsetof(UDialogueAnswer, bIsEnabledHoverEvents) == 0x0002E0, "Member 'UDialogueAnswer::bIsEnabledHoverEvents' has a wrong offset!");
static_assert(offsetof(UDialogueAnswer, BorderPadding) == 0x0002E4, "Member 'UDialogueAnswer::BorderPadding' has a wrong offset!");
static_assert(offsetof(UDialogueAnswer, DebugTextLen) == 0x0002E8, "Member 'UDialogueAnswer::DebugTextLen' has a wrong offset!");
static_assert(offsetof(UDialogueAnswer, DebugTextRow) == 0x0002F0, "Member 'UDialogueAnswer::DebugTextRow' has a wrong offset!");
static_assert(offsetof(UDialogueAnswer, HoverStyleId) == 0x0002F8, "Member 'UDialogueAnswer::HoverStyleId' has a wrong offset!");
static_assert(offsetof(UDialogueAnswer, NormalStyleId) == 0x000300, "Member 'UDialogueAnswer::NormalStyleId' has a wrong offset!");

// Class Stalker2.DialogueFastAnswer
// 0x0088 (0x03C0 - 0x0338)
class UDialogueFastAnswer final : public UDialogueAnswer
{
public:
	class UHintSwitcher*                          HintSwitcher;                                      // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldMoveOnRight;                                // 0x0340(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActionName;                                        // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StylePrefix;                                       // 0x0358(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnClickFastAnswer;                                 // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTexture2D*                             SkifChoiceIcon;                                    // 0x0378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SparkChoiceIcon;                                   // 0x0380(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             VartaChoiceIcon;                                   // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             StrelokChoiceIcon;                                 // 0x0390(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             StalkerChoiceIcon;                                 // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             NoonChoiceIcon;                                    // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndSelectAnswer();
	void PostSelectAnswer();
	void SelectAnswer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueFastAnswer">();
	}
	static class UDialogueFastAnswer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueFastAnswer>();
	}
};
static_assert(alignof(UDialogueFastAnswer) == 0x000008, "Wrong alignment on UDialogueFastAnswer");
static_assert(sizeof(UDialogueFastAnswer) == 0x0003C0, "Wrong size on UDialogueFastAnswer");
static_assert(offsetof(UDialogueFastAnswer, HintSwitcher) == 0x000338, "Member 'UDialogueFastAnswer::HintSwitcher' has a wrong offset!");
static_assert(offsetof(UDialogueFastAnswer, bShouldMoveOnRight) == 0x000340, "Member 'UDialogueFastAnswer::bShouldMoveOnRight' has a wrong offset!");
static_assert(offsetof(UDialogueFastAnswer, ActionName) == 0x000348, "Member 'UDialogueFastAnswer::ActionName' has a wrong offset!");
static_assert(offsetof(UDialogueFastAnswer, StylePrefix) == 0x000358, "Member 'UDialogueFastAnswer::StylePrefix' has a wrong offset!");
static_assert(offsetof(UDialogueFastAnswer, OnClickFastAnswer) == 0x000368, "Member 'UDialogueFastAnswer::OnClickFastAnswer' has a wrong offset!");
static_assert(offsetof(UDialogueFastAnswer, SkifChoiceIcon) == 0x000378, "Member 'UDialogueFastAnswer::SkifChoiceIcon' has a wrong offset!");
static_assert(offsetof(UDialogueFastAnswer, SparkChoiceIcon) == 0x000380, "Member 'UDialogueFastAnswer::SparkChoiceIcon' has a wrong offset!");
static_assert(offsetof(UDialogueFastAnswer, VartaChoiceIcon) == 0x000388, "Member 'UDialogueFastAnswer::VartaChoiceIcon' has a wrong offset!");
static_assert(offsetof(UDialogueFastAnswer, StrelokChoiceIcon) == 0x000390, "Member 'UDialogueFastAnswer::StrelokChoiceIcon' has a wrong offset!");
static_assert(offsetof(UDialogueFastAnswer, StalkerChoiceIcon) == 0x000398, "Member 'UDialogueFastAnswer::StalkerChoiceIcon' has a wrong offset!");
static_assert(offsetof(UDialogueFastAnswer, NoonChoiceIcon) == 0x0003A0, "Member 'UDialogueFastAnswer::NoonChoiceIcon' has a wrong offset!");

// Class Stalker2.DialogueViewFolder
// 0x00D0 (0x07C0 - 0x06F0)
class UDialogueViewFolder final : public UDialogueView
{
public:
	float                                         InputDelayTime;                                    // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultFolderIndex;                                // 0x06F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStartSelectFolderType                        DefaultSelectFolderSlot;                           // 0x06F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F9[0x7];                                      // 0x06F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USelectedAnswerMark*                    SelectedAnswerMark;                                // 0x0700(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogFolder*                          FolderSlot1;                                       // 0x0708(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogFolder*                          FolderSlot2;                                       // 0x0710(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogFolder*                          FolderSlot3;                                       // 0x0718(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogFolder*                          FolderSlot4;                                       // 0x0720(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogFolder*                          FolderSlot5;                                       // 0x0728(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogFolder*                          FolderSlot6;                                       // 0x0730(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScrollBox*                             AnswerContainer;                                   // 0x0738(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               ReplicOverlay;                                     // 0x0740(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           LeftButtonsContainer;                              // 0x0748(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           RightButtonsContainer;                             // 0x0750(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ButtonHintExit;                                    // 0x0758(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ButtonHintUpgrade;                                 // 0x0760(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ButtonHintTrade;                                   // 0x0768(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 TimerProgressImage;                                // 0x0770(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_778[0x8];                                      // 0x0778(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDialogFolder*>                  FolderWidgets;                                     // 0x0780(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UDialogFolder*>                  FolderWidgetsPool;                                 // 0x0790(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A0[0x20];                                     // 0x07A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class UDialogueAnswer* ChangeSelectFolder(const int32 IndexOldFolder, const int32 AxisMove);
	void UIDialogAnswerConfirm();
	void UIDialogAnswerDown();
	void UIDialogAnswerUp();
	void UIDialogClose();
	void UIDialogOpenTrade();
	void UIDialogOpenUpgrade();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueViewFolder">();
	}
	static class UDialogueViewFolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueViewFolder>();
	}
};
static_assert(alignof(UDialogueViewFolder) == 0x000008, "Wrong alignment on UDialogueViewFolder");
static_assert(sizeof(UDialogueViewFolder) == 0x0007C0, "Wrong size on UDialogueViewFolder");
static_assert(offsetof(UDialogueViewFolder, InputDelayTime) == 0x0006F0, "Member 'UDialogueViewFolder::InputDelayTime' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, DefaultFolderIndex) == 0x0006F4, "Member 'UDialogueViewFolder::DefaultFolderIndex' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, DefaultSelectFolderSlot) == 0x0006F8, "Member 'UDialogueViewFolder::DefaultSelectFolderSlot' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, SelectedAnswerMark) == 0x000700, "Member 'UDialogueViewFolder::SelectedAnswerMark' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, FolderSlot1) == 0x000708, "Member 'UDialogueViewFolder::FolderSlot1' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, FolderSlot2) == 0x000710, "Member 'UDialogueViewFolder::FolderSlot2' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, FolderSlot3) == 0x000718, "Member 'UDialogueViewFolder::FolderSlot3' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, FolderSlot4) == 0x000720, "Member 'UDialogueViewFolder::FolderSlot4' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, FolderSlot5) == 0x000728, "Member 'UDialogueViewFolder::FolderSlot5' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, FolderSlot6) == 0x000730, "Member 'UDialogueViewFolder::FolderSlot6' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, AnswerContainer) == 0x000738, "Member 'UDialogueViewFolder::AnswerContainer' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, ReplicOverlay) == 0x000740, "Member 'UDialogueViewFolder::ReplicOverlay' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, LeftButtonsContainer) == 0x000748, "Member 'UDialogueViewFolder::LeftButtonsContainer' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, RightButtonsContainer) == 0x000750, "Member 'UDialogueViewFolder::RightButtonsContainer' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, ButtonHintExit) == 0x000758, "Member 'UDialogueViewFolder::ButtonHintExit' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, ButtonHintUpgrade) == 0x000760, "Member 'UDialogueViewFolder::ButtonHintUpgrade' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, ButtonHintTrade) == 0x000768, "Member 'UDialogueViewFolder::ButtonHintTrade' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, TimerProgressImage) == 0x000770, "Member 'UDialogueViewFolder::TimerProgressImage' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, FolderWidgets) == 0x000780, "Member 'UDialogueViewFolder::FolderWidgets' has a wrong offset!");
static_assert(offsetof(UDialogueViewFolder, FolderWidgetsPool) == 0x000790, "Member 'UDialogueViewFolder::FolderWidgetsPool' has a wrong offset!");

// Class Stalker2.DiamondAnomalyAffectedItemComponent
// 0x0080 (0x0320 - 0x02A0)
class UDiamondAnomalyAffectedItemComponent final : public USceneComponent
{
public:
	class UNiagaraSystem*                         DiamondParticle;                                   // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicalMaterial*                      OverridePhysicalMaterial;                          // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              DiamondParticles;                                  // 0x02B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UAkAuxBus*                              DiamondAuxFilter;                                  // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkLateReverbComponent*                 DiamondAuxComponent;                               // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          DiamondFilterBounds;                               // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x48];                                     // 0x02D8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiamondAnomalyAffectedItemComponent">();
	}
	static class UDiamondAnomalyAffectedItemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiamondAnomalyAffectedItemComponent>();
	}
};
static_assert(alignof(UDiamondAnomalyAffectedItemComponent) == 0x000010, "Wrong alignment on UDiamondAnomalyAffectedItemComponent");
static_assert(sizeof(UDiamondAnomalyAffectedItemComponent) == 0x000320, "Wrong size on UDiamondAnomalyAffectedItemComponent");
static_assert(offsetof(UDiamondAnomalyAffectedItemComponent, DiamondParticle) == 0x0002A0, "Member 'UDiamondAnomalyAffectedItemComponent::DiamondParticle' has a wrong offset!");
static_assert(offsetof(UDiamondAnomalyAffectedItemComponent, OverridePhysicalMaterial) == 0x0002A8, "Member 'UDiamondAnomalyAffectedItemComponent::OverridePhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UDiamondAnomalyAffectedItemComponent, DiamondParticles) == 0x0002B0, "Member 'UDiamondAnomalyAffectedItemComponent::DiamondParticles' has a wrong offset!");
static_assert(offsetof(UDiamondAnomalyAffectedItemComponent, DiamondAuxFilter) == 0x0002C0, "Member 'UDiamondAnomalyAffectedItemComponent::DiamondAuxFilter' has a wrong offset!");
static_assert(offsetof(UDiamondAnomalyAffectedItemComponent, DiamondAuxComponent) == 0x0002C8, "Member 'UDiamondAnomalyAffectedItemComponent::DiamondAuxComponent' has a wrong offset!");
static_assert(offsetof(UDiamondAnomalyAffectedItemComponent, DiamondFilterBounds) == 0x0002D0, "Member 'UDiamondAnomalyAffectedItemComponent::DiamondFilterBounds' has a wrong offset!");

// Class Stalker2.DifficultySubView
// 0x0068 (0x0338 - 0x02D0)
class UDifficultySubView final : public UMenuSubViewBase
{
public:
	TSubclassOf<class UMenuButtonBase>            DifficultyButtonStyleClass;                        // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FShortcutData>                  DifficultyButtonShortcuts;                         // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FDifficultyData>           DifficultyDataSet;                                 // 0x02E8(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DifficultySubView">();
	}
	static class UDifficultySubView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDifficultySubView>();
	}
};
static_assert(alignof(UDifficultySubView) == 0x000008, "Wrong alignment on UDifficultySubView");
static_assert(sizeof(UDifficultySubView) == 0x000338, "Wrong size on UDifficultySubView");
static_assert(offsetof(UDifficultySubView, DifficultyButtonStyleClass) == 0x0002D0, "Member 'UDifficultySubView::DifficultyButtonStyleClass' has a wrong offset!");
static_assert(offsetof(UDifficultySubView, DifficultyButtonShortcuts) == 0x0002D8, "Member 'UDifficultySubView::DifficultyButtonShortcuts' has a wrong offset!");
static_assert(offsetof(UDifficultySubView, DifficultyDataSet) == 0x0002E8, "Member 'UDifficultySubView::DifficultyDataSet' has a wrong offset!");

// Class Stalker2.DLCPopup
// 0x0000 (0x02C0 - 0x02C0)
class UDLCPopup final : public UViewBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCPopup">();
	}
	static class UDLCPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCPopup>();
	}
};
static_assert(alignof(UDLCPopup) == 0x000008, "Wrong alignment on UDLCPopup");
static_assert(sizeof(UDLCPopup) == 0x0002C0, "Wrong size on UDLCPopup");

// Class Stalker2.DoorView
// 0x04E8 (0x0790 - 0x02A8)
class alignas(0x10) ADoorView final : public AUIDActor_Door
{
public:
	uint8                                         Pad_2A8[0x28];                                     // 0x02A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USingleClickComponent*                  OpenDoorSingleClick;                               // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USingleClickComponent*                  CloseDoorSingleClick;                              // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USingleClickComponent*                  LockedSingleClick;                                 // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHoldComponent*                         PeekDoorHold;                                      // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHoldComponent*                         ClosePeekDoorHold;                                 // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x138];                                    // 0x0308(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAkComponent*>                   DoorAkComponents;                                  // 0x0440(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FRebuildData>                   ViewRebuildMap;                                    // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPrivate)
	struct FVector                                OverrideInteractHintLocation;                      // 0x0460(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsHubDoor;                                        // 0x0478(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLocked;                                         // 0x0479(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDoubleDoor;                                     // 0x047A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47B[0x1];                                      // 0x047B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OpenAngleThreshold;                                // 0x047C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OpenAngle;                                         // 0x0480(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DecreaseImpulseAfterOpenTime;                      // 0x0484(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OpenAngularSpeed;                                  // 0x0488(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloseAngularSpeed;                                 // 0x048C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AngularSpeedNormalizer;                            // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DoorCloseTime;                                     // 0x0494(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SilentOpenAngle;                                   // 0x0498(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SilentOpenAngularSpeed;                            // 0x049C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FirstLeafAngleOnStart;                             // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SecondLeafAngleOnStart;                            // 0x04A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         KnockOutAngularSpeed;                              // 0x04A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutomaticDoorCloseTimeout;                         // 0x04AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloseDoorSpeedMultiplier;                          // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DoorConstraintSFXCooldown;                         // 0x04B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumberOfDoorHinges;                                // 0x04B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultRoot;                                       // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   FrameMeshComponent;                                // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   FirstLeafMeshComponent;                            // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   SecondLeafMeshComponent;                           // 0x04D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsConstraintComponent*            FirstLeafPhysicsConstraintComponent;               // 0x04E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsConstraintComponent*            SecondLeafPhysicsConstraintComponent;              // 0x04E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHittableComponent*                     HittableComponent;                                 // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGSCNavModifierComponent*               SpaceRestrictorComponent;                          // 0x04F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          BlockVolume;                                       // 0x0500(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalReceiverComponent*               InvertDoorStateReceiver;                           // 0x0508(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalReceiverComponent*               InvertDoorLockReceiver;                            // 0x0510(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalReceiverComponent*               OpenDoorReceiver;                                  // 0x0518(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalReceiverComponent*               CloseDoorReceiver;                                 // 0x0520(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalReceiverComponent*               LockDoorReceiver;                                  // 0x0528(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalReceiverComponent*               UnlockDoorReceiver;                                // 0x0530(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalReceiverComponent*               PeekDoorReceiver;                                  // 0x0538(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalReceiverComponent*               ForceOpenDoorReceiver;                             // 0x0540(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalReceiverComponent*               ForceCloseDoorReceiver;                            // 0x0548(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalSenderComponent*                 OpenDoorSender;                                    // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalSenderComponent*                 CloseDoorSender;                                   // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalSenderComponent*                 LockDoorSender;                                    // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalSenderComponent*                 UnlockDoorSender;                                  // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalSenderComponent*                 ForceOpenDoorSender;                               // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalSenderComponent*                 ForceCloseDoorSender;                              // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalSenderComponent*                 PeekDoorSender;                                    // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemUsageComponent*                    ItemUsageComponent;                                // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           FirstLeafAkComponent;                              // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           SecondLeafAkComponent;                             // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           DoorMovementSFX;                                   // 0x05A0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           DoorConstraintSFX;                                 // 0x05D0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           DoorOpenSFX;                                       // 0x0600(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           DoorCloseSFX;                                      // 0x0630(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           UnlockDoorSFX;                                     // 0x0660(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           LockedDoorSFX;                                     // 0x0690(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           SilentDoorOpenSFX;                                 // 0x06C0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           KnockDoorOpenSFX;                                  // 0x06F0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkRtpc>                 DoorMovementRTPC;                                  // 0x0720(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_750[0x40];                                     // 0x0750(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActualizeNavigationProperties();
	void CloseDoor(const bool bCloseFast);
	void ForceCloseDoor();
	void ForceOpenDoor();
	void InvertDoorLock();
	void InvertDoorState();
	void LockDoor();
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnDoorClosedCompletely();
	void OpenDoor();
	void PeekCloseDoor();
	void PeekDoor();
	void PlayLockedDoorSound();
	void RebuildDoorView();
	void SetClosed();

	bool IsLocked() const;
	void SetDoubleDoor(const bool bValue) const;
	void SetLocked() const;
	void SetOpen() const;
	void SetPreopened() const;
	void SetUnlocked() const;
	void UnlockDoor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorView">();
	}
	static class ADoorView* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoorView>();
	}
};
static_assert(alignof(ADoorView) == 0x000010, "Wrong alignment on ADoorView");
static_assert(sizeof(ADoorView) == 0x000790, "Wrong size on ADoorView");
static_assert(offsetof(ADoorView, Guid) == 0x0002D0, "Member 'ADoorView::Guid' has a wrong offset!");
static_assert(offsetof(ADoorView, OpenDoorSingleClick) == 0x0002E0, "Member 'ADoorView::OpenDoorSingleClick' has a wrong offset!");
static_assert(offsetof(ADoorView, CloseDoorSingleClick) == 0x0002E8, "Member 'ADoorView::CloseDoorSingleClick' has a wrong offset!");
static_assert(offsetof(ADoorView, LockedSingleClick) == 0x0002F0, "Member 'ADoorView::LockedSingleClick' has a wrong offset!");
static_assert(offsetof(ADoorView, PeekDoorHold) == 0x0002F8, "Member 'ADoorView::PeekDoorHold' has a wrong offset!");
static_assert(offsetof(ADoorView, ClosePeekDoorHold) == 0x000300, "Member 'ADoorView::ClosePeekDoorHold' has a wrong offset!");
static_assert(offsetof(ADoorView, DoorAkComponents) == 0x000440, "Member 'ADoorView::DoorAkComponents' has a wrong offset!");
static_assert(offsetof(ADoorView, ViewRebuildMap) == 0x000450, "Member 'ADoorView::ViewRebuildMap' has a wrong offset!");
static_assert(offsetof(ADoorView, OverrideInteractHintLocation) == 0x000460, "Member 'ADoorView::OverrideInteractHintLocation' has a wrong offset!");
static_assert(offsetof(ADoorView, bIsHubDoor) == 0x000478, "Member 'ADoorView::bIsHubDoor' has a wrong offset!");
static_assert(offsetof(ADoorView, bIsLocked) == 0x000479, "Member 'ADoorView::bIsLocked' has a wrong offset!");
static_assert(offsetof(ADoorView, bIsDoubleDoor) == 0x00047A, "Member 'ADoorView::bIsDoubleDoor' has a wrong offset!");
static_assert(offsetof(ADoorView, OpenAngleThreshold) == 0x00047C, "Member 'ADoorView::OpenAngleThreshold' has a wrong offset!");
static_assert(offsetof(ADoorView, OpenAngle) == 0x000480, "Member 'ADoorView::OpenAngle' has a wrong offset!");
static_assert(offsetof(ADoorView, DecreaseImpulseAfterOpenTime) == 0x000484, "Member 'ADoorView::DecreaseImpulseAfterOpenTime' has a wrong offset!");
static_assert(offsetof(ADoorView, OpenAngularSpeed) == 0x000488, "Member 'ADoorView::OpenAngularSpeed' has a wrong offset!");
static_assert(offsetof(ADoorView, CloseAngularSpeed) == 0x00048C, "Member 'ADoorView::CloseAngularSpeed' has a wrong offset!");
static_assert(offsetof(ADoorView, AngularSpeedNormalizer) == 0x000490, "Member 'ADoorView::AngularSpeedNormalizer' has a wrong offset!");
static_assert(offsetof(ADoorView, DoorCloseTime) == 0x000494, "Member 'ADoorView::DoorCloseTime' has a wrong offset!");
static_assert(offsetof(ADoorView, SilentOpenAngle) == 0x000498, "Member 'ADoorView::SilentOpenAngle' has a wrong offset!");
static_assert(offsetof(ADoorView, SilentOpenAngularSpeed) == 0x00049C, "Member 'ADoorView::SilentOpenAngularSpeed' has a wrong offset!");
static_assert(offsetof(ADoorView, FirstLeafAngleOnStart) == 0x0004A0, "Member 'ADoorView::FirstLeafAngleOnStart' has a wrong offset!");
static_assert(offsetof(ADoorView, SecondLeafAngleOnStart) == 0x0004A4, "Member 'ADoorView::SecondLeafAngleOnStart' has a wrong offset!");
static_assert(offsetof(ADoorView, KnockOutAngularSpeed) == 0x0004A8, "Member 'ADoorView::KnockOutAngularSpeed' has a wrong offset!");
static_assert(offsetof(ADoorView, AutomaticDoorCloseTimeout) == 0x0004AC, "Member 'ADoorView::AutomaticDoorCloseTimeout' has a wrong offset!");
static_assert(offsetof(ADoorView, CloseDoorSpeedMultiplier) == 0x0004B0, "Member 'ADoorView::CloseDoorSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(ADoorView, DoorConstraintSFXCooldown) == 0x0004B4, "Member 'ADoorView::DoorConstraintSFXCooldown' has a wrong offset!");
static_assert(offsetof(ADoorView, NumberOfDoorHinges) == 0x0004B8, "Member 'ADoorView::NumberOfDoorHinges' has a wrong offset!");
static_assert(offsetof(ADoorView, DefaultRoot) == 0x0004C0, "Member 'ADoorView::DefaultRoot' has a wrong offset!");
static_assert(offsetof(ADoorView, FrameMeshComponent) == 0x0004C8, "Member 'ADoorView::FrameMeshComponent' has a wrong offset!");
static_assert(offsetof(ADoorView, FirstLeafMeshComponent) == 0x0004D0, "Member 'ADoorView::FirstLeafMeshComponent' has a wrong offset!");
static_assert(offsetof(ADoorView, SecondLeafMeshComponent) == 0x0004D8, "Member 'ADoorView::SecondLeafMeshComponent' has a wrong offset!");
static_assert(offsetof(ADoorView, FirstLeafPhysicsConstraintComponent) == 0x0004E0, "Member 'ADoorView::FirstLeafPhysicsConstraintComponent' has a wrong offset!");
static_assert(offsetof(ADoorView, SecondLeafPhysicsConstraintComponent) == 0x0004E8, "Member 'ADoorView::SecondLeafPhysicsConstraintComponent' has a wrong offset!");
static_assert(offsetof(ADoorView, HittableComponent) == 0x0004F0, "Member 'ADoorView::HittableComponent' has a wrong offset!");
static_assert(offsetof(ADoorView, SpaceRestrictorComponent) == 0x0004F8, "Member 'ADoorView::SpaceRestrictorComponent' has a wrong offset!");
static_assert(offsetof(ADoorView, BlockVolume) == 0x000500, "Member 'ADoorView::BlockVolume' has a wrong offset!");
static_assert(offsetof(ADoorView, InvertDoorStateReceiver) == 0x000508, "Member 'ADoorView::InvertDoorStateReceiver' has a wrong offset!");
static_assert(offsetof(ADoorView, InvertDoorLockReceiver) == 0x000510, "Member 'ADoorView::InvertDoorLockReceiver' has a wrong offset!");
static_assert(offsetof(ADoorView, OpenDoorReceiver) == 0x000518, "Member 'ADoorView::OpenDoorReceiver' has a wrong offset!");
static_assert(offsetof(ADoorView, CloseDoorReceiver) == 0x000520, "Member 'ADoorView::CloseDoorReceiver' has a wrong offset!");
static_assert(offsetof(ADoorView, LockDoorReceiver) == 0x000528, "Member 'ADoorView::LockDoorReceiver' has a wrong offset!");
static_assert(offsetof(ADoorView, UnlockDoorReceiver) == 0x000530, "Member 'ADoorView::UnlockDoorReceiver' has a wrong offset!");
static_assert(offsetof(ADoorView, PeekDoorReceiver) == 0x000538, "Member 'ADoorView::PeekDoorReceiver' has a wrong offset!");
static_assert(offsetof(ADoorView, ForceOpenDoorReceiver) == 0x000540, "Member 'ADoorView::ForceOpenDoorReceiver' has a wrong offset!");
static_assert(offsetof(ADoorView, ForceCloseDoorReceiver) == 0x000548, "Member 'ADoorView::ForceCloseDoorReceiver' has a wrong offset!");
static_assert(offsetof(ADoorView, OpenDoorSender) == 0x000550, "Member 'ADoorView::OpenDoorSender' has a wrong offset!");
static_assert(offsetof(ADoorView, CloseDoorSender) == 0x000558, "Member 'ADoorView::CloseDoorSender' has a wrong offset!");
static_assert(offsetof(ADoorView, LockDoorSender) == 0x000560, "Member 'ADoorView::LockDoorSender' has a wrong offset!");
static_assert(offsetof(ADoorView, UnlockDoorSender) == 0x000568, "Member 'ADoorView::UnlockDoorSender' has a wrong offset!");
static_assert(offsetof(ADoorView, ForceOpenDoorSender) == 0x000570, "Member 'ADoorView::ForceOpenDoorSender' has a wrong offset!");
static_assert(offsetof(ADoorView, ForceCloseDoorSender) == 0x000578, "Member 'ADoorView::ForceCloseDoorSender' has a wrong offset!");
static_assert(offsetof(ADoorView, PeekDoorSender) == 0x000580, "Member 'ADoorView::PeekDoorSender' has a wrong offset!");
static_assert(offsetof(ADoorView, ItemUsageComponent) == 0x000588, "Member 'ADoorView::ItemUsageComponent' has a wrong offset!");
static_assert(offsetof(ADoorView, FirstLeafAkComponent) == 0x000590, "Member 'ADoorView::FirstLeafAkComponent' has a wrong offset!");
static_assert(offsetof(ADoorView, SecondLeafAkComponent) == 0x000598, "Member 'ADoorView::SecondLeafAkComponent' has a wrong offset!");
static_assert(offsetof(ADoorView, DoorMovementSFX) == 0x0005A0, "Member 'ADoorView::DoorMovementSFX' has a wrong offset!");
static_assert(offsetof(ADoorView, DoorConstraintSFX) == 0x0005D0, "Member 'ADoorView::DoorConstraintSFX' has a wrong offset!");
static_assert(offsetof(ADoorView, DoorOpenSFX) == 0x000600, "Member 'ADoorView::DoorOpenSFX' has a wrong offset!");
static_assert(offsetof(ADoorView, DoorCloseSFX) == 0x000630, "Member 'ADoorView::DoorCloseSFX' has a wrong offset!");
static_assert(offsetof(ADoorView, UnlockDoorSFX) == 0x000660, "Member 'ADoorView::UnlockDoorSFX' has a wrong offset!");
static_assert(offsetof(ADoorView, LockedDoorSFX) == 0x000690, "Member 'ADoorView::LockedDoorSFX' has a wrong offset!");
static_assert(offsetof(ADoorView, SilentDoorOpenSFX) == 0x0006C0, "Member 'ADoorView::SilentDoorOpenSFX' has a wrong offset!");
static_assert(offsetof(ADoorView, KnockDoorOpenSFX) == 0x0006F0, "Member 'ADoorView::KnockDoorOpenSFX' has a wrong offset!");
static_assert(offsetof(ADoorView, DoorMovementRTPC) == 0x000720, "Member 'ADoorView::DoorMovementRTPC' has a wrong offset!");

// Class Stalker2.DPadOpenDownIPU
// 0x0000 (0x0040 - 0x0040)
class UDPadOpenDownIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DPadOpenDownIPU">();
	}
	static class UDPadOpenDownIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDPadOpenDownIPU>();
	}
};
static_assert(alignof(UDPadOpenDownIPU) == 0x000008, "Wrong alignment on UDPadOpenDownIPU");
static_assert(sizeof(UDPadOpenDownIPU) == 0x000040, "Wrong size on UDPadOpenDownIPU");

// Class Stalker2.DPadRightIPU
// 0x0000 (0x0040 - 0x0040)
class UDPadRightIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DPadRightIPU">();
	}
	static class UDPadRightIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDPadRightIPU>();
	}
};
static_assert(alignof(UDPadRightIPU) == 0x000008, "Wrong alignment on UDPadRightIPU");
static_assert(sizeof(UDPadRightIPU) == 0x000040, "Wrong size on UDPadRightIPU");

// Class Stalker2.DragDropZone
// 0x0048 (0x02C0 - 0x0278)
class UDragDropZone : public UUserWidget
{
public:
	uint8                                         Pad_278[0x48];                                     // 0x0278(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragDropZone">();
	}
	static class UDragDropZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragDropZone>();
	}
};
static_assert(alignof(UDragDropZone) == 0x000008, "Wrong alignment on UDragDropZone");
static_assert(sizeof(UDragDropZone) == 0x0002C0, "Wrong size on UDragDropZone");

// Class Stalker2.DynamicEnvironmentParticleActor
// 0x0008 (0x02A0 - 0x0298)
class ADynamicEnvironmentParticleActor final : public AActor
{
public:
	class UDynamicEnvironmentNiagaraComponent*    EnvironmentParticleComponent;                      // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicEnvironmentParticleActor">();
	}
	static class ADynamicEnvironmentParticleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicEnvironmentParticleActor>();
	}
};
static_assert(alignof(ADynamicEnvironmentParticleActor) == 0x000008, "Wrong alignment on ADynamicEnvironmentParticleActor");
static_assert(sizeof(ADynamicEnvironmentParticleActor) == 0x0002A0, "Wrong size on ADynamicEnvironmentParticleActor");
static_assert(offsetof(ADynamicEnvironmentParticleActor, EnvironmentParticleComponent) == 0x000298, "Member 'ADynamicEnvironmentParticleActor::EnvironmentParticleComponent' has a wrong offset!");

// Class Stalker2.DynamicObstacleAvoidanceSettings
// 0x0060 (0x0098 - 0x0038)
class UDynamicObstacleAvoidanceSettings final : public UDeveloperSettings
{
public:
	struct FDynamicObstacleAvoidanceSystemSettings SystemSettings;                                   // 0x0038(0x0008)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FDynamicObstacleAvoidanceQuerrySettings QuerrySettings;                                   // 0x0040(0x0018)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FDynamicObstacleAvoidanceAgentSettings PiecefulAgentSettings;                             // 0x0058(0x0020)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FDynamicObstacleAvoidanceAgentSettings CombatAgentSettings;                               // 0x0078(0x0020)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicObstacleAvoidanceSettings">();
	}
	static class UDynamicObstacleAvoidanceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicObstacleAvoidanceSettings>();
	}
};
static_assert(alignof(UDynamicObstacleAvoidanceSettings) == 0x000008, "Wrong alignment on UDynamicObstacleAvoidanceSettings");
static_assert(sizeof(UDynamicObstacleAvoidanceSettings) == 0x000098, "Wrong size on UDynamicObstacleAvoidanceSettings");
static_assert(offsetof(UDynamicObstacleAvoidanceSettings, SystemSettings) == 0x000038, "Member 'UDynamicObstacleAvoidanceSettings::SystemSettings' has a wrong offset!");
static_assert(offsetof(UDynamicObstacleAvoidanceSettings, QuerrySettings) == 0x000040, "Member 'UDynamicObstacleAvoidanceSettings::QuerrySettings' has a wrong offset!");
static_assert(offsetof(UDynamicObstacleAvoidanceSettings, PiecefulAgentSettings) == 0x000058, "Member 'UDynamicObstacleAvoidanceSettings::PiecefulAgentSettings' has a wrong offset!");
static_assert(offsetof(UDynamicObstacleAvoidanceSettings, CombatAgentSettings) == 0x000078, "Member 'UDynamicObstacleAvoidanceSettings::CombatAgentSettings' has a wrong offset!");

// Class Stalker2.EditorTools
// 0x0020 (0x02B8 - 0x0298)
class AEditorTools final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEmptyGroupsOutputToMessageLog;                    // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEmptyGroupsOutputToConsole;                       // 0x02A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRemoveEmptyGroupActors;                           // 0x02A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EZeroBoundsFilter                             ZeroBoundsFilter;                                  // 0x02A3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bZeroBoundsOutputToConsole;                        // 0x02A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bZeroBoundsOutputToMessageLog;                     // 0x02A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBigClustersOutputToConsole;                       // 0x02A6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBigClustersOutputToMessageLog;                    // 0x02A7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBigClustersExcludeEmptyGroupActors;               // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GridNameForDebug;                                  // 0x02AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetSkyLightUpdateDeltaTime();
	static bool IsActorInGameWorld(class AActor* ActorToCheck);
	static bool IsGameWorld(class UWorld* GameWorld);

	void ChangeNotesToTeleportPoints();
	void CheckAllPrototypes();
	void FixAttachMeshes();
	void RemoveEditorContainers();
	void UpdateVoiceSounds();
	void XVerifyAllActorsForBrokenReference();

	void XRemoveRestoredLabelFromActors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorTools">();
	}
	static class AEditorTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEditorTools>();
	}
};
static_assert(alignof(AEditorTools) == 0x000008, "Wrong alignment on AEditorTools");
static_assert(sizeof(AEditorTools) == 0x0002B8, "Wrong size on AEditorTools");
static_assert(offsetof(AEditorTools, bEmptyGroupsOutputToMessageLog) == 0x0002A0, "Member 'AEditorTools::bEmptyGroupsOutputToMessageLog' has a wrong offset!");
static_assert(offsetof(AEditorTools, bEmptyGroupsOutputToConsole) == 0x0002A1, "Member 'AEditorTools::bEmptyGroupsOutputToConsole' has a wrong offset!");
static_assert(offsetof(AEditorTools, bRemoveEmptyGroupActors) == 0x0002A2, "Member 'AEditorTools::bRemoveEmptyGroupActors' has a wrong offset!");
static_assert(offsetof(AEditorTools, ZeroBoundsFilter) == 0x0002A3, "Member 'AEditorTools::ZeroBoundsFilter' has a wrong offset!");
static_assert(offsetof(AEditorTools, bZeroBoundsOutputToConsole) == 0x0002A4, "Member 'AEditorTools::bZeroBoundsOutputToConsole' has a wrong offset!");
static_assert(offsetof(AEditorTools, bZeroBoundsOutputToMessageLog) == 0x0002A5, "Member 'AEditorTools::bZeroBoundsOutputToMessageLog' has a wrong offset!");
static_assert(offsetof(AEditorTools, bBigClustersOutputToConsole) == 0x0002A6, "Member 'AEditorTools::bBigClustersOutputToConsole' has a wrong offset!");
static_assert(offsetof(AEditorTools, bBigClustersOutputToMessageLog) == 0x0002A7, "Member 'AEditorTools::bBigClustersOutputToMessageLog' has a wrong offset!");
static_assert(offsetof(AEditorTools, bBigClustersExcludeEmptyGroupActors) == 0x0002A8, "Member 'AEditorTools::bBigClustersExcludeEmptyGroupActors' has a wrong offset!");
static_assert(offsetof(AEditorTools, GridNameForDebug) == 0x0002AC, "Member 'AEditorTools::GridNameForDebug' has a wrong offset!");

// Class Stalker2.ElectricComponent
// 0x0030 (0x00D0 - 0x00A0)
class UElectricComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(float EMIDuration)> OnStartEMIEvent;                               // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnEndEMIEvent;                                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsTurnedOn;                                       // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ElectricComponent">();
	}
	static class UElectricComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UElectricComponent>();
	}
};
static_assert(alignof(UElectricComponent) == 0x000008, "Wrong alignment on UElectricComponent");
static_assert(sizeof(UElectricComponent) == 0x0000D0, "Wrong size on UElectricComponent");
static_assert(offsetof(UElectricComponent, OnStartEMIEvent) == 0x0000A0, "Member 'UElectricComponent::OnStartEMIEvent' has a wrong offset!");
static_assert(offsetof(UElectricComponent, OnEndEMIEvent) == 0x0000B0, "Member 'UElectricComponent::OnEndEMIEvent' has a wrong offset!");
static_assert(offsetof(UElectricComponent, bIsTurnedOn) == 0x0000C0, "Member 'UElectricComponent::bIsTurnedOn' has a wrong offset!");

// Class Stalker2.EmissionManager
// 0x00C8 (0x0170 - 0x00A8)
class UEmissionManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0xC8];                                      // 0x00A8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GeneratorsSequenceIdle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmissionManager">();
	}
	static class UEmissionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmissionManager>();
	}
};
static_assert(alignof(UEmissionManager) == 0x000008, "Wrong alignment on UEmissionManager");
static_assert(sizeof(UEmissionManager) == 0x000170, "Wrong size on UEmissionManager");

// Class Stalker2.EncounterNPCSpawner
// 0x0128 (0x03C0 - 0x0298)
class AEncounterNPCSpawner final : public AActor
{
public:
	uint8                                         Pad_298[0x58];                                     // 0x0298(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class USignalSenderComponent*                 AllNPCKilledSender;                                // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FEncounterSpawnPointData>       SpawnPoints;                                       // 0x02F8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	float                                         PlayerFieldOfViewAngle;                            // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatInterval                         SpawnDelay;                                        // 0x030C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NPCTotalCount;                                     // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NPCMaxCount;                                       // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NPCMinCount;                                       // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpawnSource                                  SpawnSource;                                       // 0x0320(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_321[0x9F];                                     // 0x0321(0x009F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Despawn();
	void Disable();
	void Enable();
	void OnAllNPCKilled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EncounterNPCSpawner">();
	}
	static class AEncounterNPCSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEncounterNPCSpawner>();
	}
};
static_assert(alignof(AEncounterNPCSpawner) == 0x000008, "Wrong alignment on AEncounterNPCSpawner");
static_assert(sizeof(AEncounterNPCSpawner) == 0x0003C0, "Wrong size on AEncounterNPCSpawner");
static_assert(offsetof(AEncounterNPCSpawner, AllNPCKilledSender) == 0x0002F0, "Member 'AEncounterNPCSpawner::AllNPCKilledSender' has a wrong offset!");
static_assert(offsetof(AEncounterNPCSpawner, SpawnPoints) == 0x0002F8, "Member 'AEncounterNPCSpawner::SpawnPoints' has a wrong offset!");
static_assert(offsetof(AEncounterNPCSpawner, PlayerFieldOfViewAngle) == 0x000308, "Member 'AEncounterNPCSpawner::PlayerFieldOfViewAngle' has a wrong offset!");
static_assert(offsetof(AEncounterNPCSpawner, SpawnDelay) == 0x00030C, "Member 'AEncounterNPCSpawner::SpawnDelay' has a wrong offset!");
static_assert(offsetof(AEncounterNPCSpawner, NPCTotalCount) == 0x000314, "Member 'AEncounterNPCSpawner::NPCTotalCount' has a wrong offset!");
static_assert(offsetof(AEncounterNPCSpawner, NPCMaxCount) == 0x000318, "Member 'AEncounterNPCSpawner::NPCMaxCount' has a wrong offset!");
static_assert(offsetof(AEncounterNPCSpawner, NPCMinCount) == 0x00031C, "Member 'AEncounterNPCSpawner::NPCMinCount' has a wrong offset!");
static_assert(offsetof(AEncounterNPCSpawner, SpawnSource) == 0x000320, "Member 'AEncounterNPCSpawner::SpawnSource' has a wrong offset!");

// Class Stalker2.EnvironmentParticleManager
// 0x00F0 (0x0198 - 0x00A8)
class UEnvironmentParticleManager final : public UBaseTickableManager
{
public:
	TArray<class UStaticEnvironmentNiagaraComponent*> StaticParticles;                               // 0x00A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      EmissionCrowsFall;                                 // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0xD8];                                      // 0x00C0(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentParticleManager">();
	}
	static class UEnvironmentParticleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvironmentParticleManager>();
	}
};
static_assert(alignof(UEnvironmentParticleManager) == 0x000008, "Wrong alignment on UEnvironmentParticleManager");
static_assert(sizeof(UEnvironmentParticleManager) == 0x000198, "Wrong size on UEnvironmentParticleManager");
static_assert(offsetof(UEnvironmentParticleManager, StaticParticles) == 0x0000A8, "Member 'UEnvironmentParticleManager::StaticParticles' has a wrong offset!");
static_assert(offsetof(UEnvironmentParticleManager, EmissionCrowsFall) == 0x0000B8, "Member 'UEnvironmentParticleManager::EmissionCrowsFall' has a wrong offset!");

// Class Stalker2.EquipmentSlots
// 0x0200 (0x04C0 - 0x02C0)
class UEquipmentSlots final : public UDragDropZone
{
public:
	class UCanvasPanel*                           CanvasPanel;                                       // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentSlot*                         MainHand;                                          // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentSlot*                         SecondHand;                                        // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentSlot*                         Head;                                              // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentSlot*                         Detector;                                          // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentSlot*                         Artifact1;                                         // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentSlot*                         Artifact2;                                         // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentSlot*                         Artifact3;                                         // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentSlot*                         Artifact4;                                         // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentSlot*                         Artifact5;                                         // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentSlot*                         Pistol;                                            // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentSlot*                         Torso;                                             // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                NavBorder;                                         // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            HeaderText;                                        // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x48];                                     // 0x0330(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DefaultNavBorderColor;                             // 0x0378(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DraggingNavBorderColor;                            // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryNew*                          InventoryNew;                                      // 0x0398(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class UEquipmentSlot*>            ItemSlotsWidgets;                                  // 0x03A0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<EInventoryEquipmentSlot, struct FEquipmentNavigationPaths> NavigationPaths;                 // 0x03F0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UItemDragWidget*                        CurrMovingWidget;                                  // 0x0440(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentSlot*                         CurrPickedSlot;                                    // 0x0448(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x18];                                     // 0x0450(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanelSlot*                       NavBorderSlot;                                     // 0x0468(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x50];                                     // 0x0470(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnItemMouseEnter(class UInteractableItemSlotBaseWidget* ItemWidget);
	void OnItemMouseLeave(class UInteractableItemSlotBaseWidget* ItemWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentSlots">();
	}
	static class UEquipmentSlots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentSlots>();
	}
};
static_assert(alignof(UEquipmentSlots) == 0x000008, "Wrong alignment on UEquipmentSlots");
static_assert(sizeof(UEquipmentSlots) == 0x0004C0, "Wrong size on UEquipmentSlots");
static_assert(offsetof(UEquipmentSlots, CanvasPanel) == 0x0002C0, "Member 'UEquipmentSlots::CanvasPanel' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, MainHand) == 0x0002C8, "Member 'UEquipmentSlots::MainHand' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, SecondHand) == 0x0002D0, "Member 'UEquipmentSlots::SecondHand' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, Head) == 0x0002D8, "Member 'UEquipmentSlots::Head' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, Detector) == 0x0002E0, "Member 'UEquipmentSlots::Detector' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, Artifact1) == 0x0002E8, "Member 'UEquipmentSlots::Artifact1' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, Artifact2) == 0x0002F0, "Member 'UEquipmentSlots::Artifact2' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, Artifact3) == 0x0002F8, "Member 'UEquipmentSlots::Artifact3' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, Artifact4) == 0x000300, "Member 'UEquipmentSlots::Artifact4' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, Artifact5) == 0x000308, "Member 'UEquipmentSlots::Artifact5' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, Pistol) == 0x000310, "Member 'UEquipmentSlots::Pistol' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, Torso) == 0x000318, "Member 'UEquipmentSlots::Torso' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, NavBorder) == 0x000320, "Member 'UEquipmentSlots::NavBorder' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, HeaderText) == 0x000328, "Member 'UEquipmentSlots::HeaderText' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, DefaultNavBorderColor) == 0x000378, "Member 'UEquipmentSlots::DefaultNavBorderColor' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, DraggingNavBorderColor) == 0x000388, "Member 'UEquipmentSlots::DraggingNavBorderColor' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, InventoryNew) == 0x000398, "Member 'UEquipmentSlots::InventoryNew' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, ItemSlotsWidgets) == 0x0003A0, "Member 'UEquipmentSlots::ItemSlotsWidgets' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, NavigationPaths) == 0x0003F0, "Member 'UEquipmentSlots::NavigationPaths' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, CurrMovingWidget) == 0x000440, "Member 'UEquipmentSlots::CurrMovingWidget' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, CurrPickedSlot) == 0x000448, "Member 'UEquipmentSlots::CurrPickedSlot' has a wrong offset!");
static_assert(offsetof(UEquipmentSlots, NavBorderSlot) == 0x000468, "Member 'UEquipmentSlots::NavBorderSlot' has a wrong offset!");

// Class Stalker2.EventManager
// 0x0758 (0x0800 - 0x00A8)
class UEventManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x758];                                     // 0x00A8(0x0758)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventManager">();
	}
	static class UEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventManager>();
	}
};
static_assert(alignof(UEventManager) == 0x000008, "Wrong alignment on UEventManager");
static_assert(sizeof(UEventManager) == 0x000800, "Wrong size on UEventManager");

// Class Stalker2.ExpulsionAnomaly
// 0x0050 (0x03E8 - 0x0398)
class AExpulsionAnomaly final : public AAnomaly
{
public:
	class USphereComponent*                       ActivationSphere;                                  // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGeometryCacheComponent*                ShapeGeometryCache;                                // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ShapeGeometryMaterial;                             // 0x03A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GeometryCachePath;                                 // 0x03B0(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PushDistanceDelayCurve;                            // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBoltCollided(const struct FVector& LocalPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExpulsionAnomaly">();
	}
	static class AExpulsionAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExpulsionAnomaly>();
	}
};
static_assert(alignof(AExpulsionAnomaly) == 0x000008, "Wrong alignment on AExpulsionAnomaly");
static_assert(sizeof(AExpulsionAnomaly) == 0x0003E8, "Wrong size on AExpulsionAnomaly");
static_assert(offsetof(AExpulsionAnomaly, ActivationSphere) == 0x000398, "Member 'AExpulsionAnomaly::ActivationSphere' has a wrong offset!");
static_assert(offsetof(AExpulsionAnomaly, ShapeGeometryCache) == 0x0003A0, "Member 'AExpulsionAnomaly::ShapeGeometryCache' has a wrong offset!");
static_assert(offsetof(AExpulsionAnomaly, ShapeGeometryMaterial) == 0x0003A8, "Member 'AExpulsionAnomaly::ShapeGeometryMaterial' has a wrong offset!");
static_assert(offsetof(AExpulsionAnomaly, GeometryCachePath) == 0x0003B0, "Member 'AExpulsionAnomaly::GeometryCachePath' has a wrong offset!");
static_assert(offsetof(AExpulsionAnomaly, PushDistanceDelayCurve) == 0x0003D0, "Member 'AExpulsionAnomaly::PushDistanceDelayCurve' has a wrong offset!");

// Class Stalker2.OnAKEventFinished_Proxy
// 0x0020 (0x0048 - 0x0028)
class UOnAKEventFinished_Proxy final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSoundFinished(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnAKEventFinished_Proxy">();
	}
	static class UOnAKEventFinished_Proxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnAKEventFinished_Proxy>();
	}
};
static_assert(alignof(UOnAKEventFinished_Proxy) == 0x000008, "Wrong alignment on UOnAKEventFinished_Proxy");
static_assert(sizeof(UOnAKEventFinished_Proxy) == 0x000048, "Wrong size on UOnAKEventFinished_Proxy");

// Class Stalker2.FastDialogueView
// 0x0028 (0x0718 - 0x06F0)
class UFastDialogueView final : public UDialogueView
{
public:
	class UVerticalBox*                           AnswerContainer;                                   // 0x06F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbstractProgressBar*                   TimerWidget;                                       // 0x06F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueFastAnswer*                    DialogueAnswerFastLeft;                            // 0x0700(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueFastAnswer*                    DialogueAnswerFastRight;                           // 0x0708(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsImportant;                                      // 0x0710(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_711[0x7];                                      // 0x0711(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockInput();
	void EndSelectAnswer(bool bIsRightAnswer);
	void PostSelectAnswer(bool bIsRightAnswer);
	void UIFastDialogFirstAnswer();
	void UIFastDialogSecondAnswer();
	void UpdateAfterClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FastDialogueView">();
	}
	static class UFastDialogueView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFastDialogueView>();
	}
};
static_assert(alignof(UFastDialogueView) == 0x000008, "Wrong alignment on UFastDialogueView");
static_assert(sizeof(UFastDialogueView) == 0x000718, "Wrong size on UFastDialogueView");
static_assert(offsetof(UFastDialogueView, AnswerContainer) == 0x0006F0, "Member 'UFastDialogueView::AnswerContainer' has a wrong offset!");
static_assert(offsetof(UFastDialogueView, TimerWidget) == 0x0006F8, "Member 'UFastDialogueView::TimerWidget' has a wrong offset!");
static_assert(offsetof(UFastDialogueView, DialogueAnswerFastLeft) == 0x000700, "Member 'UFastDialogueView::DialogueAnswerFastLeft' has a wrong offset!");
static_assert(offsetof(UFastDialogueView, DialogueAnswerFastRight) == 0x000708, "Member 'UFastDialogueView::DialogueAnswerFastRight' has a wrong offset!");
static_assert(offsetof(UFastDialogueView, bIsImportant) == 0x000710, "Member 'UFastDialogueView::bIsImportant' has a wrong offset!");

// Class Stalker2.FaustCloneComponent
// 0x0068 (0x0108 - 0x00A0)
class UFaustCloneComponent final : public UActorComponent
{
public:
	class UCurveFloat*                            AliveModelDissolveCurve;                           // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            DeadModelDissolveCurve;                            // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            AliveModelGroomCurve;                              // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            DeadModelGroomCurve;                               // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         CloneSwitchEffect;                                 // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloneSwitchTime;                                   // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnCloneSwitchStarted;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x28];                                      // 0x00E0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FaustCloneComponent">();
	}
	static class UFaustCloneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFaustCloneComponent>();
	}
};
static_assert(alignof(UFaustCloneComponent) == 0x000008, "Wrong alignment on UFaustCloneComponent");
static_assert(sizeof(UFaustCloneComponent) == 0x000108, "Wrong size on UFaustCloneComponent");
static_assert(offsetof(UFaustCloneComponent, AliveModelDissolveCurve) == 0x0000A0, "Member 'UFaustCloneComponent::AliveModelDissolveCurve' has a wrong offset!");
static_assert(offsetof(UFaustCloneComponent, DeadModelDissolveCurve) == 0x0000A8, "Member 'UFaustCloneComponent::DeadModelDissolveCurve' has a wrong offset!");
static_assert(offsetof(UFaustCloneComponent, AliveModelGroomCurve) == 0x0000B0, "Member 'UFaustCloneComponent::AliveModelGroomCurve' has a wrong offset!");
static_assert(offsetof(UFaustCloneComponent, DeadModelGroomCurve) == 0x0000B8, "Member 'UFaustCloneComponent::DeadModelGroomCurve' has a wrong offset!");
static_assert(offsetof(UFaustCloneComponent, CloneSwitchEffect) == 0x0000C0, "Member 'UFaustCloneComponent::CloneSwitchEffect' has a wrong offset!");
static_assert(offsetof(UFaustCloneComponent, CloneSwitchTime) == 0x0000C8, "Member 'UFaustCloneComponent::CloneSwitchTime' has a wrong offset!");
static_assert(offsetof(UFaustCloneComponent, OnCloneSwitchStarted) == 0x0000D0, "Member 'UFaustCloneComponent::OnCloneSwitchStarted' has a wrong offset!");

// Class Stalker2.AchievementTracker_Gunsmith
// 0x0008 (0x0040 - 0x0038)
class UAchievementTracker_Gunsmith final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_Gunsmith">();
	}
	static class UAchievementTracker_Gunsmith* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_Gunsmith>();
	}
};
static_assert(alignof(UAchievementTracker_Gunsmith) == 0x000008, "Wrong alignment on UAchievementTracker_Gunsmith");
static_assert(sizeof(UAchievementTracker_Gunsmith) == 0x000040, "Wrong size on UAchievementTracker_Gunsmith");

// Class Stalker2.UIDActor_FireBreathAnomaly
// 0x0010 (0x02A8 - 0x0298)
class AUIDActor_FireBreathAnomaly : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActor_FireBreathAnomaly">();
	}
	static class AUIDActor_FireBreathAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDActor_FireBreathAnomaly>();
	}
};
static_assert(alignof(AUIDActor_FireBreathAnomaly) == 0x000008, "Wrong alignment on AUIDActor_FireBreathAnomaly");
static_assert(sizeof(AUIDActor_FireBreathAnomaly) == 0x0002A8, "Wrong size on AUIDActor_FireBreathAnomaly");

// Class Stalker2.FireBreathArchiAnomaly
// 0x0098 (0x0340 - 0x02A8)
class AFireBreathArchiAnomaly final : public AUIDActor_FireBreathAnomaly
{
public:
	class UStaticMeshComponent*                   ScalableRoot;                                      // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   CollisionMesh;                                     // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinRadius;                                         // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxRadius;                                         // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinHeight;                                         // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxHeight;                                         // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPrototypeSID                          EffectPrototypeSID;                                // 0x02C8(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x18];                                     // 0x0308(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x0320(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex);
	void SetScaleAlpha(const float InScaleAlpha);
	void SetTimeAlpha(const float InTimeAlpha);

	float GetScaleAlpha() const;
	float GetTimeAlpha() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireBreathArchiAnomaly">();
	}
	static class AFireBreathArchiAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFireBreathArchiAnomaly>();
	}
};
static_assert(alignof(AFireBreathArchiAnomaly) == 0x000008, "Wrong alignment on AFireBreathArchiAnomaly");
static_assert(sizeof(AFireBreathArchiAnomaly) == 0x000340, "Wrong size on AFireBreathArchiAnomaly");
static_assert(offsetof(AFireBreathArchiAnomaly, ScalableRoot) == 0x0002A8, "Member 'AFireBreathArchiAnomaly::ScalableRoot' has a wrong offset!");
static_assert(offsetof(AFireBreathArchiAnomaly, CollisionMesh) == 0x0002B0, "Member 'AFireBreathArchiAnomaly::CollisionMesh' has a wrong offset!");
static_assert(offsetof(AFireBreathArchiAnomaly, MinRadius) == 0x0002B8, "Member 'AFireBreathArchiAnomaly::MinRadius' has a wrong offset!");
static_assert(offsetof(AFireBreathArchiAnomaly, MaxRadius) == 0x0002BC, "Member 'AFireBreathArchiAnomaly::MaxRadius' has a wrong offset!");
static_assert(offsetof(AFireBreathArchiAnomaly, MinHeight) == 0x0002C0, "Member 'AFireBreathArchiAnomaly::MinHeight' has a wrong offset!");
static_assert(offsetof(AFireBreathArchiAnomaly, MaxHeight) == 0x0002C4, "Member 'AFireBreathArchiAnomaly::MaxHeight' has a wrong offset!");
static_assert(offsetof(AFireBreathArchiAnomaly, EffectPrototypeSID) == 0x0002C8, "Member 'AFireBreathArchiAnomaly::EffectPrototypeSID' has a wrong offset!");
static_assert(offsetof(AFireBreathArchiAnomaly, Guid) == 0x000320, "Member 'AFireBreathArchiAnomaly::Guid' has a wrong offset!");

// Class Stalker2.FlashlightComponent
// 0x00B8 (0x0188 - 0x00D0)
class UFlashlightComponent : public UElectricComponent
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         MainMeshComponent;                                 // 0x00F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   FakeLightBeamComponent;                            // 0x00F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    SpotLightComponent;                                // 0x0100(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    ExtraSpotLightComponent;                           // 0x0108(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        TopAttachmentComponent;                            // 0x0110(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         ParentMeshComponent;                               // 0x0128(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            InnerRadiusCurve;                                  // 0x0130(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            OuterRadiusCurve;                                  // 0x0138(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       DynamicMaterials;                                  // 0x0140(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UMeshComponent*>                 CreatedMeshes;                                     // 0x0150(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x28];                                     // 0x0160(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightComponent">();
	}
	static class UFlashlightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightComponent>();
	}
};
static_assert(alignof(UFlashlightComponent) == 0x000008, "Wrong alignment on UFlashlightComponent");
static_assert(sizeof(UFlashlightComponent) == 0x000188, "Wrong size on UFlashlightComponent");
static_assert(offsetof(UFlashlightComponent, MainMeshComponent) == 0x0000F0, "Member 'UFlashlightComponent::MainMeshComponent' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, FakeLightBeamComponent) == 0x0000F8, "Member 'UFlashlightComponent::FakeLightBeamComponent' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, SpotLightComponent) == 0x000100, "Member 'UFlashlightComponent::SpotLightComponent' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, ExtraSpotLightComponent) == 0x000108, "Member 'UFlashlightComponent::ExtraSpotLightComponent' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, TopAttachmentComponent) == 0x000110, "Member 'UFlashlightComponent::TopAttachmentComponent' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, ParentMeshComponent) == 0x000128, "Member 'UFlashlightComponent::ParentMeshComponent' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, InnerRadiusCurve) == 0x000130, "Member 'UFlashlightComponent::InnerRadiusCurve' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, OuterRadiusCurve) == 0x000138, "Member 'UFlashlightComponent::OuterRadiusCurve' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, DynamicMaterials) == 0x000140, "Member 'UFlashlightComponent::DynamicMaterials' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, CreatedMeshes) == 0x000150, "Member 'UFlashlightComponent::CreatedMeshes' has a wrong offset!");

// Class Stalker2.ForceFeedbackDataAsset
// 0x0050 (0x0080 - 0x0030)
class UForceFeedbackDataAsset final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, struct FProcessorsArray> TriggerToProcessors;                          // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceFeedbackDataAsset">();
	}
	static class UForceFeedbackDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceFeedbackDataAsset>();
	}
};
static_assert(alignof(UForceFeedbackDataAsset) == 0x000008, "Wrong alignment on UForceFeedbackDataAsset");
static_assert(sizeof(UForceFeedbackDataAsset) == 0x000080, "Wrong size on UForceFeedbackDataAsset");
static_assert(offsetof(UForceFeedbackDataAsset, TriggerToProcessors) == 0x000030, "Member 'UForceFeedbackDataAsset::TriggerToProcessors' has a wrong offset!");

// Class Stalker2.ForceFeedbackSettings
// 0x0038 (0x0070 - 0x0038)
class UForceFeedbackSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UForceFeedbackDataAsset> FeedbackDataAsset;                                 // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StopAllPriority;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopCurrentProcessor;                             // 0x006C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceFeedbackSettings">();
	}
	static class UForceFeedbackSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceFeedbackSettings>();
	}
};
static_assert(alignof(UForceFeedbackSettings) == 0x000008, "Wrong alignment on UForceFeedbackSettings");
static_assert(sizeof(UForceFeedbackSettings) == 0x000070, "Wrong size on UForceFeedbackSettings");
static_assert(offsetof(UForceFeedbackSettings, FeedbackDataAsset) == 0x000038, "Member 'UForceFeedbackSettings::FeedbackDataAsset' has a wrong offset!");
static_assert(offsetof(UForceFeedbackSettings, StopAllPriority) == 0x000068, "Member 'UForceFeedbackSettings::StopAllPriority' has a wrong offset!");
static_assert(offsetof(UForceFeedbackSettings, bStopCurrentProcessor) == 0x00006C, "Member 'UForceFeedbackSettings::bStopCurrentProcessor' has a wrong offset!");

// Class Stalker2.ForceFeedbackSphereComponent
// 0x0030 (0x05C0 - 0x0590)
class UForceFeedbackSphereComponent final : public USphereComponent
{
public:
	struct FGameplayTag                           FeedbackTag;                                       // 0x0588(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ForceFeedbackDistanceIntensityCurve;               // 0x0590(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateIntensityRate;                               // 0x0598(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateStartFeedbackRate;                           // 0x059C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOneShotFeedback;                                  // 0x05A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisabledByDefault;                                // 0x05A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A2[0x1E];                                     // 0x05A2(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableForceFeedback();
	void EnableForceFeedback();
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceFeedbackSphereComponent">();
	}
	static class UForceFeedbackSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceFeedbackSphereComponent>();
	}
};
static_assert(alignof(UForceFeedbackSphereComponent) == 0x000010, "Wrong alignment on UForceFeedbackSphereComponent");
static_assert(sizeof(UForceFeedbackSphereComponent) == 0x0005C0, "Wrong size on UForceFeedbackSphereComponent");
static_assert(offsetof(UForceFeedbackSphereComponent, FeedbackTag) == 0x000588, "Member 'UForceFeedbackSphereComponent::FeedbackTag' has a wrong offset!");
static_assert(offsetof(UForceFeedbackSphereComponent, ForceFeedbackDistanceIntensityCurve) == 0x000590, "Member 'UForceFeedbackSphereComponent::ForceFeedbackDistanceIntensityCurve' has a wrong offset!");
static_assert(offsetof(UForceFeedbackSphereComponent, UpdateIntensityRate) == 0x000598, "Member 'UForceFeedbackSphereComponent::UpdateIntensityRate' has a wrong offset!");
static_assert(offsetof(UForceFeedbackSphereComponent, UpdateStartFeedbackRate) == 0x00059C, "Member 'UForceFeedbackSphereComponent::UpdateStartFeedbackRate' has a wrong offset!");
static_assert(offsetof(UForceFeedbackSphereComponent, bOneShotFeedback) == 0x0005A0, "Member 'UForceFeedbackSphereComponent::bOneShotFeedback' has a wrong offset!");
static_assert(offsetof(UForceFeedbackSphereComponent, bDisabledByDefault) == 0x0005A1, "Member 'UForceFeedbackSphereComponent::bDisabledByDefault' has a wrong offset!");

// Class Stalker2.GADeveloperSettings
// 0x00E8 (0x0120 - 0x0038)
class UGADeveloperSettings final : public UDeveloperSettings
{
public:
	float                                         SessionStatus_AfkThresholdToRecordSessionFinishInSeconds; // 0x0038(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerPosition_RepeatIntervalInSeconds;            // 0x003C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerPosition_AfkTimeThresholdInSeconds;          // 0x0040(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerFactionReputation_RepeatIntervalInSeconds;   // 0x0044(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerStatus_RepeatIntervalInSeconds;              // 0x0048(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerStatus_AfkTimeThresholdInSeconds;            // 0x004C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerStatus_EffectAppliedThrottleTimeWindowInSeconds; // 0x0050(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerStatus_DamageReceivedThrottleTimeWindowInSeconds; // 0x0054(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerStatus_MinDamageReceivedAmountToEmit;        // 0x0058(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FString>                           PlayerStatus_ListOfEffectsToTrack;                 // 0x0060(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         PlayerStatus_MaxEffectsAttributesCount;            // 0x00B0(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventoryStatus_RepeatIntervalInSeconds;           // 0x00B4(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventoryAction_Hover_HoverdTimeThresholdInSeconds; // 0x00B8(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerAction_Shoot_ThrottleTimeWindowInSeconds;    // 0x00BC(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerAction_UseQuickSlot_ThrottleTimeWindowInSeconds; // 0x00C0(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerAction_GetHit_ThrottleTimeWindowInSeconds;   // 0x00C4(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerCombat_PlayerHitThrottleTimeWindowInSeconds; // 0x00C8(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerCombat_EnemyHitThrottleTimeWindowInSeconds;  // 0x00CC(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FString>                           ListOfEventsToEmit;                                // 0x00D0(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GADeveloperSettings">();
	}
	static class UGADeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGADeveloperSettings>();
	}
};
static_assert(alignof(UGADeveloperSettings) == 0x000008, "Wrong alignment on UGADeveloperSettings");
static_assert(sizeof(UGADeveloperSettings) == 0x000120, "Wrong size on UGADeveloperSettings");
static_assert(offsetof(UGADeveloperSettings, SessionStatus_AfkThresholdToRecordSessionFinishInSeconds) == 0x000038, "Member 'UGADeveloperSettings::SessionStatus_AfkThresholdToRecordSessionFinishInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerPosition_RepeatIntervalInSeconds) == 0x00003C, "Member 'UGADeveloperSettings::PlayerPosition_RepeatIntervalInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerPosition_AfkTimeThresholdInSeconds) == 0x000040, "Member 'UGADeveloperSettings::PlayerPosition_AfkTimeThresholdInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerFactionReputation_RepeatIntervalInSeconds) == 0x000044, "Member 'UGADeveloperSettings::PlayerFactionReputation_RepeatIntervalInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerStatus_RepeatIntervalInSeconds) == 0x000048, "Member 'UGADeveloperSettings::PlayerStatus_RepeatIntervalInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerStatus_AfkTimeThresholdInSeconds) == 0x00004C, "Member 'UGADeveloperSettings::PlayerStatus_AfkTimeThresholdInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerStatus_EffectAppliedThrottleTimeWindowInSeconds) == 0x000050, "Member 'UGADeveloperSettings::PlayerStatus_EffectAppliedThrottleTimeWindowInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerStatus_DamageReceivedThrottleTimeWindowInSeconds) == 0x000054, "Member 'UGADeveloperSettings::PlayerStatus_DamageReceivedThrottleTimeWindowInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerStatus_MinDamageReceivedAmountToEmit) == 0x000058, "Member 'UGADeveloperSettings::PlayerStatus_MinDamageReceivedAmountToEmit' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerStatus_ListOfEffectsToTrack) == 0x000060, "Member 'UGADeveloperSettings::PlayerStatus_ListOfEffectsToTrack' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerStatus_MaxEffectsAttributesCount) == 0x0000B0, "Member 'UGADeveloperSettings::PlayerStatus_MaxEffectsAttributesCount' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, InventoryStatus_RepeatIntervalInSeconds) == 0x0000B4, "Member 'UGADeveloperSettings::InventoryStatus_RepeatIntervalInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, InventoryAction_Hover_HoverdTimeThresholdInSeconds) == 0x0000B8, "Member 'UGADeveloperSettings::InventoryAction_Hover_HoverdTimeThresholdInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerAction_Shoot_ThrottleTimeWindowInSeconds) == 0x0000BC, "Member 'UGADeveloperSettings::PlayerAction_Shoot_ThrottleTimeWindowInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerAction_UseQuickSlot_ThrottleTimeWindowInSeconds) == 0x0000C0, "Member 'UGADeveloperSettings::PlayerAction_UseQuickSlot_ThrottleTimeWindowInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerAction_GetHit_ThrottleTimeWindowInSeconds) == 0x0000C4, "Member 'UGADeveloperSettings::PlayerAction_GetHit_ThrottleTimeWindowInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerCombat_PlayerHitThrottleTimeWindowInSeconds) == 0x0000C8, "Member 'UGADeveloperSettings::PlayerCombat_PlayerHitThrottleTimeWindowInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, PlayerCombat_EnemyHitThrottleTimeWindowInSeconds) == 0x0000CC, "Member 'UGADeveloperSettings::PlayerCombat_EnemyHitThrottleTimeWindowInSeconds' has a wrong offset!");
static_assert(offsetof(UGADeveloperSettings, ListOfEventsToEmit) == 0x0000D0, "Member 'UGADeveloperSettings::ListOfEventsToEmit' has a wrong offset!");

// Class Stalker2.GAEventsLibrary
// 0x0000 (0x0028 - 0x0028)
class UGAEventsLibrary final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAEventsLibrary">();
	}
	static class UGAEventsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAEventsLibrary>();
	}
};
static_assert(alignof(UGAEventsLibrary) == 0x000008, "Wrong alignment on UGAEventsLibrary");
static_assert(sizeof(UGAEventsLibrary) == 0x000028, "Wrong size on UGAEventsLibrary");

// Class Stalker2.GAManager
// 0x0070 (0x0118 - 0x00A8)
class UGAManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x70];                                      // 0x00A8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAManager">();
	}
	static class UGAManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAManager>();
	}
};
static_assert(alignof(UGAManager) == 0x000008, "Wrong alignment on UGAManager");
static_assert(sizeof(UGAManager) == 0x000118, "Wrong size on UGAManager");

// Class Stalker2.GameGraphRenderingComponent
// 0x0060 (0x0610 - 0x05B0)
class UGameGraphRenderingComponent final : public UDebugDrawComponent
{
public:
	uint8                                         Pad_5B0[0x4];                                      // 0x05B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ShowComponentId;                                   // 0x05B4(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameGraphSceneProxyDrawParams         DrawParams;                                        // 0x05B8(0x0010)(Edit, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      GameGraphMaterial;                                 // 0x05C8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBoxSphereBounds                       GameGraphBoundsBox;                                // 0x05D0(0x0038)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_608[0x8];                                      // 0x0608(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShowAllComponents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameGraphRenderingComponent">();
	}
	static class UGameGraphRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameGraphRenderingComponent>();
	}
};
static_assert(alignof(UGameGraphRenderingComponent) == 0x000010, "Wrong alignment on UGameGraphRenderingComponent");
static_assert(sizeof(UGameGraphRenderingComponent) == 0x000610, "Wrong size on UGameGraphRenderingComponent");
static_assert(offsetof(UGameGraphRenderingComponent, ShowComponentId) == 0x0005B4, "Member 'UGameGraphRenderingComponent::ShowComponentId' has a wrong offset!");
static_assert(offsetof(UGameGraphRenderingComponent, DrawParams) == 0x0005B8, "Member 'UGameGraphRenderingComponent::DrawParams' has a wrong offset!");
static_assert(offsetof(UGameGraphRenderingComponent, GameGraphMaterial) == 0x0005C8, "Member 'UGameGraphRenderingComponent::GameGraphMaterial' has a wrong offset!");
static_assert(offsetof(UGameGraphRenderingComponent, GameGraphBoundsBox) == 0x0005D0, "Member 'UGameGraphRenderingComponent::GameGraphBoundsBox' has a wrong offset!");

// Class Stalker2.GameGraphSubsystem
// 0x0010 (0x0040 - 0x0030)
class UGameGraphSubsystem final : public UWorldSubsystem
{
public:
	class AGameGraphData*                         GameGraphData;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameGraphSubsystem">();
	}
	static class UGameGraphSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameGraphSubsystem>();
	}
};
static_assert(alignof(UGameGraphSubsystem) == 0x000008, "Wrong alignment on UGameGraphSubsystem");
static_assert(sizeof(UGameGraphSubsystem) == 0x000040, "Wrong size on UGameGraphSubsystem");
static_assert(offsetof(UGameGraphSubsystem, GameGraphData) == 0x000030, "Member 'UGameGraphSubsystem::GameGraphData' has a wrong offset!");

// Class Stalker2.GameManager
// 0x03B8 (0x0430 - 0x0078)
class UGameManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x138];                                     // 0x0078(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	class ADeveloperSpectator*                    DeveloperSpectator;                                // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            StaminaWeightCurve;                                // 0x01B8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x270];                                    // 0x01C0(0x0270)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameManager">();
	}
	static class UGameManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameManager>();
	}
};
static_assert(alignof(UGameManager) == 0x000008, "Wrong alignment on UGameManager");
static_assert(sizeof(UGameManager) == 0x000430, "Wrong size on UGameManager");
static_assert(offsetof(UGameManager, DeveloperSpectator) == 0x0001B0, "Member 'UGameManager::DeveloperSpectator' has a wrong offset!");
static_assert(offsetof(UGameManager, StaminaWeightCurve) == 0x0001B8, "Member 'UGameManager::StaminaWeightCurve' has a wrong offset!");

// Class Stalker2.GamepadMapNavigationIPU
// 0x0000 (0x0040 - 0x0040)
class UGamepadMapNavigationIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadMapNavigationIPU">();
	}
	static class UGamepadMapNavigationIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadMapNavigationIPU>();
	}
};
static_assert(alignof(UGamepadMapNavigationIPU) == 0x000008, "Wrong alignment on UGamepadMapNavigationIPU");
static_assert(sizeof(UGamepadMapNavigationIPU) == 0x000040, "Wrong size on UGamepadMapNavigationIPU");

// Class Stalker2.AbilityEventData
// 0x0010 (0x0038 - 0x0028)
class UAbilityEventData final : public UGameplayEventData
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EAbility GetAbilityType() const;
	class FName GetActivationTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityEventData">();
	}
	static class UAbilityEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityEventData>();
	}
};
static_assert(alignof(UAbilityEventData) == 0x000008, "Wrong alignment on UAbilityEventData");
static_assert(sizeof(UAbilityEventData) == 0x000038, "Wrong size on UAbilityEventData");

// Class Stalker2.SummonAbilityEventData
// 0x0018 (0x0040 - 0x0028)
class USummonAbilityEventData final : public UGameplayEventData
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FVector> GetSummonLocations() const;
	bool ShouldSpawnEffects() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonAbilityEventData">();
	}
	static class USummonAbilityEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonAbilityEventData>();
	}
};
static_assert(alignof(USummonAbilityEventData) == 0x000008, "Wrong alignment on USummonAbilityEventData");
static_assert(sizeof(USummonAbilityEventData) == 0x000040, "Wrong size on USummonAbilityEventData");

// Class Stalker2.HitEventData
// 0x0038 (0x0060 - 0x0028)
class UHitEventData final : public UGameplayEventData
{
public:
	struct FVector                                DamageHitLocation;                                 // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DamageImpulse;                                     // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDamageType                                   DamageType;                                        // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDamageSource                                 DamageSource;                                      // 0x0059(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitEventData">();
	}
	static class UHitEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitEventData>();
	}
};
static_assert(alignof(UHitEventData) == 0x000008, "Wrong alignment on UHitEventData");
static_assert(sizeof(UHitEventData) == 0x000060, "Wrong size on UHitEventData");
static_assert(offsetof(UHitEventData, DamageHitLocation) == 0x000028, "Member 'UHitEventData::DamageHitLocation' has a wrong offset!");
static_assert(offsetof(UHitEventData, DamageImpulse) == 0x000040, "Member 'UHitEventData::DamageImpulse' has a wrong offset!");
static_assert(offsetof(UHitEventData, DamageType) == 0x000058, "Member 'UHitEventData::DamageType' has a wrong offset!");
static_assert(offsetof(UHitEventData, DamageSource) == 0x000059, "Member 'UHitEventData::DamageSource' has a wrong offset!");

// Class Stalker2.PathBuilderDrawComponent
// 0x0000 (0x05B0 - 0x05B0)
class UPathBuilderDrawComponent final : public UDebugDrawComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathBuilderDrawComponent">();
	}
	static class UPathBuilderDrawComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathBuilderDrawComponent>();
	}
};
static_assert(alignof(UPathBuilderDrawComponent) == 0x000010, "Wrong alignment on UPathBuilderDrawComponent");
static_assert(sizeof(UPathBuilderDrawComponent) == 0x0005B0, "Wrong size on UPathBuilderDrawComponent");

// Class Stalker2.GameplayEventListener
// 0x0000 (0x0000 - 0x0000)
class IGameplayEventListener final
{
public:
	void OnGameplayEvent(const struct FGameplayTag& EventTag, const class UGameplayEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEventListener">();
	}
	static class IGameplayEventListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameplayEventListener>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGameplayEventListener) == 0x000001, "Wrong alignment on IGameplayEventListener");
static_assert(sizeof(IGameplayEventListener) == 0x000001, "Wrong size on IGameplayEventListener");

// Class Stalker2.GameplayPhysicalMaterial
// 0x0008 (0x0088 - 0x0080)
class UGameplayPhysicalMaterial final : public UPhysicalMaterial
{
public:
	bool                                          bAllowCustomPhysicalMaterialType;                  // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EPhysicalMaterialType                         CustomPhysicalMaterialType;                        // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayPhysicalMaterial">();
	}
	static class UGameplayPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayPhysicalMaterial>();
	}
};
static_assert(alignof(UGameplayPhysicalMaterial) == 0x000008, "Wrong alignment on UGameplayPhysicalMaterial");
static_assert(sizeof(UGameplayPhysicalMaterial) == 0x000088, "Wrong size on UGameplayPhysicalMaterial");
static_assert(offsetof(UGameplayPhysicalMaterial, bAllowCustomPhysicalMaterialType) == 0x000080, "Member 'UGameplayPhysicalMaterial::bAllowCustomPhysicalMaterialType' has a wrong offset!");
static_assert(offsetof(UGameplayPhysicalMaterial, CustomPhysicalMaterialType) == 0x000084, "Member 'UGameplayPhysicalMaterial::CustomPhysicalMaterialType' has a wrong offset!");

// Class Stalker2.GAPDAActionProcessor
// 0x0070 (0x0098 - 0x0028)
class UGAPDAActionProcessor final : public UGAPlayerProcessorInterface
{
public:
	uint8                                         Pad_28[0x70];                                      // 0x0028(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAPDAActionProcessor">();
	}
	static class UGAPDAActionProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAPDAActionProcessor>();
	}
};
static_assert(alignof(UGAPDAActionProcessor) == 0x000008, "Wrong alignment on UGAPDAActionProcessor");
static_assert(sizeof(UGAPDAActionProcessor) == 0x000098, "Wrong size on UGAPDAActionProcessor");

// Class Stalker2.GAPlayerCombatProcessor
// 0x0070 (0x0098 - 0x0028)
class UGAPlayerCombatProcessor final : public UGAPlayerProcessorInterface
{
public:
	uint8                                         Pad_28[0x70];                                      // 0x0028(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAPlayerCombatProcessor">();
	}
	static class UGAPlayerCombatProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAPlayerCombatProcessor>();
	}
};
static_assert(alignof(UGAPlayerCombatProcessor) == 0x000008, "Wrong alignment on UGAPlayerCombatProcessor");
static_assert(sizeof(UGAPlayerCombatProcessor) == 0x000098, "Wrong size on UGAPlayerCombatProcessor");

// Class Stalker2.GAPlayerFactionReputationProcessor
// 0x0000 (0x0048 - 0x0048)
class UGAPlayerFactionReputationProcessor final : public UGAPlayerProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAPlayerFactionReputationProcessor">();
	}
	static class UGAPlayerFactionReputationProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAPlayerFactionReputationProcessor>();
	}
};
static_assert(alignof(UGAPlayerFactionReputationProcessor) == 0x000008, "Wrong alignment on UGAPlayerFactionReputationProcessor");
static_assert(sizeof(UGAPlayerFactionReputationProcessor) == 0x000048, "Wrong size on UGAPlayerFactionReputationProcessor");

// Class Stalker2.GAPlayerStatusProcessor
// 0x0020 (0x0068 - 0x0048)
class UGAPlayerStatusProcessor final : public UGAPlayerProcessorBase
{
public:
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GAPlayerStatusProcessor">();
	}
	static class UGAPlayerStatusProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGAPlayerStatusProcessor>();
	}
};
static_assert(alignof(UGAPlayerStatusProcessor) == 0x000008, "Wrong alignment on UGAPlayerStatusProcessor");
static_assert(sizeof(UGAPlayerStatusProcessor) == 0x000068, "Wrong size on UGAPlayerStatusProcessor");

// Class Stalker2.GarbageCollectionSubsystem
// 0x0000 (0x0030 - 0x0030)
class UGarbageCollectionSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GarbageCollectionSubsystem">();
	}
	static class UGarbageCollectionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGarbageCollectionSubsystem>();
	}
};
static_assert(alignof(UGarbageCollectionSubsystem) == 0x000008, "Wrong alignment on UGarbageCollectionSubsystem");
static_assert(sizeof(UGarbageCollectionSubsystem) == 0x000030, "Wrong size on UGarbageCollectionSubsystem");

// Class Stalker2.PDANotesSlot
// 0x0018 (0x0318 - 0x0300)
class UPDANotesSlot final : public UPDASlotBase
{
public:
	TMulticastInlineDelegate<void(int32 OutSlotIndex)> OnNoteSlotClick;                              // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDANotesSlot">();
	}
	static class UPDANotesSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDANotesSlot>();
	}
};
static_assert(alignof(UPDANotesSlot) == 0x000008, "Wrong alignment on UPDANotesSlot");
static_assert(sizeof(UPDANotesSlot) == 0x000318, "Wrong size on UPDANotesSlot");
static_assert(offsetof(UPDANotesSlot, OnNoteSlotClick) == 0x000300, "Member 'UPDANotesSlot::OnNoteSlotClick' has a wrong offset!");

// Class Stalker2.GATutorialEventProcessor
// 0x0018 (0x0040 - 0x0028)
class UGATutorialEventProcessor final : public UGAPlayerProcessorInterface
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATutorialEventProcessor">();
	}
	static class UGATutorialEventProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATutorialEventProcessor>();
	}
};
static_assert(alignof(UGATutorialEventProcessor) == 0x000008, "Wrong alignment on UGATutorialEventProcessor");
static_assert(sizeof(UGATutorialEventProcessor) == 0x000040, "Wrong size on UGATutorialEventProcessor");

// Class Stalker2.PlayerStash
// 0x0010 (0x02F8 - 0x02E8)
class APlayerStash final : public AInteractableObject
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimatedItemContainerInteractionComponent* InteractionComponent;                          // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStash">();
	}
	static class APlayerStash* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStash>();
	}
};
static_assert(alignof(APlayerStash) == 0x000008, "Wrong alignment on APlayerStash");
static_assert(sizeof(APlayerStash) == 0x0002F8, "Wrong size on APlayerStash");
static_assert(offsetof(APlayerStash, SkeletalMeshComponent) == 0x0002E8, "Member 'APlayerStash::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(APlayerStash, InteractionComponent) == 0x0002F0, "Member 'APlayerStash::InteractionComponent' has a wrong offset!");

// Class Stalker2.GaussDisplay
// 0x0050 (0x02E8 - 0x0298)
class AGaussDisplay final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DischargeAnimationTime;                            // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChargeAnimationTime;                               // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ReloadVFX;                                         // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ReloadVFXComponent;                                // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UPlayerOpticScopeComponent> OpticScopeComponent;                            // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x28];                                     // 0x02C0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GaussDisplay">();
	}
	static class AGaussDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGaussDisplay>();
	}
};
static_assert(alignof(AGaussDisplay) == 0x000008, "Wrong alignment on AGaussDisplay");
static_assert(sizeof(AGaussDisplay) == 0x0002E8, "Wrong size on AGaussDisplay");
static_assert(offsetof(AGaussDisplay, DischargeAnimationTime) == 0x0002A0, "Member 'AGaussDisplay::DischargeAnimationTime' has a wrong offset!");
static_assert(offsetof(AGaussDisplay, ChargeAnimationTime) == 0x0002A4, "Member 'AGaussDisplay::ChargeAnimationTime' has a wrong offset!");
static_assert(offsetof(AGaussDisplay, ReloadVFX) == 0x0002A8, "Member 'AGaussDisplay::ReloadVFX' has a wrong offset!");
static_assert(offsetof(AGaussDisplay, ReloadVFXComponent) == 0x0002B0, "Member 'AGaussDisplay::ReloadVFXComponent' has a wrong offset!");
static_assert(offsetof(AGaussDisplay, OpticScopeComponent) == 0x0002B8, "Member 'AGaussDisplay::OpticScopeComponent' has a wrong offset!");

// Class Stalker2.GeigerCounterComponent
// 0x0008 (0x00D8 - 0x00D0)
class UGeigerCounterComponent final : public UPlayerEffectsSFXComponent
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeigerCounterComponent">();
	}
	static class UGeigerCounterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeigerCounterComponent>();
	}
};
static_assert(alignof(UGeigerCounterComponent) == 0x000008, "Wrong alignment on UGeigerCounterComponent");
static_assert(sizeof(UGeigerCounterComponent) == 0x0000D8, "Wrong size on UGeigerCounterComponent");

// Class Stalker2.GlobalLoadingSubsystem
// 0x0030 (0x0060 - 0x0030)
class UGlobalLoadingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UGlobal*                                GameInstance;                                      // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           PSOWarmupTimerHandle;                              // 0x0058(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalLoadingSubsystem">();
	}
	static class UGlobalLoadingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalLoadingSubsystem>();
	}
};
static_assert(alignof(UGlobalLoadingSubsystem) == 0x000008, "Wrong alignment on UGlobalLoadingSubsystem");
static_assert(sizeof(UGlobalLoadingSubsystem) == 0x000060, "Wrong size on UGlobalLoadingSubsystem");
static_assert(offsetof(UGlobalLoadingSubsystem, GameInstance) == 0x000050, "Member 'UGlobalLoadingSubsystem::GameInstance' has a wrong offset!");
static_assert(offsetof(UGlobalLoadingSubsystem, PSOWarmupTimerHandle) == 0x000058, "Member 'UGlobalLoadingSubsystem::PSOWarmupTimerHandle' has a wrong offset!");

// Class Stalker2.GraphicsSettingsWidget
// 0x0118 (0x03A8 - 0x0290)
class UGraphicsSettingsWidget final : public USettingsPage
{
public:
	class USettingElementSwitcher*                OverallQuality;                                    // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                OverallQualityXSX;                                 // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                RenderingResolution;                               // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                Sharpness;                                         // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                UpscalingMethod;                                   // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementOnOff*                   DLSSRayReconstruction;                             // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                DLSSFrameGeneration;                               // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementOnOff*                   FFXFrameGeneration;                                // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                UpscalingQualityPreset;                            // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                ViewDistance;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                PostProcessing;                                    // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                TexturesQuality;                                   // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                ShadowsQuality;                                    // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                EffectsQuality;                                    // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                ReflectionsQuality;                                // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                FoliageQuality;                                    // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                GlobalIllumination;                                // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                ShadingQuality;                                    // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                HairQuality;                                       // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                ObjectDetailQuality;                               // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                VolumetricFogQuality;                              // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                VolumetricCloudsQuality;                           // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                SkyQuality;                                        // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                DOFQuality;                                        // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                MaterialQuality;                                   // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementSwitcher*                MotionBlurQuality;                                 // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsElementPercent*                MotionBlurStrength;                                // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingElementOnOff*                   LightShaftsQuality;                                // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        PCSpecificElements;                                // 0x0370(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        ConsoleSpecificElements;                           // 0x0380(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class USettingElement*>                UpscalingWidgets;                                  // 0x0390(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GraphicsSettingsWidget">();
	}
	static class UGraphicsSettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGraphicsSettingsWidget>();
	}
};
static_assert(alignof(UGraphicsSettingsWidget) == 0x000008, "Wrong alignment on UGraphicsSettingsWidget");
static_assert(sizeof(UGraphicsSettingsWidget) == 0x0003A8, "Wrong size on UGraphicsSettingsWidget");
static_assert(offsetof(UGraphicsSettingsWidget, OverallQuality) == 0x000290, "Member 'UGraphicsSettingsWidget::OverallQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, OverallQualityXSX) == 0x000298, "Member 'UGraphicsSettingsWidget::OverallQualityXSX' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, RenderingResolution) == 0x0002A0, "Member 'UGraphicsSettingsWidget::RenderingResolution' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, Sharpness) == 0x0002A8, "Member 'UGraphicsSettingsWidget::Sharpness' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, UpscalingMethod) == 0x0002B0, "Member 'UGraphicsSettingsWidget::UpscalingMethod' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, DLSSRayReconstruction) == 0x0002B8, "Member 'UGraphicsSettingsWidget::DLSSRayReconstruction' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, DLSSFrameGeneration) == 0x0002C0, "Member 'UGraphicsSettingsWidget::DLSSFrameGeneration' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, FFXFrameGeneration) == 0x0002C8, "Member 'UGraphicsSettingsWidget::FFXFrameGeneration' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, UpscalingQualityPreset) == 0x0002D0, "Member 'UGraphicsSettingsWidget::UpscalingQualityPreset' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, ViewDistance) == 0x0002D8, "Member 'UGraphicsSettingsWidget::ViewDistance' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, PostProcessing) == 0x0002E0, "Member 'UGraphicsSettingsWidget::PostProcessing' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, TexturesQuality) == 0x0002E8, "Member 'UGraphicsSettingsWidget::TexturesQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, ShadowsQuality) == 0x0002F0, "Member 'UGraphicsSettingsWidget::ShadowsQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, EffectsQuality) == 0x0002F8, "Member 'UGraphicsSettingsWidget::EffectsQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, ReflectionsQuality) == 0x000300, "Member 'UGraphicsSettingsWidget::ReflectionsQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, FoliageQuality) == 0x000308, "Member 'UGraphicsSettingsWidget::FoliageQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, GlobalIllumination) == 0x000310, "Member 'UGraphicsSettingsWidget::GlobalIllumination' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, ShadingQuality) == 0x000318, "Member 'UGraphicsSettingsWidget::ShadingQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, HairQuality) == 0x000320, "Member 'UGraphicsSettingsWidget::HairQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, ObjectDetailQuality) == 0x000328, "Member 'UGraphicsSettingsWidget::ObjectDetailQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, VolumetricFogQuality) == 0x000330, "Member 'UGraphicsSettingsWidget::VolumetricFogQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, VolumetricCloudsQuality) == 0x000338, "Member 'UGraphicsSettingsWidget::VolumetricCloudsQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, SkyQuality) == 0x000340, "Member 'UGraphicsSettingsWidget::SkyQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, DOFQuality) == 0x000348, "Member 'UGraphicsSettingsWidget::DOFQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, MaterialQuality) == 0x000350, "Member 'UGraphicsSettingsWidget::MaterialQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, MotionBlurQuality) == 0x000358, "Member 'UGraphicsSettingsWidget::MotionBlurQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, MotionBlurStrength) == 0x000360, "Member 'UGraphicsSettingsWidget::MotionBlurStrength' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, LightShaftsQuality) == 0x000368, "Member 'UGraphicsSettingsWidget::LightShaftsQuality' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, PCSpecificElements) == 0x000370, "Member 'UGraphicsSettingsWidget::PCSpecificElements' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, ConsoleSpecificElements) == 0x000380, "Member 'UGraphicsSettingsWidget::ConsoleSpecificElements' has a wrong offset!");
static_assert(offsetof(UGraphicsSettingsWidget, UpscalingWidgets) == 0x000390, "Member 'UGraphicsSettingsWidget::UpscalingWidgets' has a wrong offset!");

// Class Stalker2.GrenadeExplosionComponent
// 0x0000 (0x0110 - 0x0110)
class UGrenadeExplosionComponent final : public UExplosionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrenadeExplosionComponent">();
	}
	static class UGrenadeExplosionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrenadeExplosionComponent>();
	}
};
static_assert(alignof(UGrenadeExplosionComponent) == 0x000008, "Wrong alignment on UGrenadeExplosionComponent");
static_assert(sizeof(UGrenadeExplosionComponent) == 0x000110, "Wrong size on UGrenadeExplosionComponent");

// Class Stalker2.GSCAIController
// 0x0000 (0x03C0 - 0x03C0)
class AGSCAIController final : public AAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCAIController">();
	}
	static class AGSCAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGSCAIController>();
	}
};
static_assert(alignof(AGSCAIController) == 0x000008, "Wrong alignment on AGSCAIController");
static_assert(sizeof(AGSCAIController) == 0x0003C0, "Wrong size on AGSCAIController");

// Class Stalker2.AchievementTracker_EatFoodSet
// 0x00B8 (0x00F0 - 0x0038)
class UAchievementTracker_EatFoodSet final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0xB8];                                      // 0x0038(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_EatFoodSet">();
	}
	static class UAchievementTracker_EatFoodSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_EatFoodSet>();
	}
};
static_assert(alignof(UAchievementTracker_EatFoodSet) == 0x000008, "Wrong alignment on UAchievementTracker_EatFoodSet");
static_assert(sizeof(UAchievementTracker_EatFoodSet) == 0x0000F0, "Wrong size on UAchievementTracker_EatFoodSet");

// Class Stalker2.GSCAudioVolume
// 0x0790 (0x0A80 - 0x02F0)
class alignas(0x10) AGSCAudioVolume final : public AAkSpatialAudioVolume
{
public:
	class UAudioRoomBakedReflectionComponent*     BakedReflection;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioRoomBandwidthComponent*           Bandwidth;                                         // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FadeTransitionDuration;                            // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAkCurveInterpolation                         FadeCurveType;                                     // 0x0304(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableCrowdedAmbient;                             // 0x0305(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_306[0x2];                                      // 0x0306(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          CrowdedAmbientAudioEvent;                          // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAudioRoomPresetBase                          AudioRoomPresetBase;                               // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAudioRoomPresetBandwidth                     AudioRoomPresetBandwidth;                          // 0x0311(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             AudioVolumeCollisionChannel;                       // 0x0312(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_313[0x5];                                      // 0x0313(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextRenderComponent*                   InfoTextRenderComponent;                           // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendRadius;                                       // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendWeight;                                       // 0x0324(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Priority;                                          // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverride_LumenSkylightLeaking;                    // 0x032C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32D[0x3];                                      // 0x032D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkyLightLeakingAmount;                             // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_334[0x74C];                                    // 0x0334(0x074C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCAudioVolume">();
	}
	static class AGSCAudioVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGSCAudioVolume>();
	}
};
static_assert(alignof(AGSCAudioVolume) == 0x000010, "Wrong alignment on AGSCAudioVolume");
static_assert(sizeof(AGSCAudioVolume) == 0x000A80, "Wrong size on AGSCAudioVolume");
static_assert(offsetof(AGSCAudioVolume, BakedReflection) == 0x0002F0, "Member 'AGSCAudioVolume::BakedReflection' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, Bandwidth) == 0x0002F8, "Member 'AGSCAudioVolume::Bandwidth' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, FadeTransitionDuration) == 0x000300, "Member 'AGSCAudioVolume::FadeTransitionDuration' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, FadeCurveType) == 0x000304, "Member 'AGSCAudioVolume::FadeCurveType' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, bEnableCrowdedAmbient) == 0x000305, "Member 'AGSCAudioVolume::bEnableCrowdedAmbient' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, CrowdedAmbientAudioEvent) == 0x000308, "Member 'AGSCAudioVolume::CrowdedAmbientAudioEvent' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, AudioRoomPresetBase) == 0x000310, "Member 'AGSCAudioVolume::AudioRoomPresetBase' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, AudioRoomPresetBandwidth) == 0x000311, "Member 'AGSCAudioVolume::AudioRoomPresetBandwidth' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, AudioVolumeCollisionChannel) == 0x000312, "Member 'AGSCAudioVolume::AudioVolumeCollisionChannel' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, InfoTextRenderComponent) == 0x000318, "Member 'AGSCAudioVolume::InfoTextRenderComponent' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, BlendRadius) == 0x000320, "Member 'AGSCAudioVolume::BlendRadius' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, BlendWeight) == 0x000324, "Member 'AGSCAudioVolume::BlendWeight' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, Priority) == 0x000328, "Member 'AGSCAudioVolume::Priority' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, bOverride_LumenSkylightLeaking) == 0x00032C, "Member 'AGSCAudioVolume::bOverride_LumenSkylightLeaking' has a wrong offset!");
static_assert(offsetof(AGSCAudioVolume, SkyLightLeakingAmount) == 0x000330, "Member 'AGSCAudioVolume::SkyLightLeakingAmount' has a wrong offset!");

// Class Stalker2.PDANotePanel
// 0x0078 (0x0358 - 0x02E0)
class UPDANotePanel final : public UPDASlotPanelBase
{
public:
	class USizeBox*                               AbsentNoteSizeBox;                                 // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ENoteType, struct FSlotFilterSettings>   SlotFilterSettings;                                // 0x02E8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_338[0x20];                                     // 0x0338(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDANotePanel">();
	}
	static class UPDANotePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDANotePanel>();
	}
};
static_assert(alignof(UPDANotePanel) == 0x000008, "Wrong alignment on UPDANotePanel");
static_assert(sizeof(UPDANotePanel) == 0x000358, "Wrong size on UPDANotePanel");
static_assert(offsetof(UPDANotePanel, AbsentNoteSizeBox) == 0x0002E0, "Member 'UPDANotePanel::AbsentNoteSizeBox' has a wrong offset!");
static_assert(offsetof(UPDANotePanel, SlotFilterSettings) == 0x0002E8, "Member 'UPDANotePanel::SlotFilterSettings' has a wrong offset!");

// Class Stalker2.GSCAudioVolumeSettings
// 0x0038 (0x0070 - 0x0038)
class UGSCAudioVolumeSettings final : public UDeveloperSettings
{
public:
	float                                         AmbientTimerDelay;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNPCinVolume;                                    // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkRtpc>                 AmbientVolumeRTPC;                                 // 0x0040(0x0030)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCAudioVolumeSettings">();
	}
	static class UGSCAudioVolumeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSCAudioVolumeSettings>();
	}
};
static_assert(alignof(UGSCAudioVolumeSettings) == 0x000008, "Wrong alignment on UGSCAudioVolumeSettings");
static_assert(sizeof(UGSCAudioVolumeSettings) == 0x000070, "Wrong size on UGSCAudioVolumeSettings");
static_assert(offsetof(UGSCAudioVolumeSettings, AmbientTimerDelay) == 0x000038, "Member 'UGSCAudioVolumeSettings::AmbientTimerDelay' has a wrong offset!");
static_assert(offsetof(UGSCAudioVolumeSettings, MaxNPCinVolume) == 0x00003C, "Member 'UGSCAudioVolumeSettings::MaxNPCinVolume' has a wrong offset!");
static_assert(offsetof(UGSCAudioVolumeSettings, AmbientVolumeRTPC) == 0x000040, "Member 'UGSCAudioVolumeSettings::AmbientVolumeRTPC' has a wrong offset!");

// Class Stalker2.DrawGSCDebug
// 0x0070 (0x0620 - 0x05B0)
class UDrawGSCDebug final : public UDebugDrawComponent
{
public:
	uint8                                         Pad_5B0[0x70];                                     // 0x05B0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrawGSCDebug">();
	}
	static class UDrawGSCDebug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrawGSCDebug>();
	}
};
static_assert(alignof(UDrawGSCDebug) == 0x000010, "Wrong alignment on UDrawGSCDebug");
static_assert(sizeof(UDrawGSCDebug) == 0x000620, "Wrong size on UDrawGSCDebug");

// Class Stalker2.GSCDebugDrawer
// 0x0008 (0x02A0 - 0x0298)
class AGSCDebugDrawer final : public AActor
{
public:
	class UDrawGSCDebug*                          DrawComponent;                                     // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCDebugDrawer">();
	}
	static class AGSCDebugDrawer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGSCDebugDrawer>();
	}
};
static_assert(alignof(AGSCDebugDrawer) == 0x000008, "Wrong alignment on AGSCDebugDrawer");
static_assert(sizeof(AGSCDebugDrawer) == 0x0002A0, "Wrong size on AGSCDebugDrawer");
static_assert(offsetof(AGSCDebugDrawer, DrawComponent) == 0x000298, "Member 'AGSCDebugDrawer::DrawComponent' has a wrong offset!");

// Class Stalker2.GSCLocalPlayer
// 0x00A0 (0x0338 - 0x0298)
class UGSCLocalPlayer final : public ULocalPlayer
{
public:
	TMap<class FName, uint32>                     DLCNameToBitFlag;                                  // 0x0298(0x0050)(Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x50];                                     // 0x02E8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void XClipboardToFile();
	void XExportSaves();
	void XFileToClipboard();
	void XFinishLoginProcess(const bool bSuccess);
	void XImportSaves();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCLocalPlayer">();
	}
	static class UGSCLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSCLocalPlayer>();
	}
};
static_assert(alignof(UGSCLocalPlayer) == 0x000008, "Wrong alignment on UGSCLocalPlayer");
static_assert(sizeof(UGSCLocalPlayer) == 0x000338, "Wrong size on UGSCLocalPlayer");
static_assert(offsetof(UGSCLocalPlayer, DLCNameToBitFlag) == 0x000298, "Member 'UGSCLocalPlayer::DLCNameToBitFlag' has a wrong offset!");

// Class Stalker2.GSCModIOSubsystem
// 0x00A8 (0x00D8 - 0x0030)
class UGSCModIOSubsystem final : public UModSubsystemBase
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ModBrowserClass;                                   // 0x0058(0x0030)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ModBrowserLoadingClass;                            // 0x0088(0x0030)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModioSubsystem*                        ModioSubsystem;                                    // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModioUISubsystem*                      ModioUISubsystem;                                  // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ModBrowserWidget;                                  // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ModBrowserLoadingWidget;                           // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleModBrowserClosed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCModIOSubsystem">();
	}
	static class UGSCModIOSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSCModIOSubsystem>();
	}
};
static_assert(alignof(UGSCModIOSubsystem) == 0x000008, "Wrong alignment on UGSCModIOSubsystem");
static_assert(sizeof(UGSCModIOSubsystem) == 0x0000D8, "Wrong size on UGSCModIOSubsystem");
static_assert(offsetof(UGSCModIOSubsystem, ModBrowserClass) == 0x000058, "Member 'UGSCModIOSubsystem::ModBrowserClass' has a wrong offset!");
static_assert(offsetof(UGSCModIOSubsystem, ModBrowserLoadingClass) == 0x000088, "Member 'UGSCModIOSubsystem::ModBrowserLoadingClass' has a wrong offset!");
static_assert(offsetof(UGSCModIOSubsystem, ModioSubsystem) == 0x0000B8, "Member 'UGSCModIOSubsystem::ModioSubsystem' has a wrong offset!");
static_assert(offsetof(UGSCModIOSubsystem, ModioUISubsystem) == 0x0000C0, "Member 'UGSCModIOSubsystem::ModioUISubsystem' has a wrong offset!");
static_assert(offsetof(UGSCModIOSubsystem, ModBrowserWidget) == 0x0000C8, "Member 'UGSCModIOSubsystem::ModBrowserWidget' has a wrong offset!");
static_assert(offsetof(UGSCModIOSubsystem, ModBrowserLoadingWidget) == 0x0000D0, "Member 'UGSCModIOSubsystem::ModBrowserLoadingWidget' has a wrong offset!");

// Class Stalker2.GSCNavigationSettings
// 0x00C0 (0x00F8 - 0x0038)
class UGSCNavigationSettings final : public UDeveloperSettings
{
public:
	TArray<struct FSoftClassPath>                 NavAreasPriorities;                                // 0x0038(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TMap<struct FSoftClassPath, struct FDefaultRestrictions> DefaultRestrictions;                    // 0x0048(0x0050)(Edit, Config, Protected, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         NavAreaClasses;                                    // 0x0098(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class UClass*, struct FDefaultRestrictions> NavAreaDefaultRestrictions;                     // 0x00A8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCNavigationSettings">();
	}
	static class UGSCNavigationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSCNavigationSettings>();
	}
};
static_assert(alignof(UGSCNavigationSettings) == 0x000008, "Wrong alignment on UGSCNavigationSettings");
static_assert(sizeof(UGSCNavigationSettings) == 0x0000F8, "Wrong size on UGSCNavigationSettings");
static_assert(offsetof(UGSCNavigationSettings, NavAreasPriorities) == 0x000038, "Member 'UGSCNavigationSettings::NavAreasPriorities' has a wrong offset!");
static_assert(offsetof(UGSCNavigationSettings, DefaultRestrictions) == 0x000048, "Member 'UGSCNavigationSettings::DefaultRestrictions' has a wrong offset!");
static_assert(offsetof(UGSCNavigationSettings, NavAreaClasses) == 0x000098, "Member 'UGSCNavigationSettings::NavAreaClasses' has a wrong offset!");
static_assert(offsetof(UGSCNavigationSettings, NavAreaDefaultRestrictions) == 0x0000A8, "Member 'UGSCNavigationSettings::NavAreaDefaultRestrictions' has a wrong offset!");

// Class Stalker2.GSCTextBlock
// 0x0000 (0x0360 - 0x0360)
class UGSCTextBlock final : public UTextBlock
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSCTextBlock">();
	}
	static class UGSCTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSCTextBlock>();
	}
};
static_assert(alignof(UGSCTextBlock) == 0x000010, "Wrong alignment on UGSCTextBlock");
static_assert(sizeof(UGSCTextBlock) == 0x000360, "Wrong size on UGSCTextBlock");

// Class Stalker2.AchievementTracker_UseDifferentWeapons
// 0x0060 (0x0098 - 0x0038)
class UAchievementTracker_UseDifferentWeapons final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x60];                                      // 0x0038(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_UseDifferentWeapons">();
	}
	static class UAchievementTracker_UseDifferentWeapons* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_UseDifferentWeapons>();
	}
};
static_assert(alignof(UAchievementTracker_UseDifferentWeapons) == 0x000008, "Wrong alignment on UAchievementTracker_UseDifferentWeapons");
static_assert(sizeof(UAchievementTracker_UseDifferentWeapons) == 0x000098, "Wrong size on UAchievementTracker_UseDifferentWeapons");

// Class Stalker2.GuidInterface
// 0x0000 (0x0000 - 0x0000)
class IGuidInterface final
{
public:
	struct FGuid GetGUID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidInterface">();
	}
	static class IGuidInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGuidInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGuidInterface) == 0x000001, "Wrong alignment on IGuidInterface");
static_assert(sizeof(IGuidInterface) == 0x000001, "Wrong size on IGuidInterface");

// Class Stalker2.NavArea_Dialog
// 0x0000 (0x0048 - 0x0048)
class UNavArea_Dialog final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Dialog">();
	}
	static class UNavArea_Dialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Dialog>();
	}
};
static_assert(alignof(UNavArea_Dialog) == 0x000008, "Wrong alignment on UNavArea_Dialog");
static_assert(sizeof(UNavArea_Dialog) == 0x000048, "Wrong size on UNavArea_Dialog");

// Class Stalker2.GuitarAutoStrumIPU
// 0x0008 (0x0048 - 0x0040)
class UGuitarAutoStrumIPU final : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarAutoStrumIPU">();
	}
	static class UGuitarAutoStrumIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarAutoStrumIPU>();
	}
};
static_assert(alignof(UGuitarAutoStrumIPU) == 0x000008, "Wrong alignment on UGuitarAutoStrumIPU");
static_assert(sizeof(UGuitarAutoStrumIPU) == 0x000048, "Wrong size on UGuitarAutoStrumIPU");

// Class Stalker2.GuitarChord1IPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarChord1IPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarChord1IPU">();
	}
	static class UGuitarChord1IPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarChord1IPU>();
	}
};
static_assert(alignof(UGuitarChord1IPU) == 0x000008, "Wrong alignment on UGuitarChord1IPU");
static_assert(sizeof(UGuitarChord1IPU) == 0x000040, "Wrong size on UGuitarChord1IPU");

// Class Stalker2.GuitarChord2IPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarChord2IPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarChord2IPU">();
	}
	static class UGuitarChord2IPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarChord2IPU>();
	}
};
static_assert(alignof(UGuitarChord2IPU) == 0x000008, "Wrong alignment on UGuitarChord2IPU");
static_assert(sizeof(UGuitarChord2IPU) == 0x000040, "Wrong size on UGuitarChord2IPU");

// Class Stalker2.GuitarChord3IPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarChord3IPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarChord3IPU">();
	}
	static class UGuitarChord3IPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarChord3IPU>();
	}
};
static_assert(alignof(UGuitarChord3IPU) == 0x000008, "Wrong alignment on UGuitarChord3IPU");
static_assert(sizeof(UGuitarChord3IPU) == 0x000040, "Wrong size on UGuitarChord3IPU");

// Class Stalker2.PDATutorialSlot
// 0x0080 (0x0380 - 0x0300)
class UPDATutorialSlot final : public UPDASlotBase
{
public:
	class UTexture2D*                             NavigationIcon;                                    // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             CombatIcon;                                        // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SurvivalIcon;                                      // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             EarningsIcon;                                      // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NavigationSID;                                     // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CombatSID;                                         // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SurvivalSID;                                       // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EarningsSID;                                       // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 OutSlotIndex)> OnTutorialSlotClick;                          // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTextWidget*                            CategoryText;                                      // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDATutorialSlot">();
	}
	static class UPDATutorialSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDATutorialSlot>();
	}
};
static_assert(alignof(UPDATutorialSlot) == 0x000008, "Wrong alignment on UPDATutorialSlot");
static_assert(sizeof(UPDATutorialSlot) == 0x000380, "Wrong size on UPDATutorialSlot");
static_assert(offsetof(UPDATutorialSlot, NavigationIcon) == 0x000300, "Member 'UPDATutorialSlot::NavigationIcon' has a wrong offset!");
static_assert(offsetof(UPDATutorialSlot, CombatIcon) == 0x000308, "Member 'UPDATutorialSlot::CombatIcon' has a wrong offset!");
static_assert(offsetof(UPDATutorialSlot, SurvivalIcon) == 0x000310, "Member 'UPDATutorialSlot::SurvivalIcon' has a wrong offset!");
static_assert(offsetof(UPDATutorialSlot, EarningsIcon) == 0x000318, "Member 'UPDATutorialSlot::EarningsIcon' has a wrong offset!");
static_assert(offsetof(UPDATutorialSlot, NavigationSID) == 0x000320, "Member 'UPDATutorialSlot::NavigationSID' has a wrong offset!");
static_assert(offsetof(UPDATutorialSlot, CombatSID) == 0x000330, "Member 'UPDATutorialSlot::CombatSID' has a wrong offset!");
static_assert(offsetof(UPDATutorialSlot, SurvivalSID) == 0x000340, "Member 'UPDATutorialSlot::SurvivalSID' has a wrong offset!");
static_assert(offsetof(UPDATutorialSlot, EarningsSID) == 0x000350, "Member 'UPDATutorialSlot::EarningsSID' has a wrong offset!");
static_assert(offsetof(UPDATutorialSlot, OnTutorialSlotClick) == 0x000360, "Member 'UPDATutorialSlot::OnTutorialSlotClick' has a wrong offset!");
static_assert(offsetof(UPDATutorialSlot, CategoryText) == 0x000370, "Member 'UPDATutorialSlot::CategoryText' has a wrong offset!");

// Class Stalker2.GuitarChord4IPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarChord4IPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarChord4IPU">();
	}
	static class UGuitarChord4IPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarChord4IPU>();
	}
};
static_assert(alignof(UGuitarChord4IPU) == 0x000008, "Wrong alignment on UGuitarChord4IPU");
static_assert(sizeof(UGuitarChord4IPU) == 0x000040, "Wrong size on UGuitarChord4IPU");

// Class Stalker2.GuitarChord5IPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarChord5IPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarChord5IPU">();
	}
	static class UGuitarChord5IPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarChord5IPU>();
	}
};
static_assert(alignof(UGuitarChord5IPU) == 0x000008, "Wrong alignment on UGuitarChord5IPU");
static_assert(sizeof(UGuitarChord5IPU) == 0x000040, "Wrong size on UGuitarChord5IPU");

// Class Stalker2.GuitarChord6IPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarChord6IPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarChord6IPU">();
	}
	static class UGuitarChord6IPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarChord6IPU>();
	}
};
static_assert(alignof(UGuitarChord6IPU) == 0x000008, "Wrong alignment on UGuitarChord6IPU");
static_assert(sizeof(UGuitarChord6IPU) == 0x000040, "Wrong size on UGuitarChord6IPU");

// Class Stalker2.GuitarChord7IPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarChord7IPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarChord7IPU">();
	}
	static class UGuitarChord7IPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarChord7IPU>();
	}
};
static_assert(alignof(UGuitarChord7IPU) == 0x000008, "Wrong alignment on UGuitarChord7IPU");
static_assert(sizeof(UGuitarChord7IPU) == 0x000040, "Wrong size on UGuitarChord7IPU");

// Class Stalker2.GuitarChordAxisSelectionIPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarChordAxisSelectionIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarChordAxisSelectionIPU">();
	}
	static class UGuitarChordAxisSelectionIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarChordAxisSelectionIPU>();
	}
};
static_assert(alignof(UGuitarChordAxisSelectionIPU) == 0x000008, "Wrong alignment on UGuitarChordAxisSelectionIPU");
static_assert(sizeof(UGuitarChordAxisSelectionIPU) == 0x000040, "Wrong size on UGuitarChordAxisSelectionIPU");

// Class Stalker2.SaveableComponent
// 0x0000 (0x0000 - 0x0000)
class ISaveableComponent final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveableComponent">();
	}
	static class ISaveableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISaveableComponent>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISaveableComponent) == 0x000001, "Wrong alignment on ISaveableComponent");
static_assert(sizeof(ISaveableComponent) == 0x000001, "Wrong size on ISaveableComponent");

// Class Stalker2.GuitarChordSelectorView
// 0x0048 (0x0310 - 0x02C8)
class UGuitarChordSelectorView final : public UViewBaseExtended
{
public:
	class UHintInputController*                   HintGuitarSwapScale;                               // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGuitarChordView*                       GuitarChord1View;                                  // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGuitarChordView*                       GuitarChord2View;                                  // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGuitarChordView*                       GuitarChord3View;                                  // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGuitarChordView*                       GuitarChord4View;                                  // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGuitarChordView*                       GuitarChord5View;                                  // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGuitarChordView*                       GuitarChord6View;                                  // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGuitarChordView*                       HoveredChord;                                      // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarChordSelectorView">();
	}
	static class UGuitarChordSelectorView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarChordSelectorView>();
	}
};
static_assert(alignof(UGuitarChordSelectorView) == 0x000008, "Wrong alignment on UGuitarChordSelectorView");
static_assert(sizeof(UGuitarChordSelectorView) == 0x000310, "Wrong size on UGuitarChordSelectorView");
static_assert(offsetof(UGuitarChordSelectorView, HintGuitarSwapScale) == 0x0002C8, "Member 'UGuitarChordSelectorView::HintGuitarSwapScale' has a wrong offset!");
static_assert(offsetof(UGuitarChordSelectorView, GuitarChord1View) == 0x0002D0, "Member 'UGuitarChordSelectorView::GuitarChord1View' has a wrong offset!");
static_assert(offsetof(UGuitarChordSelectorView, GuitarChord2View) == 0x0002D8, "Member 'UGuitarChordSelectorView::GuitarChord2View' has a wrong offset!");
static_assert(offsetof(UGuitarChordSelectorView, GuitarChord3View) == 0x0002E0, "Member 'UGuitarChordSelectorView::GuitarChord3View' has a wrong offset!");
static_assert(offsetof(UGuitarChordSelectorView, GuitarChord4View) == 0x0002E8, "Member 'UGuitarChordSelectorView::GuitarChord4View' has a wrong offset!");
static_assert(offsetof(UGuitarChordSelectorView, GuitarChord5View) == 0x0002F0, "Member 'UGuitarChordSelectorView::GuitarChord5View' has a wrong offset!");
static_assert(offsetof(UGuitarChordSelectorView, GuitarChord6View) == 0x0002F8, "Member 'UGuitarChordSelectorView::GuitarChord6View' has a wrong offset!");
static_assert(offsetof(UGuitarChordSelectorView, HoveredChord) == 0x000300, "Member 'UGuitarChordSelectorView::HoveredChord' has a wrong offset!");

// Class Stalker2.GuitarChordView
// 0x0000 (0x0278 - 0x0278)
class UGuitarChordView final : public UWidgetBase
{
public:
	void OnMajorScale();
	void OnMinorScale();
	void OnSelected();
	void OnUnselected();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarChordView">();
	}
	static class UGuitarChordView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarChordView>();
	}
};
static_assert(alignof(UGuitarChordView) == 0x000008, "Wrong alignment on UGuitarChordView");
static_assert(sizeof(UGuitarChordView) == 0x000278, "Wrong size on UGuitarChordView");

// Class Stalker2.GuitarContextualAction
// 0x0000 (0x0040 - 0x0040)
class UGuitarContextualAction final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarContextualAction">();
	}
	static class UGuitarContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarContextualAction>();
	}
};
static_assert(alignof(UGuitarContextualAction) == 0x000008, "Wrong alignment on UGuitarContextualAction");
static_assert(sizeof(UGuitarContextualAction) == 0x000040, "Wrong size on UGuitarContextualAction");

// Class Stalker2.SingleClickIPU
// 0x0008 (0x0048 - 0x0040)
class USingleClickIPU final : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleClickIPU">();
	}
	static class USingleClickIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleClickIPU>();
	}
};
static_assert(alignof(USingleClickIPU) == 0x000008, "Wrong alignment on USingleClickIPU");
static_assert(sizeof(USingleClickIPU) == 0x000048, "Wrong size on USingleClickIPU");

// Class Stalker2.GuitarExitIPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarExitIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarExitIPU">();
	}
	static class UGuitarExitIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarExitIPU>();
	}
};
static_assert(alignof(UGuitarExitIPU) == 0x000008, "Wrong alignment on UGuitarExitIPU");
static_assert(sizeof(UGuitarExitIPU) == 0x000040, "Wrong size on UGuitarExitIPU");

// Class Stalker2.GuitarResetCameraIPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarResetCameraIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarResetCameraIPU">();
	}
	static class UGuitarResetCameraIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarResetCameraIPU>();
	}
};
static_assert(alignof(UGuitarResetCameraIPU) == 0x000008, "Wrong alignment on UGuitarResetCameraIPU");
static_assert(sizeof(UGuitarResetCameraIPU) == 0x000040, "Wrong size on UGuitarResetCameraIPU");

// Class Stalker2.GuitarStrumDownIPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarStrumDownIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarStrumDownIPU">();
	}
	static class UGuitarStrumDownIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarStrumDownIPU>();
	}
};
static_assert(alignof(UGuitarStrumDownIPU) == 0x000008, "Wrong alignment on UGuitarStrumDownIPU");
static_assert(sizeof(UGuitarStrumDownIPU) == 0x000040, "Wrong size on UGuitarStrumDownIPU");

// Class Stalker2.GuitarStrumIPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarStrumIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarStrumIPU">();
	}
	static class UGuitarStrumIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarStrumIPU>();
	}
};
static_assert(alignof(UGuitarStrumIPU) == 0x000008, "Wrong alignment on UGuitarStrumIPU");
static_assert(sizeof(UGuitarStrumIPU) == 0x000040, "Wrong size on UGuitarStrumIPU");

// Class Stalker2.GuitarStrumUpIPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarStrumUpIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarStrumUpIPU">();
	}
	static class UGuitarStrumUpIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarStrumUpIPU>();
	}
};
static_assert(alignof(UGuitarStrumUpIPU) == 0x000008, "Wrong alignment on UGuitarStrumUpIPU");
static_assert(sizeof(UGuitarStrumUpIPU) == 0x000040, "Wrong size on UGuitarStrumUpIPU");

// Class Stalker2.SettingsCategory
// 0x0018 (0x0290 - 0x0278)
class USettingsCategory final : public UWidgetBase
{
public:
	class FString                                 CategoryNameSID;                                   // 0x0278(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            CategoryNameText;                                  // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsCategory">();
	}
	static class USettingsCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsCategory>();
	}
};
static_assert(alignof(USettingsCategory) == 0x000008, "Wrong alignment on USettingsCategory");
static_assert(sizeof(USettingsCategory) == 0x000290, "Wrong size on USettingsCategory");
static_assert(offsetof(USettingsCategory, CategoryNameSID) == 0x000278, "Member 'USettingsCategory::CategoryNameSID' has a wrong offset!");
static_assert(offsetof(USettingsCategory, CategoryNameText) == 0x000288, "Member 'USettingsCategory::CategoryNameText' has a wrong offset!");

// Class Stalker2.GuitarSwapMajorMinorScaleIPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarSwapMajorMinorScaleIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarSwapMajorMinorScaleIPU">();
	}
	static class UGuitarSwapMajorMinorScaleIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarSwapMajorMinorScaleIPU>();
	}
};
static_assert(alignof(UGuitarSwapMajorMinorScaleIPU) == 0x000008, "Wrong alignment on UGuitarSwapMajorMinorScaleIPU");
static_assert(sizeof(UGuitarSwapMajorMinorScaleIPU) == 0x000040, "Wrong size on UGuitarSwapMajorMinorScaleIPU");

// Class Stalker2.GuitarUseIPU
// 0x0000 (0x0040 - 0x0040)
class UGuitarUseIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuitarUseIPU">();
	}
	static class UGuitarUseIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuitarUseIPU>();
	}
};
static_assert(alignof(UGuitarUseIPU) == 0x000008, "Wrong alignment on UGuitarUseIPU");
static_assert(sizeof(UGuitarUseIPU) == 0x000040, "Wrong size on UGuitarUseIPU");

// Class Stalker2.PlayerContextualActionExitIPU
// 0x0000 (0x0040 - 0x0040)
class UPlayerContextualActionExitIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerContextualActionExitIPU">();
	}
	static class UPlayerContextualActionExitIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerContextualActionExitIPU>();
	}
};
static_assert(alignof(UPlayerContextualActionExitIPU) == 0x000008, "Wrong alignment on UPlayerContextualActionExitIPU");
static_assert(sizeof(UPlayerContextualActionExitIPU) == 0x000040, "Wrong size on UPlayerContextualActionExitIPU");

// Class Stalker2.HeadFlashlightComponent
// 0x0048 (0x01D0 - 0x0188)
class UHeadFlashlightComponent final : public UFlashlightComponent
{
public:
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          FlashlightTurnOnAudioEvent;                        // 0x0190(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          FlashlightTurnOffAudioEvent;                       // 0x0198(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          FlashlightBurnOutAudioEvent;                       // 0x01A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x28];                                     // 0x01A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadFlashlightComponent">();
	}
	static class UHeadFlashlightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadFlashlightComponent>();
	}
};
static_assert(alignof(UHeadFlashlightComponent) == 0x000008, "Wrong alignment on UHeadFlashlightComponent");
static_assert(sizeof(UHeadFlashlightComponent) == 0x0001D0, "Wrong size on UHeadFlashlightComponent");
static_assert(offsetof(UHeadFlashlightComponent, FlashlightTurnOnAudioEvent) == 0x000190, "Member 'UHeadFlashlightComponent::FlashlightTurnOnAudioEvent' has a wrong offset!");
static_assert(offsetof(UHeadFlashlightComponent, FlashlightTurnOffAudioEvent) == 0x000198, "Member 'UHeadFlashlightComponent::FlashlightTurnOffAudioEvent' has a wrong offset!");
static_assert(offsetof(UHeadFlashlightComponent, FlashlightBurnOutAudioEvent) == 0x0001A0, "Member 'UHeadFlashlightComponent::FlashlightBurnOutAudioEvent' has a wrong offset!");

// Class Stalker2.HintAction
// 0x0020 (0x0360 - 0x0340)
class UHintAction final : public UCommonHint
{
public:
	class UButton*                                HintButton;                                        // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x18];                                     // 0x0348(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintAction">();
	}
	static class UHintAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintAction>();
	}
};
static_assert(alignof(UHintAction) == 0x000008, "Wrong alignment on UHintAction");
static_assert(sizeof(UHintAction) == 0x000360, "Wrong size on UHintAction");
static_assert(offsetof(UHintAction, HintButton) == 0x000340, "Member 'UHintAction::HintButton' has a wrong offset!");

// Class Stalker2.HintActionRichText
// 0x0038 (0x0378 - 0x0340)
class UHintActionRichText final : public UCommonHint
{
public:
	class UHorizontalBox*                         HorizontalBox;                                     // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x10];                                     // 0x0348(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableHintLock;                                   // 0x0358(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_359[0x1F];                                     // 0x0359(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintActionRichText">();
	}
	static class UHintActionRichText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintActionRichText>();
	}
};
static_assert(alignof(UHintActionRichText) == 0x000008, "Wrong alignment on UHintActionRichText");
static_assert(sizeof(UHintActionRichText) == 0x000378, "Wrong size on UHintActionRichText");
static_assert(offsetof(UHintActionRichText, HorizontalBox) == 0x000340, "Member 'UHintActionRichText::HorizontalBox' has a wrong offset!");
static_assert(offsetof(UHintActionRichText, bEnableHintLock) == 0x000358, "Member 'UHintActionRichText::bEnableHintLock' has a wrong offset!");

// Class Stalker2.AsyncActionBase
// 0x0000 (0x0028 - 0x0028)
class UAsyncActionBase : public UObject
{
public:
	void ExecuteAction(class UHintControllerBase* InHintController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncActionBase">();
	}
	static class UAsyncActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncActionBase>();
	}
};
static_assert(alignof(UAsyncActionBase) == 0x000008, "Wrong alignment on UAsyncActionBase");
static_assert(sizeof(UAsyncActionBase) == 0x000028, "Wrong size on UAsyncActionBase");

// Class Stalker2.AsyncVisibilityAction
// 0x0008 (0x0030 - 0x0028)
class UAsyncVisibilityAction final : public UAsyncActionBase
{
public:
	ESlateVisibility                              Visibility;                                        // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncVisibilityAction">();
	}
	static class UAsyncVisibilityAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncVisibilityAction>();
	}
};
static_assert(alignof(UAsyncVisibilityAction) == 0x000008, "Wrong alignment on UAsyncVisibilityAction");
static_assert(sizeof(UAsyncVisibilityAction) == 0x000030, "Wrong size on UAsyncVisibilityAction");
static_assert(offsetof(UAsyncVisibilityAction, Visibility) == 0x000028, "Member 'UAsyncVisibilityAction::Visibility' has a wrong offset!");

// Class Stalker2.HintControllerBase
// 0x00C8 (0x0340 - 0x0278)
class UHintControllerBase : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInitializeAutomatically;                          // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHintControllerSettings                ControllerSettings;                                // 0x0298(0x0050)(Edit, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHintStyleSettings                     StyleSettings;                                     // 0x02E8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class UPlatformSwitcherBase*                  PlatformSwitcher;                                  // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            LeftText;                                          // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                LeftGap;                                           // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            RightText;                                         // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                RightGap;                                          // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintControllerBase">();
	}
	static class UHintControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintControllerBase>();
	}
};
static_assert(alignof(UHintControllerBase) == 0x000008, "Wrong alignment on UHintControllerBase");
static_assert(sizeof(UHintControllerBase) == 0x000340, "Wrong size on UHintControllerBase");
static_assert(offsetof(UHintControllerBase, bInitializeAutomatically) == 0x000290, "Member 'UHintControllerBase::bInitializeAutomatically' has a wrong offset!");
static_assert(offsetof(UHintControllerBase, ControllerSettings) == 0x000298, "Member 'UHintControllerBase::ControllerSettings' has a wrong offset!");
static_assert(offsetof(UHintControllerBase, StyleSettings) == 0x0002E8, "Member 'UHintControllerBase::StyleSettings' has a wrong offset!");
static_assert(offsetof(UHintControllerBase, PlatformSwitcher) == 0x000318, "Member 'UHintControllerBase::PlatformSwitcher' has a wrong offset!");
static_assert(offsetof(UHintControllerBase, LeftText) == 0x000320, "Member 'UHintControllerBase::LeftText' has a wrong offset!");
static_assert(offsetof(UHintControllerBase, LeftGap) == 0x000328, "Member 'UHintControllerBase::LeftGap' has a wrong offset!");
static_assert(offsetof(UHintControllerBase, RightText) == 0x000330, "Member 'UHintControllerBase::RightText' has a wrong offset!");
static_assert(offsetof(UHintControllerBase, RightGap) == 0x000338, "Member 'UHintControllerBase::RightGap' has a wrong offset!");

// Class Stalker2.StackSplitContexualTrade
// 0x0090 (0x0510 - 0x0480)
class UStackSplitContexualTrade final : public UStackSplitContextual
{
public:
	class FString                                 SellLocSID;                                        // 0x0480(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SellAllLocSID;                                     // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuyLocSID;                                         // 0x04A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuyAllLocSID;                                      // 0x04B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnLocSID;                                      // 0x04C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnAllLocSID;                                   // 0x04D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SellTitleLocSID;                                   // 0x04E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuyTitleLocSID;                                    // 0x04F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnTitleLocSID;                                 // 0x0500(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StackSplitContexualTrade">();
	}
	static class UStackSplitContexualTrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStackSplitContexualTrade>();
	}
};
static_assert(alignof(UStackSplitContexualTrade) == 0x000008, "Wrong alignment on UStackSplitContexualTrade");
static_assert(sizeof(UStackSplitContexualTrade) == 0x000510, "Wrong size on UStackSplitContexualTrade");
static_assert(offsetof(UStackSplitContexualTrade, SellLocSID) == 0x000480, "Member 'UStackSplitContexualTrade::SellLocSID' has a wrong offset!");
static_assert(offsetof(UStackSplitContexualTrade, SellAllLocSID) == 0x000490, "Member 'UStackSplitContexualTrade::SellAllLocSID' has a wrong offset!");
static_assert(offsetof(UStackSplitContexualTrade, BuyLocSID) == 0x0004A0, "Member 'UStackSplitContexualTrade::BuyLocSID' has a wrong offset!");
static_assert(offsetof(UStackSplitContexualTrade, BuyAllLocSID) == 0x0004B0, "Member 'UStackSplitContexualTrade::BuyAllLocSID' has a wrong offset!");
static_assert(offsetof(UStackSplitContexualTrade, ReturnLocSID) == 0x0004C0, "Member 'UStackSplitContexualTrade::ReturnLocSID' has a wrong offset!");
static_assert(offsetof(UStackSplitContexualTrade, ReturnAllLocSID) == 0x0004D0, "Member 'UStackSplitContexualTrade::ReturnAllLocSID' has a wrong offset!");
static_assert(offsetof(UStackSplitContexualTrade, SellTitleLocSID) == 0x0004E0, "Member 'UStackSplitContexualTrade::SellTitleLocSID' has a wrong offset!");
static_assert(offsetof(UStackSplitContexualTrade, BuyTitleLocSID) == 0x0004F0, "Member 'UStackSplitContexualTrade::BuyTitleLocSID' has a wrong offset!");
static_assert(offsetof(UStackSplitContexualTrade, ReturnTitleLocSID) == 0x000500, "Member 'UStackSplitContexualTrade::ReturnTitleLocSID' has a wrong offset!");

// Class Stalker2.HintDecoratorBase
// 0x01C0 (0x01F0 - 0x0030)
class UHintDecoratorBase final : public URichTextBlockImageDecorator
{
public:
	EGSCInputDeviceType                           DefaultPlatform;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableEditorDebug;                                // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRecolorIcon;                                // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x1];                                       // 0x0033(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StyleId;                                           // 0x0034(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRecolorConnectedBack;                       // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUseStylePrefix;                             // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x1B2];                                     // 0x003E(0x01B2)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintDecoratorBase">();
	}
	static class UHintDecoratorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintDecoratorBase>();
	}
};
static_assert(alignof(UHintDecoratorBase) == 0x000008, "Wrong alignment on UHintDecoratorBase");
static_assert(sizeof(UHintDecoratorBase) == 0x0001F0, "Wrong size on UHintDecoratorBase");
static_assert(offsetof(UHintDecoratorBase, DefaultPlatform) == 0x000030, "Member 'UHintDecoratorBase::DefaultPlatform' has a wrong offset!");
static_assert(offsetof(UHintDecoratorBase, bEnableEditorDebug) == 0x000031, "Member 'UHintDecoratorBase::bEnableEditorDebug' has a wrong offset!");
static_assert(offsetof(UHintDecoratorBase, bEnableRecolorIcon) == 0x000032, "Member 'UHintDecoratorBase::bEnableRecolorIcon' has a wrong offset!");
static_assert(offsetof(UHintDecoratorBase, StyleId) == 0x000034, "Member 'UHintDecoratorBase::StyleId' has a wrong offset!");
static_assert(offsetof(UHintDecoratorBase, bEnableRecolorConnectedBack) == 0x00003C, "Member 'UHintDecoratorBase::bEnableRecolorConnectedBack' has a wrong offset!");
static_assert(offsetof(UHintDecoratorBase, bShouldUseStylePrefix) == 0x00003D, "Member 'UHintDecoratorBase::bShouldUseStylePrefix' has a wrong offset!");

// Class Stalker2.HintHelper
// 0x0000 (0x0028 - 0x0028)
class UHintHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintHelper">();
	}
	static class UHintHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintHelper>();
	}
};
static_assert(alignof(UHintHelper) == 0x000008, "Wrong alignment on UHintHelper");
static_assert(sizeof(UHintHelper) == 0x000028, "Wrong size on UHintHelper");

// Class Stalker2.HintImageBase
// 0x0020 (0x0298 - 0x0278)
class UHintImageBase : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EInputIconsType                               InputIconsType;                                    // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintImageBase">();
	}
	static class UHintImageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintImageBase>();
	}
};
static_assert(alignof(UHintImageBase) == 0x000008, "Wrong alignment on UHintImageBase");
static_assert(sizeof(UHintImageBase) == 0x000298, "Wrong size on UHintImageBase");
static_assert(offsetof(UHintImageBase, InputIconsType) == 0x000290, "Member 'UHintImageBase::InputIconsType' has a wrong offset!");

// Class Stalker2.HintImageGamepad
// 0x0008 (0x02A0 - 0x0298)
class UHintImageGamepad : public UHintImageBase
{
public:
	class UImage*                                 HintImage;                                         // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintImageGamepad">();
	}
	static class UHintImageGamepad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintImageGamepad>();
	}
};
static_assert(alignof(UHintImageGamepad) == 0x000008, "Wrong alignment on UHintImageGamepad");
static_assert(sizeof(UHintImageGamepad) == 0x0002A0, "Wrong size on UHintImageGamepad");
static_assert(offsetof(UHintImageGamepad, HintImage) == 0x000298, "Member 'UHintImageGamepad::HintImage' has a wrong offset!");

// Class Stalker2.HintImageKeyboard
// 0x0030 (0x02C8 - 0x0298)
class UHintImageKeyboard : public UHintImageBase
{
public:
	class UImage*                                 HintImage;                                         // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HintBackground;                                    // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         HintChar;                                          // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 KeyboardCharStyle;                                 // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BackgroundName;                                    // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintImageKeyboard">();
	}
	static class UHintImageKeyboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintImageKeyboard>();
	}
};
static_assert(alignof(UHintImageKeyboard) == 0x000008, "Wrong alignment on UHintImageKeyboard");
static_assert(sizeof(UHintImageKeyboard) == 0x0002C8, "Wrong size on UHintImageKeyboard");
static_assert(offsetof(UHintImageKeyboard, HintImage) == 0x000298, "Member 'UHintImageKeyboard::HintImage' has a wrong offset!");
static_assert(offsetof(UHintImageKeyboard, HintBackground) == 0x0002A0, "Member 'UHintImageKeyboard::HintBackground' has a wrong offset!");
static_assert(offsetof(UHintImageKeyboard, HintChar) == 0x0002A8, "Member 'UHintImageKeyboard::HintChar' has a wrong offset!");
static_assert(offsetof(UHintImageKeyboard, KeyboardCharStyle) == 0x0002B0, "Member 'UHintImageKeyboard::KeyboardCharStyle' has a wrong offset!");
static_assert(offsetof(UHintImageKeyboard, BackgroundName) == 0x0002C0, "Member 'UHintImageKeyboard::BackgroundName' has a wrong offset!");

// Class Stalker2.SignalSenderComponent
// 0x0010 (0x00C8 - 0x00B8)
class USignalSenderComponent final : public UGuidActorComponent
{
public:
	TArray<struct FSignalToSend>                  Signals;                                           // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)

public:
	void Send(class UObject* DataObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SignalSenderComponent">();
	}
	static class USignalSenderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USignalSenderComponent>();
	}
};
static_assert(alignof(USignalSenderComponent) == 0x000008, "Wrong alignment on USignalSenderComponent");
static_assert(sizeof(USignalSenderComponent) == 0x0000C8, "Wrong size on USignalSenderComponent");
static_assert(offsetof(USignalSenderComponent, Signals) == 0x0000B8, "Member 'USignalSenderComponent::Signals' has a wrong offset!");

// Class Stalker2.HintInputController
// 0x0020 (0x0360 - 0x0340)
class UHintInputController : public UHintControllerBase
{
public:
	class UActionMimicButton*                     MimicButtonElement;                                // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHandleMouseInput;                                 // 0x0348(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x17];                                     // 0x0349(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintInputController">();
	}
	static class UHintInputController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintInputController>();
	}
};
static_assert(alignof(UHintInputController) == 0x000008, "Wrong alignment on UHintInputController");
static_assert(sizeof(UHintInputController) == 0x000360, "Wrong size on UHintInputController");
static_assert(offsetof(UHintInputController, MimicButtonElement) == 0x000340, "Member 'UHintInputController::MimicButtonElement' has a wrong offset!");
static_assert(offsetof(UHintInputController, bHandleMouseInput) == 0x000348, "Member 'UHintInputController::bHandleMouseInput' has a wrong offset!");

// Class Stalker2.HintKey
// 0x0120 (0x0430 - 0x0310)
class UHintKey final : public UHintBase
{
public:
	class UHintRichTextWidget*                    HintRichTextWidget;                                // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       MultiClickAnim;                                    // 0x0318(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       RunActionAnim;                                     // 0x0320(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       MultiClickIdle;                                    // 0x0328(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        ActionSwitcher;                                    // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           HoldProgress;                                      // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ProgressImage;                                     // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ProgressImageBack;                                 // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                HintButton;                                        // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UTexture2D*>          BackgroundStyleToBackgroundTexture;                // 0x0358(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UImage*                                 HoldProgressImage;                                 // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 HoldProgressImageBack;                             // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 MultiClickProgressImage;                           // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 MultiClickProgressImageBack;                       // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 HoldProgressTutorials;                             // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       SingleClickAnim;                                   // 0x03D0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 HintDynamicBackground;                             // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      HintBackgroundOffsets;                             // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseKeyFromTopMappingContext;                      // 0x03F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F1[0x3];                                      // 0x03F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HintDesignIteration;                               // 0x03F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 IconKey;                                           // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 IconLock;                                          // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 IconLowHealth;                                     // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 EnabledIconsColor;                                 // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DisabledIconsColor;                                // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_418[0x18];                                     // 0x0418(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayHintAnimation(bool bSingleClick);
	void SetHintKeyLockState(const bool ShowIcon, const bool IsKeyAvailable);
	void SetHintState(const bool IsActive);
	void SetLowHealthState(const bool ShowIcon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintKey">();
	}
	static class UHintKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintKey>();
	}
};
static_assert(alignof(UHintKey) == 0x000008, "Wrong alignment on UHintKey");
static_assert(sizeof(UHintKey) == 0x000430, "Wrong size on UHintKey");
static_assert(offsetof(UHintKey, HintRichTextWidget) == 0x000310, "Member 'UHintKey::HintRichTextWidget' has a wrong offset!");
static_assert(offsetof(UHintKey, MultiClickAnim) == 0x000318, "Member 'UHintKey::MultiClickAnim' has a wrong offset!");
static_assert(offsetof(UHintKey, RunActionAnim) == 0x000320, "Member 'UHintKey::RunActionAnim' has a wrong offset!");
static_assert(offsetof(UHintKey, MultiClickIdle) == 0x000328, "Member 'UHintKey::MultiClickIdle' has a wrong offset!");
static_assert(offsetof(UHintKey, ActionSwitcher) == 0x000330, "Member 'UHintKey::ActionSwitcher' has a wrong offset!");
static_assert(offsetof(UHintKey, HoldProgress) == 0x000338, "Member 'UHintKey::HoldProgress' has a wrong offset!");
static_assert(offsetof(UHintKey, ProgressImage) == 0x000340, "Member 'UHintKey::ProgressImage' has a wrong offset!");
static_assert(offsetof(UHintKey, ProgressImageBack) == 0x000348, "Member 'UHintKey::ProgressImageBack' has a wrong offset!");
static_assert(offsetof(UHintKey, HintButton) == 0x000350, "Member 'UHintKey::HintButton' has a wrong offset!");
static_assert(offsetof(UHintKey, BackgroundStyleToBackgroundTexture) == 0x000358, "Member 'UHintKey::BackgroundStyleToBackgroundTexture' has a wrong offset!");
static_assert(offsetof(UHintKey, HoldProgressImage) == 0x0003A8, "Member 'UHintKey::HoldProgressImage' has a wrong offset!");
static_assert(offsetof(UHintKey, HoldProgressImageBack) == 0x0003B0, "Member 'UHintKey::HoldProgressImageBack' has a wrong offset!");
static_assert(offsetof(UHintKey, MultiClickProgressImage) == 0x0003B8, "Member 'UHintKey::MultiClickProgressImage' has a wrong offset!");
static_assert(offsetof(UHintKey, MultiClickProgressImageBack) == 0x0003C0, "Member 'UHintKey::MultiClickProgressImageBack' has a wrong offset!");
static_assert(offsetof(UHintKey, HoldProgressTutorials) == 0x0003C8, "Member 'UHintKey::HoldProgressTutorials' has a wrong offset!");
static_assert(offsetof(UHintKey, SingleClickAnim) == 0x0003D0, "Member 'UHintKey::SingleClickAnim' has a wrong offset!");
static_assert(offsetof(UHintKey, HintDynamicBackground) == 0x0003D8, "Member 'UHintKey::HintDynamicBackground' has a wrong offset!");
static_assert(offsetof(UHintKey, HintBackgroundOffsets) == 0x0003E0, "Member 'UHintKey::HintBackgroundOffsets' has a wrong offset!");
static_assert(offsetof(UHintKey, bUseKeyFromTopMappingContext) == 0x0003F0, "Member 'UHintKey::bUseKeyFromTopMappingContext' has a wrong offset!");
static_assert(offsetof(UHintKey, HintDesignIteration) == 0x0003F4, "Member 'UHintKey::HintDesignIteration' has a wrong offset!");
static_assert(offsetof(UHintKey, IconKey) == 0x0003F8, "Member 'UHintKey::IconKey' has a wrong offset!");
static_assert(offsetof(UHintKey, IconLock) == 0x000400, "Member 'UHintKey::IconLock' has a wrong offset!");
static_assert(offsetof(UHintKey, IconLowHealth) == 0x000408, "Member 'UHintKey::IconLowHealth' has a wrong offset!");
static_assert(offsetof(UHintKey, EnabledIconsColor) == 0x000410, "Member 'UHintKey::EnabledIconsColor' has a wrong offset!");
static_assert(offsetof(UHintKey, DisabledIconsColor) == 0x000414, "Member 'UHintKey::DisabledIconsColor' has a wrong offset!");

// Class Stalker2.HintProgressIPU
// 0x0018 (0x0058 - 0x0040)
class UHintProgressIPU final : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintProgressIPU">();
	}
	static class UHintProgressIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintProgressIPU>();
	}
};
static_assert(alignof(UHintProgressIPU) == 0x000008, "Wrong alignment on UHintProgressIPU");
static_assert(sizeof(UHintProgressIPU) == 0x000058, "Wrong size on UHintProgressIPU");

// Class Stalker2.ItemAnimCollection
// 0x02D0 (0x02F8 - 0x0028)
class UItemAnimCollection final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterWeaponAnimations             UseItemAnimation;                                  // 0x0030(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterWeaponAnimations             UseItemFastAnimation;                              // 0x0050(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimWeaponSwingContainer              SwingConfigContainer;                              // 0x0070(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponInertiaContainer                StopSwingInertia;                                  // 0x00A8(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPlayerWeaponAnimations                WeaponAnimations;                                  // 0x00C8(0x0230)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAnimCollection">();
	}
	static class UItemAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAnimCollection>();
	}
};
static_assert(alignof(UItemAnimCollection) == 0x000008, "Wrong alignment on UItemAnimCollection");
static_assert(sizeof(UItemAnimCollection) == 0x0002F8, "Wrong size on UItemAnimCollection");
static_assert(offsetof(UItemAnimCollection, UseItemAnimation) == 0x000030, "Member 'UItemAnimCollection::UseItemAnimation' has a wrong offset!");
static_assert(offsetof(UItemAnimCollection, UseItemFastAnimation) == 0x000050, "Member 'UItemAnimCollection::UseItemFastAnimation' has a wrong offset!");
static_assert(offsetof(UItemAnimCollection, SwingConfigContainer) == 0x000070, "Member 'UItemAnimCollection::SwingConfigContainer' has a wrong offset!");
static_assert(offsetof(UItemAnimCollection, StopSwingInertia) == 0x0000A8, "Member 'UItemAnimCollection::StopSwingInertia' has a wrong offset!");
static_assert(offsetof(UItemAnimCollection, WeaponAnimations) == 0x0000C8, "Member 'UItemAnimCollection::WeaponAnimations' has a wrong offset!");

// Class Stalker2.RichTextWidget
// 0x0010 (0x0940 - 0x0930)
class URichTextWidget : public URichTextBlock
{
public:
	bool                                          bEnableStyleManager;                               // 0x0930(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_931[0xF];                                      // 0x0931(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextWidget">();
	}
	static class URichTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextWidget>();
	}
};
static_assert(alignof(URichTextWidget) == 0x000010, "Wrong alignment on URichTextWidget");
static_assert(sizeof(URichTextWidget) == 0x000940, "Wrong size on URichTextWidget");
static_assert(offsetof(URichTextWidget, bEnableStyleManager) == 0x000930, "Member 'URichTextWidget::bEnableStyleManager' has a wrong offset!");

// Class Stalker2.HintRichTextWidget
// 0x0050 (0x0990 - 0x0940)
class UHintRichTextWidget final : public URichTextWidget
{
public:
	uint8                                         Pad_940[0x50];                                     // 0x0940(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintRichTextWidget">();
	}
	static class UHintRichTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintRichTextWidget>();
	}
};
static_assert(alignof(UHintRichTextWidget) == 0x000010, "Wrong alignment on UHintRichTextWidget");
static_assert(sizeof(UHintRichTextWidget) == 0x000990, "Wrong size on UHintRichTextWidget");

// Class Stalker2.HintSwitcher
// 0x0030 (0x0340 - 0x0310)
class UHintSwitcher final : public UHintBase
{
public:
	class UPlatformSwitcher*                      HintSwitcher;                                      // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintKey*                               HintPC;                                            // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintKey*                               HintConsole;                                       // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                HintButton;                                        // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHintKey*>                       HintKeys;                                          // 0x0330(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintSwitcher">();
	}
	static class UHintSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintSwitcher>();
	}
};
static_assert(alignof(UHintSwitcher) == 0x000008, "Wrong alignment on UHintSwitcher");
static_assert(sizeof(UHintSwitcher) == 0x000340, "Wrong size on UHintSwitcher");
static_assert(offsetof(UHintSwitcher, HintSwitcher) == 0x000310, "Member 'UHintSwitcher::HintSwitcher' has a wrong offset!");
static_assert(offsetof(UHintSwitcher, HintPC) == 0x000318, "Member 'UHintSwitcher::HintPC' has a wrong offset!");
static_assert(offsetof(UHintSwitcher, HintConsole) == 0x000320, "Member 'UHintSwitcher::HintConsole' has a wrong offset!");
static_assert(offsetof(UHintSwitcher, HintButton) == 0x000328, "Member 'UHintSwitcher::HintButton' has a wrong offset!");
static_assert(offsetof(UHintSwitcher, HintKeys) == 0x000330, "Member 'UHintSwitcher::HintKeys' has a wrong offset!");

// Class Stalker2.HintTutorialController
// 0x0018 (0x0358 - 0x0340)
class UHintTutorialController final : public UHintControllerBase
{
public:
	float                                         IntervalClick;                                     // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IntervalHold;                                      // 0x0344(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x10];                                     // 0x0348(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintTutorialController">();
	}
	static class UHintTutorialController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintTutorialController>();
	}
};
static_assert(alignof(UHintTutorialController) == 0x000008, "Wrong alignment on UHintTutorialController");
static_assert(sizeof(UHintTutorialController) == 0x000358, "Wrong size on UHintTutorialController");
static_assert(offsetof(UHintTutorialController, IntervalClick) == 0x000340, "Member 'UHintTutorialController::IntervalClick' has a wrong offset!");
static_assert(offsetof(UHintTutorialController, IntervalHold) == 0x000344, "Member 'UHintTutorialController::IntervalHold' has a wrong offset!");

// Class Stalker2.HintViewBase
// 0x00D0 (0x0348 - 0x0278)
class UHintViewBase : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInitializeAutomatically;                          // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHintViewSettings                      HintViewSettings;                                  // 0x0294(0x0020)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHintImageBase*                         HintIconImage;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintImageBase*                         HintIconImageDisabled;                             // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ProgressMaterial;                                  // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               ViewSizeBox;                                       // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              ViewScaleBox;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       PressAnimation;                                    // 0x02E0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PressAnimationSpeedMultiplier;                     // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EHintProgressType, struct FProgressMaterialData> ProgressMaterialMap;                       // 0x02F0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x8];                                      // 0x0340(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintViewBase">();
	}
	static class UHintViewBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintViewBase>();
	}
};
static_assert(alignof(UHintViewBase) == 0x000008, "Wrong alignment on UHintViewBase");
static_assert(sizeof(UHintViewBase) == 0x000348, "Wrong size on UHintViewBase");
static_assert(offsetof(UHintViewBase, bInitializeAutomatically) == 0x000290, "Member 'UHintViewBase::bInitializeAutomatically' has a wrong offset!");
static_assert(offsetof(UHintViewBase, HintViewSettings) == 0x000294, "Member 'UHintViewBase::HintViewSettings' has a wrong offset!");
static_assert(offsetof(UHintViewBase, HintIconImage) == 0x0002B8, "Member 'UHintViewBase::HintIconImage' has a wrong offset!");
static_assert(offsetof(UHintViewBase, HintIconImageDisabled) == 0x0002C0, "Member 'UHintViewBase::HintIconImageDisabled' has a wrong offset!");
static_assert(offsetof(UHintViewBase, ProgressMaterial) == 0x0002C8, "Member 'UHintViewBase::ProgressMaterial' has a wrong offset!");
static_assert(offsetof(UHintViewBase, ViewSizeBox) == 0x0002D0, "Member 'UHintViewBase::ViewSizeBox' has a wrong offset!");
static_assert(offsetof(UHintViewBase, ViewScaleBox) == 0x0002D8, "Member 'UHintViewBase::ViewScaleBox' has a wrong offset!");
static_assert(offsetof(UHintViewBase, PressAnimation) == 0x0002E0, "Member 'UHintViewBase::PressAnimation' has a wrong offset!");
static_assert(offsetof(UHintViewBase, PressAnimationSpeedMultiplier) == 0x0002E8, "Member 'UHintViewBase::PressAnimationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UHintViewBase, ProgressMaterialMap) == 0x0002F0, "Member 'UHintViewBase::ProgressMaterialMap' has a wrong offset!");

// Class Stalker2.PlayerAnimCollection
// 0x0338 (0x0360 - 0x0028)
class UPlayerAnimCollection final : public UObject
{
public:
	struct FPlayerExternalAnimations              ExternalAnimations;                                // 0x0028(0x0278)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPlayerInternalAnimations              InternalAnimations;                                // 0x02A0(0x00B8)(Edit, Protected, NativeAccessSpecifierProtected)
	class UPlayerAnimCollection*                  ParentAnimCollection;                              // 0x0358(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAnimCollection">();
	}
	static class UPlayerAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAnimCollection>();
	}
};
static_assert(alignof(UPlayerAnimCollection) == 0x000008, "Wrong alignment on UPlayerAnimCollection");
static_assert(sizeof(UPlayerAnimCollection) == 0x000360, "Wrong size on UPlayerAnimCollection");
static_assert(offsetof(UPlayerAnimCollection, ExternalAnimations) == 0x000028, "Member 'UPlayerAnimCollection::ExternalAnimations' has a wrong offset!");
static_assert(offsetof(UPlayerAnimCollection, InternalAnimations) == 0x0002A0, "Member 'UPlayerAnimCollection::InternalAnimations' has a wrong offset!");
static_assert(offsetof(UPlayerAnimCollection, ParentAnimCollection) == 0x000358, "Member 'UPlayerAnimCollection::ParentAnimCollection' has a wrong offset!");

// Class Stalker2.HitReceiver
// 0x0000 (0x0000 - 0x0000)
class IHitReceiver final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReceiver">();
	}
	static class IHitReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHitReceiver>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHitReceiver) == 0x000001, "Wrong alignment on IHitReceiver");
static_assert(sizeof(IHitReceiver) == 0x000001, "Wrong size on IHitReceiver");

// Class Stalker2.HitReceiverComponent
// 0x0078 (0x0118 - 0x00A0)
class UHitReceiverComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FCommonHitArgs& Common, const struct FExplosionHitArgs& HitArgs)> ExplosionHit; // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FCommonHitArgs& Common, const struct FBulletProjectileHitArgs& HitArgs)> BulletProjectileHit; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FCommonHitArgs& Common, const struct FMeleeHitArgs& HitArgs)> MeleeHit; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FCommonHitArgs& Common, const struct FAnomalyHitArgs& HitArgs)> AnomalyHit; // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FCommonHitArgs& Common, const struct FProjectileHitArgs& HitArgs)> ProjectileHit; // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FCommonHitArgs& Common, const struct FPhysicsHitArgs& HitArgs)> PhysicsHit; // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FCommonHitArgs& Common, const struct FWaterHitArgs& HitArgs)> WaterHit; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReceiverComponent">();
	}
	static class UHitReceiverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReceiverComponent>();
	}
};
static_assert(alignof(UHitReceiverComponent) == 0x000008, "Wrong alignment on UHitReceiverComponent");
static_assert(sizeof(UHitReceiverComponent) == 0x000118, "Wrong size on UHitReceiverComponent");
static_assert(offsetof(UHitReceiverComponent, ExplosionHit) == 0x0000A8, "Member 'UHitReceiverComponent::ExplosionHit' has a wrong offset!");
static_assert(offsetof(UHitReceiverComponent, BulletProjectileHit) == 0x0000B8, "Member 'UHitReceiverComponent::BulletProjectileHit' has a wrong offset!");
static_assert(offsetof(UHitReceiverComponent, MeleeHit) == 0x0000C8, "Member 'UHitReceiverComponent::MeleeHit' has a wrong offset!");
static_assert(offsetof(UHitReceiverComponent, AnomalyHit) == 0x0000D8, "Member 'UHitReceiverComponent::AnomalyHit' has a wrong offset!");
static_assert(offsetof(UHitReceiverComponent, ProjectileHit) == 0x0000E8, "Member 'UHitReceiverComponent::ProjectileHit' has a wrong offset!");
static_assert(offsetof(UHitReceiverComponent, PhysicsHit) == 0x0000F8, "Member 'UHitReceiverComponent::PhysicsHit' has a wrong offset!");
static_assert(offsetof(UHitReceiverComponent, WaterHit) == 0x000108, "Member 'UHitReceiverComponent::WaterHit' has a wrong offset!");

// Class Stalker2.HittableComponent
// 0x0020 (0x00C0 - 0x00A0)
class UHittableComponent final : public UActorComponent
{
public:
	bool                                          bCanHitWater;                                      // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x1F];                                      // 0x00A1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HittableComponent">();
	}
	static class UHittableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHittableComponent>();
	}
};
static_assert(alignof(UHittableComponent) == 0x000008, "Wrong alignment on UHittableComponent");
static_assert(sizeof(UHittableComponent) == 0x0000C0, "Wrong size on UHittableComponent");
static_assert(offsetof(UHittableComponent, bCanHitWater) == 0x0000A0, "Member 'UHittableComponent::bCanHitWater' has a wrong offset!");

// Class Stalker2.ProjectileSpawnSettings
// 0x0018 (0x0050 - 0x0038)
class UProjectileSpawnSettings final : public UDeveloperSettings
{
public:
	float                                         ProjectileAmountRefreshRate;                       // 0x0038(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileActiveKeepTime;                          // 0x003C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileDesiredPreHeatTime;                      // 0x0040(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileExtraPreHeatShots;                       // 0x0044(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileSpawnPerFrameAmount;                     // 0x0048(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDestroyedProjectilesPerFrame;                   // 0x004C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileSpawnSettings">();
	}
	static class UProjectileSpawnSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileSpawnSettings>();
	}
};
static_assert(alignof(UProjectileSpawnSettings) == 0x000008, "Wrong alignment on UProjectileSpawnSettings");
static_assert(sizeof(UProjectileSpawnSettings) == 0x000050, "Wrong size on UProjectileSpawnSettings");
static_assert(offsetof(UProjectileSpawnSettings, ProjectileAmountRefreshRate) == 0x000038, "Member 'UProjectileSpawnSettings::ProjectileAmountRefreshRate' has a wrong offset!");
static_assert(offsetof(UProjectileSpawnSettings, ProjectileActiveKeepTime) == 0x00003C, "Member 'UProjectileSpawnSettings::ProjectileActiveKeepTime' has a wrong offset!");
static_assert(offsetof(UProjectileSpawnSettings, ProjectileDesiredPreHeatTime) == 0x000040, "Member 'UProjectileSpawnSettings::ProjectileDesiredPreHeatTime' has a wrong offset!");
static_assert(offsetof(UProjectileSpawnSettings, ProjectileExtraPreHeatShots) == 0x000044, "Member 'UProjectileSpawnSettings::ProjectileExtraPreHeatShots' has a wrong offset!");
static_assert(offsetof(UProjectileSpawnSettings, ProjectileSpawnPerFrameAmount) == 0x000048, "Member 'UProjectileSpawnSettings::ProjectileSpawnPerFrameAmount' has a wrong offset!");
static_assert(offsetof(UProjectileSpawnSettings, MaxDestroyedProjectilesPerFrame) == 0x00004C, "Member 'UProjectileSpawnSettings::MaxDestroyedProjectilesPerFrame' has a wrong offset!");

// Class Stalker2.HoldBreathIPU
// 0x0000 (0x0058 - 0x0058)
class UHoldBreathIPU final : public UBehaviorBasedIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoldBreathIPU">();
	}
	static class UHoldBreathIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoldBreathIPU>();
	}
};
static_assert(alignof(UHoldBreathIPU) == 0x000008, "Wrong alignment on UHoldBreathIPU");
static_assert(sizeof(UHoldBreathIPU) == 0x000058, "Wrong size on UHoldBreathIPU");

// Class Stalker2.HoldIPU
// 0x0008 (0x0048 - 0x0040)
class UHoldIPU final : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoldIPU">();
	}
	static class UHoldIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoldIPU>();
	}
};
static_assert(alignof(UHoldIPU) == 0x000008, "Wrong alignment on UHoldIPU");
static_assert(sizeof(UHoldIPU) == 0x000048, "Wrong size on UHoldIPU");

// Class Stalker2.HUDContextualLegend
// 0x0028 (0x02A0 - 0x0278)
class UHUDContextualLegend final : public UChildViewBase
{
public:
	class URichTextBlock*                         LegendText;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DropDeadBodyHintSID;                               // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GuitarPCAHintSID;                                  // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDContextualLegend">();
	}
	static class UHUDContextualLegend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDContextualLegend>();
	}
};
static_assert(alignof(UHUDContextualLegend) == 0x000008, "Wrong alignment on UHUDContextualLegend");
static_assert(sizeof(UHUDContextualLegend) == 0x0002A0, "Wrong size on UHUDContextualLegend");
static_assert(offsetof(UHUDContextualLegend, LegendText) == 0x000278, "Member 'UHUDContextualLegend::LegendText' has a wrong offset!");
static_assert(offsetof(UHUDContextualLegend, DropDeadBodyHintSID) == 0x000280, "Member 'UHUDContextualLegend::DropDeadBodyHintSID' has a wrong offset!");
static_assert(offsetof(UHUDContextualLegend, GuitarPCAHintSID) == 0x000290, "Member 'UHUDContextualLegend::GuitarPCAHintSID' has a wrong offset!");

// Class Stalker2.HudHintsPanel
// 0x0068 (0x02E0 - 0x0278)
class UHudHintsPanel final : public UChildViewBase
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HintHudRestoreHideTime;                            // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HintRestoreHUDNonActiveOpacity;                    // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintRestoreHUD;                                    // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           CommonHintBox;                                     // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   ChangeAmmoType;                                    // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   ItemSelector;                                      // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   OpenInventory;                                     // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   OpenMap;                                           // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   OpenPDA;                                           // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CommonHintsOpacitySpeedChange;                     // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RestoreOpacitySpeedChange;                         // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateInputDependent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudHintsPanel">();
	}
	static class UHudHintsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHudHintsPanel>();
	}
};
static_assert(alignof(UHudHintsPanel) == 0x000008, "Wrong alignment on UHudHintsPanel");
static_assert(sizeof(UHudHintsPanel) == 0x0002E0, "Wrong size on UHudHintsPanel");
static_assert(offsetof(UHudHintsPanel, HintHudRestoreHideTime) == 0x000288, "Member 'UHudHintsPanel::HintHudRestoreHideTime' has a wrong offset!");
static_assert(offsetof(UHudHintsPanel, HintRestoreHUDNonActiveOpacity) == 0x00028C, "Member 'UHudHintsPanel::HintRestoreHUDNonActiveOpacity' has a wrong offset!");
static_assert(offsetof(UHudHintsPanel, HintRestoreHUD) == 0x000290, "Member 'UHudHintsPanel::HintRestoreHUD' has a wrong offset!");
static_assert(offsetof(UHudHintsPanel, CommonHintBox) == 0x000298, "Member 'UHudHintsPanel::CommonHintBox' has a wrong offset!");
static_assert(offsetof(UHudHintsPanel, ChangeAmmoType) == 0x0002A0, "Member 'UHudHintsPanel::ChangeAmmoType' has a wrong offset!");
static_assert(offsetof(UHudHintsPanel, ItemSelector) == 0x0002A8, "Member 'UHudHintsPanel::ItemSelector' has a wrong offset!");
static_assert(offsetof(UHudHintsPanel, OpenInventory) == 0x0002B0, "Member 'UHudHintsPanel::OpenInventory' has a wrong offset!");
static_assert(offsetof(UHudHintsPanel, OpenMap) == 0x0002B8, "Member 'UHudHintsPanel::OpenMap' has a wrong offset!");
static_assert(offsetof(UHudHintsPanel, OpenPDA) == 0x0002C0, "Member 'UHudHintsPanel::OpenPDA' has a wrong offset!");
static_assert(offsetof(UHudHintsPanel, CommonHintsOpacitySpeedChange) == 0x0002D8, "Member 'UHudHintsPanel::CommonHintsOpacitySpeedChange' has a wrong offset!");
static_assert(offsetof(UHudHintsPanel, RestoreOpacitySpeedChange) == 0x0002DC, "Member 'UHudHintsPanel::RestoreOpacitySpeedChange' has a wrong offset!");

// Class Stalker2.SpaceRestrictorsCheats
// 0x0000 (0x0028 - 0x0028)
class USpaceRestrictorsCheats final : public UCheatManagerExtension
{
public:
	void XRestrictorsPrint();
	void XRestrictorsShowResponse(const int32 UID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpaceRestrictorsCheats">();
	}
	static class USpaceRestrictorsCheats* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpaceRestrictorsCheats>();
	}
};
static_assert(alignof(USpaceRestrictorsCheats) == 0x000008, "Wrong alignment on USpaceRestrictorsCheats");
static_assert(sizeof(USpaceRestrictorsCheats) == 0x000028, "Wrong size on USpaceRestrictorsCheats");

// Class Stalker2.HUDRestoreIPU
// 0x0000 (0x0040 - 0x0040)
class UHUDRestoreIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDRestoreIPU">();
	}
	static class UHUDRestoreIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDRestoreIPU>();
	}
};
static_assert(alignof(UHUDRestoreIPU) == 0x000008, "Wrong alignment on UHUDRestoreIPU");
static_assert(sizeof(UHUDRestoreIPU) == 0x000040, "Wrong size on UHUDRestoreIPU");

// Class Stalker2.HumanAnimCollection
// 0x0200 (0x0228 - 0x0028)
class UHumanAnimCollection final : public UObject
{
public:
	TMap<EAnomalyAnimInteraction, class UAnimMontage*> AnomalyInteractions;                          // 0x0028(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EAnimationTargetType, class UAnimMontage*> AnimationTargetTypes;                            // 0x0078(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FHumanExternalAnimations               ExternalAnimations;                                // 0x00C8(0x00D0)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<EAnimStealthKillPose, class UAnimMontage*> StealthDeaths;                                   // 0x0198(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FCriticalHitAnimations>         CriticalHits;                                      // 0x01E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FPoseSearchLocomotionAnimCollectionData PoseSearchLocomotionAnimCollectionData;           // 0x01F8(0x0030)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanAnimCollection">();
	}
	static class UHumanAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanAnimCollection>();
	}
};
static_assert(alignof(UHumanAnimCollection) == 0x000008, "Wrong alignment on UHumanAnimCollection");
static_assert(sizeof(UHumanAnimCollection) == 0x000228, "Wrong size on UHumanAnimCollection");
static_assert(offsetof(UHumanAnimCollection, AnomalyInteractions) == 0x000028, "Member 'UHumanAnimCollection::AnomalyInteractions' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, AnimationTargetTypes) == 0x000078, "Member 'UHumanAnimCollection::AnimationTargetTypes' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, ExternalAnimations) == 0x0000C8, "Member 'UHumanAnimCollection::ExternalAnimations' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, StealthDeaths) == 0x000198, "Member 'UHumanAnimCollection::StealthDeaths' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, CriticalHits) == 0x0001E8, "Member 'UHumanAnimCollection::CriticalHits' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, PoseSearchLocomotionAnimCollectionData) == 0x0001F8, "Member 'UHumanAnimCollection::PoseSearchLocomotionAnimCollectionData' has a wrong offset!");

// Class Stalker2.HumanDefaultAnimCollection
// 0x0230 (0x0258 - 0x0028)
class UHumanDefaultAnimCollection final : public UObject
{
public:
	class UHumanAnimCollection*                   HumanAnimCollection;                               // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 HumanAnimBlueprint;                                // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEquipUnequipAnimations                EquipUnequip;                                      // 0x0038(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPDAUsageAnimations                    PDAUsage;                                          // 0x0050(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDragDeadBodyAnimations                DragDeadBodyAnimations;                            // 0x0068(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSmartCoverAnimCollectionData          SmartCoverAnimCollectionData;                      // 0x0078(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FHumanDeathAnimations                  DeathAnimations;                                   // 0x00C8(0x00F0)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<EEmotionalDialogState, struct FAnimDialogContextualWeightedArray> DialogIdleAnimations;     // 0x01B8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<EDialogAnimationType, struct FAnimDialogContextualArray> DialogAnimations;                  // 0x0208(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	TMap<ELookAtOwnerState, struct FAnimSequenceArray> GetDialogAnimations(class FName DialogAnimationType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanDefaultAnimCollection">();
	}
	static class UHumanDefaultAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanDefaultAnimCollection>();
	}
};
static_assert(alignof(UHumanDefaultAnimCollection) == 0x000008, "Wrong alignment on UHumanDefaultAnimCollection");
static_assert(sizeof(UHumanDefaultAnimCollection) == 0x000258, "Wrong size on UHumanDefaultAnimCollection");
static_assert(offsetof(UHumanDefaultAnimCollection, HumanAnimCollection) == 0x000028, "Member 'UHumanDefaultAnimCollection::HumanAnimCollection' has a wrong offset!");
static_assert(offsetof(UHumanDefaultAnimCollection, HumanAnimBlueprint) == 0x000030, "Member 'UHumanDefaultAnimCollection::HumanAnimBlueprint' has a wrong offset!");
static_assert(offsetof(UHumanDefaultAnimCollection, EquipUnequip) == 0x000038, "Member 'UHumanDefaultAnimCollection::EquipUnequip' has a wrong offset!");
static_assert(offsetof(UHumanDefaultAnimCollection, PDAUsage) == 0x000050, "Member 'UHumanDefaultAnimCollection::PDAUsage' has a wrong offset!");
static_assert(offsetof(UHumanDefaultAnimCollection, DragDeadBodyAnimations) == 0x000068, "Member 'UHumanDefaultAnimCollection::DragDeadBodyAnimations' has a wrong offset!");
static_assert(offsetof(UHumanDefaultAnimCollection, SmartCoverAnimCollectionData) == 0x000078, "Member 'UHumanDefaultAnimCollection::SmartCoverAnimCollectionData' has a wrong offset!");
static_assert(offsetof(UHumanDefaultAnimCollection, DeathAnimations) == 0x0000C8, "Member 'UHumanDefaultAnimCollection::DeathAnimations' has a wrong offset!");
static_assert(offsetof(UHumanDefaultAnimCollection, DialogIdleAnimations) == 0x0001B8, "Member 'UHumanDefaultAnimCollection::DialogIdleAnimations' has a wrong offset!");
static_assert(offsetof(UHumanDefaultAnimCollection, DialogAnimations) == 0x000208, "Member 'UHumanDefaultAnimCollection::DialogAnimations' has a wrong offset!");

// Class Stalker2.PostUpdateTickAggregationManager
// 0x01D8 (0x0280 - 0x00A8)
class UPostUpdateTickAggregationManager final : public UBaseTickableManager
{
public:
	struct FProjectileCollection                  ProjectilesCollection;                             // 0x00A8(0x0078)(Transient, NativeAccessSpecifierPrivate)
	struct FPhysicalManagerCollection             PhysicalManagerCollection;                         // 0x0120(0x0078)(Transient, NativeAccessSpecifierPrivate)
	struct FPhysicsObjectCollection               PhysicsObjectCollection;                           // 0x0198(0x0098)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x50];                                     // 0x0230(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostUpdateTickAggregationManager">();
	}
	static class UPostUpdateTickAggregationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostUpdateTickAggregationManager>();
	}
};
static_assert(alignof(UPostUpdateTickAggregationManager) == 0x000008, "Wrong alignment on UPostUpdateTickAggregationManager");
static_assert(sizeof(UPostUpdateTickAggregationManager) == 0x000280, "Wrong size on UPostUpdateTickAggregationManager");
static_assert(offsetof(UPostUpdateTickAggregationManager, ProjectilesCollection) == 0x0000A8, "Member 'UPostUpdateTickAggregationManager::ProjectilesCollection' has a wrong offset!");
static_assert(offsetof(UPostUpdateTickAggregationManager, PhysicalManagerCollection) == 0x000120, "Member 'UPostUpdateTickAggregationManager::PhysicalManagerCollection' has a wrong offset!");
static_assert(offsetof(UPostUpdateTickAggregationManager, PhysicsObjectCollection) == 0x000198, "Member 'UPostUpdateTickAggregationManager::PhysicsObjectCollection' has a wrong offset!");

// Class Stalker2.HumanFirearmAnimCollection
// 0x0288 (0x02B0 - 0x0028)
class UHumanFirearmAnimCollection final : public UObject
{
public:
	struct FHumanFirearmInternalAnimations        InternalAnimations;                                // 0x0028(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FHumanWeaponExternalAnimations         ExternalAnimations;                                // 0x00F8(0x0040)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FVector>             SocketLocations;                                   // 0x0138(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsOneHanded;                                      // 0x0188(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHumanWeaponAnimations                 WeaponAnimations;                                  // 0x0190(0x0120)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanFirearmAnimCollection">();
	}
	static class UHumanFirearmAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanFirearmAnimCollection>();
	}
};
static_assert(alignof(UHumanFirearmAnimCollection) == 0x000008, "Wrong alignment on UHumanFirearmAnimCollection");
static_assert(sizeof(UHumanFirearmAnimCollection) == 0x0002B0, "Wrong size on UHumanFirearmAnimCollection");
static_assert(offsetof(UHumanFirearmAnimCollection, InternalAnimations) == 0x000028, "Member 'UHumanFirearmAnimCollection::InternalAnimations' has a wrong offset!");
static_assert(offsetof(UHumanFirearmAnimCollection, ExternalAnimations) == 0x0000F8, "Member 'UHumanFirearmAnimCollection::ExternalAnimations' has a wrong offset!");
static_assert(offsetof(UHumanFirearmAnimCollection, SocketLocations) == 0x000138, "Member 'UHumanFirearmAnimCollection::SocketLocations' has a wrong offset!");
static_assert(offsetof(UHumanFirearmAnimCollection, bIsOneHanded) == 0x000188, "Member 'UHumanFirearmAnimCollection::bIsOneHanded' has a wrong offset!");
static_assert(offsetof(UHumanFirearmAnimCollection, WeaponAnimations) == 0x000190, "Member 'UHumanFirearmAnimCollection::WeaponAnimations' has a wrong offset!");

// Class Stalker2.HyperlinkButton
// 0x0060 (0x0320 - 0x02C0)
class UHyperlinkButton : public UButtonBase
{
public:
	class UTextWidget*                            Text;                                              // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Underline;                                         // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 URL;                                               // 0x02D0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DefaultText;                                       // 0x02E0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnableLocalization;                               // 0x02F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LocalizationSID;                                   // 0x0300(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SetStyleIdHover;                                   // 0x0310(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SetStyleIdUnHover;                                 // 0x0318(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HyperlinkButton">();
	}
	static class UHyperlinkButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHyperlinkButton>();
	}
};
static_assert(alignof(UHyperlinkButton) == 0x000008, "Wrong alignment on UHyperlinkButton");
static_assert(sizeof(UHyperlinkButton) == 0x000320, "Wrong size on UHyperlinkButton");
static_assert(offsetof(UHyperlinkButton, Text) == 0x0002C0, "Member 'UHyperlinkButton::Text' has a wrong offset!");
static_assert(offsetof(UHyperlinkButton, Underline) == 0x0002C8, "Member 'UHyperlinkButton::Underline' has a wrong offset!");
static_assert(offsetof(UHyperlinkButton, URL) == 0x0002D0, "Member 'UHyperlinkButton::URL' has a wrong offset!");
static_assert(offsetof(UHyperlinkButton, DefaultText) == 0x0002E0, "Member 'UHyperlinkButton::DefaultText' has a wrong offset!");
static_assert(offsetof(UHyperlinkButton, bEnableLocalization) == 0x0002F8, "Member 'UHyperlinkButton::bEnableLocalization' has a wrong offset!");
static_assert(offsetof(UHyperlinkButton, LocalizationSID) == 0x000300, "Member 'UHyperlinkButton::LocalizationSID' has a wrong offset!");
static_assert(offsetof(UHyperlinkButton, SetStyleIdHover) == 0x000310, "Member 'UHyperlinkButton::SetStyleIdHover' has a wrong offset!");
static_assert(offsetof(UHyperlinkButton, SetStyleIdUnHover) == 0x000318, "Member 'UHyperlinkButton::SetStyleIdUnHover' has a wrong offset!");

// Class Stalker2.IdleScreenView
// 0x0050 (0x0318 - 0x02C8)
class UIdleScreenView : public UViewBaseExtended
{
public:
	struct FVector2f                              LoadArrowRotation;                                 // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndicatorSpeed;                                    // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        TextSwitcher;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       TextTransitionAnim;                                // 0x02E0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ShaderCompilingAnim;                               // 0x02E8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ShadersCompilationBox;                             // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBarWidget*                     ProgressBarShaderCompiling;                        // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x18];                                     // 0x0300(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnyKeyIsPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IdleScreenView">();
	}
	static class UIdleScreenView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIdleScreenView>();
	}
};
static_assert(alignof(UIdleScreenView) == 0x000008, "Wrong alignment on UIdleScreenView");
static_assert(sizeof(UIdleScreenView) == 0x000318, "Wrong size on UIdleScreenView");
static_assert(offsetof(UIdleScreenView, LoadArrowRotation) == 0x0002C8, "Member 'UIdleScreenView::LoadArrowRotation' has a wrong offset!");
static_assert(offsetof(UIdleScreenView, IndicatorSpeed) == 0x0002D0, "Member 'UIdleScreenView::IndicatorSpeed' has a wrong offset!");
static_assert(offsetof(UIdleScreenView, TextSwitcher) == 0x0002D8, "Member 'UIdleScreenView::TextSwitcher' has a wrong offset!");
static_assert(offsetof(UIdleScreenView, TextTransitionAnim) == 0x0002E0, "Member 'UIdleScreenView::TextTransitionAnim' has a wrong offset!");
static_assert(offsetof(UIdleScreenView, ShaderCompilingAnim) == 0x0002E8, "Member 'UIdleScreenView::ShaderCompilingAnim' has a wrong offset!");
static_assert(offsetof(UIdleScreenView, ShadersCompilationBox) == 0x0002F0, "Member 'UIdleScreenView::ShadersCompilationBox' has a wrong offset!");
static_assert(offsetof(UIdleScreenView, ProgressBarShaderCompiling) == 0x0002F8, "Member 'UIdleScreenView::ProgressBarShaderCompiling' has a wrong offset!");

// Class Stalker2.ImageWidget
// 0x0158 (0x03D0 - 0x0278)
class UImageWidget : public UWidgetBase
{
public:
	class FName                                   StyleId;                                           // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStyleManager;                               // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetDefaultIcon;                                   // 0x0281(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_282[0xE];                                      // 0x0282(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIconSettings                          IconSettings;                                      // 0x0290(0x0120)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UImage*                                 ImageObj;                                          // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x18];                                     // 0x03B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBrushTextureInIconSettings(class UTexture2D* Texture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageWidget">();
	}
	static class UImageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageWidget>();
	}
};
static_assert(alignof(UImageWidget) == 0x000010, "Wrong alignment on UImageWidget");
static_assert(sizeof(UImageWidget) == 0x0003D0, "Wrong size on UImageWidget");
static_assert(offsetof(UImageWidget, StyleId) == 0x000278, "Member 'UImageWidget::StyleId' has a wrong offset!");
static_assert(offsetof(UImageWidget, bEnableStyleManager) == 0x000280, "Member 'UImageWidget::bEnableStyleManager' has a wrong offset!");
static_assert(offsetof(UImageWidget, bSetDefaultIcon) == 0x000281, "Member 'UImageWidget::bSetDefaultIcon' has a wrong offset!");
static_assert(offsetof(UImageWidget, IconSettings) == 0x000290, "Member 'UImageWidget::IconSettings' has a wrong offset!");
static_assert(offsetof(UImageWidget, ImageObj) == 0x0003B0, "Member 'UImageWidget::ImageObj' has a wrong offset!");

// Class Stalker2.ImpulseComponent
// 0x0000 (0x00A0 - 0x00A0)
class UImpulseComponent final : public UActorComponent
{
public:
	void ApplyImpulse(const class AActor* InTargetActor, const struct FVector& InImpulse, const bool bIgnoreMass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpulseComponent">();
	}
	static class UImpulseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImpulseComponent>();
	}
};
static_assert(alignof(UImpulseComponent) == 0x000008, "Wrong alignment on UImpulseComponent");
static_assert(sizeof(UImpulseComponent) == 0x0000A0, "Wrong size on UImpulseComponent");

// Class Stalker2.RazerSensaSettings
// 0x0080 (0x00B8 - 0x0038)
class URazerSensaSettings final : public UDeveloperSettings
{
public:
	struct FRazerSensaEvent                       PlayerKnockdownEvent;                              // 0x0038(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerSensaEvent                       ObjectHitEvent;                                    // 0x0048(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerSensaEvent                       HeadDamageEvent;                                   // 0x0058(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerSensaEvent                       ControllerPsyPunchEvent;                           // 0x0068(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerSensaEvent                       FaustPsyPunchEvent;                                // 0x0078(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FRazerSensaDamageSettings>      DamageEvents;                                      // 0x0088(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerSensaEvent                       StunEvent;                                         // 0x0098(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerSensaEvent                       PsyFieldEvent;                                     // 0x00A8(0x0010)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RazerSensaSettings">();
	}
	static class URazerSensaSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URazerSensaSettings>();
	}
};
static_assert(alignof(URazerSensaSettings) == 0x000008, "Wrong alignment on URazerSensaSettings");
static_assert(sizeof(URazerSensaSettings) == 0x0000B8, "Wrong size on URazerSensaSettings");
static_assert(offsetof(URazerSensaSettings, PlayerKnockdownEvent) == 0x000038, "Member 'URazerSensaSettings::PlayerKnockdownEvent' has a wrong offset!");
static_assert(offsetof(URazerSensaSettings, ObjectHitEvent) == 0x000048, "Member 'URazerSensaSettings::ObjectHitEvent' has a wrong offset!");
static_assert(offsetof(URazerSensaSettings, HeadDamageEvent) == 0x000058, "Member 'URazerSensaSettings::HeadDamageEvent' has a wrong offset!");
static_assert(offsetof(URazerSensaSettings, ControllerPsyPunchEvent) == 0x000068, "Member 'URazerSensaSettings::ControllerPsyPunchEvent' has a wrong offset!");
static_assert(offsetof(URazerSensaSettings, FaustPsyPunchEvent) == 0x000078, "Member 'URazerSensaSettings::FaustPsyPunchEvent' has a wrong offset!");
static_assert(offsetof(URazerSensaSettings, DamageEvents) == 0x000088, "Member 'URazerSensaSettings::DamageEvents' has a wrong offset!");
static_assert(offsetof(URazerSensaSettings, StunEvent) == 0x000098, "Member 'URazerSensaSettings::StunEvent' has a wrong offset!");
static_assert(offsetof(URazerSensaSettings, PsyFieldEvent) == 0x0000A8, "Member 'URazerSensaSettings::PsyFieldEvent' has a wrong offset!");

// Class Stalker2.InertionIPU
// 0x0020 (0x0060 - 0x0040)
class UInertionIPU : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InertionIPU">();
	}
	static class UInertionIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInertionIPU>();
	}
};
static_assert(alignof(UInertionIPU) == 0x000008, "Wrong alignment on UInertionIPU");
static_assert(sizeof(UInertionIPU) == 0x000060, "Wrong size on UInertionIPU");

// Class Stalker2.InitialControllerTrackerManager
// 0x0000 (0x0078 - 0x0078)
class UInitialControllerTrackerManager final : public UBaseManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InitialControllerTrackerManager">();
	}
	static class UInitialControllerTrackerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInitialControllerTrackerManager>();
	}
};
static_assert(alignof(UInitialControllerTrackerManager) == 0x000008, "Wrong alignment on UInitialControllerTrackerManager");
static_assert(sizeof(UInitialControllerTrackerManager) == 0x000078, "Wrong size on UInitialControllerTrackerManager");

// Class Stalker2.InitLevelGameMode
// 0x0000 (0x0340 - 0x0340)
class AInitLevelGameMode final : public AStalker2BaseGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InitLevelGameMode">();
	}
	static class AInitLevelGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInitLevelGameMode>();
	}
};
static_assert(alignof(AInitLevelGameMode) == 0x000008, "Wrong alignment on AInitLevelGameMode");
static_assert(sizeof(AInitLevelGameMode) == 0x000340, "Wrong size on AInitLevelGameMode");

// Class Stalker2.InputDamageModifierComponent
// 0x0010 (0x00B0 - 0x00A0)
class UInputDamageModifierComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageModifier;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIgnoreHitFeedback(const bool bInIgnore);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputDamageModifierComponent">();
	}
	static class UInputDamageModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputDamageModifierComponent>();
	}
};
static_assert(alignof(UInputDamageModifierComponent) == 0x000008, "Wrong alignment on UInputDamageModifierComponent");
static_assert(sizeof(UInputDamageModifierComponent) == 0x0000B0, "Wrong size on UInputDamageModifierComponent");
static_assert(offsetof(UInputDamageModifierComponent, DamageModifier) == 0x0000A8, "Member 'UInputDamageModifierComponent::DamageModifier' has a wrong offset!");

// Class Stalker2.InputManager
// 0x01B0 (0x0258 - 0x00A8)
class UInputManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0xF8];                                      // 0x00A8(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UInputMappingContext>    RemapMappingContext;                               // 0x01A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInputProcessingUnit*>           InputProcessingUnits;                              // 0x01A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UInputProcessingUnit*>           TickableIPUs;                                      // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x10];                                     // 0x01C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        InputComponent;                                    // 0x01D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerInput*                           PlayerInput;                                       // 0x01E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacter*                             PlayerCharacter;                                   // 0x01E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 InteractProgressBarFocusedActor;                   // 0x01F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x60];                                     // 0x01F8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputManager">();
	}
	static class UInputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputManager>();
	}
};
static_assert(alignof(UInputManager) == 0x000008, "Wrong alignment on UInputManager");
static_assert(sizeof(UInputManager) == 0x000258, "Wrong size on UInputManager");
static_assert(offsetof(UInputManager, RemapMappingContext) == 0x0001A0, "Member 'UInputManager::RemapMappingContext' has a wrong offset!");
static_assert(offsetof(UInputManager, InputProcessingUnits) == 0x0001A8, "Member 'UInputManager::InputProcessingUnits' has a wrong offset!");
static_assert(offsetof(UInputManager, TickableIPUs) == 0x0001B8, "Member 'UInputManager::TickableIPUs' has a wrong offset!");
static_assert(offsetof(UInputManager, InputComponent) == 0x0001D8, "Member 'UInputManager::InputComponent' has a wrong offset!");
static_assert(offsetof(UInputManager, PlayerInput) == 0x0001E0, "Member 'UInputManager::PlayerInput' has a wrong offset!");
static_assert(offsetof(UInputManager, PlayerCharacter) == 0x0001E8, "Member 'UInputManager::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UInputManager, InteractProgressBarFocusedActor) == 0x0001F0, "Member 'UInputManager::InteractProgressBarFocusedActor' has a wrong offset!");

// Class Stalker2.StaticMeshBatcher
// 0x0030 (0x02C8 - 0x0298)
class AStaticMeshBatcher final : public AActor
{
public:
	TArray<class UInstancedStaticMeshComponent*>  BatchedISM;                                        // 0x0298(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x20];                                     // 0x02A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshBatcher">();
	}
	static class AStaticMeshBatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticMeshBatcher>();
	}
};
static_assert(alignof(AStaticMeshBatcher) == 0x000008, "Wrong alignment on AStaticMeshBatcher");
static_assert(sizeof(AStaticMeshBatcher) == 0x0002C8, "Wrong size on AStaticMeshBatcher");
static_assert(offsetof(AStaticMeshBatcher, BatchedISM) == 0x000298, "Member 'AStaticMeshBatcher::BatchedISM' has a wrong offset!");

// Class Stalker2.InputMappingSettingsModel
// 0x0010 (0x0040 - 0x0030)
class UInputMappingSettingsModel final : public UDataAsset
{
public:
	TArray<struct FInputMappingSettingsElementModels> ElementsModels;                                // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputMappingSettingsModel">();
	}
	static class UInputMappingSettingsModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputMappingSettingsModel>();
	}
};
static_assert(alignof(UInputMappingSettingsModel) == 0x000008, "Wrong alignment on UInputMappingSettingsModel");
static_assert(sizeof(UInputMappingSettingsModel) == 0x000040, "Wrong size on UInputMappingSettingsModel");
static_assert(offsetof(UInputMappingSettingsModel, ElementsModels) == 0x000030, "Member 'UInputMappingSettingsModel::ElementsModels' has a wrong offset!");

// Class Stalker2.InputTriggerActionBlocker
// 0x0008 (0x0058 - 0x0050)
class UInputTriggerActionBlocker final : public UInputTrigger
{
public:
	class UActionBlockerConditionBase*            Condition;                                         // 0x0050(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputTriggerActionBlocker">();
	}
	static class UInputTriggerActionBlocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputTriggerActionBlocker>();
	}
};
static_assert(alignof(UInputTriggerActionBlocker) == 0x000008, "Wrong alignment on UInputTriggerActionBlocker");
static_assert(sizeof(UInputTriggerActionBlocker) == 0x000058, "Wrong size on UInputTriggerActionBlocker");
static_assert(offsetof(UInputTriggerActionBlocker, Condition) == 0x000050, "Member 'UInputTriggerActionBlocker::Condition' has a wrong offset!");

// Class Stalker2.PsyNoiseSFXComponent
// 0x0000 (0x00D0 - 0x00D0)
class UPsyNoiseSFXComponent final : public UPlayerEffectsSFXComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsyNoiseSFXComponent">();
	}
	static class UPsyNoiseSFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsyNoiseSFXComponent>();
	}
};
static_assert(alignof(UPsyNoiseSFXComponent) == 0x000008, "Wrong alignment on UPsyNoiseSFXComponent");
static_assert(sizeof(UPsyNoiseSFXComponent) == 0x0000D0, "Wrong size on UPsyNoiseSFXComponent");

// Class Stalker2.InspectArtifactExitIPU
// 0x0000 (0x0040 - 0x0040)
class UInspectArtifactExitIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectArtifactExitIPU">();
	}
	static class UInspectArtifactExitIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectArtifactExitIPU>();
	}
};
static_assert(alignof(UInspectArtifactExitIPU) == 0x000008, "Wrong alignment on UInspectArtifactExitIPU");
static_assert(sizeof(UInspectArtifactExitIPU) == 0x000040, "Wrong size on UInspectArtifactExitIPU");

// Class Stalker2.InspectArtifactView
// 0x0038 (0x0300 - 0x02C8)
class UInspectArtifactView final : public UViewBaseExtended
{
public:
	class UWidgetAnimation*                       HintFadeAnimation;                                 // 0x02C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HintFadeInPlaybackSpeed;                           // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HintFadeOutPlaybackSpeed;                          // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HintShowTime;                                      // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC[0x24];                                     // 0x02DC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectArtifactView">();
	}
	static class UInspectArtifactView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectArtifactView>();
	}
};
static_assert(alignof(UInspectArtifactView) == 0x000008, "Wrong alignment on UInspectArtifactView");
static_assert(sizeof(UInspectArtifactView) == 0x000300, "Wrong size on UInspectArtifactView");
static_assert(offsetof(UInspectArtifactView, HintFadeAnimation) == 0x0002C8, "Member 'UInspectArtifactView::HintFadeAnimation' has a wrong offset!");
static_assert(offsetof(UInspectArtifactView, HintFadeInPlaybackSpeed) == 0x0002D0, "Member 'UInspectArtifactView::HintFadeInPlaybackSpeed' has a wrong offset!");
static_assert(offsetof(UInspectArtifactView, HintFadeOutPlaybackSpeed) == 0x0002D4, "Member 'UInspectArtifactView::HintFadeOutPlaybackSpeed' has a wrong offset!");
static_assert(offsetof(UInspectArtifactView, HintShowTime) == 0x0002D8, "Member 'UInspectArtifactView::HintShowTime' has a wrong offset!");

// Class Stalker2.InteracDerivedVersionComponent
// 0x0010 (0x00B8 - 0x00A8)
class UInteracDerivedVersionComponent final : public UInteractableVersionComponent
{
public:
	bool                                          bChangeEnabled;                                    // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeUnbreakable;                                // 0x00A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeBroken;                                     // 0x00AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeSelfSufficient;                             // 0x00AB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangePrerequisiteRequired;                       // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewEnabled;                                       // 0x00AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewUnbreakable;                                   // 0x00AE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewBroken;                                        // 0x00AF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewSelfSufficient;                                // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewPrerequisiteRequired;                          // 0x00B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteracDerivedVersionComponent">();
	}
	static class UInteracDerivedVersionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteracDerivedVersionComponent>();
	}
};
static_assert(alignof(UInteracDerivedVersionComponent) == 0x000008, "Wrong alignment on UInteracDerivedVersionComponent");
static_assert(sizeof(UInteracDerivedVersionComponent) == 0x0000B8, "Wrong size on UInteracDerivedVersionComponent");
static_assert(offsetof(UInteracDerivedVersionComponent, bChangeEnabled) == 0x0000A8, "Member 'UInteracDerivedVersionComponent::bChangeEnabled' has a wrong offset!");
static_assert(offsetof(UInteracDerivedVersionComponent, bChangeUnbreakable) == 0x0000A9, "Member 'UInteracDerivedVersionComponent::bChangeUnbreakable' has a wrong offset!");
static_assert(offsetof(UInteracDerivedVersionComponent, bChangeBroken) == 0x0000AA, "Member 'UInteracDerivedVersionComponent::bChangeBroken' has a wrong offset!");
static_assert(offsetof(UInteracDerivedVersionComponent, bChangeSelfSufficient) == 0x0000AB, "Member 'UInteracDerivedVersionComponent::bChangeSelfSufficient' has a wrong offset!");
static_assert(offsetof(UInteracDerivedVersionComponent, bChangePrerequisiteRequired) == 0x0000AC, "Member 'UInteracDerivedVersionComponent::bChangePrerequisiteRequired' has a wrong offset!");
static_assert(offsetof(UInteracDerivedVersionComponent, bNewEnabled) == 0x0000AD, "Member 'UInteracDerivedVersionComponent::bNewEnabled' has a wrong offset!");
static_assert(offsetof(UInteracDerivedVersionComponent, bNewUnbreakable) == 0x0000AE, "Member 'UInteracDerivedVersionComponent::bNewUnbreakable' has a wrong offset!");
static_assert(offsetof(UInteracDerivedVersionComponent, bNewBroken) == 0x0000AF, "Member 'UInteracDerivedVersionComponent::bNewBroken' has a wrong offset!");
static_assert(offsetof(UInteracDerivedVersionComponent, bNewSelfSufficient) == 0x0000B0, "Member 'UInteracDerivedVersionComponent::bNewSelfSufficient' has a wrong offset!");
static_assert(offsetof(UInteracDerivedVersionComponent, bNewPrerequisiteRequired) == 0x0000B1, "Member 'UInteracDerivedVersionComponent::bNewPrerequisiteRequired' has a wrong offset!");

// Class Stalker2.InteractableItemContainer
// 0x0140 (0x03E8 - 0x02A8)
class AInteractableItemContainer final : public AUIDActor_ItemContainer
{
public:
	uint8                                         Pad_2A8[0x20];                                     // 0x02A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsSoundsComponent*                PhysicsSoundsComponent;                            // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsInteractionComponent*           PhysicsInteractionComponent;                       // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHittableComponent*                     HittableComponent;                                 // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULaserSightComponent*                   LaserSightComponent;                               // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataLayerPhysicsComponent*             DataLayerPhysicsComponent;                         // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemContainerInteractionComponent*     InteractionComponent;                              // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FWeaponAttachMeshesData                WeaponAttachesData;                                // 0x02F8(0x0080)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x70];                                     // 0x0378(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableItemContainer">();
	}
	static class AInteractableItemContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractableItemContainer>();
	}
};
static_assert(alignof(AInteractableItemContainer) == 0x000008, "Wrong alignment on AInteractableItemContainer");
static_assert(sizeof(AInteractableItemContainer) == 0x0003E8, "Wrong size on AInteractableItemContainer");
static_assert(offsetof(AInteractableItemContainer, PhysicsSoundsComponent) == 0x0002C8, "Member 'AInteractableItemContainer::PhysicsSoundsComponent' has a wrong offset!");
static_assert(offsetof(AInteractableItemContainer, PhysicsInteractionComponent) == 0x0002D0, "Member 'AInteractableItemContainer::PhysicsInteractionComponent' has a wrong offset!");
static_assert(offsetof(AInteractableItemContainer, HittableComponent) == 0x0002D8, "Member 'AInteractableItemContainer::HittableComponent' has a wrong offset!");
static_assert(offsetof(AInteractableItemContainer, LaserSightComponent) == 0x0002E0, "Member 'AInteractableItemContainer::LaserSightComponent' has a wrong offset!");
static_assert(offsetof(AInteractableItemContainer, DataLayerPhysicsComponent) == 0x0002E8, "Member 'AInteractableItemContainer::DataLayerPhysicsComponent' has a wrong offset!");
static_assert(offsetof(AInteractableItemContainer, InteractionComponent) == 0x0002F0, "Member 'AInteractableItemContainer::InteractionComponent' has a wrong offset!");
static_assert(offsetof(AInteractableItemContainer, WeaponAttachesData) == 0x0002F8, "Member 'AInteractableItemContainer::WeaponAttachesData' has a wrong offset!");

// Class Stalker2.Stalker2HUD
// 0x0000 (0x0388 - 0x0388)
class AStalker2HUD final : public AHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Stalker2HUD">();
	}
	static class AStalker2HUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStalker2HUD>();
	}
};
static_assert(alignof(AStalker2HUD) == 0x000008, "Wrong alignment on AStalker2HUD");
static_assert(sizeof(AStalker2HUD) == 0x000388, "Wrong size on AStalker2HUD");

// Class Stalker2.InteractableMonitorSection
// 0x0028 (0x0310 - 0x02E8)
class AInteractableMonitorSection final : public AInteractableObject
{
public:
	class UStaticMeshComponent*                   MonitorMesh;                                       // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USignalReceiverComponent*               ActivationSignalReceiver;                          // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USignalReceiverComponent*               DeactivationSignalReceiver;                        // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USignalReceiverComponent*               DestructionSignalReceiver;                         // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         DestructionVFX;                                    // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnActivationSignalReceived(class UObject* InObject);
	void OnDeactivationSignalReceived(class UObject* InObject);
	void OnDestructionSignalReceived(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableMonitorSection">();
	}
	static class AInteractableMonitorSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractableMonitorSection>();
	}
};
static_assert(alignof(AInteractableMonitorSection) == 0x000008, "Wrong alignment on AInteractableMonitorSection");
static_assert(sizeof(AInteractableMonitorSection) == 0x000310, "Wrong size on AInteractableMonitorSection");
static_assert(offsetof(AInteractableMonitorSection, MonitorMesh) == 0x0002E8, "Member 'AInteractableMonitorSection::MonitorMesh' has a wrong offset!");
static_assert(offsetof(AInteractableMonitorSection, ActivationSignalReceiver) == 0x0002F0, "Member 'AInteractableMonitorSection::ActivationSignalReceiver' has a wrong offset!");
static_assert(offsetof(AInteractableMonitorSection, DeactivationSignalReceiver) == 0x0002F8, "Member 'AInteractableMonitorSection::DeactivationSignalReceiver' has a wrong offset!");
static_assert(offsetof(AInteractableMonitorSection, DestructionSignalReceiver) == 0x000300, "Member 'AInteractableMonitorSection::DestructionSignalReceiver' has a wrong offset!");
static_assert(offsetof(AInteractableMonitorSection, DestructionVFX) == 0x000308, "Member 'AInteractableMonitorSection::DestructionVFX' has a wrong offset!");

// Class Stalker2.InteractHintInputController
// 0x0068 (0x03A8 - 0x0340)
class UInteractHintInputController final : public UHintControllerBase
{
public:
	uint8                                         Pad_340[0x8];                                      // 0x0340(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 IconImage;                                         // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EInteractionTypeIcon, TSoftObjectPtr<class UTexture2D>> InteractionTypeIcons;               // 0x0350(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractHintInputController">();
	}
	static class UInteractHintInputController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractHintInputController>();
	}
};
static_assert(alignof(UInteractHintInputController) == 0x000008, "Wrong alignment on UInteractHintInputController");
static_assert(sizeof(UInteractHintInputController) == 0x0003A8, "Wrong size on UInteractHintInputController");
static_assert(offsetof(UInteractHintInputController, IconImage) == 0x000348, "Member 'UInteractHintInputController::IconImage' has a wrong offset!");
static_assert(offsetof(UInteractHintInputController, InteractionTypeIcons) == 0x000350, "Member 'UInteractHintInputController::InteractionTypeIcons' has a wrong offset!");

// Class Stalker2.InteractPaintInterface
// 0x0000 (0x0000 - 0x0000)
class IInteractPaintInterface final
{
public:
	void OnPaintSettingsChanged(const bool bInteractPaint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractPaintInterface">();
	}
	static class IInteractPaintInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractPaintInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IInteractPaintInterface) == 0x000001, "Wrong alignment on IInteractPaintInterface");
static_assert(sizeof(IInteractPaintInterface) == 0x000001, "Wrong size on IInteractPaintInterface");

// Class Stalker2.InteractView
// 0x00E8 (0x03A8 - 0x02C0)
class UInteractView final : public UViewBase
{
public:
	class UInteractHintInputController*           MainHint;                                          // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractHintInputController*           OptionalHint;                                      // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           BothElementCanvas;                                 // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           HintCanvas;                                        // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           InteractCanvas;                                    // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            NameText;                                          // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            ActionText;                                        // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            SecondActionText;                                  // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               MainActionElement;                                 // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               SecondActionElement;                               // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               NameElement;                                       // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 UpgradeIcon;                                       // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 DurabilityIcon;                                    // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 OverweightIcon;                                    // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 MainRightSoftTile;                                 // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              InteractItemOffset;                                // 0x0338(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UInteractionComponent>> InteractionComponents;                       // 0x0348(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UInteractHintInputController*>   HintWidgets;                                       // 0x0358(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x28];                                     // 0x0368(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UpgradesBlueprintL10n;                             // 0x0390(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideInteractHints();
	void UpdateHintState();
	void UpdateInteractHints();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractView">();
	}
	static class UInteractView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractView>();
	}
};
static_assert(alignof(UInteractView) == 0x000008, "Wrong alignment on UInteractView");
static_assert(sizeof(UInteractView) == 0x0003A8, "Wrong size on UInteractView");
static_assert(offsetof(UInteractView, MainHint) == 0x0002C0, "Member 'UInteractView::MainHint' has a wrong offset!");
static_assert(offsetof(UInteractView, OptionalHint) == 0x0002C8, "Member 'UInteractView::OptionalHint' has a wrong offset!");
static_assert(offsetof(UInteractView, BothElementCanvas) == 0x0002D0, "Member 'UInteractView::BothElementCanvas' has a wrong offset!");
static_assert(offsetof(UInteractView, HintCanvas) == 0x0002D8, "Member 'UInteractView::HintCanvas' has a wrong offset!");
static_assert(offsetof(UInteractView, InteractCanvas) == 0x0002E0, "Member 'UInteractView::InteractCanvas' has a wrong offset!");
static_assert(offsetof(UInteractView, NameText) == 0x0002E8, "Member 'UInteractView::NameText' has a wrong offset!");
static_assert(offsetof(UInteractView, ActionText) == 0x0002F0, "Member 'UInteractView::ActionText' has a wrong offset!");
static_assert(offsetof(UInteractView, SecondActionText) == 0x0002F8, "Member 'UInteractView::SecondActionText' has a wrong offset!");
static_assert(offsetof(UInteractView, MainActionElement) == 0x000300, "Member 'UInteractView::MainActionElement' has a wrong offset!");
static_assert(offsetof(UInteractView, SecondActionElement) == 0x000308, "Member 'UInteractView::SecondActionElement' has a wrong offset!");
static_assert(offsetof(UInteractView, NameElement) == 0x000310, "Member 'UInteractView::NameElement' has a wrong offset!");
static_assert(offsetof(UInteractView, UpgradeIcon) == 0x000318, "Member 'UInteractView::UpgradeIcon' has a wrong offset!");
static_assert(offsetof(UInteractView, DurabilityIcon) == 0x000320, "Member 'UInteractView::DurabilityIcon' has a wrong offset!");
static_assert(offsetof(UInteractView, OverweightIcon) == 0x000328, "Member 'UInteractView::OverweightIcon' has a wrong offset!");
static_assert(offsetof(UInteractView, MainRightSoftTile) == 0x000330, "Member 'UInteractView::MainRightSoftTile' has a wrong offset!");
static_assert(offsetof(UInteractView, InteractItemOffset) == 0x000338, "Member 'UInteractView::InteractItemOffset' has a wrong offset!");
static_assert(offsetof(UInteractView, InteractionComponents) == 0x000348, "Member 'UInteractView::InteractionComponents' has a wrong offset!");
static_assert(offsetof(UInteractView, HintWidgets) == 0x000358, "Member 'UInteractView::HintWidgets' has a wrong offset!");
static_assert(offsetof(UInteractView, UpgradesBlueprintL10n) == 0x000390, "Member 'UInteractView::UpgradesBlueprintL10n' has a wrong offset!");

// Class Stalker2.InteractViewHint
// 0x0090 (0x03D0 - 0x0340)
class UInteractViewHint final : public UCommonHint
{
public:
	class UTextWidget*                            TitleText;                                         // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            InteractText;                                      // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            InteractTextSmall;                                 // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           HintsContainer;                                    // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImageWidget*                           IconUpgrade;                                       // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImageWidget*                           IconOverweight;                                    // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       RunActionAnim;                                     // 0x0370(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x58];                                     // 0x0378(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRunAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractViewHint">();
	}
	static class UInteractViewHint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractViewHint>();
	}
};
static_assert(alignof(UInteractViewHint) == 0x000008, "Wrong alignment on UInteractViewHint");
static_assert(sizeof(UInteractViewHint) == 0x0003D0, "Wrong size on UInteractViewHint");
static_assert(offsetof(UInteractViewHint, TitleText) == 0x000340, "Member 'UInteractViewHint::TitleText' has a wrong offset!");
static_assert(offsetof(UInteractViewHint, InteractText) == 0x000348, "Member 'UInteractViewHint::InteractText' has a wrong offset!");
static_assert(offsetof(UInteractViewHint, InteractTextSmall) == 0x000350, "Member 'UInteractViewHint::InteractTextSmall' has a wrong offset!");
static_assert(offsetof(UInteractViewHint, HintsContainer) == 0x000358, "Member 'UInteractViewHint::HintsContainer' has a wrong offset!");
static_assert(offsetof(UInteractViewHint, IconUpgrade) == 0x000360, "Member 'UInteractViewHint::IconUpgrade' has a wrong offset!");
static_assert(offsetof(UInteractViewHint, IconOverweight) == 0x000368, "Member 'UInteractViewHint::IconOverweight' has a wrong offset!");
static_assert(offsetof(UInteractViewHint, RunActionAnim) == 0x000370, "Member 'UInteractViewHint::RunActionAnim' has a wrong offset!");

// Class Stalker2.InventoryIPU
// 0x0000 (0x0040 - 0x0040)
class UInventoryIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryIPU">();
	}
	static class UInventoryIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryIPU>();
	}
};
static_assert(alignof(UInventoryIPU) == 0x000008, "Wrong alignment on UInventoryIPU");
static_assert(sizeof(UInventoryIPU) == 0x000040, "Wrong size on UInventoryIPU");

// Class Stalker2.InventoryNew
// 0x1100 (0x13C8 - 0x02C8)
class UInventoryNew : public UViewBaseExtended
{
public:
	class UCanvasPanel*                           CanvasPanel;                                       // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEquipmentSlots*                        EquipmentWidget;                                   // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQuickPanel*                            QuickPanel;                                        // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomGrid*                            InventoryWidget;                                   // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableItemSlotBaseWidget*        CurrSelectedItem;                                  // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableItemSlotBaseWidget*        HoveredItem;                                       // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableItemSlotBaseWidget*        CurrClickedItem;                                   // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemInfo*                              ItemTooltip;                                       // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemCompareWidget*                     ItemCompareWidget;                                 // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TakeAllIcon;                                       // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            LootSeparator;                                     // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomGrid*                            LootGridWidget;                                    // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ButtonTakeAllItems;                                // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDragDropZone*                          DropZone;                                          // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDragDropZone*                          RejectDropZoneInventory;                           // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDragDropZone*                          RejectDropZoneEquipment;                           // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDragDropZone*                          RejectDropZoneLootSmall;                           // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDragDropZone*                          RejectDropZoneLootBig;                             // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDragDropZone*                          ContextualDropZone;                                // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               HintsOverlay;                                      // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               SafeZoneOverlay;                                   // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintToggleEquipment;                               // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintToggleDescription;                             // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintToggleAutoComparing;                           // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintClose;                                         // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintBack;                                          // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintUseItem;                                       // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintEquip;                                         // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintMoveToBackpack;                                // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintRemoveAttach;                                  // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintUnload;                                        // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintChangeCompareItemHint;                         // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintDropItem;                                      // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintLootTakeItem;                                  // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintLootPutDown;                                   // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintLootTakeAllOther;                              // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintLootTakeAllPlayerStash;                        // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintSortInventory;                                 // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintShowContextualMenu;                            // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintMoveItem;                                      // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintPlaceItem;                                     // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintRemoveQuickAccess;                             // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UseItemHoldTime;                                   // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropItemHoldTime;                                  // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUpgradeMenuWidget*                     UpgradeMenu;                                       // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                SortButton;                                        // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               LootOverlay;                                       // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconTakeAllItems;                                  // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TooltipAndHintsPadding;                            // 0x0448(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHintInputController*>           VisibleStateHints;                                 // 0x0450(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UHintInputController*>           CommonHints;                                       // 0x0460(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkSwitchValue*                         ItemTypeSwitchValue;                               // 0x0478(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TooltipDistance;                                   // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UUserWidget*, ESlateVisibility>    GridVisibilityMap;                                 // 0x0488(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x30];                                     // 0x04D8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            CurrGamepadNavigatedWidget;                        // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_510[0x10];                                     // 0x0510(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemDragWidget*                        DragWidget;                                        // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemDragWidget*                        DragWidgetGrid;                                    // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemTooltipShowDelay;                              // 0x0530(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemTooltipCompareShowDelay;                       // 0x0534(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemInfo>                  ItemTooltipClass;                                  // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemDragWidget>            DragWidgetClass;                                   // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemDragWidget>            DragGridWidgetClass;                               // 0x0548(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UStackSplittingWidget>      StackSplitWidgetClass;                             // 0x0550(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStackSplitContextual*                  StackSplitContextual;                              // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStackSplittingWidget*                  StackSplit;                                        // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ItemBacktDefault;                                  // 0x0568(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ItemBackOk;                                        // 0x0578(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ItemBackInterceptOne;                              // 0x0588(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ItemBackInterceptTwo;                              // 0x0598(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ItemBackDepend;                                    // 0x05A8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ItemBackHoveredCompatible;                         // 0x05B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C8[0x10];                                     // 0x05C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadNavigationThreshold;                        // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       RadiationMark;                                     // 0x05E0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ToggleEquipmentIconColor;                          // 0x05E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OverWeightColor;                                   // 0x05F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NormalWeightColor;                                 // 0x0608(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_618[0x30];                                     // 0x0618(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            RightClickMenuWidget;                              // 0x0648(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_650[0x68];                                     // 0x0650(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableItemSlotBaseWidget*        ItemSlotStartedDrag;                               // 0x06B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableItemSlotBaseWidget*        CurrGamepadSelectedItem;                           // 0x06C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C8[0x48];                                     // 0x06C8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	EInventoryEquipmentSlot                       CurrentCompareSlot;                                // 0x0710(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_711[0x7];                                      // 0x0711(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEquipmentSlot*                         EquipmentSlotToCompare;                            // 0x0718(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInventoryEquipmentSlot                       CurrentCompareItemSlotType;                        // 0x0720(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_721[0x4FF];                                    // 0x0721(0x04FF)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCustomGridSlot*>                GridSlotsPool;                                     // 0x0C20(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C30[0x798];                                    // 0x0C30(0x0798)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DropItemHoldReleased();
	void GamepadDragStop();
	void HideRightClickMenu();
	void InventoryWidgetTakeAllItems();
	void LootTakeAllHoldReleased();
	void LootTakeAllHoldStarted();
	void LootTakeItemAction();
	void OnDragDropCanceled(const struct FVector2D& Pos);
	void OnDropItemHoldTriggered();
	void OnDropToEmptyPlace(const struct FVector2D& Pos);
	void OnEquipHoldTriggered();
	void OnExitClick(class FName ButtonId);
	void OnGamepadContextMenu();
	void OnGamepadEquipItem();
	void OnGamepadItemSelectHoldFinished();
	void OnGamepadSelectItemForMoveRepeat();
	void OnGamepadSelectItemRelease();
	void OnMoveToBackpackHoldTriggered();
	void OnRejectDrop(const struct FVector2D& Pos);
	void OnRightClickMenuCanceled();
	void OnRightClickMenuItemHover(const struct FRightClickMenuItemData& ItemData, const bool bInHover);
	void OnRightClickMenuItemSelected(const struct FRightClickMenuItemData& ItemData);
	void OnSplitCanceled();
	void OnSplitConfirmed(int32 ItemAmountSplitForDrop, const struct FItemUID& ItemUID);
	void OnTakeAllHoldTriggered();
	void OnUseItemHoldTriggered();
	void OnVisibilityChangedEvent(ESlateVisibility NewVisibility);
	void ShowTooltip();
	void SortInventory();
	void UIGamepadInventoryItemAction();
	void UIInventoryChangeComparingItem();
	void UIInventoryDropItem();
	void UIInventoryEnableAutoComparing();
	void UIInventoryItemAction();
	void UIInventoryNavigateDown();
	void UIInventoryNavigateLeft();
	void UIInventoryNavigateRight();
	void UIInventoryNavigateUp();
	void UIInventorySort();
	void UIInventoryTakeItem();
	void UIInventoryToggleEquipment();
	void UIInventoryToggleItemInfo();
	void UpdateInputDependent();
	void UseItemHoldReleased();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryNew">();
	}
	static class UInventoryNew* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryNew>();
	}
};
static_assert(alignof(UInventoryNew) == 0x000008, "Wrong alignment on UInventoryNew");
static_assert(sizeof(UInventoryNew) == 0x0013C8, "Wrong size on UInventoryNew");
static_assert(offsetof(UInventoryNew, CanvasPanel) == 0x0002C8, "Member 'UInventoryNew::CanvasPanel' has a wrong offset!");
static_assert(offsetof(UInventoryNew, EquipmentWidget) == 0x0002D0, "Member 'UInventoryNew::EquipmentWidget' has a wrong offset!");
static_assert(offsetof(UInventoryNew, QuickPanel) == 0x0002D8, "Member 'UInventoryNew::QuickPanel' has a wrong offset!");
static_assert(offsetof(UInventoryNew, InventoryWidget) == 0x0002E0, "Member 'UInventoryNew::InventoryWidget' has a wrong offset!");
static_assert(offsetof(UInventoryNew, CurrSelectedItem) == 0x0002E8, "Member 'UInventoryNew::CurrSelectedItem' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HoveredItem) == 0x0002F0, "Member 'UInventoryNew::HoveredItem' has a wrong offset!");
static_assert(offsetof(UInventoryNew, CurrClickedItem) == 0x0002F8, "Member 'UInventoryNew::CurrClickedItem' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ItemTooltip) == 0x000300, "Member 'UInventoryNew::ItemTooltip' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ItemCompareWidget) == 0x000308, "Member 'UInventoryNew::ItemCompareWidget' has a wrong offset!");
static_assert(offsetof(UInventoryNew, TakeAllIcon) == 0x000310, "Member 'UInventoryNew::TakeAllIcon' has a wrong offset!");
static_assert(offsetof(UInventoryNew, LootSeparator) == 0x000318, "Member 'UInventoryNew::LootSeparator' has a wrong offset!");
static_assert(offsetof(UInventoryNew, LootGridWidget) == 0x000320, "Member 'UInventoryNew::LootGridWidget' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ButtonTakeAllItems) == 0x000328, "Member 'UInventoryNew::ButtonTakeAllItems' has a wrong offset!");
static_assert(offsetof(UInventoryNew, DropZone) == 0x000330, "Member 'UInventoryNew::DropZone' has a wrong offset!");
static_assert(offsetof(UInventoryNew, RejectDropZoneInventory) == 0x000338, "Member 'UInventoryNew::RejectDropZoneInventory' has a wrong offset!");
static_assert(offsetof(UInventoryNew, RejectDropZoneEquipment) == 0x000340, "Member 'UInventoryNew::RejectDropZoneEquipment' has a wrong offset!");
static_assert(offsetof(UInventoryNew, RejectDropZoneLootSmall) == 0x000348, "Member 'UInventoryNew::RejectDropZoneLootSmall' has a wrong offset!");
static_assert(offsetof(UInventoryNew, RejectDropZoneLootBig) == 0x000350, "Member 'UInventoryNew::RejectDropZoneLootBig' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ContextualDropZone) == 0x000358, "Member 'UInventoryNew::ContextualDropZone' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintsOverlay) == 0x000360, "Member 'UInventoryNew::HintsOverlay' has a wrong offset!");
static_assert(offsetof(UInventoryNew, SafeZoneOverlay) == 0x000368, "Member 'UInventoryNew::SafeZoneOverlay' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintToggleEquipment) == 0x000370, "Member 'UInventoryNew::HintToggleEquipment' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintToggleDescription) == 0x000378, "Member 'UInventoryNew::HintToggleDescription' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintToggleAutoComparing) == 0x000380, "Member 'UInventoryNew::HintToggleAutoComparing' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintClose) == 0x000388, "Member 'UInventoryNew::HintClose' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintBack) == 0x000390, "Member 'UInventoryNew::HintBack' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintUseItem) == 0x000398, "Member 'UInventoryNew::HintUseItem' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintEquip) == 0x0003A0, "Member 'UInventoryNew::HintEquip' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintMoveToBackpack) == 0x0003A8, "Member 'UInventoryNew::HintMoveToBackpack' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintRemoveAttach) == 0x0003B0, "Member 'UInventoryNew::HintRemoveAttach' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintUnload) == 0x0003B8, "Member 'UInventoryNew::HintUnload' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintChangeCompareItemHint) == 0x0003C0, "Member 'UInventoryNew::HintChangeCompareItemHint' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintDropItem) == 0x0003C8, "Member 'UInventoryNew::HintDropItem' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintLootTakeItem) == 0x0003D0, "Member 'UInventoryNew::HintLootTakeItem' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintLootPutDown) == 0x0003D8, "Member 'UInventoryNew::HintLootPutDown' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintLootTakeAllOther) == 0x0003E0, "Member 'UInventoryNew::HintLootTakeAllOther' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintLootTakeAllPlayerStash) == 0x0003E8, "Member 'UInventoryNew::HintLootTakeAllPlayerStash' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintSortInventory) == 0x0003F0, "Member 'UInventoryNew::HintSortInventory' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintShowContextualMenu) == 0x0003F8, "Member 'UInventoryNew::HintShowContextualMenu' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintMoveItem) == 0x000400, "Member 'UInventoryNew::HintMoveItem' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintPlaceItem) == 0x000408, "Member 'UInventoryNew::HintPlaceItem' has a wrong offset!");
static_assert(offsetof(UInventoryNew, HintRemoveQuickAccess) == 0x000410, "Member 'UInventoryNew::HintRemoveQuickAccess' has a wrong offset!");
static_assert(offsetof(UInventoryNew, UseItemHoldTime) == 0x000420, "Member 'UInventoryNew::UseItemHoldTime' has a wrong offset!");
static_assert(offsetof(UInventoryNew, DropItemHoldTime) == 0x000424, "Member 'UInventoryNew::DropItemHoldTime' has a wrong offset!");
static_assert(offsetof(UInventoryNew, UpgradeMenu) == 0x000428, "Member 'UInventoryNew::UpgradeMenu' has a wrong offset!");
static_assert(offsetof(UInventoryNew, SortButton) == 0x000430, "Member 'UInventoryNew::SortButton' has a wrong offset!");
static_assert(offsetof(UInventoryNew, LootOverlay) == 0x000438, "Member 'UInventoryNew::LootOverlay' has a wrong offset!");
static_assert(offsetof(UInventoryNew, IconTakeAllItems) == 0x000440, "Member 'UInventoryNew::IconTakeAllItems' has a wrong offset!");
static_assert(offsetof(UInventoryNew, TooltipAndHintsPadding) == 0x000448, "Member 'UInventoryNew::TooltipAndHintsPadding' has a wrong offset!");
static_assert(offsetof(UInventoryNew, VisibleStateHints) == 0x000450, "Member 'UInventoryNew::VisibleStateHints' has a wrong offset!");
static_assert(offsetof(UInventoryNew, CommonHints) == 0x000460, "Member 'UInventoryNew::CommonHints' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ItemTypeSwitchValue) == 0x000478, "Member 'UInventoryNew::ItemTypeSwitchValue' has a wrong offset!");
static_assert(offsetof(UInventoryNew, TooltipDistance) == 0x000480, "Member 'UInventoryNew::TooltipDistance' has a wrong offset!");
static_assert(offsetof(UInventoryNew, GridVisibilityMap) == 0x000488, "Member 'UInventoryNew::GridVisibilityMap' has a wrong offset!");
static_assert(offsetof(UInventoryNew, CurrGamepadNavigatedWidget) == 0x000508, "Member 'UInventoryNew::CurrGamepadNavigatedWidget' has a wrong offset!");
static_assert(offsetof(UInventoryNew, DragWidget) == 0x000520, "Member 'UInventoryNew::DragWidget' has a wrong offset!");
static_assert(offsetof(UInventoryNew, DragWidgetGrid) == 0x000528, "Member 'UInventoryNew::DragWidgetGrid' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ItemTooltipShowDelay) == 0x000530, "Member 'UInventoryNew::ItemTooltipShowDelay' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ItemTooltipCompareShowDelay) == 0x000534, "Member 'UInventoryNew::ItemTooltipCompareShowDelay' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ItemTooltipClass) == 0x000538, "Member 'UInventoryNew::ItemTooltipClass' has a wrong offset!");
static_assert(offsetof(UInventoryNew, DragWidgetClass) == 0x000540, "Member 'UInventoryNew::DragWidgetClass' has a wrong offset!");
static_assert(offsetof(UInventoryNew, DragGridWidgetClass) == 0x000548, "Member 'UInventoryNew::DragGridWidgetClass' has a wrong offset!");
static_assert(offsetof(UInventoryNew, StackSplitWidgetClass) == 0x000550, "Member 'UInventoryNew::StackSplitWidgetClass' has a wrong offset!");
static_assert(offsetof(UInventoryNew, StackSplitContextual) == 0x000558, "Member 'UInventoryNew::StackSplitContextual' has a wrong offset!");
static_assert(offsetof(UInventoryNew, StackSplit) == 0x000560, "Member 'UInventoryNew::StackSplit' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ItemBacktDefault) == 0x000568, "Member 'UInventoryNew::ItemBacktDefault' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ItemBackOk) == 0x000578, "Member 'UInventoryNew::ItemBackOk' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ItemBackInterceptOne) == 0x000588, "Member 'UInventoryNew::ItemBackInterceptOne' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ItemBackInterceptTwo) == 0x000598, "Member 'UInventoryNew::ItemBackInterceptTwo' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ItemBackDepend) == 0x0005A8, "Member 'UInventoryNew::ItemBackDepend' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ItemBackHoveredCompatible) == 0x0005B8, "Member 'UInventoryNew::ItemBackHoveredCompatible' has a wrong offset!");
static_assert(offsetof(UInventoryNew, GamepadNavigationThreshold) == 0x0005D8, "Member 'UInventoryNew::GamepadNavigationThreshold' has a wrong offset!");
static_assert(offsetof(UInventoryNew, RadiationMark) == 0x0005E0, "Member 'UInventoryNew::RadiationMark' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ToggleEquipmentIconColor) == 0x0005E8, "Member 'UInventoryNew::ToggleEquipmentIconColor' has a wrong offset!");
static_assert(offsetof(UInventoryNew, OverWeightColor) == 0x0005F8, "Member 'UInventoryNew::OverWeightColor' has a wrong offset!");
static_assert(offsetof(UInventoryNew, NormalWeightColor) == 0x000608, "Member 'UInventoryNew::NormalWeightColor' has a wrong offset!");
static_assert(offsetof(UInventoryNew, RightClickMenuWidget) == 0x000648, "Member 'UInventoryNew::RightClickMenuWidget' has a wrong offset!");
static_assert(offsetof(UInventoryNew, ItemSlotStartedDrag) == 0x0006B8, "Member 'UInventoryNew::ItemSlotStartedDrag' has a wrong offset!");
static_assert(offsetof(UInventoryNew, CurrGamepadSelectedItem) == 0x0006C0, "Member 'UInventoryNew::CurrGamepadSelectedItem' has a wrong offset!");
static_assert(offsetof(UInventoryNew, CurrentCompareSlot) == 0x000710, "Member 'UInventoryNew::CurrentCompareSlot' has a wrong offset!");
static_assert(offsetof(UInventoryNew, EquipmentSlotToCompare) == 0x000718, "Member 'UInventoryNew::EquipmentSlotToCompare' has a wrong offset!");
static_assert(offsetof(UInventoryNew, CurrentCompareItemSlotType) == 0x000720, "Member 'UInventoryNew::CurrentCompareItemSlotType' has a wrong offset!");
static_assert(offsetof(UInventoryNew, GridSlotsPool) == 0x000C20, "Member 'UInventoryNew::GridSlotsPool' has a wrong offset!");

// Class Stalker2.ItemAppearanceComponent
// 0x02A8 (0x0360 - 0x00B8)
class UItemAppearanceComponent final : public UUIDActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 WeaponMeshInHands;                                 // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 WeaponMeshUnequipped;                              // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SecondaryItemInHands;                              // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 ShootingAttachMesh;                                // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                SilencerRTPCParameter;                             // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                FireIntervalRTPCParameter;                         // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                MechModulatorRTPCParameter;                        // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          LastBulletInClipEvent;                             // 0x0100(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          ShellSoundEvent;                                   // 0x0108(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         WeaponTypeSwitch;                                  // 0x0110(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          WeaponJamEvent;                                    // 0x0118(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           WeaponAkComponent;                                 // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          KnifeLightAttackImpactEvent;                       // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          KnifeHeavyAttackImpactEvent;                       // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0xC0];                                     // 0x0138(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponAttachMeshesData                WeaponInHandsAttachesData;                         // 0x01F8(0x0080)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FWeaponAttachMeshesData                ShadowAttachesData;                                // 0x0278(0x0080)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x60];                                     // 0x02F8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleCallbackHandler*               CollisionHandler;                                  // 0x0358(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnShotSoundStart(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAppearanceComponent">();
	}
	static class UItemAppearanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAppearanceComponent>();
	}
};
static_assert(alignof(UItemAppearanceComponent) == 0x000008, "Wrong alignment on UItemAppearanceComponent");
static_assert(sizeof(UItemAppearanceComponent) == 0x000360, "Wrong size on UItemAppearanceComponent");
static_assert(offsetof(UItemAppearanceComponent, WeaponMeshInHands) == 0x0000C8, "Member 'UItemAppearanceComponent::WeaponMeshInHands' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, WeaponMeshUnequipped) == 0x0000D0, "Member 'UItemAppearanceComponent::WeaponMeshUnequipped' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, SecondaryItemInHands) == 0x0000D8, "Member 'UItemAppearanceComponent::SecondaryItemInHands' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, ShootingAttachMesh) == 0x0000E0, "Member 'UItemAppearanceComponent::ShootingAttachMesh' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, SilencerRTPCParameter) == 0x0000E8, "Member 'UItemAppearanceComponent::SilencerRTPCParameter' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, FireIntervalRTPCParameter) == 0x0000F0, "Member 'UItemAppearanceComponent::FireIntervalRTPCParameter' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, MechModulatorRTPCParameter) == 0x0000F8, "Member 'UItemAppearanceComponent::MechModulatorRTPCParameter' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, LastBulletInClipEvent) == 0x000100, "Member 'UItemAppearanceComponent::LastBulletInClipEvent' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, ShellSoundEvent) == 0x000108, "Member 'UItemAppearanceComponent::ShellSoundEvent' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, WeaponTypeSwitch) == 0x000110, "Member 'UItemAppearanceComponent::WeaponTypeSwitch' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, WeaponJamEvent) == 0x000118, "Member 'UItemAppearanceComponent::WeaponJamEvent' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, WeaponAkComponent) == 0x000120, "Member 'UItemAppearanceComponent::WeaponAkComponent' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, KnifeLightAttackImpactEvent) == 0x000128, "Member 'UItemAppearanceComponent::KnifeLightAttackImpactEvent' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, KnifeHeavyAttackImpactEvent) == 0x000130, "Member 'UItemAppearanceComponent::KnifeHeavyAttackImpactEvent' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, WeaponInHandsAttachesData) == 0x0001F8, "Member 'UItemAppearanceComponent::WeaponInHandsAttachesData' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, ShadowAttachesData) == 0x000278, "Member 'UItemAppearanceComponent::ShadowAttachesData' has a wrong offset!");
static_assert(offsetof(UItemAppearanceComponent, CollisionHandler) == 0x000358, "Member 'UItemAppearanceComponent::CollisionHandler' has a wrong offset!");

// Class Stalker2.ItemCompareWidget
// 0x0050 (0x02C8 - 0x0278)
class UItemCompareWidget final : public UWidgetBase
{
public:
	class UItemInfo*                              PrimaryItemInfo;                                   // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemInfo*                              SecondaryItemInfo;                                 // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemEquippedWidget*                    ItemEquippedWidget;                                // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ToggleAnimation;                                   // 0x0290(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimationPlayRate;                                 // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PrimaryWeaponSID;                                  // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SecondaryWeaponSID;                                // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetItemEquippedData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCompareWidget">();
	}
	static class UItemCompareWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCompareWidget>();
	}
};
static_assert(alignof(UItemCompareWidget) == 0x000008, "Wrong alignment on UItemCompareWidget");
static_assert(sizeof(UItemCompareWidget) == 0x0002C8, "Wrong size on UItemCompareWidget");
static_assert(offsetof(UItemCompareWidget, PrimaryItemInfo) == 0x000278, "Member 'UItemCompareWidget::PrimaryItemInfo' has a wrong offset!");
static_assert(offsetof(UItemCompareWidget, SecondaryItemInfo) == 0x000280, "Member 'UItemCompareWidget::SecondaryItemInfo' has a wrong offset!");
static_assert(offsetof(UItemCompareWidget, ItemEquippedWidget) == 0x000288, "Member 'UItemCompareWidget::ItemEquippedWidget' has a wrong offset!");
static_assert(offsetof(UItemCompareWidget, ToggleAnimation) == 0x000290, "Member 'UItemCompareWidget::ToggleAnimation' has a wrong offset!");
static_assert(offsetof(UItemCompareWidget, AnimationPlayRate) == 0x000298, "Member 'UItemCompareWidget::AnimationPlayRate' has a wrong offset!");
static_assert(offsetof(UItemCompareWidget, PrimaryWeaponSID) == 0x0002A0, "Member 'UItemCompareWidget::PrimaryWeaponSID' has a wrong offset!");
static_assert(offsetof(UItemCompareWidget, SecondaryWeaponSID) == 0x0002B0, "Member 'UItemCompareWidget::SecondaryWeaponSID' has a wrong offset!");

// Class Stalker2.ItemContainerHoldComponent
// 0x0020 (0x0250 - 0x0230)
class UItemContainerHoldComponent final : public UHoldComponent
{
public:
	uint8                                         Pad_230[0x20];                                     // 0x0230(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemContainerHoldComponent">();
	}
	static class UItemContainerHoldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemContainerHoldComponent>();
	}
};
static_assert(alignof(UItemContainerHoldComponent) == 0x000008, "Wrong alignment on UItemContainerHoldComponent");
static_assert(sizeof(UItemContainerHoldComponent) == 0x000250, "Wrong size on UItemContainerHoldComponent");

// Class Stalker2.ItemDragWidget
// 0x0070 (0x0480 - 0x0410)
class UItemDragWidget final : public UItemSlotBaseWidget
{
public:
	class USizeBox*                               ItemImageSizeBox;                                  // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Background;                                        // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                Border;                                            // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x50];                                     // 0x0428(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnEquipSlot;                                   // 0x0478(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDragWidget">();
	}
	static class UItemDragWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemDragWidget>();
	}
};
static_assert(alignof(UItemDragWidget) == 0x000010, "Wrong alignment on UItemDragWidget");
static_assert(sizeof(UItemDragWidget) == 0x000480, "Wrong size on UItemDragWidget");
static_assert(offsetof(UItemDragWidget, ItemImageSizeBox) == 0x000410, "Member 'UItemDragWidget::ItemImageSizeBox' has a wrong offset!");
static_assert(offsetof(UItemDragWidget, Background) == 0x000418, "Member 'UItemDragWidget::Background' has a wrong offset!");
static_assert(offsetof(UItemDragWidget, Border) == 0x000420, "Member 'UItemDragWidget::Border' has a wrong offset!");
static_assert(offsetof(UItemDragWidget, ReturnEquipSlot) == 0x000478, "Member 'UItemDragWidget::ReturnEquipSlot' has a wrong offset!");

// Class Stalker2.ItemEquippedWidget
// 0x0028 (0x02A0 - 0x0278)
class UItemEquippedWidget final : public UWidgetBase
{
public:
	class UImage*                                 SwapIcon;                                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeaponTextBox;                                     // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             EquippedTextBox;                                   // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 EquippedSID;                                       // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemEquippedWidget">();
	}
	static class UItemEquippedWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemEquippedWidget>();
	}
};
static_assert(alignof(UItemEquippedWidget) == 0x000008, "Wrong alignment on UItemEquippedWidget");
static_assert(sizeof(UItemEquippedWidget) == 0x0002A0, "Wrong size on UItemEquippedWidget");
static_assert(offsetof(UItemEquippedWidget, SwapIcon) == 0x000278, "Member 'UItemEquippedWidget::SwapIcon' has a wrong offset!");
static_assert(offsetof(UItemEquippedWidget, WeaponTextBox) == 0x000280, "Member 'UItemEquippedWidget::WeaponTextBox' has a wrong offset!");
static_assert(offsetof(UItemEquippedWidget, EquippedTextBox) == 0x000288, "Member 'UItemEquippedWidget::EquippedTextBox' has a wrong offset!");
static_assert(offsetof(UItemEquippedWidget, EquippedSID) == 0x000290, "Member 'UItemEquippedWidget::EquippedSID' has a wrong offset!");

// Class Stalker2.ItemGiveComponent
// 0x0010 (0x00B0 - 0x00A0)
class UItemGiveComponent final : public UActorComponent
{
public:
	TArray<struct FInteractObjectData>            ObjectsToGive;                                     // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void ProvideItems();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemGiveComponent">();
	}
	static class UItemGiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemGiveComponent>();
	}
};
static_assert(alignof(UItemGiveComponent) == 0x000008, "Wrong alignment on UItemGiveComponent");
static_assert(sizeof(UItemGiveComponent) == 0x0000B0, "Wrong size on UItemGiveComponent");
static_assert(offsetof(UItemGiveComponent, ObjectsToGive) == 0x0000A0, "Member 'UItemGiveComponent::ObjectsToGive' has a wrong offset!");

// Class Stalker2.OptimizationSettings
// 0x0020 (0x0048 - 0x0028)
class UOptimizationSettings final : public UObject
{
public:
	bool                                          bPSOWarmupStarted;                                 // 0x0028(0x0001)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReloadPrototypes;                                 // 0x0029(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SoftMemoryThresholdMultiplier;                     // 0x002C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StreamingDistanceMemoryMultiplier;                 // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StreamingDistanceModifierLimit;                    // 0x0034(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MemoryThresholdMultiplierToStartHighPriorityNavMeshLoading; // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AfkTimeout;                                        // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaterTraceDistanceTolerance;                       // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlwaysCleanXSSViews;                              // 0x0044(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimizationSettings">();
	}
	static class UOptimizationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimizationSettings>();
	}
};
static_assert(alignof(UOptimizationSettings) == 0x000008, "Wrong alignment on UOptimizationSettings");
static_assert(sizeof(UOptimizationSettings) == 0x000048, "Wrong size on UOptimizationSettings");
static_assert(offsetof(UOptimizationSettings, bPSOWarmupStarted) == 0x000028, "Member 'UOptimizationSettings::bPSOWarmupStarted' has a wrong offset!");
static_assert(offsetof(UOptimizationSettings, bReloadPrototypes) == 0x000029, "Member 'UOptimizationSettings::bReloadPrototypes' has a wrong offset!");
static_assert(offsetof(UOptimizationSettings, SoftMemoryThresholdMultiplier) == 0x00002C, "Member 'UOptimizationSettings::SoftMemoryThresholdMultiplier' has a wrong offset!");
static_assert(offsetof(UOptimizationSettings, StreamingDistanceMemoryMultiplier) == 0x000030, "Member 'UOptimizationSettings::StreamingDistanceMemoryMultiplier' has a wrong offset!");
static_assert(offsetof(UOptimizationSettings, StreamingDistanceModifierLimit) == 0x000034, "Member 'UOptimizationSettings::StreamingDistanceModifierLimit' has a wrong offset!");
static_assert(offsetof(UOptimizationSettings, MemoryThresholdMultiplierToStartHighPriorityNavMeshLoading) == 0x000038, "Member 'UOptimizationSettings::MemoryThresholdMultiplierToStartHighPriorityNavMeshLoading' has a wrong offset!");
static_assert(offsetof(UOptimizationSettings, AfkTimeout) == 0x00003C, "Member 'UOptimizationSettings::AfkTimeout' has a wrong offset!");
static_assert(offsetof(UOptimizationSettings, WaterTraceDistanceTolerance) == 0x000040, "Member 'UOptimizationSettings::WaterTraceDistanceTolerance' has a wrong offset!");
static_assert(offsetof(UOptimizationSettings, bAlwaysCleanXSSViews) == 0x000044, "Member 'UOptimizationSettings::bAlwaysCleanXSSViews' has a wrong offset!");

// Class Stalker2.ItemInfo
// 0x0AD8 (0x0D50 - 0x0278)
class UItemInfo final : public UWidgetBase
{
public:
	class UImage*                                 FullBackCenter;                                    // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            HeaderText;                                        // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            DurabilityText;                                    // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            CaliberText;                                       // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            ModeText;                                          // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            MagazineText;                                      // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            Price;                                             // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            DurabilityPercentText;                             // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URichTextWidget*                        FittingWeaponsRichText;                            // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               FittingWeaponsBox;                                 // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URichTextWidget*                        AmmoTypeRichText;                                  // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               AmmoTypeBox;                                       // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress1;                                 // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress2;                                 // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress3;                                 // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress4;                                 // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress5;                                 // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress6;                                 // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress7;                                 // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress8;                                 // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 FullBackTitle;                                     // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Single;                                            // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Dualshot;                                          // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Burst;                                             // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Auto;                                              // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            AmmoName;                                          // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            MagSize;                                           // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            Weight;                                            // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            ItemDescription;                                   // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           ItemStatValueBox;                                  // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         ArmorValuesBox;                                    // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         ArtContainersBox;                                  // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            ArtCount;                                          // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           FireTypesBox;                                      // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 SplitterLeft;                                      // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 SplitterRight;                                     // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           AmmoBox;                                           // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           MagBox;                                            // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         WeightBox;                                         // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               DurabilityOverlay;                                 // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProgressBar*                           Durability;                                        // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 DurabilityBackground;                              // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       RadiationMark;                                     // 0x03C8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageAttach;                                       // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               EquipmentMarkOverlay;                              // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            BlueprintIndicatorText;                            // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               ItemInfoBox;                                       // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EItemType, class UTexture2D*>            ItemTypeBackgroundMapping;                         // 0x03F0(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UTexture2D*                             FallbackHeaderBackground;                          // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemStatValue>             ItemInfoWidgetClass;                               // 0x0448(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemStatValue>             ArmorAdditionalEffectWidgetClass;                  // 0x0450(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProgressBarStyle                      DurabilityStyle;                                   // 0x0460(0x02F0)(Transient, NativeAccessSpecifierPublic)
	struct FSlateBrush                            BackgroundDurabilityImage;                         // 0x0750(0x00F0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ZeroDurabilityFillImage;                           // 0x0840(0x00F0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LowDurabilityFillImage;                            // 0x0930(0x00F0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            MidDurabilityFillImage;                            // 0x0A20(0x00F0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            FullDurabilityFillImage;                           // 0x0B10(0x00F0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             DamageIcon;                                        // 0x0C00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PenetrationIcon;                                   // 0x0C08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FireRateIcon;                                      // 0x0C10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DistanceIcon;                                      // 0x0C18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             AccuracyIcon;                                      // 0x0C20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             RadiationArmorIcon;                                // 0x0C28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PhysicalArmorIcon;                                 // 0x0C30(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PsyArmorIcon;                                      // 0x0C38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ChemicalArmorIcon;                                 // 0x0C40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ElectoArmorIcon;                                   // 0x0C48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FireArmorIcon;                                     // 0x0C50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             GrenadeRangeIcom;                                  // 0x0C58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C60[0x58];                                     // 0x0C60(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UItemStatValue*>                 ItemStatValueArray;                                // 0x0CB8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        EffectDurationIcon;                                // 0x0CC8(0x0020)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CE8[0x50];                                     // 0x0CE8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EEffectType>                           IncludeArmorAdditionalEffects;                     // 0x0D38(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D48[0x8];                                      // 0x0D48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemInfo">();
	}
	static class UItemInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemInfo>();
	}
};
static_assert(alignof(UItemInfo) == 0x000010, "Wrong alignment on UItemInfo");
static_assert(sizeof(UItemInfo) == 0x000D50, "Wrong size on UItemInfo");
static_assert(offsetof(UItemInfo, FullBackCenter) == 0x000278, "Member 'UItemInfo::FullBackCenter' has a wrong offset!");
static_assert(offsetof(UItemInfo, HeaderText) == 0x000280, "Member 'UItemInfo::HeaderText' has a wrong offset!");
static_assert(offsetof(UItemInfo, DurabilityText) == 0x000288, "Member 'UItemInfo::DurabilityText' has a wrong offset!");
static_assert(offsetof(UItemInfo, CaliberText) == 0x000290, "Member 'UItemInfo::CaliberText' has a wrong offset!");
static_assert(offsetof(UItemInfo, ModeText) == 0x000298, "Member 'UItemInfo::ModeText' has a wrong offset!");
static_assert(offsetof(UItemInfo, MagazineText) == 0x0002A0, "Member 'UItemInfo::MagazineText' has a wrong offset!");
static_assert(offsetof(UItemInfo, Price) == 0x0002A8, "Member 'UItemInfo::Price' has a wrong offset!");
static_assert(offsetof(UItemInfo, DurabilityPercentText) == 0x0002B0, "Member 'UItemInfo::DurabilityPercentText' has a wrong offset!");
static_assert(offsetof(UItemInfo, FittingWeaponsRichText) == 0x0002B8, "Member 'UItemInfo::FittingWeaponsRichText' has a wrong offset!");
static_assert(offsetof(UItemInfo, FittingWeaponsBox) == 0x0002C0, "Member 'UItemInfo::FittingWeaponsBox' has a wrong offset!");
static_assert(offsetof(UItemInfo, AmmoTypeRichText) == 0x0002C8, "Member 'UItemInfo::AmmoTypeRichText' has a wrong offset!");
static_assert(offsetof(UItemInfo, AmmoTypeBox) == 0x0002D0, "Member 'UItemInfo::AmmoTypeBox' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemStatProgress1) == 0x0002D8, "Member 'UItemInfo::ItemStatProgress1' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemStatProgress2) == 0x0002E0, "Member 'UItemInfo::ItemStatProgress2' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemStatProgress3) == 0x0002E8, "Member 'UItemInfo::ItemStatProgress3' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemStatProgress4) == 0x0002F0, "Member 'UItemInfo::ItemStatProgress4' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemStatProgress5) == 0x0002F8, "Member 'UItemInfo::ItemStatProgress5' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemStatProgress6) == 0x000300, "Member 'UItemInfo::ItemStatProgress6' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemStatProgress7) == 0x000308, "Member 'UItemInfo::ItemStatProgress7' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemStatProgress8) == 0x000310, "Member 'UItemInfo::ItemStatProgress8' has a wrong offset!");
static_assert(offsetof(UItemInfo, FullBackTitle) == 0x000318, "Member 'UItemInfo::FullBackTitle' has a wrong offset!");
static_assert(offsetof(UItemInfo, Single) == 0x000320, "Member 'UItemInfo::Single' has a wrong offset!");
static_assert(offsetof(UItemInfo, Dualshot) == 0x000328, "Member 'UItemInfo::Dualshot' has a wrong offset!");
static_assert(offsetof(UItemInfo, Burst) == 0x000330, "Member 'UItemInfo::Burst' has a wrong offset!");
static_assert(offsetof(UItemInfo, Auto) == 0x000338, "Member 'UItemInfo::Auto' has a wrong offset!");
static_assert(offsetof(UItemInfo, AmmoName) == 0x000340, "Member 'UItemInfo::AmmoName' has a wrong offset!");
static_assert(offsetof(UItemInfo, MagSize) == 0x000348, "Member 'UItemInfo::MagSize' has a wrong offset!");
static_assert(offsetof(UItemInfo, Weight) == 0x000350, "Member 'UItemInfo::Weight' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemDescription) == 0x000358, "Member 'UItemInfo::ItemDescription' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemStatValueBox) == 0x000360, "Member 'UItemInfo::ItemStatValueBox' has a wrong offset!");
static_assert(offsetof(UItemInfo, ArmorValuesBox) == 0x000368, "Member 'UItemInfo::ArmorValuesBox' has a wrong offset!");
static_assert(offsetof(UItemInfo, ArtContainersBox) == 0x000370, "Member 'UItemInfo::ArtContainersBox' has a wrong offset!");
static_assert(offsetof(UItemInfo, ArtCount) == 0x000378, "Member 'UItemInfo::ArtCount' has a wrong offset!");
static_assert(offsetof(UItemInfo, FireTypesBox) == 0x000380, "Member 'UItemInfo::FireTypesBox' has a wrong offset!");
static_assert(offsetof(UItemInfo, SplitterLeft) == 0x000388, "Member 'UItemInfo::SplitterLeft' has a wrong offset!");
static_assert(offsetof(UItemInfo, SplitterRight) == 0x000390, "Member 'UItemInfo::SplitterRight' has a wrong offset!");
static_assert(offsetof(UItemInfo, AmmoBox) == 0x000398, "Member 'UItemInfo::AmmoBox' has a wrong offset!");
static_assert(offsetof(UItemInfo, MagBox) == 0x0003A0, "Member 'UItemInfo::MagBox' has a wrong offset!");
static_assert(offsetof(UItemInfo, WeightBox) == 0x0003A8, "Member 'UItemInfo::WeightBox' has a wrong offset!");
static_assert(offsetof(UItemInfo, DurabilityOverlay) == 0x0003B0, "Member 'UItemInfo::DurabilityOverlay' has a wrong offset!");
static_assert(offsetof(UItemInfo, Durability) == 0x0003B8, "Member 'UItemInfo::Durability' has a wrong offset!");
static_assert(offsetof(UItemInfo, DurabilityBackground) == 0x0003C0, "Member 'UItemInfo::DurabilityBackground' has a wrong offset!");
static_assert(offsetof(UItemInfo, RadiationMark) == 0x0003C8, "Member 'UItemInfo::RadiationMark' has a wrong offset!");
static_assert(offsetof(UItemInfo, ImageAttach) == 0x0003D0, "Member 'UItemInfo::ImageAttach' has a wrong offset!");
static_assert(offsetof(UItemInfo, EquipmentMarkOverlay) == 0x0003D8, "Member 'UItemInfo::EquipmentMarkOverlay' has a wrong offset!");
static_assert(offsetof(UItemInfo, BlueprintIndicatorText) == 0x0003E0, "Member 'UItemInfo::BlueprintIndicatorText' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemInfoBox) == 0x0003E8, "Member 'UItemInfo::ItemInfoBox' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemTypeBackgroundMapping) == 0x0003F0, "Member 'UItemInfo::ItemTypeBackgroundMapping' has a wrong offset!");
static_assert(offsetof(UItemInfo, FallbackHeaderBackground) == 0x000440, "Member 'UItemInfo::FallbackHeaderBackground' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemInfoWidgetClass) == 0x000448, "Member 'UItemInfo::ItemInfoWidgetClass' has a wrong offset!");
static_assert(offsetof(UItemInfo, ArmorAdditionalEffectWidgetClass) == 0x000450, "Member 'UItemInfo::ArmorAdditionalEffectWidgetClass' has a wrong offset!");
static_assert(offsetof(UItemInfo, DurabilityStyle) == 0x000460, "Member 'UItemInfo::DurabilityStyle' has a wrong offset!");
static_assert(offsetof(UItemInfo, BackgroundDurabilityImage) == 0x000750, "Member 'UItemInfo::BackgroundDurabilityImage' has a wrong offset!");
static_assert(offsetof(UItemInfo, ZeroDurabilityFillImage) == 0x000840, "Member 'UItemInfo::ZeroDurabilityFillImage' has a wrong offset!");
static_assert(offsetof(UItemInfo, LowDurabilityFillImage) == 0x000930, "Member 'UItemInfo::LowDurabilityFillImage' has a wrong offset!");
static_assert(offsetof(UItemInfo, MidDurabilityFillImage) == 0x000A20, "Member 'UItemInfo::MidDurabilityFillImage' has a wrong offset!");
static_assert(offsetof(UItemInfo, FullDurabilityFillImage) == 0x000B10, "Member 'UItemInfo::FullDurabilityFillImage' has a wrong offset!");
static_assert(offsetof(UItemInfo, DamageIcon) == 0x000C00, "Member 'UItemInfo::DamageIcon' has a wrong offset!");
static_assert(offsetof(UItemInfo, PenetrationIcon) == 0x000C08, "Member 'UItemInfo::PenetrationIcon' has a wrong offset!");
static_assert(offsetof(UItemInfo, FireRateIcon) == 0x000C10, "Member 'UItemInfo::FireRateIcon' has a wrong offset!");
static_assert(offsetof(UItemInfo, DistanceIcon) == 0x000C18, "Member 'UItemInfo::DistanceIcon' has a wrong offset!");
static_assert(offsetof(UItemInfo, AccuracyIcon) == 0x000C20, "Member 'UItemInfo::AccuracyIcon' has a wrong offset!");
static_assert(offsetof(UItemInfo, RadiationArmorIcon) == 0x000C28, "Member 'UItemInfo::RadiationArmorIcon' has a wrong offset!");
static_assert(offsetof(UItemInfo, PhysicalArmorIcon) == 0x000C30, "Member 'UItemInfo::PhysicalArmorIcon' has a wrong offset!");
static_assert(offsetof(UItemInfo, PsyArmorIcon) == 0x000C38, "Member 'UItemInfo::PsyArmorIcon' has a wrong offset!");
static_assert(offsetof(UItemInfo, ChemicalArmorIcon) == 0x000C40, "Member 'UItemInfo::ChemicalArmorIcon' has a wrong offset!");
static_assert(offsetof(UItemInfo, ElectoArmorIcon) == 0x000C48, "Member 'UItemInfo::ElectoArmorIcon' has a wrong offset!");
static_assert(offsetof(UItemInfo, FireArmorIcon) == 0x000C50, "Member 'UItemInfo::FireArmorIcon' has a wrong offset!");
static_assert(offsetof(UItemInfo, GrenadeRangeIcom) == 0x000C58, "Member 'UItemInfo::GrenadeRangeIcom' has a wrong offset!");
static_assert(offsetof(UItemInfo, ItemStatValueArray) == 0x000CB8, "Member 'UItemInfo::ItemStatValueArray' has a wrong offset!");
static_assert(offsetof(UItemInfo, EffectDurationIcon) == 0x000CC8, "Member 'UItemInfo::EffectDurationIcon' has a wrong offset!");
static_assert(offsetof(UItemInfo, IncludeArmorAdditionalEffects) == 0x000D38, "Member 'UItemInfo::IncludeArmorAdditionalEffects' has a wrong offset!");

// Class Stalker2.SequenceComponent
// 0x0060 (0x0088 - 0x0028)
class USequenceComponent final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPreBlendCinematicComponent*            PreBlendCinematicComponent;                        // 0x0038(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x48];                                      // 0x0040(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSequenceFinished();
	void OnSequenceStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequenceComponent">();
	}
	static class USequenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequenceComponent>();
	}
};
static_assert(alignof(USequenceComponent) == 0x000008, "Wrong alignment on USequenceComponent");
static_assert(sizeof(USequenceComponent) == 0x000088, "Wrong size on USequenceComponent");
static_assert(offsetof(USequenceComponent, PreBlendCinematicComponent) == 0x000038, "Member 'USequenceComponent::PreBlendCinematicComponent' has a wrong offset!");

// Class Stalker2.ItemManager
// 0x0030 (0x00A8 - 0x0078)
class UItemManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x30];                                      // 0x0078(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemManager">();
	}
	static class UItemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemManager>();
	}
};
static_assert(alignof(UItemManager) == 0x000008, "Wrong alignment on UItemManager");
static_assert(sizeof(UItemManager) == 0x0000A8, "Wrong size on UItemManager");

// Class Stalker2.ItemSelectorAxisSelectionIPU
// 0x0000 (0x0040 - 0x0040)
class UItemSelectorAxisSelectionIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSelectorAxisSelectionIPU">();
	}
	static class UItemSelectorAxisSelectionIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSelectorAxisSelectionIPU>();
	}
};
static_assert(alignof(UItemSelectorAxisSelectionIPU) == 0x000008, "Wrong alignment on UItemSelectorAxisSelectionIPU");
static_assert(sizeof(UItemSelectorAxisSelectionIPU) == 0x000040, "Wrong size on UItemSelectorAxisSelectionIPU");

// Class Stalker2.NiagaraEyeAdaptationProvider
// 0x0008 (0x0108 - 0x0100)
class UNiagaraEyeAdaptationProvider final : public UNiagaraParameterProvider
{
public:
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraEyeAdaptationProvider">();
	}
	static class UNiagaraEyeAdaptationProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraEyeAdaptationProvider>();
	}
};
static_assert(alignof(UNiagaraEyeAdaptationProvider) == 0x000008, "Wrong alignment on UNiagaraEyeAdaptationProvider");
static_assert(sizeof(UNiagaraEyeAdaptationProvider) == 0x000108, "Wrong size on UNiagaraEyeAdaptationProvider");

// Class Stalker2.ItemSelectorSlotBase
// 0x0018 (0x0290 - 0x0278)
class UItemSelectorSlotBase : public UWidgetBase
{
public:
	class UImageWidget*                           WeaponIcon;                                        // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             AlternativeIconTexture;                            // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMainHandEquipmentType                        DisplaySlotType;                                   // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSelectorSlotBase">();
	}
	static class UItemSelectorSlotBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSelectorSlotBase>();
	}
};
static_assert(alignof(UItemSelectorSlotBase) == 0x000008, "Wrong alignment on UItemSelectorSlotBase");
static_assert(sizeof(UItemSelectorSlotBase) == 0x000290, "Wrong size on UItemSelectorSlotBase");
static_assert(offsetof(UItemSelectorSlotBase, WeaponIcon) == 0x000278, "Member 'UItemSelectorSlotBase::WeaponIcon' has a wrong offset!");
static_assert(offsetof(UItemSelectorSlotBase, AlternativeIconTexture) == 0x000280, "Member 'UItemSelectorSlotBase::AlternativeIconTexture' has a wrong offset!");
static_assert(offsetof(UItemSelectorSlotBase, DisplaySlotType) == 0x000288, "Member 'UItemSelectorSlotBase::DisplaySlotType' has a wrong offset!");

// Class Stalker2.ItemSelectorEquipSlot
// 0x0058 (0x02E8 - 0x0290)
class UItemSelectorEquipSlot final : public UItemSelectorSlotBase
{
public:
	class UOverlay*                               SlotHighlight;                                     // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               SlotHighlightWhite;                                // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               SlotSizeBox;                                       // 0x02A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InputActionName;                                   // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   HintSwitcher;                                      // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDpadNavigation                               DpadNavigation;                                    // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAvailable;                                      // 0x02C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2[0x2];                                      // 0x02C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IndexEquipSlot;                                    // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SlotSize;                                          // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FlipHintLetter;                                    // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0xF];                                      // 0x02D9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSelectorEquipSlot">();
	}
	static class UItemSelectorEquipSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSelectorEquipSlot>();
	}
};
static_assert(alignof(UItemSelectorEquipSlot) == 0x000008, "Wrong alignment on UItemSelectorEquipSlot");
static_assert(sizeof(UItemSelectorEquipSlot) == 0x0002E8, "Wrong size on UItemSelectorEquipSlot");
static_assert(offsetof(UItemSelectorEquipSlot, SlotHighlight) == 0x000290, "Member 'UItemSelectorEquipSlot::SlotHighlight' has a wrong offset!");
static_assert(offsetof(UItemSelectorEquipSlot, SlotHighlightWhite) == 0x000298, "Member 'UItemSelectorEquipSlot::SlotHighlightWhite' has a wrong offset!");
static_assert(offsetof(UItemSelectorEquipSlot, SlotSizeBox) == 0x0002A0, "Member 'UItemSelectorEquipSlot::SlotSizeBox' has a wrong offset!");
static_assert(offsetof(UItemSelectorEquipSlot, InputActionName) == 0x0002A8, "Member 'UItemSelectorEquipSlot::InputActionName' has a wrong offset!");
static_assert(offsetof(UItemSelectorEquipSlot, HintSwitcher) == 0x0002B8, "Member 'UItemSelectorEquipSlot::HintSwitcher' has a wrong offset!");
static_assert(offsetof(UItemSelectorEquipSlot, DpadNavigation) == 0x0002C0, "Member 'UItemSelectorEquipSlot::DpadNavigation' has a wrong offset!");
static_assert(offsetof(UItemSelectorEquipSlot, bIsAvailable) == 0x0002C1, "Member 'UItemSelectorEquipSlot::bIsAvailable' has a wrong offset!");
static_assert(offsetof(UItemSelectorEquipSlot, IndexEquipSlot) == 0x0002C4, "Member 'UItemSelectorEquipSlot::IndexEquipSlot' has a wrong offset!");
static_assert(offsetof(UItemSelectorEquipSlot, SlotSize) == 0x0002C8, "Member 'UItemSelectorEquipSlot::SlotSize' has a wrong offset!");
static_assert(offsetof(UItemSelectorEquipSlot, FlipHintLetter) == 0x0002D8, "Member 'UItemSelectorEquipSlot::FlipHintLetter' has a wrong offset!");

// Class Stalker2.ItemSelectorIPU
// 0x0000 (0x0058 - 0x0058)
class UItemSelectorIPU final : public UBehaviorBasedIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSelectorIPU">();
	}
	static class UItemSelectorIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSelectorIPU>();
	}
};
static_assert(alignof(UItemSelectorIPU) == 0x000008, "Wrong alignment on UItemSelectorIPU");
static_assert(sizeof(UItemSelectorIPU) == 0x000058, "Wrong size on UItemSelectorIPU");

// Class Stalker2.ItemSelectorView
// 0x0210 (0x04D8 - 0x02C8)
class UItemSelectorView final : public UViewBaseExtended
{
public:
	bool                                          bIsActive;                                         // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UImageWidget*                           AmmoIcon;                                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 AmmoIconSwipe;                                     // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 FireTypeIcon;                                      // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 GrenadeIcon;                                       // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 GrenadeIconSwipe;                                  // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 NavigateArrowLeftGrenade;                          // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 NavigateArrowRightGrenade;                         // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 NavigateArrowLeftAmmo;                             // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 NavigateArrowRightAmmo;                            // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            TextAmmoType;                                      // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        MidleSwitcher;                                     // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            TextShutType;                                      // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   ModeHintSwitcher;                                  // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   AmmoHintSwitcher;                                  // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   GrenadeHintSwitcher;                               // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                HintUseGuitar;                                     // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ItemSelectorChangeGrenade;                         // 0x0350(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ItemSelectorChangeAmmo;                            // 0x0358(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ItemSelectorChangeFireMode;                        // 0x0360(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ItemSelectorRestoreState;                          // 0x0368(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastChangeSlotTime;                                // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastChangeUpdateTime;                              // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputDelayTime;                                    // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemSelectorChangeAmmoSpeed;                       // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemSelectorChangeFireModeSpeed;                   // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemSelectorChangeGrenadeSpeed;                    // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMainHandEquipmentType                        DefoultSelectSlotType;                             // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldIgnoreEmptySlot;                            // 0x0389(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38A[0x6];                                      // 0x038A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EFireType, struct FFireTypeDisplayInfo>  FireTypesInfo;                                     // 0x0390(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UItemSelectorEquipSlot*                 SideSlotDetector;                                  // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemSelectorEquipSlot*                 SideSlotFlashlight;                                // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemSelectorEquipSlot*                 SideSlotUnarmed;                                   // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemSelectorEquipSlot*                 SideSlotLauncher;                                  // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemSelectorWeaponSlot*                SelectedSlot;                                      // 0x0400(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemSelectorWeaponSlot*                HoveredSlot;                                       // 0x0408(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemSelectorEquipSlot*                 SelectedEquipSlot;                                 // 0x0410(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x78];                                     // 0x0418(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemSelectorWeaponSlot*                HoveredSlotAtStartOfAnimation;                     // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x40];                                     // 0x0498(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeAmmoType();
	void ChangeFireType();
	TArray<class UItemSelectorWeaponSlot*> GetSlotsBP();
	void UIItemSelectorDetector();
	void UIItemSelectorFlashlight();
	void UIItemSelectorGrenadeLauncher();
	void UIItemSelectorUnarm();

	void ToggleAttachMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSelectorView">();
	}
	static class UItemSelectorView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSelectorView>();
	}
};
static_assert(alignof(UItemSelectorView) == 0x000008, "Wrong alignment on UItemSelectorView");
static_assert(sizeof(UItemSelectorView) == 0x0004D8, "Wrong size on UItemSelectorView");
static_assert(offsetof(UItemSelectorView, bIsActive) == 0x0002C8, "Member 'UItemSelectorView::bIsActive' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, AmmoIcon) == 0x0002D0, "Member 'UItemSelectorView::AmmoIcon' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, AmmoIconSwipe) == 0x0002D8, "Member 'UItemSelectorView::AmmoIconSwipe' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, FireTypeIcon) == 0x0002E0, "Member 'UItemSelectorView::FireTypeIcon' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, GrenadeIcon) == 0x0002E8, "Member 'UItemSelectorView::GrenadeIcon' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, GrenadeIconSwipe) == 0x0002F0, "Member 'UItemSelectorView::GrenadeIconSwipe' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, NavigateArrowLeftGrenade) == 0x0002F8, "Member 'UItemSelectorView::NavigateArrowLeftGrenade' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, NavigateArrowRightGrenade) == 0x000300, "Member 'UItemSelectorView::NavigateArrowRightGrenade' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, NavigateArrowLeftAmmo) == 0x000308, "Member 'UItemSelectorView::NavigateArrowLeftAmmo' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, NavigateArrowRightAmmo) == 0x000310, "Member 'UItemSelectorView::NavigateArrowRightAmmo' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, TextAmmoType) == 0x000318, "Member 'UItemSelectorView::TextAmmoType' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, MidleSwitcher) == 0x000320, "Member 'UItemSelectorView::MidleSwitcher' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, TextShutType) == 0x000328, "Member 'UItemSelectorView::TextShutType' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, ModeHintSwitcher) == 0x000330, "Member 'UItemSelectorView::ModeHintSwitcher' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, AmmoHintSwitcher) == 0x000338, "Member 'UItemSelectorView::AmmoHintSwitcher' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, GrenadeHintSwitcher) == 0x000340, "Member 'UItemSelectorView::GrenadeHintSwitcher' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, HintUseGuitar) == 0x000348, "Member 'UItemSelectorView::HintUseGuitar' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, ItemSelectorChangeGrenade) == 0x000350, "Member 'UItemSelectorView::ItemSelectorChangeGrenade' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, ItemSelectorChangeAmmo) == 0x000358, "Member 'UItemSelectorView::ItemSelectorChangeAmmo' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, ItemSelectorChangeFireMode) == 0x000360, "Member 'UItemSelectorView::ItemSelectorChangeFireMode' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, ItemSelectorRestoreState) == 0x000368, "Member 'UItemSelectorView::ItemSelectorRestoreState' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, FastChangeSlotTime) == 0x000370, "Member 'UItemSelectorView::FastChangeSlotTime' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, FastChangeUpdateTime) == 0x000374, "Member 'UItemSelectorView::FastChangeUpdateTime' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, InputDelayTime) == 0x000378, "Member 'UItemSelectorView::InputDelayTime' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, ItemSelectorChangeAmmoSpeed) == 0x00037C, "Member 'UItemSelectorView::ItemSelectorChangeAmmoSpeed' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, ItemSelectorChangeFireModeSpeed) == 0x000380, "Member 'UItemSelectorView::ItemSelectorChangeFireModeSpeed' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, ItemSelectorChangeGrenadeSpeed) == 0x000384, "Member 'UItemSelectorView::ItemSelectorChangeGrenadeSpeed' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, DefoultSelectSlotType) == 0x000388, "Member 'UItemSelectorView::DefoultSelectSlotType' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, bShouldIgnoreEmptySlot) == 0x000389, "Member 'UItemSelectorView::bShouldIgnoreEmptySlot' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, FireTypesInfo) == 0x000390, "Member 'UItemSelectorView::FireTypesInfo' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, SideSlotDetector) == 0x0003E0, "Member 'UItemSelectorView::SideSlotDetector' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, SideSlotFlashlight) == 0x0003E8, "Member 'UItemSelectorView::SideSlotFlashlight' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, SideSlotUnarmed) == 0x0003F0, "Member 'UItemSelectorView::SideSlotUnarmed' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, SideSlotLauncher) == 0x0003F8, "Member 'UItemSelectorView::SideSlotLauncher' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, SelectedSlot) == 0x000400, "Member 'UItemSelectorView::SelectedSlot' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, HoveredSlot) == 0x000408, "Member 'UItemSelectorView::HoveredSlot' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, SelectedEquipSlot) == 0x000410, "Member 'UItemSelectorView::SelectedEquipSlot' has a wrong offset!");
static_assert(offsetof(UItemSelectorView, HoveredSlotAtStartOfAnimation) == 0x000490, "Member 'UItemSelectorView::HoveredSlotAtStartOfAnimation' has a wrong offset!");

// Class Stalker2.ItemSelectorWeaponSlot
// 0x0360 (0x05F0 - 0x0290)
class UItemSelectorWeaponSlot final : public UItemSelectorSlotBase
{
public:
	struct FLinearColor                           SelectedColor;                                     // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ActiveColor;                                       // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultColor;                                      // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               SlotRadiusSizeBox;                                 // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                RotationBox;                                       // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BackgroundImage;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              BackgroundTexture;                                 // 0x02D8(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Particles;                                         // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            GrenadeText;                                       // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            AmmoText;                                          // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            AmmoTextMax;                                       // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            UnderbarrelAmmoText;                               // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            UnderbarrelAmmoTextMax;                            // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            AmmoSlash;                                         // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            UnderbarrelAmmoSlash;                              // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               IconContainer;                                     // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        AmmoContainer;                                     // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndexSlot;                                         // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AlternativeDisplayText;                            // 0x0360(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         SlotAngle;                                         // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ContainerSizeMax;                                  // 0x0380(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ContainerSizeMin;                                  // 0x0390(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ParticlesTranslation;                              // 0x03A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HoverTextColor;                                    // 0x03B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UnHoverTextColor;                                  // 0x03C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlotBlocked;                                      // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           UnBlockColor;                                      // 0x03D4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BlockColor;                                        // 0x03E4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELayerSlotType                                LayerSlotType;                                     // 0x03F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F5[0x3];                                      // 0x03F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeVCoordinate;                                   // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalSpeed;                                   // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftFadeDistance;                                  // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UTiling;                                           // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalSpeed;                                     // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VTiling;                                           // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x30];                                     // 0x0410(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               AttachesOverlay;                                   // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UImageWidget>               AttachImageWidgetClass;                            // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIconSettings                          IconSettings;                                      // 0x0450(0x0120)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_570[0x80];                                     // 0x0570(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConstructUpdateSlotScale();
	TArray<class UUserWidget*> GetHoveredWidgets();
	bool IsAlternativeSlot();
	bool IsGrenadeSlot();
	bool IsWeaponSlot();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSelectorWeaponSlot">();
	}
	static class UItemSelectorWeaponSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSelectorWeaponSlot>();
	}
};
static_assert(alignof(UItemSelectorWeaponSlot) == 0x000010, "Wrong alignment on UItemSelectorWeaponSlot");
static_assert(sizeof(UItemSelectorWeaponSlot) == 0x0005F0, "Wrong size on UItemSelectorWeaponSlot");
static_assert(offsetof(UItemSelectorWeaponSlot, SelectedColor) == 0x000290, "Member 'UItemSelectorWeaponSlot::SelectedColor' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, ActiveColor) == 0x0002A0, "Member 'UItemSelectorWeaponSlot::ActiveColor' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, DefaultColor) == 0x0002B0, "Member 'UItemSelectorWeaponSlot::DefaultColor' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, SlotRadiusSizeBox) == 0x0002C0, "Member 'UItemSelectorWeaponSlot::SlotRadiusSizeBox' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, RotationBox) == 0x0002C8, "Member 'UItemSelectorWeaponSlot::RotationBox' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, BackgroundImage) == 0x0002D0, "Member 'UItemSelectorWeaponSlot::BackgroundImage' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, BackgroundTexture) == 0x0002D8, "Member 'UItemSelectorWeaponSlot::BackgroundTexture' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, Particles) == 0x000308, "Member 'UItemSelectorWeaponSlot::Particles' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, GrenadeText) == 0x000310, "Member 'UItemSelectorWeaponSlot::GrenadeText' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, AmmoText) == 0x000318, "Member 'UItemSelectorWeaponSlot::AmmoText' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, AmmoTextMax) == 0x000320, "Member 'UItemSelectorWeaponSlot::AmmoTextMax' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, UnderbarrelAmmoText) == 0x000328, "Member 'UItemSelectorWeaponSlot::UnderbarrelAmmoText' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, UnderbarrelAmmoTextMax) == 0x000330, "Member 'UItemSelectorWeaponSlot::UnderbarrelAmmoTextMax' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, AmmoSlash) == 0x000338, "Member 'UItemSelectorWeaponSlot::AmmoSlash' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, UnderbarrelAmmoSlash) == 0x000340, "Member 'UItemSelectorWeaponSlot::UnderbarrelAmmoSlash' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, IconContainer) == 0x000348, "Member 'UItemSelectorWeaponSlot::IconContainer' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, AmmoContainer) == 0x000350, "Member 'UItemSelectorWeaponSlot::AmmoContainer' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, IndexSlot) == 0x000358, "Member 'UItemSelectorWeaponSlot::IndexSlot' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, AlternativeDisplayText) == 0x000360, "Member 'UItemSelectorWeaponSlot::AlternativeDisplayText' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, SlotAngle) == 0x000378, "Member 'UItemSelectorWeaponSlot::SlotAngle' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, Radius) == 0x00037C, "Member 'UItemSelectorWeaponSlot::Radius' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, ContainerSizeMax) == 0x000380, "Member 'UItemSelectorWeaponSlot::ContainerSizeMax' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, ContainerSizeMin) == 0x000390, "Member 'UItemSelectorWeaponSlot::ContainerSizeMin' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, ParticlesTranslation) == 0x0003A0, "Member 'UItemSelectorWeaponSlot::ParticlesTranslation' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, HoverTextColor) == 0x0003B0, "Member 'UItemSelectorWeaponSlot::HoverTextColor' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, UnHoverTextColor) == 0x0003C0, "Member 'UItemSelectorWeaponSlot::UnHoverTextColor' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, bSlotBlocked) == 0x0003D0, "Member 'UItemSelectorWeaponSlot::bSlotBlocked' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, UnBlockColor) == 0x0003D4, "Member 'UItemSelectorWeaponSlot::UnBlockColor' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, BlockColor) == 0x0003E4, "Member 'UItemSelectorWeaponSlot::BlockColor' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, LayerSlotType) == 0x0003F4, "Member 'UItemSelectorWeaponSlot::LayerSlotType' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, FadeVCoordinate) == 0x0003F8, "Member 'UItemSelectorWeaponSlot::FadeVCoordinate' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, HorizontalSpeed) == 0x0003FC, "Member 'UItemSelectorWeaponSlot::HorizontalSpeed' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, SoftFadeDistance) == 0x000400, "Member 'UItemSelectorWeaponSlot::SoftFadeDistance' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, UTiling) == 0x000404, "Member 'UItemSelectorWeaponSlot::UTiling' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, VerticalSpeed) == 0x000408, "Member 'UItemSelectorWeaponSlot::VerticalSpeed' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, VTiling) == 0x00040C, "Member 'UItemSelectorWeaponSlot::VTiling' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, AttachesOverlay) == 0x000440, "Member 'UItemSelectorWeaponSlot::AttachesOverlay' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, AttachImageWidgetClass) == 0x000448, "Member 'UItemSelectorWeaponSlot::AttachImageWidgetClass' has a wrong offset!");
static_assert(offsetof(UItemSelectorWeaponSlot, IconSettings) == 0x000450, "Member 'UItemSelectorWeaponSlot::IconSettings' has a wrong offset!");

// Class Stalker2.ItemSlotState
// 0x0070 (0x02E8 - 0x0278)
class UItemSlotState final : public UUserWidget
{
public:
	class UImage*                                 Highlight;                                         // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Background;                                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Quest;                                             // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              SizeReductionToFitEquipment;                       // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SizeReductionToFitGrid;                            // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DependencyColor;                                   // 0x02B0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HoveredColor;                                      // 0x02C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultColor;                                      // 0x02D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSlotState">();
	}
	static class UItemSlotState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSlotState>();
	}
};
static_assert(alignof(UItemSlotState) == 0x000008, "Wrong alignment on UItemSlotState");
static_assert(sizeof(UItemSlotState) == 0x0002E8, "Wrong size on UItemSlotState");
static_assert(offsetof(UItemSlotState, Highlight) == 0x000278, "Member 'UItemSlotState::Highlight' has a wrong offset!");
static_assert(offsetof(UItemSlotState, Background) == 0x000280, "Member 'UItemSlotState::Background' has a wrong offset!");
static_assert(offsetof(UItemSlotState, Quest) == 0x000288, "Member 'UItemSlotState::Quest' has a wrong offset!");
static_assert(offsetof(UItemSlotState, SizeReductionToFitEquipment) == 0x000290, "Member 'UItemSlotState::SizeReductionToFitEquipment' has a wrong offset!");
static_assert(offsetof(UItemSlotState, SizeReductionToFitGrid) == 0x0002A0, "Member 'UItemSlotState::SizeReductionToFitGrid' has a wrong offset!");
static_assert(offsetof(UItemSlotState, DependencyColor) == 0x0002B0, "Member 'UItemSlotState::DependencyColor' has a wrong offset!");
static_assert(offsetof(UItemSlotState, HoveredColor) == 0x0002C0, "Member 'UItemSlotState::HoveredColor' has a wrong offset!");
static_assert(offsetof(UItemSlotState, DefaultColor) == 0x0002D0, "Member 'UItemSlotState::DefaultColor' has a wrong offset!");

// Class Stalker2.ItemsStatsUpgrades
// 0x0170 (0x03E8 - 0x0278)
class UItemsStatsUpgrades final : public UWidgetBase
{
public:
	class UTextWidget*                            DurabilityPercentText;                             // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress1;                                 // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress2;                                 // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress3;                                 // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress4;                                 // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress5;                                 // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress6;                                 // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress7;                                 // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStatProgress*                      ItemStatProgress8;                                 // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               DurabilityOverlay;                                 // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProgressBar*                           Durability;                                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       RadiationMark;                                     // 0x02D0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           ItemStatValueBox;                                  // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UItemStatValue>             ItemInfoWidgetClass;                               // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorDurabilityZero;                               // 0x02E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorDurabilityLow;                                // 0x02F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorDurabilityMid;                                // 0x0308(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorDurabilityFull;                               // 0x0318(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DamageIcon;                                        // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PenetrationIcon;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FireRateIcon;                                      // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DistanceIcon;                                      // 0x0340(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             AccuracyIcon;                                      // 0x0348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             RadiationArmorIcon;                                // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PhysicalArmorIcon;                                 // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PsyArmorIcon;                                      // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ChemicalArmorIcon;                                 // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ElectoArmorIcon;                                   // 0x0370(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FireArmorIcon;                                     // 0x0378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x58];                                     // 0x0380(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UItemStatValue*>                 ItemStatValueArray;                                // 0x03D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemsStatsUpgrades">();
	}
	static class UItemsStatsUpgrades* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemsStatsUpgrades>();
	}
};
static_assert(alignof(UItemsStatsUpgrades) == 0x000008, "Wrong alignment on UItemsStatsUpgrades");
static_assert(sizeof(UItemsStatsUpgrades) == 0x0003E8, "Wrong size on UItemsStatsUpgrades");
static_assert(offsetof(UItemsStatsUpgrades, DurabilityPercentText) == 0x000278, "Member 'UItemsStatsUpgrades::DurabilityPercentText' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ItemStatProgress1) == 0x000280, "Member 'UItemsStatsUpgrades::ItemStatProgress1' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ItemStatProgress2) == 0x000288, "Member 'UItemsStatsUpgrades::ItemStatProgress2' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ItemStatProgress3) == 0x000290, "Member 'UItemsStatsUpgrades::ItemStatProgress3' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ItemStatProgress4) == 0x000298, "Member 'UItemsStatsUpgrades::ItemStatProgress4' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ItemStatProgress5) == 0x0002A0, "Member 'UItemsStatsUpgrades::ItemStatProgress5' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ItemStatProgress6) == 0x0002A8, "Member 'UItemsStatsUpgrades::ItemStatProgress6' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ItemStatProgress7) == 0x0002B0, "Member 'UItemsStatsUpgrades::ItemStatProgress7' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ItemStatProgress8) == 0x0002B8, "Member 'UItemsStatsUpgrades::ItemStatProgress8' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, DurabilityOverlay) == 0x0002C0, "Member 'UItemsStatsUpgrades::DurabilityOverlay' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, Durability) == 0x0002C8, "Member 'UItemsStatsUpgrades::Durability' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, RadiationMark) == 0x0002D0, "Member 'UItemsStatsUpgrades::RadiationMark' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ItemStatValueBox) == 0x0002D8, "Member 'UItemsStatsUpgrades::ItemStatValueBox' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ItemInfoWidgetClass) == 0x0002E0, "Member 'UItemsStatsUpgrades::ItemInfoWidgetClass' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ColorDurabilityZero) == 0x0002E8, "Member 'UItemsStatsUpgrades::ColorDurabilityZero' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ColorDurabilityLow) == 0x0002F8, "Member 'UItemsStatsUpgrades::ColorDurabilityLow' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ColorDurabilityMid) == 0x000308, "Member 'UItemsStatsUpgrades::ColorDurabilityMid' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ColorDurabilityFull) == 0x000318, "Member 'UItemsStatsUpgrades::ColorDurabilityFull' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, DamageIcon) == 0x000328, "Member 'UItemsStatsUpgrades::DamageIcon' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, PenetrationIcon) == 0x000330, "Member 'UItemsStatsUpgrades::PenetrationIcon' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, FireRateIcon) == 0x000338, "Member 'UItemsStatsUpgrades::FireRateIcon' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, DistanceIcon) == 0x000340, "Member 'UItemsStatsUpgrades::DistanceIcon' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, AccuracyIcon) == 0x000348, "Member 'UItemsStatsUpgrades::AccuracyIcon' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, RadiationArmorIcon) == 0x000350, "Member 'UItemsStatsUpgrades::RadiationArmorIcon' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, PhysicalArmorIcon) == 0x000358, "Member 'UItemsStatsUpgrades::PhysicalArmorIcon' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, PsyArmorIcon) == 0x000360, "Member 'UItemsStatsUpgrades::PsyArmorIcon' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ChemicalArmorIcon) == 0x000368, "Member 'UItemsStatsUpgrades::ChemicalArmorIcon' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ElectoArmorIcon) == 0x000370, "Member 'UItemsStatsUpgrades::ElectoArmorIcon' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, FireArmorIcon) == 0x000378, "Member 'UItemsStatsUpgrades::FireArmorIcon' has a wrong offset!");
static_assert(offsetof(UItemsStatsUpgrades, ItemStatValueArray) == 0x0003D8, "Member 'UItemsStatsUpgrades::ItemStatValueArray' has a wrong offset!");

// Class Stalker2.ItemStatProgress
// 0x0060 (0x02D8 - 0x0278)
class UItemStatProgress final : public UUserWidget
{
public:
	class UImage*                                 IconImage;                                         // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            Name_0;                                            // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProgressBar*                           ProgressBackground;                                // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProgressBar*                           ProgressForeground;                                // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           DefaultColor;                                      // 0x0298(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BetterColor;                                       // 0x02A8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           WorseColor;                                        // 0x02B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BuffColor;                                         // 0x02C8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemStatProgress">();
	}
	static class UItemStatProgress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemStatProgress>();
	}
};
static_assert(alignof(UItemStatProgress) == 0x000008, "Wrong alignment on UItemStatProgress");
static_assert(sizeof(UItemStatProgress) == 0x0002D8, "Wrong size on UItemStatProgress");
static_assert(offsetof(UItemStatProgress, IconImage) == 0x000278, "Member 'UItemStatProgress::IconImage' has a wrong offset!");
static_assert(offsetof(UItemStatProgress, Name_0) == 0x000280, "Member 'UItemStatProgress::Name_0' has a wrong offset!");
static_assert(offsetof(UItemStatProgress, ProgressBackground) == 0x000288, "Member 'UItemStatProgress::ProgressBackground' has a wrong offset!");
static_assert(offsetof(UItemStatProgress, ProgressForeground) == 0x000290, "Member 'UItemStatProgress::ProgressForeground' has a wrong offset!");
static_assert(offsetof(UItemStatProgress, DefaultColor) == 0x000298, "Member 'UItemStatProgress::DefaultColor' has a wrong offset!");
static_assert(offsetof(UItemStatProgress, BetterColor) == 0x0002A8, "Member 'UItemStatProgress::BetterColor' has a wrong offset!");
static_assert(offsetof(UItemStatProgress, WorseColor) == 0x0002B8, "Member 'UItemStatProgress::WorseColor' has a wrong offset!");
static_assert(offsetof(UItemStatProgress, BuffColor) == 0x0002C8, "Member 'UItemStatProgress::BuffColor' has a wrong offset!");

// Class Stalker2.ItemStatValue
// 0x0068 (0x02E0 - 0x0278)
class UItemStatValue final : public UWidgetBase
{
public:
	class UTextWidget*                            Name_0;                                            // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            Value;                                             // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            ValuePostFix;                                      // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           PositiveEffectValueColor;                          // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           NegativeEffectValueColor;                          // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           NeutralEffectValueColor;                           // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x18];                                     // 0x02C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UImageWidget*                           IconImage;                                         // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemStatValue">();
	}
	static class UItemStatValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemStatValue>();
	}
};
static_assert(alignof(UItemStatValue) == 0x000008, "Wrong alignment on UItemStatValue");
static_assert(sizeof(UItemStatValue) == 0x0002E0, "Wrong size on UItemStatValue");
static_assert(offsetof(UItemStatValue, Name_0) == 0x000278, "Member 'UItemStatValue::Name_0' has a wrong offset!");
static_assert(offsetof(UItemStatValue, Value) == 0x000280, "Member 'UItemStatValue::Value' has a wrong offset!");
static_assert(offsetof(UItemStatValue, ValuePostFix) == 0x000288, "Member 'UItemStatValue::ValuePostFix' has a wrong offset!");
static_assert(offsetof(UItemStatValue, PositiveEffectValueColor) == 0x000290, "Member 'UItemStatValue::PositiveEffectValueColor' has a wrong offset!");
static_assert(offsetof(UItemStatValue, NegativeEffectValueColor) == 0x0002A0, "Member 'UItemStatValue::NegativeEffectValueColor' has a wrong offset!");
static_assert(offsetof(UItemStatValue, NeutralEffectValueColor) == 0x0002B0, "Member 'UItemStatValue::NeutralEffectValueColor' has a wrong offset!");
static_assert(offsetof(UItemStatValue, IconImage) == 0x0002D8, "Member 'UItemStatValue::IconImage' has a wrong offset!");

// Class Stalker2.RegionToEpicIDConfig
// 0x0050 (0x0088 - 0x0038)
class URegionToEpicIDConfig final : public UDeveloperSettings
{
public:
	TMap<ERegion, int32>                          RegionToEpicMap;                                   // 0x0038(0x0050)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RegionToEpicIDConfig">();
	}
	static class URegionToEpicIDConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<URegionToEpicIDConfig>();
	}
};
static_assert(alignof(URegionToEpicIDConfig) == 0x000008, "Wrong alignment on URegionToEpicIDConfig");
static_assert(sizeof(URegionToEpicIDConfig) == 0x000088, "Wrong size on URegionToEpicIDConfig");
static_assert(offsetof(URegionToEpicIDConfig, RegionToEpicMap) == 0x000038, "Member 'URegionToEpicIDConfig::RegionToEpicMap' has a wrong offset!");

// Class Stalker2.ItemUsageComponent
// 0x0028 (0x00C8 - 0x00A0)
class UItemUsageComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInteractObject>                ObjectsNeededToInteract;                           // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAffectedComponent(class UInteractionComponent* InteractionComponent);
	void ConsumeRequiredItems();
	void RemoveAffectedComponent(class UInteractionComponent* InteractionComponent);

	bool HasAnyItemNeededToInteract() const;
	bool HasRequiredItems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemUsageComponent">();
	}
	static class UItemUsageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemUsageComponent>();
	}
};
static_assert(alignof(UItemUsageComponent) == 0x000008, "Wrong alignment on UItemUsageComponent");
static_assert(sizeof(UItemUsageComponent) == 0x0000C8, "Wrong size on UItemUsageComponent");
static_assert(offsetof(UItemUsageComponent, ObjectsNeededToInteract) == 0x0000A8, "Member 'UItemUsageComponent::ObjectsNeededToInteract' has a wrong offset!");

// Class Stalker2.JournalIPU
// 0x0000 (0x0040 - 0x0040)
class UJournalIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JournalIPU">();
	}
	static class UJournalIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJournalIPU>();
	}
};
static_assert(alignof(UJournalIPU) == 0x000008, "Wrong alignment on UJournalIPU");
static_assert(sizeof(UJournalIPU) == 0x000040, "Wrong size on UJournalIPU");

// Class Stalker2.JournalMouseIPU
// 0x0000 (0x0040 - 0x0040)
class UJournalMouseIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JournalMouseIPU">();
	}
	static class UJournalMouseIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJournalMouseIPU>();
	}
};
static_assert(alignof(UJournalMouseIPU) == 0x000008, "Wrong alignment on UJournalMouseIPU");
static_assert(sizeof(UJournalMouseIPU) == 0x000040, "Wrong size on UJournalMouseIPU");

// Class Stalker2.QuickPanel
// 0x0228 (0x04A0 - 0x0278)
class UQuickPanel final : public UChildViewBase
{
public:
	uint8                                         Pad_278[0x80];                                     // 0x0278(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFillQuickSlots;                                   // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESortGroup                                    SlotADefaultEquipment;                             // 0x02F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESortGroup                                    SlotBDefaultEquipment;                             // 0x02FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESortGroup                                    SlotCDefaultEquipment;                             // 0x02FB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESortGroup                                    SlotDDefaultEquipment;                             // 0x02FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x02FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FE[0x2];                                      // 0x02FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateShouldUseAnimationTime;                      // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AnimPanelHide;                                     // 0x0308(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AnimPanelShow;                                     // 0x0310(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBorder*                                NavBorder;                                         // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanelSlot*                       NavBorderSlot;                                     // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x28];                                     // 0x0328(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DefaultNavBorderColor;                             // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DraggingNavBorderColor;                            // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHintInputController*                   LeftHint;                                          // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   RightHint;                                         // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQuickSlot*                             QuickSlot1;                                        // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQuickSlot*                             QuickSlot3;                                        // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQuickSlot*                             QuickSlot2;                                        // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQuickSlot*                             QuickSlot4;                                        // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UQuickSlot*>                     QuickSlots;                                        // 0x03A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UImage*                                 HoldProgressLeft;                                  // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HoldProgressRight;                                 // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintAction*                            HintLeft;                                          // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintAction*                            HintRight;                                         // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoldInactiveOpacity;                               // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoldActiveOpacity;                                 // 0x03DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HidePanelDelay;                                    // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QuickSlotsFadeIn;                                  // 0x03E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QuickSlotsFadeOut;                                 // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInventoryQuickPanel;                              // 0x03EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3ED[0x3];                                      // 0x03ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UQuickSlot*                             CurrSelectedSlot;                                  // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0x48];                                     // 0x03F8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryNew*                          InventoryNew;                                      // 0x0440(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_448[0x58];                                     // 0x0448(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnQuickSlotMouseEnter(class UQuickSlot* ItemWidget);
	void OnQuickSlotMouseLeave(class UQuickSlot* HoveredWidget);

	bool PlayShouldUseAnimationIfRequired(ESortGroup InSortGroup) const;
	void UpdateShouldUseAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickPanel">();
	}
	static class UQuickPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickPanel>();
	}
};
static_assert(alignof(UQuickPanel) == 0x000008, "Wrong alignment on UQuickPanel");
static_assert(sizeof(UQuickPanel) == 0x0004A0, "Wrong size on UQuickPanel");
static_assert(offsetof(UQuickPanel, bFillQuickSlots) == 0x0002F8, "Member 'UQuickPanel::bFillQuickSlots' has a wrong offset!");
static_assert(offsetof(UQuickPanel, SlotADefaultEquipment) == 0x0002F9, "Member 'UQuickPanel::SlotADefaultEquipment' has a wrong offset!");
static_assert(offsetof(UQuickPanel, SlotBDefaultEquipment) == 0x0002FA, "Member 'UQuickPanel::SlotBDefaultEquipment' has a wrong offset!");
static_assert(offsetof(UQuickPanel, SlotCDefaultEquipment) == 0x0002FB, "Member 'UQuickPanel::SlotCDefaultEquipment' has a wrong offset!");
static_assert(offsetof(UQuickPanel, SlotDDefaultEquipment) == 0x0002FC, "Member 'UQuickPanel::SlotDDefaultEquipment' has a wrong offset!");
static_assert(offsetof(UQuickPanel, bAnimate) == 0x0002FD, "Member 'UQuickPanel::bAnimate' has a wrong offset!");
static_assert(offsetof(UQuickPanel, UpdateShouldUseAnimationTime) == 0x000300, "Member 'UQuickPanel::UpdateShouldUseAnimationTime' has a wrong offset!");
static_assert(offsetof(UQuickPanel, AnimPanelHide) == 0x000308, "Member 'UQuickPanel::AnimPanelHide' has a wrong offset!");
static_assert(offsetof(UQuickPanel, AnimPanelShow) == 0x000310, "Member 'UQuickPanel::AnimPanelShow' has a wrong offset!");
static_assert(offsetof(UQuickPanel, NavBorder) == 0x000318, "Member 'UQuickPanel::NavBorder' has a wrong offset!");
static_assert(offsetof(UQuickPanel, NavBorderSlot) == 0x000320, "Member 'UQuickPanel::NavBorderSlot' has a wrong offset!");
static_assert(offsetof(UQuickPanel, DefaultNavBorderColor) == 0x000350, "Member 'UQuickPanel::DefaultNavBorderColor' has a wrong offset!");
static_assert(offsetof(UQuickPanel, DraggingNavBorderColor) == 0x000360, "Member 'UQuickPanel::DraggingNavBorderColor' has a wrong offset!");
static_assert(offsetof(UQuickPanel, LeftHint) == 0x000378, "Member 'UQuickPanel::LeftHint' has a wrong offset!");
static_assert(offsetof(UQuickPanel, RightHint) == 0x000380, "Member 'UQuickPanel::RightHint' has a wrong offset!");
static_assert(offsetof(UQuickPanel, QuickSlot1) == 0x000388, "Member 'UQuickPanel::QuickSlot1' has a wrong offset!");
static_assert(offsetof(UQuickPanel, QuickSlot3) == 0x000390, "Member 'UQuickPanel::QuickSlot3' has a wrong offset!");
static_assert(offsetof(UQuickPanel, QuickSlot2) == 0x000398, "Member 'UQuickPanel::QuickSlot2' has a wrong offset!");
static_assert(offsetof(UQuickPanel, QuickSlot4) == 0x0003A0, "Member 'UQuickPanel::QuickSlot4' has a wrong offset!");
static_assert(offsetof(UQuickPanel, QuickSlots) == 0x0003A8, "Member 'UQuickPanel::QuickSlots' has a wrong offset!");
static_assert(offsetof(UQuickPanel, HoldProgressLeft) == 0x0003B8, "Member 'UQuickPanel::HoldProgressLeft' has a wrong offset!");
static_assert(offsetof(UQuickPanel, HoldProgressRight) == 0x0003C0, "Member 'UQuickPanel::HoldProgressRight' has a wrong offset!");
static_assert(offsetof(UQuickPanel, HintLeft) == 0x0003C8, "Member 'UQuickPanel::HintLeft' has a wrong offset!");
static_assert(offsetof(UQuickPanel, HintRight) == 0x0003D0, "Member 'UQuickPanel::HintRight' has a wrong offset!");
static_assert(offsetof(UQuickPanel, HoldInactiveOpacity) == 0x0003D8, "Member 'UQuickPanel::HoldInactiveOpacity' has a wrong offset!");
static_assert(offsetof(UQuickPanel, HoldActiveOpacity) == 0x0003DC, "Member 'UQuickPanel::HoldActiveOpacity' has a wrong offset!");
static_assert(offsetof(UQuickPanel, HidePanelDelay) == 0x0003E0, "Member 'UQuickPanel::HidePanelDelay' has a wrong offset!");
static_assert(offsetof(UQuickPanel, QuickSlotsFadeIn) == 0x0003E4, "Member 'UQuickPanel::QuickSlotsFadeIn' has a wrong offset!");
static_assert(offsetof(UQuickPanel, QuickSlotsFadeOut) == 0x0003E8, "Member 'UQuickPanel::QuickSlotsFadeOut' has a wrong offset!");
static_assert(offsetof(UQuickPanel, bInventoryQuickPanel) == 0x0003EC, "Member 'UQuickPanel::bInventoryQuickPanel' has a wrong offset!");
static_assert(offsetof(UQuickPanel, CurrSelectedSlot) == 0x0003F0, "Member 'UQuickPanel::CurrSelectedSlot' has a wrong offset!");
static_assert(offsetof(UQuickPanel, InventoryNew) == 0x000440, "Member 'UQuickPanel::InventoryNew' has a wrong offset!");

// Class Stalker2.JournalPage
// 0x00F0 (0x0388 - 0x0298)
class UJournalPage final : public UPDAPage
{
public:
	class UPDAQuestButton*                        CurrentQuestButton;                                // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDAQuestButton*                        DoneQuestButton;                                   // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDAQuestPanel*                         PDAQuestPanel;                                     // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDAQuestDetails*                       QuestDetails;                                      // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   SelectQuestHint;                                   // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   HintSelectPanelLeft;                               // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   HintSelectPanelRight;                              // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   ButtonHintTransitionToMap;                         // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MainQuestLocalizationSID;                          // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SecondaryQuestLocalizationSID;                     // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FinishQuestLocalizationSID;                        // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FeilQuestLocalizationSID;                          // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CanceledQuestLocalizationSID;                      // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelectInput;                                       // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MainQuestTint;                                     // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultQuestTint;                                  // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuestSlotListScrollTime;                           // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TabTransitionTime;                                 // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x30];                                     // 0x0358(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClickButtonQuest(const class FName ButtonId);
	void SelectedSlotWithMouse();
	void ShowDetails(bool bEmpty);
	void StageSlotHover();
	void UIPDANavigationDown();
	void UIPDANavigationLeft();
	void UIPDANavigationLeftHint();
	void UIPDANavigationReleased();
	void UIPDANavigationRight();
	void UIPDANavigationRightHint();
	void UIPDANavigationSelect();
	void UIPDANavigationSelectPanelLeft();
	void UIPDANavigationSelectPanelRight();
	void UIPDANavigationUp();
	void UIPDATransitionToMarkerPosition();
	void UpdateButton(const int32 IndexUpdateButton);
	void UpdateHoverDetailsElement(const bool bHovered, const EDetailsElementType ElementType);
	void UpdateStageOnDetailed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JournalPage">();
	}
	static class UJournalPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJournalPage>();
	}
};
static_assert(alignof(UJournalPage) == 0x000008, "Wrong alignment on UJournalPage");
static_assert(sizeof(UJournalPage) == 0x000388, "Wrong size on UJournalPage");
static_assert(offsetof(UJournalPage, CurrentQuestButton) == 0x000298, "Member 'UJournalPage::CurrentQuestButton' has a wrong offset!");
static_assert(offsetof(UJournalPage, DoneQuestButton) == 0x0002A0, "Member 'UJournalPage::DoneQuestButton' has a wrong offset!");
static_assert(offsetof(UJournalPage, PDAQuestPanel) == 0x0002A8, "Member 'UJournalPage::PDAQuestPanel' has a wrong offset!");
static_assert(offsetof(UJournalPage, QuestDetails) == 0x0002B0, "Member 'UJournalPage::QuestDetails' has a wrong offset!");
static_assert(offsetof(UJournalPage, SelectQuestHint) == 0x0002B8, "Member 'UJournalPage::SelectQuestHint' has a wrong offset!");
static_assert(offsetof(UJournalPage, HintSelectPanelLeft) == 0x0002C0, "Member 'UJournalPage::HintSelectPanelLeft' has a wrong offset!");
static_assert(offsetof(UJournalPage, HintSelectPanelRight) == 0x0002C8, "Member 'UJournalPage::HintSelectPanelRight' has a wrong offset!");
static_assert(offsetof(UJournalPage, ButtonHintTransitionToMap) == 0x0002D0, "Member 'UJournalPage::ButtonHintTransitionToMap' has a wrong offset!");
static_assert(offsetof(UJournalPage, MainQuestLocalizationSID) == 0x0002D8, "Member 'UJournalPage::MainQuestLocalizationSID' has a wrong offset!");
static_assert(offsetof(UJournalPage, SecondaryQuestLocalizationSID) == 0x0002E8, "Member 'UJournalPage::SecondaryQuestLocalizationSID' has a wrong offset!");
static_assert(offsetof(UJournalPage, FinishQuestLocalizationSID) == 0x0002F8, "Member 'UJournalPage::FinishQuestLocalizationSID' has a wrong offset!");
static_assert(offsetof(UJournalPage, FeilQuestLocalizationSID) == 0x000308, "Member 'UJournalPage::FeilQuestLocalizationSID' has a wrong offset!");
static_assert(offsetof(UJournalPage, CanceledQuestLocalizationSID) == 0x000318, "Member 'UJournalPage::CanceledQuestLocalizationSID' has a wrong offset!");
static_assert(offsetof(UJournalPage, SelectInput) == 0x000328, "Member 'UJournalPage::SelectInput' has a wrong offset!");
static_assert(offsetof(UJournalPage, MainQuestTint) == 0x000330, "Member 'UJournalPage::MainQuestTint' has a wrong offset!");
static_assert(offsetof(UJournalPage, DefaultQuestTint) == 0x000340, "Member 'UJournalPage::DefaultQuestTint' has a wrong offset!");
static_assert(offsetof(UJournalPage, QuestSlotListScrollTime) == 0x000350, "Member 'UJournalPage::QuestSlotListScrollTime' has a wrong offset!");
static_assert(offsetof(UJournalPage, TabTransitionTime) == 0x000354, "Member 'UJournalPage::TabTransitionTime' has a wrong offset!");

// Class Stalker2.KeyboardMappingSettingsPage
// 0x0000 (0x02F0 - 0x02F0)
class UKeyboardMappingSettingsPage final : public UInputMappingSettingsPage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyboardMappingSettingsPage">();
	}
	static class UKeyboardMappingSettingsPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyboardMappingSettingsPage>();
	}
};
static_assert(alignof(UKeyboardMappingSettingsPage) == 0x000008, "Wrong alignment on UKeyboardMappingSettingsPage");
static_assert(sizeof(UKeyboardMappingSettingsPage) == 0x0002F0, "Wrong size on UKeyboardMappingSettingsPage");

// Class Stalker2.ObjWaterContactController
// 0x0040 (0x0138 - 0x00F8)
class UObjWaterContactController final : public UWaterContactController
{
public:
	uint8                                         Pad_F8[0x40];                                      // 0x00F8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjWaterContactController">();
	}
	static class UObjWaterContactController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjWaterContactController>();
	}
};
static_assert(alignof(UObjWaterContactController) == 0x000008, "Wrong alignment on UObjWaterContactController");
static_assert(sizeof(UObjWaterContactController) == 0x000138, "Wrong size on UObjWaterContactController");

// Class Stalker2.KorshunovBossComponent
// 0x0158 (0x01F8 - 0x00A0)
class UKorshunovBossComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x68];                                      // 0x00A0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EShieldState State)> OnShieldStateChanged;                         // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ECoilsState State)> OnCoilsStateChanged;                           // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Value)>   OnCoilsHeated;                                     // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCoilsDamageThresholdPassed;                      // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<float>                                 PhasesHealthThresholds;                            // 0x0148(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         MeleeResistancePercent;                            // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StunDuration;                                      // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpZScale;                                        // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CutsceneSequenceTrackingDistance;                  // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShieldArmorHealth;                                 // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoilsHeatingThreshold;                             // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      CoilsMaterialInstance;                             // 0x0170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATelekineticShield>         TelekineticShieldType;                             // 0x0178(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x78];                                     // 0x0180(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KorshunovBossComponent">();
	}
	static class UKorshunovBossComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKorshunovBossComponent>();
	}
};
static_assert(alignof(UKorshunovBossComponent) == 0x000008, "Wrong alignment on UKorshunovBossComponent");
static_assert(sizeof(UKorshunovBossComponent) == 0x0001F8, "Wrong size on UKorshunovBossComponent");
static_assert(offsetof(UKorshunovBossComponent, OnShieldStateChanged) == 0x000108, "Member 'UKorshunovBossComponent::OnShieldStateChanged' has a wrong offset!");
static_assert(offsetof(UKorshunovBossComponent, OnCoilsStateChanged) == 0x000118, "Member 'UKorshunovBossComponent::OnCoilsStateChanged' has a wrong offset!");
static_assert(offsetof(UKorshunovBossComponent, OnCoilsHeated) == 0x000128, "Member 'UKorshunovBossComponent::OnCoilsHeated' has a wrong offset!");
static_assert(offsetof(UKorshunovBossComponent, OnCoilsDamageThresholdPassed) == 0x000138, "Member 'UKorshunovBossComponent::OnCoilsDamageThresholdPassed' has a wrong offset!");
static_assert(offsetof(UKorshunovBossComponent, PhasesHealthThresholds) == 0x000148, "Member 'UKorshunovBossComponent::PhasesHealthThresholds' has a wrong offset!");
static_assert(offsetof(UKorshunovBossComponent, MeleeResistancePercent) == 0x000158, "Member 'UKorshunovBossComponent::MeleeResistancePercent' has a wrong offset!");
static_assert(offsetof(UKorshunovBossComponent, StunDuration) == 0x00015C, "Member 'UKorshunovBossComponent::StunDuration' has a wrong offset!");
static_assert(offsetof(UKorshunovBossComponent, JumpZScale) == 0x000160, "Member 'UKorshunovBossComponent::JumpZScale' has a wrong offset!");
static_assert(offsetof(UKorshunovBossComponent, CutsceneSequenceTrackingDistance) == 0x000164, "Member 'UKorshunovBossComponent::CutsceneSequenceTrackingDistance' has a wrong offset!");
static_assert(offsetof(UKorshunovBossComponent, ShieldArmorHealth) == 0x000168, "Member 'UKorshunovBossComponent::ShieldArmorHealth' has a wrong offset!");
static_assert(offsetof(UKorshunovBossComponent, CoilsHeatingThreshold) == 0x00016C, "Member 'UKorshunovBossComponent::CoilsHeatingThreshold' has a wrong offset!");
static_assert(offsetof(UKorshunovBossComponent, CoilsMaterialInstance) == 0x000170, "Member 'UKorshunovBossComponent::CoilsMaterialInstance' has a wrong offset!");
static_assert(offsetof(UKorshunovBossComponent, TelekineticShieldType) == 0x000178, "Member 'UKorshunovBossComponent::TelekineticShieldType' has a wrong offset!");

// Class Stalker2.SelectedAnswerMark
// 0x0068 (0x02E0 - 0x0278)
class USelectedAnswerMark final : public UWidgetBase
{
public:
	class UUserWidget*                            Hint;                                              // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 LockSwitcher;                                      // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Background;                                        // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               TimerContainer;                                    // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x48];                                     // 0x0298(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectedAnswerMark">();
	}
	static class USelectedAnswerMark* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectedAnswerMark>();
	}
};
static_assert(alignof(USelectedAnswerMark) == 0x000008, "Wrong alignment on USelectedAnswerMark");
static_assert(sizeof(USelectedAnswerMark) == 0x0002E0, "Wrong size on USelectedAnswerMark");
static_assert(offsetof(USelectedAnswerMark, Hint) == 0x000278, "Member 'USelectedAnswerMark::Hint' has a wrong offset!");
static_assert(offsetof(USelectedAnswerMark, LockSwitcher) == 0x000280, "Member 'USelectedAnswerMark::LockSwitcher' has a wrong offset!");
static_assert(offsetof(USelectedAnswerMark, Background) == 0x000288, "Member 'USelectedAnswerMark::Background' has a wrong offset!");
static_assert(offsetof(USelectedAnswerMark, TimerContainer) == 0x000290, "Member 'USelectedAnswerMark::TimerContainer' has a wrong offset!");

// Class Stalker2.VolumeForEffects
// 0x0088 (0x0360 - 0x02D8)
class AVolumeForEffects : public AVolume
{
public:
	uint8                                         Pad_2D8[0x28];                                     // 0x02D8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x0300(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSpawnDisabled;                                    // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOverlapVolumeEffect>           EffectsToApply;                                    // 0x0318(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x20];                                     // 0x0328(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USignalReceiverComponent*               ActivateVolumeSignal;                              // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USignalReceiverComponent*               DeactivateVolumeSignal;                            // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateDelegateHandle(class UObject* DataObject);
	void DeactivateDelegateHandle(class UObject* DataObject);
	void SetDisabled(const bool bDisabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VolumeForEffects">();
	}
	static class AVolumeForEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVolumeForEffects>();
	}
};
static_assert(alignof(AVolumeForEffects) == 0x000008, "Wrong alignment on AVolumeForEffects");
static_assert(sizeof(AVolumeForEffects) == 0x000360, "Wrong size on AVolumeForEffects");
static_assert(offsetof(AVolumeForEffects, Guid) == 0x000300, "Member 'AVolumeForEffects::Guid' has a wrong offset!");
static_assert(offsetof(AVolumeForEffects, bSpawnDisabled) == 0x000310, "Member 'AVolumeForEffects::bSpawnDisabled' has a wrong offset!");
static_assert(offsetof(AVolumeForEffects, EffectsToApply) == 0x000318, "Member 'AVolumeForEffects::EffectsToApply' has a wrong offset!");
static_assert(offsetof(AVolumeForEffects, ActivateVolumeSignal) == 0x000348, "Member 'AVolumeForEffects::ActivateVolumeSignal' has a wrong offset!");
static_assert(offsetof(AVolumeForEffects, DeactivateVolumeSignal) == 0x000350, "Member 'AVolumeForEffects::DeactivateVolumeSignal' has a wrong offset!");

// Class Stalker2.KorshunovFightVolumeForEffects
// 0x0048 (0x03A8 - 0x0360)
class AKorshunovFightVolumeForEffects final : public AVolumeForEffects
{
public:
	float                                         ActiveTime;                                        // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAkAudioEvent>           VolumeSFX;                                         // 0x0368(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      VolumeVFX;                                         // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KorshunovFightVolumeForEffects">();
	}
	static class AKorshunovFightVolumeForEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKorshunovFightVolumeForEffects>();
	}
};
static_assert(alignof(AKorshunovFightVolumeForEffects) == 0x000008, "Wrong alignment on AKorshunovFightVolumeForEffects");
static_assert(sizeof(AKorshunovFightVolumeForEffects) == 0x0003A8, "Wrong size on AKorshunovFightVolumeForEffects");
static_assert(offsetof(AKorshunovFightVolumeForEffects, ActiveTime) == 0x000360, "Member 'AKorshunovFightVolumeForEffects::ActiveTime' has a wrong offset!");
static_assert(offsetof(AKorshunovFightVolumeForEffects, VolumeSFX) == 0x000368, "Member 'AKorshunovFightVolumeForEffects::VolumeSFX' has a wrong offset!");
static_assert(offsetof(AKorshunovFightVolumeForEffects, VolumeVFX) == 0x000398, "Member 'AKorshunovFightVolumeForEffects::VolumeVFX' has a wrong offset!");

// Class Stalker2.LadderAscendIPU
// 0x0000 (0x0040 - 0x0040)
class ULadderAscendIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderAscendIPU">();
	}
	static class ULadderAscendIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULadderAscendIPU>();
	}
};
static_assert(alignof(ULadderAscendIPU) == 0x000008, "Wrong alignment on ULadderAscendIPU");
static_assert(sizeof(ULadderAscendIPU) == 0x000040, "Wrong size on ULadderAscendIPU");

// Class Stalker2.LadderComponent
// 0x0050 (0x0108 - 0x00B8)
class ULadderComponent final : public UGuidActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            UnfoldingCurve;                                    // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            HorizontalOffsetCurve;                             // 0x00C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnUnfoldingStarted;                                // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnUnfoldingEnded;                                  // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnHiddenStateChanged;                              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x5];                                      // 0x0100(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTopBlocked;                                       // 0x0105(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLadderHidden;                                     // 0x0106(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_107[0x1];                                      // 0x0107(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetLadderHidden(const bool InbLadderHidden);
	void SetTopBlocked(const bool InbTopBlocked);

	bool IsLadderHidden() const;
	bool IsTopBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderComponent">();
	}
	static class ULadderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULadderComponent>();
	}
};
static_assert(alignof(ULadderComponent) == 0x000008, "Wrong alignment on ULadderComponent");
static_assert(sizeof(ULadderComponent) == 0x000108, "Wrong size on ULadderComponent");
static_assert(offsetof(ULadderComponent, UnfoldingCurve) == 0x0000C0, "Member 'ULadderComponent::UnfoldingCurve' has a wrong offset!");
static_assert(offsetof(ULadderComponent, HorizontalOffsetCurve) == 0x0000C8, "Member 'ULadderComponent::HorizontalOffsetCurve' has a wrong offset!");
static_assert(offsetof(ULadderComponent, OnUnfoldingStarted) == 0x0000D0, "Member 'ULadderComponent::OnUnfoldingStarted' has a wrong offset!");
static_assert(offsetof(ULadderComponent, OnUnfoldingEnded) == 0x0000E0, "Member 'ULadderComponent::OnUnfoldingEnded' has a wrong offset!");
static_assert(offsetof(ULadderComponent, OnHiddenStateChanged) == 0x0000F0, "Member 'ULadderComponent::OnHiddenStateChanged' has a wrong offset!");
static_assert(offsetof(ULadderComponent, bTopBlocked) == 0x000105, "Member 'ULadderComponent::bTopBlocked' has a wrong offset!");
static_assert(offsetof(ULadderComponent, bLadderHidden) == 0x000106, "Member 'ULadderComponent::bLadderHidden' has a wrong offset!");

// Class Stalker2.LadderDescendIPU
// 0x0000 (0x0040 - 0x0040)
class ULadderDescendIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderDescendIPU">();
	}
	static class ULadderDescendIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULadderDescendIPU>();
	}
};
static_assert(alignof(ULadderDescendIPU) == 0x000008, "Wrong alignment on ULadderDescendIPU");
static_assert(sizeof(ULadderDescendIPU) == 0x000040, "Wrong size on ULadderDescendIPU");

// Class Stalker2.LadderJumpIPU
// 0x0000 (0x0040 - 0x0040)
class ULadderJumpIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderJumpIPU">();
	}
	static class ULadderJumpIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULadderJumpIPU>();
	}
};
static_assert(alignof(ULadderJumpIPU) == 0x000008, "Wrong alignment on ULadderJumpIPU");
static_assert(sizeof(ULadderJumpIPU) == 0x000040, "Wrong size on ULadderJumpIPU");

// Class Stalker2.SaveLoadNotificationView
// 0x0038 (0x0300 - 0x02C8)
class USaveLoadNotificationView : public UViewBaseExtended
{
public:
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               SaveLoadNotificationOverlay;                       // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SaveLoadNotificationViewZOrder;                    // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                DefaultNotifyPadding;                              // 0x02E4(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USaveLoadNotificationBase*              ActiveSaveLoadNotificationWidget;                  // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadNotificationView">();
	}
	static class USaveLoadNotificationView* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadNotificationView>();
	}
};
static_assert(alignof(USaveLoadNotificationView) == 0x000008, "Wrong alignment on USaveLoadNotificationView");
static_assert(sizeof(USaveLoadNotificationView) == 0x000300, "Wrong size on USaveLoadNotificationView");
static_assert(offsetof(USaveLoadNotificationView, SaveLoadNotificationOverlay) == 0x0002D8, "Member 'USaveLoadNotificationView::SaveLoadNotificationOverlay' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationView, SaveLoadNotificationViewZOrder) == 0x0002E0, "Member 'USaveLoadNotificationView::SaveLoadNotificationViewZOrder' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationView, DefaultNotifyPadding) == 0x0002E4, "Member 'USaveLoadNotificationView::DefaultNotifyPadding' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationView, ActiveSaveLoadNotificationWidget) == 0x0002F8, "Member 'USaveLoadNotificationView::ActiveSaveLoadNotificationWidget' has a wrong offset!");

// Class Stalker2.LairNavModifierVolume
// 0x0000 (0x0308 - 0x0308)
class ALairNavModifierVolume final : public ASystemicNavModifierVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LairNavModifierVolume">();
	}
	static class ALairNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALairNavModifierVolume>();
	}
};
static_assert(alignof(ALairNavModifierVolume) == 0x000008, "Wrong alignment on ALairNavModifierVolume");
static_assert(sizeof(ALairNavModifierVolume) == 0x000308, "Wrong size on ALairNavModifierVolume");

// Class Stalker2.LaserSightComponent
// 0x00A0 (0x0140 - 0x00A0)
class alignas(0x10) ULaserSightComponent : public UActorComponent
{
public:
	class UMeshComponent*                         ParentMesh;                                        // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x80];                                      // 0x00A8(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      LaserSightVFX;                                     // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LaserSightComponent">();
	}
	static class ULaserSightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULaserSightComponent>();
	}
};
static_assert(alignof(ULaserSightComponent) == 0x000010, "Wrong alignment on ULaserSightComponent");
static_assert(sizeof(ULaserSightComponent) == 0x000140, "Wrong size on ULaserSightComponent");
static_assert(offsetof(ULaserSightComponent, ParentMesh) == 0x0000A0, "Member 'ULaserSightComponent::ParentMesh' has a wrong offset!");
static_assert(offsetof(ULaserSightComponent, LaserSightVFX) == 0x000128, "Member 'ULaserSightComponent::LaserSightVFX' has a wrong offset!");

// Class Stalker2.LavaLampAnomaly
// 0x02F0 (0x0688 - 0x0398)
class ALavaLampAnomaly final : public AAnomaly
{
public:
	class UAkAudioEvent*                          CollisionPlayEvent;                                // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          CollisionStopEvent;                                // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ClotEvent;                                         // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ParticleLifetimeAfterCollision;                    // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClotEventDelay;                                    // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       OverlapSphereComponent;                            // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ActivationParticle;                                // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ClotDecalMaterial;                                 // 0x03C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x2B8];                                    // 0x03D0(0x02B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFollowPositionChanged(const struct FVector& FollowPosition);
	void OnLavaCollision(const struct FBasicParticleData& BasicParticleData);
	void OnLavaStaticObjectCollision(const struct FVector& Location, const struct FVector& NormalDirection, float Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LavaLampAnomaly">();
	}
	static class ALavaLampAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALavaLampAnomaly>();
	}
};
static_assert(alignof(ALavaLampAnomaly) == 0x000008, "Wrong alignment on ALavaLampAnomaly");
static_assert(sizeof(ALavaLampAnomaly) == 0x000688, "Wrong size on ALavaLampAnomaly");
static_assert(offsetof(ALavaLampAnomaly, CollisionPlayEvent) == 0x000398, "Member 'ALavaLampAnomaly::CollisionPlayEvent' has a wrong offset!");
static_assert(offsetof(ALavaLampAnomaly, CollisionStopEvent) == 0x0003A0, "Member 'ALavaLampAnomaly::CollisionStopEvent' has a wrong offset!");
static_assert(offsetof(ALavaLampAnomaly, ClotEvent) == 0x0003A8, "Member 'ALavaLampAnomaly::ClotEvent' has a wrong offset!");
static_assert(offsetof(ALavaLampAnomaly, ParticleLifetimeAfterCollision) == 0x0003B0, "Member 'ALavaLampAnomaly::ParticleLifetimeAfterCollision' has a wrong offset!");
static_assert(offsetof(ALavaLampAnomaly, ClotEventDelay) == 0x0003B4, "Member 'ALavaLampAnomaly::ClotEventDelay' has a wrong offset!");
static_assert(offsetof(ALavaLampAnomaly, OverlapSphereComponent) == 0x0003B8, "Member 'ALavaLampAnomaly::OverlapSphereComponent' has a wrong offset!");
static_assert(offsetof(ALavaLampAnomaly, ActivationParticle) == 0x0003C0, "Member 'ALavaLampAnomaly::ActivationParticle' has a wrong offset!");
static_assert(offsetof(ALavaLampAnomaly, ClotDecalMaterial) == 0x0003C8, "Member 'ALavaLampAnomaly::ClotDecalMaterial' has a wrong offset!");

// Class Stalker2.LayeredItemImage
// 0x01A8 (0x0420 - 0x0278)
class ULayeredItemImage final : public UWidgetBase
{
public:
	class FString                                 PathSuffix;                                        // 0x0278(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImageWidget*                           MainImage;                                         // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               ImagesOverlay;                                     // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               LowPrioOverlay;                                    // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               HighPrioOverlay;                                   // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IconsAsyncRequestCounter;                          // 0x02A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UImageWidget>               ImageWidgetClass;                                  // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIconSettings                          IconSettings;                                      // 0x02C0(0x0120)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UImageWidget*>                   ImageWidgets;                                      // 0x03E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x30];                                     // 0x03F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LayeredItemImage">();
	}
	static class ULayeredItemImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULayeredItemImage>();
	}
};
static_assert(alignof(ULayeredItemImage) == 0x000010, "Wrong alignment on ULayeredItemImage");
static_assert(sizeof(ULayeredItemImage) == 0x000420, "Wrong size on ULayeredItemImage");
static_assert(offsetof(ULayeredItemImage, PathSuffix) == 0x000278, "Member 'ULayeredItemImage::PathSuffix' has a wrong offset!");
static_assert(offsetof(ULayeredItemImage, MainImage) == 0x000288, "Member 'ULayeredItemImage::MainImage' has a wrong offset!");
static_assert(offsetof(ULayeredItemImage, ImagesOverlay) == 0x000290, "Member 'ULayeredItemImage::ImagesOverlay' has a wrong offset!");
static_assert(offsetof(ULayeredItemImage, LowPrioOverlay) == 0x000298, "Member 'ULayeredItemImage::LowPrioOverlay' has a wrong offset!");
static_assert(offsetof(ULayeredItemImage, HighPrioOverlay) == 0x0002A0, "Member 'ULayeredItemImage::HighPrioOverlay' has a wrong offset!");
static_assert(offsetof(ULayeredItemImage, IconsAsyncRequestCounter) == 0x0002A8, "Member 'ULayeredItemImage::IconsAsyncRequestCounter' has a wrong offset!");
static_assert(offsetof(ULayeredItemImage, ImageWidgetClass) == 0x0002B0, "Member 'ULayeredItemImage::ImageWidgetClass' has a wrong offset!");
static_assert(offsetof(ULayeredItemImage, IconSettings) == 0x0002C0, "Member 'ULayeredItemImage::IconSettings' has a wrong offset!");
static_assert(offsetof(ULayeredItemImage, ImageWidgets) == 0x0003E0, "Member 'ULayeredItemImage::ImageWidgets' has a wrong offset!");

// Class Stalker2.SkipKeyHint
// 0x0008 (0x0280 - 0x0278)
class USkipKeyHint final : public UUserWidget
{
public:
	class UHintControllerBase*                    InputController;                                   // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkipKeyHint">();
	}
	static class USkipKeyHint* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkipKeyHint>();
	}
};
static_assert(alignof(USkipKeyHint) == 0x000008, "Wrong alignment on USkipKeyHint");
static_assert(sizeof(USkipKeyHint) == 0x000280, "Wrong size on USkipKeyHint");
static_assert(offsetof(USkipKeyHint, InputController) == 0x000278, "Member 'USkipKeyHint::InputController' has a wrong offset!");

// Class Stalker2.LeanLeftIPU
// 0x0000 (0x0058 - 0x0058)
class ULeanLeftIPU final : public UBehaviorBasedIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeanLeftIPU">();
	}
	static class ULeanLeftIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeanLeftIPU>();
	}
};
static_assert(alignof(ULeanLeftIPU) == 0x000008, "Wrong alignment on ULeanLeftIPU");
static_assert(sizeof(ULeanLeftIPU) == 0x000058, "Wrong size on ULeanLeftIPU");

// Class Stalker2.PDAMenuButton
// 0x0068 (0x0328 - 0x02C0)
class UPDAMenuButton final : public UButtonBase
{
public:
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 SelectLine;                                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Notify;                                            // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            ButtonText;                                        // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLocalisation;                               // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ButtonLocalizationSID;                             // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x02F8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEnableSelectAnimation;                            // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SetStyleIdHover;                                   // 0x0314(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetStyleIdUnHover;                                 // 0x031C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAMenuButton">();
	}
	static class UPDAMenuButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAMenuButton>();
	}
};
static_assert(alignof(UPDAMenuButton) == 0x000008, "Wrong alignment on UPDAMenuButton");
static_assert(sizeof(UPDAMenuButton) == 0x000328, "Wrong size on UPDAMenuButton");
static_assert(offsetof(UPDAMenuButton, SelectLine) == 0x0002C8, "Member 'UPDAMenuButton::SelectLine' has a wrong offset!");
static_assert(offsetof(UPDAMenuButton, Notify) == 0x0002D0, "Member 'UPDAMenuButton::Notify' has a wrong offset!");
static_assert(offsetof(UPDAMenuButton, ButtonText) == 0x0002D8, "Member 'UPDAMenuButton::ButtonText' has a wrong offset!");
static_assert(offsetof(UPDAMenuButton, bEnableLocalisation) == 0x0002E0, "Member 'UPDAMenuButton::bEnableLocalisation' has a wrong offset!");
static_assert(offsetof(UPDAMenuButton, ButtonLocalizationSID) == 0x0002E8, "Member 'UPDAMenuButton::ButtonLocalizationSID' has a wrong offset!");
static_assert(offsetof(UPDAMenuButton, DisplayText) == 0x0002F8, "Member 'UPDAMenuButton::DisplayText' has a wrong offset!");
static_assert(offsetof(UPDAMenuButton, bEnableSelectAnimation) == 0x000310, "Member 'UPDAMenuButton::bEnableSelectAnimation' has a wrong offset!");
static_assert(offsetof(UPDAMenuButton, SetStyleIdHover) == 0x000314, "Member 'UPDAMenuButton::SetStyleIdHover' has a wrong offset!");
static_assert(offsetof(UPDAMenuButton, SetStyleIdUnHover) == 0x00031C, "Member 'UPDAMenuButton::SetStyleIdUnHover' has a wrong offset!");

// Class Stalker2.Lever
// 0x00D0 (0x0348 - 0x0278)
class ULever final : public ULockableComponent
{
public:
	float                                         CurrentValue;                                      // 0x0278(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldConsumeItemOnOpen;                          // 0x027C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseInBothSides;                                   // 0x027D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27E[0x2];                                      // 0x027E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   LeverHandleMesh;                                   // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            LeverCurve;                                        // 0x0288(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            LeverCurveReverse;                                 // 0x0290(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0xB0];                                     // 0x0298(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeLeverPosition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Lever">();
	}
	static class ULever* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULever>();
	}
};
static_assert(alignof(ULever) == 0x000008, "Wrong alignment on ULever");
static_assert(sizeof(ULever) == 0x000348, "Wrong size on ULever");
static_assert(offsetof(ULever, CurrentValue) == 0x000278, "Member 'ULever::CurrentValue' has a wrong offset!");
static_assert(offsetof(ULever, bShouldConsumeItemOnOpen) == 0x00027C, "Member 'ULever::bShouldConsumeItemOnOpen' has a wrong offset!");
static_assert(offsetof(ULever, bUseInBothSides) == 0x00027D, "Member 'ULever::bUseInBothSides' has a wrong offset!");
static_assert(offsetof(ULever, LeverHandleMesh) == 0x000280, "Member 'ULever::LeverHandleMesh' has a wrong offset!");
static_assert(offsetof(ULever, LeverCurve) == 0x000288, "Member 'ULever::LeverCurve' has a wrong offset!");
static_assert(offsetof(ULever, LeverCurveReverse) == 0x000290, "Member 'ULever::LeverCurveReverse' has a wrong offset!");

// Class Stalker2.SettingsManager
// 0x0150 (0x01F8 - 0x00A8)
class USettingsManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x100];                                     // 0x00A8(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRtpc*                                MainVolumeRTPCParameter;                           // 0x01A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                MusicVolumeRTPCParameter;                          // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                EffectsVolumeRTPCParameter;                        // 0x01B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                DialogueVolumeRTPCParameter;                       // 0x01C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                MuteAllRTPCParameter;                              // 0x01C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                DisableCopyrightedMusicRTPCParameter;              // 0x01D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkEffectShareSet*                      FullAkEffectShareSet;                              // 0x01D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkEffectShareSet*                      MediumAkEffectShareSet;                            // 0x01E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkEffectShareSet*                      NarrowAkEffectShareSet;                            // 0x01E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F0[0x8];                                      // 0x01F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsManager">();
	}
	static class USettingsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsManager>();
	}
};
static_assert(alignof(USettingsManager) == 0x000008, "Wrong alignment on USettingsManager");
static_assert(sizeof(USettingsManager) == 0x0001F8, "Wrong size on USettingsManager");
static_assert(offsetof(USettingsManager, MainVolumeRTPCParameter) == 0x0001A8, "Member 'USettingsManager::MainVolumeRTPCParameter' has a wrong offset!");
static_assert(offsetof(USettingsManager, MusicVolumeRTPCParameter) == 0x0001B0, "Member 'USettingsManager::MusicVolumeRTPCParameter' has a wrong offset!");
static_assert(offsetof(USettingsManager, EffectsVolumeRTPCParameter) == 0x0001B8, "Member 'USettingsManager::EffectsVolumeRTPCParameter' has a wrong offset!");
static_assert(offsetof(USettingsManager, DialogueVolumeRTPCParameter) == 0x0001C0, "Member 'USettingsManager::DialogueVolumeRTPCParameter' has a wrong offset!");
static_assert(offsetof(USettingsManager, MuteAllRTPCParameter) == 0x0001C8, "Member 'USettingsManager::MuteAllRTPCParameter' has a wrong offset!");
static_assert(offsetof(USettingsManager, DisableCopyrightedMusicRTPCParameter) == 0x0001D0, "Member 'USettingsManager::DisableCopyrightedMusicRTPCParameter' has a wrong offset!");
static_assert(offsetof(USettingsManager, FullAkEffectShareSet) == 0x0001D8, "Member 'USettingsManager::FullAkEffectShareSet' has a wrong offset!");
static_assert(offsetof(USettingsManager, MediumAkEffectShareSet) == 0x0001E0, "Member 'USettingsManager::MediumAkEffectShareSet' has a wrong offset!");
static_assert(offsetof(USettingsManager, NarrowAkEffectShareSet) == 0x0001E8, "Member 'USettingsManager::NarrowAkEffectShareSet' has a wrong offset!");

// Class Stalker2.LightBulbComponent
// 0x0010 (0x00C8 - 0x00B8)
class ULightBulbComponent final : public UGuidActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFlicker;                                          // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoLightOnNight;                                 // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAutoLightOnNight(const bool bInAutoLightOnNight);
	void SetFlicker(const bool bInFlicker);

	bool IsAutoLightOnNight() const;
	bool IsFlicker() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightBulbComponent">();
	}
	static class ULightBulbComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightBulbComponent>();
	}
};
static_assert(alignof(ULightBulbComponent) == 0x000008, "Wrong alignment on ULightBulbComponent");
static_assert(sizeof(ULightBulbComponent) == 0x0000C8, "Wrong size on ULightBulbComponent");
static_assert(offsetof(ULightBulbComponent, bFlicker) == 0x0000C0, "Member 'ULightBulbComponent::bFlicker' has a wrong offset!");
static_assert(offsetof(ULightBulbComponent, bAutoLightOnNight) == 0x0000C1, "Member 'ULightBulbComponent::bAutoLightOnNight' has a wrong offset!");

// Class Stalker2.LightningBallAnomaly
// 0x00C0 (0x0458 - 0x0398)
class ALightningBallAnomaly final : public AAnomaly
{
public:
	class USphereComponent*                       OverlapDamageComponent;                            // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      IdleParticle;                                      // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         ExplosionParticle;                                 // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         AnomalyEatingParticle;                             // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          FeastAudioEvent;                                   // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         FeastIdleSwitch;                                   // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         FeastEndSwitch;                                    // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AnomalyExplosionAudioEvent;                        // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULightningBallNavigationComponent*      AnomalyNavigationComponent;                        // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x78];                                     // 0x03E0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightningBallAnomaly">();
	}
	static class ALightningBallAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALightningBallAnomaly>();
	}
};
static_assert(alignof(ALightningBallAnomaly) == 0x000008, "Wrong alignment on ALightningBallAnomaly");
static_assert(sizeof(ALightningBallAnomaly) == 0x000458, "Wrong size on ALightningBallAnomaly");
static_assert(offsetof(ALightningBallAnomaly, OverlapDamageComponent) == 0x000398, "Member 'ALightningBallAnomaly::OverlapDamageComponent' has a wrong offset!");
static_assert(offsetof(ALightningBallAnomaly, IdleParticle) == 0x0003A0, "Member 'ALightningBallAnomaly::IdleParticle' has a wrong offset!");
static_assert(offsetof(ALightningBallAnomaly, ExplosionParticle) == 0x0003A8, "Member 'ALightningBallAnomaly::ExplosionParticle' has a wrong offset!");
static_assert(offsetof(ALightningBallAnomaly, AnomalyEatingParticle) == 0x0003B0, "Member 'ALightningBallAnomaly::AnomalyEatingParticle' has a wrong offset!");
static_assert(offsetof(ALightningBallAnomaly, FeastAudioEvent) == 0x0003B8, "Member 'ALightningBallAnomaly::FeastAudioEvent' has a wrong offset!");
static_assert(offsetof(ALightningBallAnomaly, FeastIdleSwitch) == 0x0003C0, "Member 'ALightningBallAnomaly::FeastIdleSwitch' has a wrong offset!");
static_assert(offsetof(ALightningBallAnomaly, FeastEndSwitch) == 0x0003C8, "Member 'ALightningBallAnomaly::FeastEndSwitch' has a wrong offset!");
static_assert(offsetof(ALightningBallAnomaly, AnomalyExplosionAudioEvent) == 0x0003D0, "Member 'ALightningBallAnomaly::AnomalyExplosionAudioEvent' has a wrong offset!");
static_assert(offsetof(ALightningBallAnomaly, AnomalyNavigationComponent) == 0x0003D8, "Member 'ALightningBallAnomaly::AnomalyNavigationComponent' has a wrong offset!");

// Class Stalker2.LightsCache
// 0x0020 (0x00C8 - 0x00A8)
class ULightsCache final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightsCache">();
	}
	static class ULightsCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightsCache>();
	}
};
static_assert(alignof(ULightsCache) == 0x000008, "Wrong alignment on ULightsCache");
static_assert(sizeof(ULightsCache) == 0x0000C8, "Wrong size on ULightsCache");

// Class Stalker2.LoadingScreenManager
// 0x0048 (0x0078 - 0x0030)
class ULoadingScreenManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreenManager">();
	}
	static class ULoadingScreenManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingScreenManager>();
	}
};
static_assert(alignof(ULoadingScreenManager) == 0x000008, "Wrong alignment on ULoadingScreenManager");
static_assert(sizeof(ULoadingScreenManager) == 0x000078, "Wrong size on ULoadingScreenManager");

// Class Stalker2.LoadingScreenSettings
// 0x0330 (0x0368 - 0x0038)
class ULoadingScreenSettings final : public UDeveloperSettings
{
public:
	TMap<ELoadingDestination, struct FLoadingScreenBehaviourSettings> LoadingScreenBehaviourSettings; // 0x0038(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         DescriptionFont;                                   // 0x0088(0x0058)(Edit, BlueprintVisible, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         TitleFont;                                         // 0x00E0(0x0058)(Edit, BlueprintVisible, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         WaitForUserInputTextStyle;                         // 0x0138(0x0058)(Edit, BlueprintVisible, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextColor;                                         // 0x0190(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                ContentPadding;                                    // 0x01A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                TipsTitleTextPadding;                              // 0x01B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                TipsTextPadding;                                   // 0x01C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                LoadArrowPadding;                                  // 0x01D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              LoadArrowRotation;                                 // 0x01E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitForUserInputTextPos;                           // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TipsRangeMax;                                      // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   WaitForUserInputText;                              // 0x01F8(0x0018)(Edit, BlueprintVisible, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LoadingScreenIndicatorBackground;                  // 0x0210(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LoadingScreenIndicatorBackgroundSize;              // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LoadingIndicatorArrow;                             // 0x0240(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ForegroundImage;                                   // 0x0260(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SlidingDirtMaterialPtrTopLeft;                     // 0x0280(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SlidingDirtMaterialPtrTopRight;                    // 0x02A0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SlidingDirtMaterialPtrBottomLeft;                  // 0x02C0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SlidingDirtMaterialPtrBottomRight;                 // 0x02E0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInfoScreenSettings>            InfoScreenSettingsData;                            // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector2D                              SlidingDirtMaterialSize;                           // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeTillShowingLoadingIndicator;                   // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeTillHidingLoadingScreen;                       // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CustomTeleportMediaSource;                         // 0x0328(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IntroductionLogoMediaSource;                       // 0x0348(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreenSettings">();
	}
	static class ULoadingScreenSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingScreenSettings>();
	}
};
static_assert(alignof(ULoadingScreenSettings) == 0x000008, "Wrong alignment on ULoadingScreenSettings");
static_assert(sizeof(ULoadingScreenSettings) == 0x000368, "Wrong size on ULoadingScreenSettings");
static_assert(offsetof(ULoadingScreenSettings, LoadingScreenBehaviourSettings) == 0x000038, "Member 'ULoadingScreenSettings::LoadingScreenBehaviourSettings' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, DescriptionFont) == 0x000088, "Member 'ULoadingScreenSettings::DescriptionFont' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, TitleFont) == 0x0000E0, "Member 'ULoadingScreenSettings::TitleFont' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, WaitForUserInputTextStyle) == 0x000138, "Member 'ULoadingScreenSettings::WaitForUserInputTextStyle' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, TextColor) == 0x000190, "Member 'ULoadingScreenSettings::TextColor' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, ContentPadding) == 0x0001A0, "Member 'ULoadingScreenSettings::ContentPadding' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, TipsTitleTextPadding) == 0x0001B0, "Member 'ULoadingScreenSettings::TipsTitleTextPadding' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, TipsTextPadding) == 0x0001C0, "Member 'ULoadingScreenSettings::TipsTextPadding' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, LoadArrowPadding) == 0x0001D0, "Member 'ULoadingScreenSettings::LoadArrowPadding' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, LoadArrowRotation) == 0x0001E0, "Member 'ULoadingScreenSettings::LoadArrowRotation' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, WaitForUserInputTextPos) == 0x0001F0, "Member 'ULoadingScreenSettings::WaitForUserInputTextPos' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, TipsRangeMax) == 0x0001F4, "Member 'ULoadingScreenSettings::TipsRangeMax' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, WaitForUserInputText) == 0x0001F8, "Member 'ULoadingScreenSettings::WaitForUserInputText' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, LoadingScreenIndicatorBackground) == 0x000210, "Member 'ULoadingScreenSettings::LoadingScreenIndicatorBackground' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, LoadingScreenIndicatorBackgroundSize) == 0x000230, "Member 'ULoadingScreenSettings::LoadingScreenIndicatorBackgroundSize' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, LoadingIndicatorArrow) == 0x000240, "Member 'ULoadingScreenSettings::LoadingIndicatorArrow' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, ForegroundImage) == 0x000260, "Member 'ULoadingScreenSettings::ForegroundImage' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, SlidingDirtMaterialPtrTopLeft) == 0x000280, "Member 'ULoadingScreenSettings::SlidingDirtMaterialPtrTopLeft' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, SlidingDirtMaterialPtrTopRight) == 0x0002A0, "Member 'ULoadingScreenSettings::SlidingDirtMaterialPtrTopRight' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, SlidingDirtMaterialPtrBottomLeft) == 0x0002C0, "Member 'ULoadingScreenSettings::SlidingDirtMaterialPtrBottomLeft' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, SlidingDirtMaterialPtrBottomRight) == 0x0002E0, "Member 'ULoadingScreenSettings::SlidingDirtMaterialPtrBottomRight' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, InfoScreenSettingsData) == 0x000300, "Member 'ULoadingScreenSettings::InfoScreenSettingsData' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, SlidingDirtMaterialSize) == 0x000310, "Member 'ULoadingScreenSettings::SlidingDirtMaterialSize' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, TimeTillShowingLoadingIndicator) == 0x000320, "Member 'ULoadingScreenSettings::TimeTillShowingLoadingIndicator' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, TimeTillHidingLoadingScreen) == 0x000324, "Member 'ULoadingScreenSettings::TimeTillHidingLoadingScreen' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, CustomTeleportMediaSource) == 0x000328, "Member 'ULoadingScreenSettings::CustomTeleportMediaSource' has a wrong offset!");
static_assert(offsetof(ULoadingScreenSettings, IntroductionLogoMediaSource) == 0x000348, "Member 'ULoadingScreenSettings::IntroductionLogoMediaSource' has a wrong offset!");

// Class Stalker2.LoadingScreenWidget
// 0x00A8 (0x0350 - 0x02A8)
class ULoadingScreenWidget : public UBaseLoadingScreenWidget
{
public:
	class UTextBlock*                             PressAnyButtonText;                                // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 LoadingScreenImage;                                // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 LoadingProgressBar;                                // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 LoadingProgressArrow;                              // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             Title;                                             // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             Hint;                                              // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UTexture2D>>      LoadingScreensSet;                                 // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         FadeTime;                                          // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ArrowMinMaxAngles;                                 // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ArrowInterpSpeed;                                  // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PressAnyButtonL10n;                                // 0x0308(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x38];                                     // 0x0318(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreenWidget">();
	}
	static class ULoadingScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingScreenWidget>();
	}
};
static_assert(alignof(ULoadingScreenWidget) == 0x000008, "Wrong alignment on ULoadingScreenWidget");
static_assert(sizeof(ULoadingScreenWidget) == 0x000350, "Wrong size on ULoadingScreenWidget");
static_assert(offsetof(ULoadingScreenWidget, PressAnyButtonText) == 0x0002A8, "Member 'ULoadingScreenWidget::PressAnyButtonText' has a wrong offset!");
static_assert(offsetof(ULoadingScreenWidget, LoadingScreenImage) == 0x0002B0, "Member 'ULoadingScreenWidget::LoadingScreenImage' has a wrong offset!");
static_assert(offsetof(ULoadingScreenWidget, LoadingProgressBar) == 0x0002B8, "Member 'ULoadingScreenWidget::LoadingProgressBar' has a wrong offset!");
static_assert(offsetof(ULoadingScreenWidget, LoadingProgressArrow) == 0x0002C0, "Member 'ULoadingScreenWidget::LoadingProgressArrow' has a wrong offset!");
static_assert(offsetof(ULoadingScreenWidget, Title) == 0x0002C8, "Member 'ULoadingScreenWidget::Title' has a wrong offset!");
static_assert(offsetof(ULoadingScreenWidget, Hint) == 0x0002D0, "Member 'ULoadingScreenWidget::Hint' has a wrong offset!");
static_assert(offsetof(ULoadingScreenWidget, LoadingScreensSet) == 0x0002D8, "Member 'ULoadingScreenWidget::LoadingScreensSet' has a wrong offset!");
static_assert(offsetof(ULoadingScreenWidget, FadeTime) == 0x0002E8, "Member 'ULoadingScreenWidget::FadeTime' has a wrong offset!");
static_assert(offsetof(ULoadingScreenWidget, ArrowMinMaxAngles) == 0x0002F0, "Member 'ULoadingScreenWidget::ArrowMinMaxAngles' has a wrong offset!");
static_assert(offsetof(ULoadingScreenWidget, ArrowInterpSpeed) == 0x000300, "Member 'ULoadingScreenWidget::ArrowInterpSpeed' has a wrong offset!");
static_assert(offsetof(ULoadingScreenWidget, PressAnyButtonL10n) == 0x000308, "Member 'ULoadingScreenWidget::PressAnyButtonL10n' has a wrong offset!");

// Class Stalker2.PauseMenuIPU
// 0x0000 (0x0040 - 0x0040)
class UPauseMenuIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseMenuIPU">();
	}
	static class UPauseMenuIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPauseMenuIPU>();
	}
};
static_assert(alignof(UPauseMenuIPU) == 0x000008, "Wrong alignment on UPauseMenuIPU");
static_assert(sizeof(UPauseMenuIPU) == 0x000040, "Wrong size on UPauseMenuIPU");

// Class Stalker2.LocalizationDatabase
// 0x0000 (0x0028 - 0x0028)
class ULocalizationDatabase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizationDatabase">();
	}
	static class ULocalizationDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalizationDatabase>();
	}
};
static_assert(alignof(ULocalizationDatabase) == 0x000008, "Wrong alignment on ULocalizationDatabase");
static_assert(sizeof(ULocalizationDatabase) == 0x000028, "Wrong size on ULocalizationDatabase");

// Class Stalker2.SettingElementButton
// 0x0020 (0x1DA0 - 0x1D80)
class USettingElementButton final : public USettingElement
{
public:
	uint8                                         Pad_1D80[0x18];                                    // 0x1D80(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	ENestingIndex                                 NestingWindowIndex;                                // 0x1D98(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D99[0x7];                                     // 0x1D99(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeLegendOnHovered();
	void ChangeLegendOnUnhovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingElementButton">();
	}
	static class USettingElementButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingElementButton>();
	}
};
static_assert(alignof(USettingElementButton) == 0x000010, "Wrong alignment on USettingElementButton");
static_assert(sizeof(USettingElementButton) == 0x001DA0, "Wrong size on USettingElementButton");
static_assert(offsetof(USettingElementButton, NestingWindowIndex) == 0x001D98, "Member 'USettingElementButton::NestingWindowIndex' has a wrong offset!");

// Class Stalker2.LocalizationWidget
// 0x0040 (0x02B8 - 0x0278)
class ULocalizationWidget : public UWidgetBase
{
public:
	bool                                          bEnableLocalization;                               // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LocalizationSID;                                   // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextBlock*                         RichTextBlockObj;                                  // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlockObj;                                      // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonTextBlock*                       CommonTextBlockObj;                                // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizationWidget">();
	}
	static class ULocalizationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalizationWidget>();
	}
};
static_assert(alignof(ULocalizationWidget) == 0x000008, "Wrong alignment on ULocalizationWidget");
static_assert(sizeof(ULocalizationWidget) == 0x0002B8, "Wrong size on ULocalizationWidget");
static_assert(offsetof(ULocalizationWidget, bEnableLocalization) == 0x000278, "Member 'ULocalizationWidget::bEnableLocalization' has a wrong offset!");
static_assert(offsetof(ULocalizationWidget, LocalizationSID) == 0x000280, "Member 'ULocalizationWidget::LocalizationSID' has a wrong offset!");
static_assert(offsetof(ULocalizationWidget, RichTextBlockObj) == 0x000290, "Member 'ULocalizationWidget::RichTextBlockObj' has a wrong offset!");
static_assert(offsetof(ULocalizationWidget, TextBlockObj) == 0x000298, "Member 'ULocalizationWidget::TextBlockObj' has a wrong offset!");
static_assert(offsetof(ULocalizationWidget, CommonTextBlockObj) == 0x0002A0, "Member 'ULocalizationWidget::CommonTextBlockObj' has a wrong offset!");

// Class Stalker2.LocalizedImage
// 0x0098 (0x0310 - 0x0278)
class ULocalizedImage : public UWidgetBase
{
public:
	class UImage*                                 Image;                                             // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<ELocalizationLanguage, TSoftObjectPtr<class UTexture2D>> LocalizedImages;                   // 0x0280(0x0050)(Edit, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>              FallbackImage;                                     // 0x02D0(0x0030)(Edit, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceLoadImage(const TSoftObjectPtr<class UTexture2D>& SoftImage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizedImage">();
	}
	static class ULocalizedImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalizedImage>();
	}
};
static_assert(alignof(ULocalizedImage) == 0x000008, "Wrong alignment on ULocalizedImage");
static_assert(sizeof(ULocalizedImage) == 0x000310, "Wrong size on ULocalizedImage");
static_assert(offsetof(ULocalizedImage, Image) == 0x000278, "Member 'ULocalizedImage::Image' has a wrong offset!");
static_assert(offsetof(ULocalizedImage, LocalizedImages) == 0x000280, "Member 'ULocalizedImage::LocalizedImages' has a wrong offset!");
static_assert(offsetof(ULocalizedImage, FallbackImage) == 0x0002D0, "Member 'ULocalizedImage::FallbackImage' has a wrong offset!");

// Class Stalker2.LookAtSourceComponent
// 0x0070 (0x0110 - 0x00A0)
class ULookAtSourceComponent final : public UActorComponent
{
public:
	class AActor*                                 Target;                                            // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultSetting;                                // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLookAtAngleParams                     LookAtAngleParams;                                 // 0x00B0(0x0060)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtSourceComponent">();
	}
	static class ULookAtSourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtSourceComponent>();
	}
};
static_assert(alignof(ULookAtSourceComponent) == 0x000008, "Wrong alignment on ULookAtSourceComponent");
static_assert(sizeof(ULookAtSourceComponent) == 0x000110, "Wrong size on ULookAtSourceComponent");
static_assert(offsetof(ULookAtSourceComponent, Target) == 0x0000A0, "Member 'ULookAtSourceComponent::Target' has a wrong offset!");
static_assert(offsetof(ULookAtSourceComponent, bIsEnabled) == 0x0000A8, "Member 'ULookAtSourceComponent::bIsEnabled' has a wrong offset!");
static_assert(offsetof(ULookAtSourceComponent, bUseDefaultSetting) == 0x0000A9, "Member 'ULookAtSourceComponent::bUseDefaultSetting' has a wrong offset!");
static_assert(offsetof(ULookAtSourceComponent, LookAtAngleParams) == 0x0000B0, "Member 'ULookAtSourceComponent::LookAtAngleParams' has a wrong offset!");

// Class Stalker2.LookAtTargetComponent
// 0x0000 (0x02A0 - 0x02A0)
class ULookAtTargetComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtTargetComponent">();
	}
	static class ULookAtTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtTargetComponent>();
	}
};
static_assert(alignof(ULookAtTargetComponent) == 0x000010, "Wrong alignment on ULookAtTargetComponent");
static_assert(sizeof(ULookAtTargetComponent) == 0x0002A0, "Wrong size on ULookAtTargetComponent");

// Class Stalker2.NiagaraWindIntensityDirectionProvider
// 0x0000 (0x0100 - 0x0100)
class UNiagaraWindIntensityDirectionProvider final : public UNiagaraParameterProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraWindIntensityDirectionProvider">();
	}
	static class UNiagaraWindIntensityDirectionProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraWindIntensityDirectionProvider>();
	}
};
static_assert(alignof(UNiagaraWindIntensityDirectionProvider) == 0x000008, "Wrong alignment on UNiagaraWindIntensityDirectionProvider");
static_assert(sizeof(UNiagaraWindIntensityDirectionProvider) == 0x000100, "Wrong size on UNiagaraWindIntensityDirectionProvider");

// Class Stalker2.LookUpIPU
// 0x0000 (0x0060 - 0x0060)
class ULookUpIPU final : public UInertionIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookUpIPU">();
	}
	static class ULookUpIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookUpIPU>();
	}
};
static_assert(alignof(ULookUpIPU) == 0x000008, "Wrong alignment on ULookUpIPU");
static_assert(sizeof(ULookUpIPU) == 0x000060, "Wrong size on ULookUpIPU");

// Class Stalker2.MainHandEquipItemIPU
// 0x0008 (0x0048 - 0x0040)
class UMainHandEquipItemIPU : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainHandEquipItemIPU">();
	}
	static class UMainHandEquipItemIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainHandEquipItemIPU>();
	}
};
static_assert(alignof(UMainHandEquipItemIPU) == 0x000008, "Wrong alignment on UMainHandEquipItemIPU");
static_assert(sizeof(UMainHandEquipItemIPU) == 0x000048, "Wrong size on UMainHandEquipItemIPU");

// Class Stalker2.MainHandEquipBoltIPU
// 0x0000 (0x0048 - 0x0048)
class UMainHandEquipBoltIPU final : public UMainHandEquipItemIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainHandEquipBoltIPU">();
	}
	static class UMainHandEquipBoltIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainHandEquipBoltIPU>();
	}
};
static_assert(alignof(UMainHandEquipBoltIPU) == 0x000008, "Wrong alignment on UMainHandEquipBoltIPU");
static_assert(sizeof(UMainHandEquipBoltIPU) == 0x000048, "Wrong size on UMainHandEquipBoltIPU");

// Class Stalker2.PDARadiationLine
// 0x0010 (0x0288 - 0x0278)
class UPDARadiationLine final : public UWidgetBase
{
public:
	class UWidgetAnimation*                       MoveAnim;                                          // 0x0278(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShoudBlockAnim;                                   // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveAnimSpeed;                                     // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDARadiationLine">();
	}
	static class UPDARadiationLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDARadiationLine>();
	}
};
static_assert(alignof(UPDARadiationLine) == 0x000008, "Wrong alignment on UPDARadiationLine");
static_assert(sizeof(UPDARadiationLine) == 0x000288, "Wrong size on UPDARadiationLine");
static_assert(offsetof(UPDARadiationLine, MoveAnim) == 0x000278, "Member 'UPDARadiationLine::MoveAnim' has a wrong offset!");
static_assert(offsetof(UPDARadiationLine, bShoudBlockAnim) == 0x000280, "Member 'UPDARadiationLine::bShoudBlockAnim' has a wrong offset!");
static_assert(offsetof(UPDARadiationLine, MoveAnimSpeed) == 0x000284, "Member 'UPDARadiationLine::MoveAnimSpeed' has a wrong offset!");

// Class Stalker2.MainHandEquipDetectorIPU
// 0x0008 (0x0048 - 0x0040)
class UMainHandEquipDetectorIPU final : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainHandEquipDetectorIPU">();
	}
	static class UMainHandEquipDetectorIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainHandEquipDetectorIPU>();
	}
};
static_assert(alignof(UMainHandEquipDetectorIPU) == 0x000008, "Wrong alignment on UMainHandEquipDetectorIPU");
static_assert(sizeof(UMainHandEquipDetectorIPU) == 0x000048, "Wrong size on UMainHandEquipDetectorIPU");

// Class Stalker2.MainHandEquipGrenadeIPU
// 0x0000 (0x0048 - 0x0048)
class UMainHandEquipGrenadeIPU final : public UMainHandEquipItemIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainHandEquipGrenadeIPU">();
	}
	static class UMainHandEquipGrenadeIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainHandEquipGrenadeIPU>();
	}
};
static_assert(alignof(UMainHandEquipGrenadeIPU) == 0x000008, "Wrong alignment on UMainHandEquipGrenadeIPU");
static_assert(sizeof(UMainHandEquipGrenadeIPU) == 0x000048, "Wrong size on UMainHandEquipGrenadeIPU");

// Class Stalker2.MainHandEquipKnifeIPU
// 0x0000 (0x0048 - 0x0048)
class UMainHandEquipKnifeIPU final : public UMainHandEquipItemIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainHandEquipKnifeIPU">();
	}
	static class UMainHandEquipKnifeIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainHandEquipKnifeIPU>();
	}
};
static_assert(alignof(UMainHandEquipKnifeIPU) == 0x000008, "Wrong alignment on UMainHandEquipKnifeIPU");
static_assert(sizeof(UMainHandEquipKnifeIPU) == 0x000048, "Wrong size on UMainHandEquipKnifeIPU");

// Class Stalker2.MainHandEquipPistolIPU
// 0x0000 (0x0048 - 0x0048)
class UMainHandEquipPistolIPU final : public UMainHandEquipItemIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainHandEquipPistolIPU">();
	}
	static class UMainHandEquipPistolIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainHandEquipPistolIPU>();
	}
};
static_assert(alignof(UMainHandEquipPistolIPU) == 0x000008, "Wrong alignment on UMainHandEquipPistolIPU");
static_assert(sizeof(UMainHandEquipPistolIPU) == 0x000048, "Wrong size on UMainHandEquipPistolIPU");

// Class Stalker2.MainHandEquipPrimaryWeaponIPU
// 0x0000 (0x0048 - 0x0048)
class UMainHandEquipPrimaryWeaponIPU final : public UMainHandEquipItemIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainHandEquipPrimaryWeaponIPU">();
	}
	static class UMainHandEquipPrimaryWeaponIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainHandEquipPrimaryWeaponIPU>();
	}
};
static_assert(alignof(UMainHandEquipPrimaryWeaponIPU) == 0x000008, "Wrong alignment on UMainHandEquipPrimaryWeaponIPU");
static_assert(sizeof(UMainHandEquipPrimaryWeaponIPU) == 0x000048, "Wrong size on UMainHandEquipPrimaryWeaponIPU");

// Class Stalker2.MainHandEquipSecondaryWeaponIPU
// 0x0000 (0x0048 - 0x0048)
class UMainHandEquipSecondaryWeaponIPU final : public UMainHandEquipItemIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainHandEquipSecondaryWeaponIPU">();
	}
	static class UMainHandEquipSecondaryWeaponIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainHandEquipSecondaryWeaponIPU>();
	}
};
static_assert(alignof(UMainHandEquipSecondaryWeaponIPU) == 0x000008, "Wrong alignment on UMainHandEquipSecondaryWeaponIPU");
static_assert(sizeof(UMainHandEquipSecondaryWeaponIPU) == 0x000048, "Wrong size on UMainHandEquipSecondaryWeaponIPU");

// Class Stalker2.MainMenuGameMode
// 0x0000 (0x0340 - 0x0340)
class AMainMenuGameMode final : public AStalker2BaseGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuGameMode">();
	}
	static class AMainMenuGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMainMenuGameMode>();
	}
};
static_assert(alignof(AMainMenuGameMode) == 0x000008, "Wrong alignment on AMainMenuGameMode");
static_assert(sizeof(AMainMenuGameMode) == 0x000340, "Wrong size on AMainMenuGameMode");

// Class Stalker2.MainMenuSubView
// 0x0000 (0x02D0 - 0x02D0)
class UMainMenuSubView final : public UMenuSubViewBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuSubView">();
	}
	static class UMainMenuSubView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuSubView>();
	}
};
static_assert(alignof(UMainMenuSubView) == 0x000008, "Wrong alignment on UMainMenuSubView");
static_assert(sizeof(UMainMenuSubView) == 0x0002D0, "Wrong size on UMainMenuSubView");

// Class Stalker2.PDAQuestButton
// 0x0020 (0x0340 - 0x0320)
class UPDAQuestButton final : public UPDAButtonBase
{
public:
	class UTextWidget*                            ButtonText;                                        // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLocalization;                               // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ButtonLocalizationSID;                             // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAQuestButton">();
	}
	static class UPDAQuestButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAQuestButton>();
	}
};
static_assert(alignof(UPDAQuestButton) == 0x000008, "Wrong alignment on UPDAQuestButton");
static_assert(sizeof(UPDAQuestButton) == 0x000340, "Wrong size on UPDAQuestButton");
static_assert(offsetof(UPDAQuestButton, ButtonText) == 0x000320, "Member 'UPDAQuestButton::ButtonText' has a wrong offset!");
static_assert(offsetof(UPDAQuestButton, bEnableLocalization) == 0x000328, "Member 'UPDAQuestButton::bEnableLocalization' has a wrong offset!");
static_assert(offsetof(UPDAQuestButton, ButtonLocalizationSID) == 0x000330, "Member 'UPDAQuestButton::ButtonLocalizationSID' has a wrong offset!");

// Class Stalker2.MainMenuView
// 0x0008 (0x0340 - 0x0338)
class UMainMenuView final : public UMenuMainViewBase
{
public:
	TSubclassOf<class UMenuSubViewBase>           FirstTimeSettingsViewClass;                        // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuView">();
	}
	static class UMainMenuView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuView>();
	}
};
static_assert(alignof(UMainMenuView) == 0x000008, "Wrong alignment on UMainMenuView");
static_assert(sizeof(UMainMenuView) == 0x000340, "Wrong size on UMainMenuView");
static_assert(offsetof(UMainMenuView, FirstTimeSettingsViewClass) == 0x000338, "Member 'UMainMenuView::FirstTimeSettingsViewClass' has a wrong offset!");

// Class Stalker2.ShowSafeZoneViewButton
// 0x0000 (0x0300 - 0x0300)
class UShowSafeZoneViewButton final : public UMenuButtonBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowSafeZoneViewButton">();
	}
	static class UShowSafeZoneViewButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowSafeZoneViewButton>();
	}
};
static_assert(alignof(UShowSafeZoneViewButton) == 0x000008, "Wrong alignment on UShowSafeZoneViewButton");
static_assert(sizeof(UShowSafeZoneViewButton) == 0x000300, "Wrong size on UShowSafeZoneViewButton");

// Class Stalker2.MapBorderIndicator
// 0x0020 (0x0298 - 0x0278)
class UMapBorderIndicator final : public UWidgetBase
{
public:
	class UImage*                                 BorderLeft;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BorderRight;                                       // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BorderBottom;                                      // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BorderTop;                                         // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapBorderIndicator">();
	}
	static class UMapBorderIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapBorderIndicator>();
	}
};
static_assert(alignof(UMapBorderIndicator) == 0x000008, "Wrong alignment on UMapBorderIndicator");
static_assert(sizeof(UMapBorderIndicator) == 0x000298, "Wrong size on UMapBorderIndicator");
static_assert(offsetof(UMapBorderIndicator, BorderLeft) == 0x000278, "Member 'UMapBorderIndicator::BorderLeft' has a wrong offset!");
static_assert(offsetof(UMapBorderIndicator, BorderRight) == 0x000280, "Member 'UMapBorderIndicator::BorderRight' has a wrong offset!");
static_assert(offsetof(UMapBorderIndicator, BorderBottom) == 0x000288, "Member 'UMapBorderIndicator::BorderBottom' has a wrong offset!");
static_assert(offsetof(UMapBorderIndicator, BorderTop) == 0x000290, "Member 'UMapBorderIndicator::BorderTop' has a wrong offset!");

// Class Stalker2.MapCapture
// 0x0090 (0x0340 - 0x02B0)
class alignas(0x10) AMapCapture final : public ASceneCapture2D
{
public:
	struct FIntVector2                            StartCaptureLocation;                              // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector2                            EyeAdaptationTile;                                 // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector2                            DebugCaptureLocation;                              // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCaptureConfig                         CaptureConfig;                                     // 0x02C8(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0310(0x0008)(Edit, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x28];                                     // 0x0318(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapCapture">();
	}
	static class AMapCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapCapture>();
	}
};
static_assert(alignof(AMapCapture) == 0x000010, "Wrong alignment on AMapCapture");
static_assert(sizeof(AMapCapture) == 0x000340, "Wrong size on AMapCapture");
static_assert(offsetof(AMapCapture, StartCaptureLocation) == 0x0002B0, "Member 'AMapCapture::StartCaptureLocation' has a wrong offset!");
static_assert(offsetof(AMapCapture, EyeAdaptationTile) == 0x0002B8, "Member 'AMapCapture::EyeAdaptationTile' has a wrong offset!");
static_assert(offsetof(AMapCapture, DebugCaptureLocation) == 0x0002C0, "Member 'AMapCapture::DebugCaptureLocation' has a wrong offset!");
static_assert(offsetof(AMapCapture, CaptureConfig) == 0x0002C8, "Member 'AMapCapture::CaptureConfig' has a wrong offset!");
static_assert(offsetof(AMapCapture, RenderTarget) == 0x000310, "Member 'AMapCapture::RenderTarget' has a wrong offset!");

// Class Stalker2.PlayerFirearmAnimCollection
// 0x05C0 (0x05E8 - 0x0028)
class UPlayerFirearmAnimCollection final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerFirearmInternalAnimations       InternalAnimations;                                // 0x0030(0x02B8)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FVector>             SocketLocations;                                   // 0x02E8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UCurveVector*                           IdleSwayCurve;                                     // 0x0338(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayerWeaponAnimations                WeaponAnimations;                                  // 0x0340(0x0230)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FPlayerAutoCoverAnimations             AutoCoverAnimations;                               // 0x0570(0x0078)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerFirearmAnimCollection">();
	}
	static class UPlayerFirearmAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerFirearmAnimCollection>();
	}
};
static_assert(alignof(UPlayerFirearmAnimCollection) == 0x000008, "Wrong alignment on UPlayerFirearmAnimCollection");
static_assert(sizeof(UPlayerFirearmAnimCollection) == 0x0005E8, "Wrong size on UPlayerFirearmAnimCollection");
static_assert(offsetof(UPlayerFirearmAnimCollection, InternalAnimations) == 0x000030, "Member 'UPlayerFirearmAnimCollection::InternalAnimations' has a wrong offset!");
static_assert(offsetof(UPlayerFirearmAnimCollection, SocketLocations) == 0x0002E8, "Member 'UPlayerFirearmAnimCollection::SocketLocations' has a wrong offset!");
static_assert(offsetof(UPlayerFirearmAnimCollection, IdleSwayCurve) == 0x000338, "Member 'UPlayerFirearmAnimCollection::IdleSwayCurve' has a wrong offset!");
static_assert(offsetof(UPlayerFirearmAnimCollection, WeaponAnimations) == 0x000340, "Member 'UPlayerFirearmAnimCollection::WeaponAnimations' has a wrong offset!");
static_assert(offsetof(UPlayerFirearmAnimCollection, AutoCoverAnimations) == 0x000570, "Member 'UPlayerFirearmAnimCollection::AutoCoverAnimations' has a wrong offset!");

// Class Stalker2.MapLegend
// 0x0048 (0x02C0 - 0x0278)
class UMapLegend final : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x20];                                     // 0x0278(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       FadeInAnimation;                                   // 0x0298(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           NoteList;                                          // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             LegendScroll;                                      // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadScrollSpeed;                                // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInAnimationSpeed;                              // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutAnimationSpeed;                             // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapLegend">();
	}
	static class UMapLegend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapLegend>();
	}
};
static_assert(alignof(UMapLegend) == 0x000008, "Wrong alignment on UMapLegend");
static_assert(sizeof(UMapLegend) == 0x0002C0, "Wrong size on UMapLegend");
static_assert(offsetof(UMapLegend, FadeInAnimation) == 0x000298, "Member 'UMapLegend::FadeInAnimation' has a wrong offset!");
static_assert(offsetof(UMapLegend, NoteList) == 0x0002A0, "Member 'UMapLegend::NoteList' has a wrong offset!");
static_assert(offsetof(UMapLegend, LegendScroll) == 0x0002A8, "Member 'UMapLegend::LegendScroll' has a wrong offset!");
static_assert(offsetof(UMapLegend, GamepadScrollSpeed) == 0x0002B0, "Member 'UMapLegend::GamepadScrollSpeed' has a wrong offset!");
static_assert(offsetof(UMapLegend, FadeInAnimationSpeed) == 0x0002B4, "Member 'UMapLegend::FadeInAnimationSpeed' has a wrong offset!");
static_assert(offsetof(UMapLegend, FadeOutAnimationSpeed) == 0x0002B8, "Member 'UMapLegend::FadeOutAnimationSpeed' has a wrong offset!");

// Class Stalker2.MapLegendNote
// 0x0038 (0x02B0 - 0x0278)
class UMapLegendNote final : public UWidgetBase
{
public:
	class UImage*                                 MarkerIcon;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            MarkerName;                                        // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBox;                                           // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMarkerType                                   MarkerType;                                        // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MarkerNameSID;                                     // 0x0298(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Height;                                            // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapLegendNote">();
	}
	static class UMapLegendNote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapLegendNote>();
	}
};
static_assert(alignof(UMapLegendNote) == 0x000008, "Wrong alignment on UMapLegendNote");
static_assert(sizeof(UMapLegendNote) == 0x0002B0, "Wrong size on UMapLegendNote");
static_assert(offsetof(UMapLegendNote, MarkerIcon) == 0x000278, "Member 'UMapLegendNote::MarkerIcon' has a wrong offset!");
static_assert(offsetof(UMapLegendNote, MarkerName) == 0x000280, "Member 'UMapLegendNote::MarkerName' has a wrong offset!");
static_assert(offsetof(UMapLegendNote, SizeBox) == 0x000288, "Member 'UMapLegendNote::SizeBox' has a wrong offset!");
static_assert(offsetof(UMapLegendNote, MarkerType) == 0x000290, "Member 'UMapLegendNote::MarkerType' has a wrong offset!");
static_assert(offsetof(UMapLegendNote, MarkerNameSID) == 0x000298, "Member 'UMapLegendNote::MarkerNameSID' has a wrong offset!");
static_assert(offsetof(UMapLegendNote, Height) == 0x0002A8, "Member 'UMapLegendNote::Height' has a wrong offset!");

// Class Stalker2.MapMouseIPU
// 0x0000 (0x0040 - 0x0040)
class UMapMouseIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMouseIPU">();
	}
	static class UMapMouseIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMouseIPU>();
	}
};
static_assert(alignof(UMapMouseIPU) == 0x000008, "Wrong alignment on UMapMouseIPU");
static_assert(sizeof(UMapMouseIPU) == 0x000040, "Wrong size on UMapMouseIPU");

// Class Stalker2.PlatformManager
// 0x0060 (0x0108 - 0x00A8)
class UPlatformManager final : public UBaseTickableManager
{
public:
	int32                                         InputStorySize;                                    // 0x00A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePlatformSwitchingThreshold;                    // 0x00AC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlatformSwitchingThreshold;                        // 0x00B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSwitchToOtherDeviceOnConnect;                     // 0x00B4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMouseFeatures;                                 // 0x00B5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B6[0x52];                                      // 0x00B6(0x0052)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformManager">();
	}
	static class UPlatformManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformManager>();
	}
};
static_assert(alignof(UPlatformManager) == 0x000008, "Wrong alignment on UPlatformManager");
static_assert(sizeof(UPlatformManager) == 0x000108, "Wrong size on UPlatformManager");
static_assert(offsetof(UPlatformManager, InputStorySize) == 0x0000A8, "Member 'UPlatformManager::InputStorySize' has a wrong offset!");
static_assert(offsetof(UPlatformManager, bUsePlatformSwitchingThreshold) == 0x0000AC, "Member 'UPlatformManager::bUsePlatformSwitchingThreshold' has a wrong offset!");
static_assert(offsetof(UPlatformManager, PlatformSwitchingThreshold) == 0x0000B0, "Member 'UPlatformManager::PlatformSwitchingThreshold' has a wrong offset!");
static_assert(offsetof(UPlatformManager, bSwitchToOtherDeviceOnConnect) == 0x0000B4, "Member 'UPlatformManager::bSwitchToOtherDeviceOnConnect' has a wrong offset!");
static_assert(offsetof(UPlatformManager, bUseMouseFeatures) == 0x0000B5, "Member 'UPlatformManager::bUseMouseFeatures' has a wrong offset!");

// Class Stalker2.MapSettingsAsset
// 0x0100 (0x0130 - 0x0030)
class UMapSettingsAsset final : public UDataAsset
{
public:
	float                                         HubFoldingRadius;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HubFoldingZoomLevel;                               // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableReverseHoldMoveAxis;                        // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMouseMovement;                              // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHoldBorderMoving;                           // 0x003A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadCursorMovementSpeedMultiplier;              // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadMapMovementSpeedMultiplier;                 // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttractionRadius;                                  // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttractionSpeed;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnselectedAreaBrightness;                          // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TooltipPadding;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FZoomLevelSettings>             ZoomLevelSettings;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         PlayerLandmarksLimitTotal;                         // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CreateRadius;                                      // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EMarkerType, struct FZoomMarkerSettings> ZoomMarkerSettings;                                // 0x0070(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EMarkerType, int32>                      ZOrderMarkerSettings;                              // 0x00C0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ZOrderForHoverMarker;                              // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FZoomMarkerSettings                    DefaultMarkerZoomSettings;                         // 0x0114(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MapMarkerLocationUpdateTime;                       // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapMarkerLocationUpdateRadius;                     // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MarkerUntrackDistance;                             // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapSettingsAsset">();
	}
	static class UMapSettingsAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapSettingsAsset>();
	}
};
static_assert(alignof(UMapSettingsAsset) == 0x000008, "Wrong alignment on UMapSettingsAsset");
static_assert(sizeof(UMapSettingsAsset) == 0x000130, "Wrong size on UMapSettingsAsset");
static_assert(offsetof(UMapSettingsAsset, HubFoldingRadius) == 0x000030, "Member 'UMapSettingsAsset::HubFoldingRadius' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, HubFoldingZoomLevel) == 0x000034, "Member 'UMapSettingsAsset::HubFoldingZoomLevel' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, bEnableReverseHoldMoveAxis) == 0x000038, "Member 'UMapSettingsAsset::bEnableReverseHoldMoveAxis' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, bEnableMouseMovement) == 0x000039, "Member 'UMapSettingsAsset::bEnableMouseMovement' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, bEnableHoldBorderMoving) == 0x00003A, "Member 'UMapSettingsAsset::bEnableHoldBorderMoving' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, GamepadCursorMovementSpeedMultiplier) == 0x00003C, "Member 'UMapSettingsAsset::GamepadCursorMovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, GamepadMapMovementSpeedMultiplier) == 0x000040, "Member 'UMapSettingsAsset::GamepadMapMovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, AttractionRadius) == 0x000044, "Member 'UMapSettingsAsset::AttractionRadius' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, AttractionSpeed) == 0x000048, "Member 'UMapSettingsAsset::AttractionSpeed' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, UnselectedAreaBrightness) == 0x00004C, "Member 'UMapSettingsAsset::UnselectedAreaBrightness' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, TooltipPadding) == 0x000050, "Member 'UMapSettingsAsset::TooltipPadding' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, ZoomLevelSettings) == 0x000058, "Member 'UMapSettingsAsset::ZoomLevelSettings' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, PlayerLandmarksLimitTotal) == 0x000068, "Member 'UMapSettingsAsset::PlayerLandmarksLimitTotal' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, CreateRadius) == 0x00006C, "Member 'UMapSettingsAsset::CreateRadius' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, ZoomMarkerSettings) == 0x000070, "Member 'UMapSettingsAsset::ZoomMarkerSettings' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, ZOrderMarkerSettings) == 0x0000C0, "Member 'UMapSettingsAsset::ZOrderMarkerSettings' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, ZOrderForHoverMarker) == 0x000110, "Member 'UMapSettingsAsset::ZOrderForHoverMarker' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, DefaultMarkerZoomSettings) == 0x000114, "Member 'UMapSettingsAsset::DefaultMarkerZoomSettings' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, MapMarkerLocationUpdateTime) == 0x000124, "Member 'UMapSettingsAsset::MapMarkerLocationUpdateTime' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, MapMarkerLocationUpdateRadius) == 0x000128, "Member 'UMapSettingsAsset::MapMarkerLocationUpdateRadius' has a wrong offset!");
static_assert(offsetof(UMapSettingsAsset, MarkerUntrackDistance) == 0x00012C, "Member 'UMapSettingsAsset::MarkerUntrackDistance' has a wrong offset!");

// Class Stalker2.MapSetupParams
// 0x0008 (0x02A0 - 0x0298)
class AMapSetupParams final : public AActor
{
public:
	bool                                          bDisableLightingManager;                           // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableReflectionManager;                         // 0x0299(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29A[0x6];                                      // 0x029A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapSetupParams">();
	}
	static class AMapSetupParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapSetupParams>();
	}
};
static_assert(alignof(AMapSetupParams) == 0x000008, "Wrong alignment on AMapSetupParams");
static_assert(sizeof(AMapSetupParams) == 0x0002A0, "Wrong size on AMapSetupParams");
static_assert(offsetof(AMapSetupParams, bDisableLightingManager) == 0x000298, "Member 'AMapSetupParams::bDisableLightingManager' has a wrong offset!");
static_assert(offsetof(AMapSetupParams, bDisableReflectionManager) == 0x000299, "Member 'AMapSetupParams::bDisableReflectionManager' has a wrong offset!");

// Class Stalker2.MapTransitionActionBlockerCondition
// 0x0008 (0x0030 - 0x0028)
class UMapTransitionActionBlockerCondition final : public UActionBlockerConditionBase
{
public:
	bool                                          bBlockMapTransition;                               // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapTransitionActionBlockerCondition">();
	}
	static class UMapTransitionActionBlockerCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapTransitionActionBlockerCondition>();
	}
};
static_assert(alignof(UMapTransitionActionBlockerCondition) == 0x000008, "Wrong alignment on UMapTransitionActionBlockerCondition");
static_assert(sizeof(UMapTransitionActionBlockerCondition) == 0x000030, "Wrong size on UMapTransitionActionBlockerCondition");
static_assert(offsetof(UMapTransitionActionBlockerCondition, bBlockMapTransition) == 0x000028, "Member 'UMapTransitionActionBlockerCondition::bBlockMapTransition' has a wrong offset!");

// Class Stalker2.MarkerCompassWidget
// 0x0050 (0x02C8 - 0x0278)
class UMarkerCompassWidget final : public UWidgetBase
{
public:
	class UTextBlock*                             DistanceText;                                      // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconImage;                                         // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HeightArrow;                                       // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                DistanceContainer;                                 // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               IconSizeBox;                                       // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HideDelayForEnemyMarkers;                          // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HideEnemyTime;                                     // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateRate;                                        // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x1C];                                     // 0x02AC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarkerCompassWidget">();
	}
	static class UMarkerCompassWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarkerCompassWidget>();
	}
};
static_assert(alignof(UMarkerCompassWidget) == 0x000008, "Wrong alignment on UMarkerCompassWidget");
static_assert(sizeof(UMarkerCompassWidget) == 0x0002C8, "Wrong size on UMarkerCompassWidget");
static_assert(offsetof(UMarkerCompassWidget, DistanceText) == 0x000278, "Member 'UMarkerCompassWidget::DistanceText' has a wrong offset!");
static_assert(offsetof(UMarkerCompassWidget, IconImage) == 0x000280, "Member 'UMarkerCompassWidget::IconImage' has a wrong offset!");
static_assert(offsetof(UMarkerCompassWidget, HeightArrow) == 0x000288, "Member 'UMarkerCompassWidget::HeightArrow' has a wrong offset!");
static_assert(offsetof(UMarkerCompassWidget, DistanceContainer) == 0x000290, "Member 'UMarkerCompassWidget::DistanceContainer' has a wrong offset!");
static_assert(offsetof(UMarkerCompassWidget, IconSizeBox) == 0x000298, "Member 'UMarkerCompassWidget::IconSizeBox' has a wrong offset!");
static_assert(offsetof(UMarkerCompassWidget, HideDelayForEnemyMarkers) == 0x0002A0, "Member 'UMarkerCompassWidget::HideDelayForEnemyMarkers' has a wrong offset!");
static_assert(offsetof(UMarkerCompassWidget, HideEnemyTime) == 0x0002A4, "Member 'UMarkerCompassWidget::HideEnemyTime' has a wrong offset!");
static_assert(offsetof(UMarkerCompassWidget, UpdateRate) == 0x0002A8, "Member 'UMarkerCompassWidget::UpdateRate' has a wrong offset!");

// Class Stalker2.MarkerSettings
// 0x00A0 (0x00D0 - 0x0030)
class UMarkerSettings final : public UDataAsset
{
public:
	TMap<EMarkerType, struct FMarkerTypeSettings> MarkerTypeSettings;                                // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CompassMarkerVisibilityCurve;                      // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMarkerTypeSettings                    MarkerSettingsDefaultObject;                       // 0x0088(0x0048)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarkerSettings">();
	}
	static class UMarkerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarkerSettings>();
	}
};
static_assert(alignof(UMarkerSettings) == 0x000008, "Wrong alignment on UMarkerSettings");
static_assert(sizeof(UMarkerSettings) == 0x0000D0, "Wrong size on UMarkerSettings");
static_assert(offsetof(UMarkerSettings, MarkerTypeSettings) == 0x000030, "Member 'UMarkerSettings::MarkerTypeSettings' has a wrong offset!");
static_assert(offsetof(UMarkerSettings, CompassMarkerVisibilityCurve) == 0x000080, "Member 'UMarkerSettings::CompassMarkerVisibilityCurve' has a wrong offset!");
static_assert(offsetof(UMarkerSettings, MarkerSettingsDefaultObject) == 0x000088, "Member 'UMarkerSettings::MarkerSettingsDefaultObject' has a wrong offset!");

// Class Stalker2.MenuButtonActionBase
// 0x0008 (0x0030 - 0x0028)
class UMenuButtonActionBase : public UObject
{
public:
	bool                                          bShouldPlaySound;                                  // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EUISound                                      OnExecuteSound;                                    // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ExecuteButtonAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuButtonActionBase">();
	}
	static class UMenuButtonActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuButtonActionBase>();
	}
};
static_assert(alignof(UMenuButtonActionBase) == 0x000008, "Wrong alignment on UMenuButtonActionBase");
static_assert(sizeof(UMenuButtonActionBase) == 0x000030, "Wrong size on UMenuButtonActionBase");
static_assert(offsetof(UMenuButtonActionBase, bShouldPlaySound) == 0x000028, "Member 'UMenuButtonActionBase::bShouldPlaySound' has a wrong offset!");
static_assert(offsetof(UMenuButtonActionBase, OnExecuteSound) == 0x00002C, "Member 'UMenuButtonActionBase::OnExecuteSound' has a wrong offset!");

// Class Stalker2.GotoViewAction
// 0x0048 (0x0078 - 0x0030)
class UGotoViewAction : public UMenuButtonActionBase
{
public:
	TSoftClassPtr<class UClass>                   DestinationWidget;                                 // 0x0030(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChangeBehaviourOnPresentation;                    // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CampaignIndex;                                     // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DifficultyPrototypeSID;                            // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GotoViewAction">();
	}
	static class UGotoViewAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGotoViewAction>();
	}
};
static_assert(alignof(UGotoViewAction) == 0x000008, "Wrong alignment on UGotoViewAction");
static_assert(sizeof(UGotoViewAction) == 0x000078, "Wrong size on UGotoViewAction");
static_assert(offsetof(UGotoViewAction, DestinationWidget) == 0x000030, "Member 'UGotoViewAction::DestinationWidget' has a wrong offset!");
static_assert(offsetof(UGotoViewAction, bChangeBehaviourOnPresentation) == 0x000060, "Member 'UGotoViewAction::bChangeBehaviourOnPresentation' has a wrong offset!");
static_assert(offsetof(UGotoViewAction, CampaignIndex) == 0x000064, "Member 'UGotoViewAction::CampaignIndex' has a wrong offset!");
static_assert(offsetof(UGotoViewAction, DifficultyPrototypeSID) == 0x000068, "Member 'UGotoViewAction::DifficultyPrototypeSID' has a wrong offset!");

// Class Stalker2.SelectNextOption
// 0x0000 (0x0030 - 0x0030)
class USelectNextOption final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectNextOption">();
	}
	static class USelectNextOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectNextOption>();
	}
};
static_assert(alignof(USelectNextOption) == 0x000008, "Wrong alignment on USelectNextOption");
static_assert(sizeof(USelectNextOption) == 0x000030, "Wrong size on USelectNextOption");

// Class Stalker2.SelectPreviousOption
// 0x0000 (0x0030 - 0x0030)
class USelectPreviousOption final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectPreviousOption">();
	}
	static class USelectPreviousOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectPreviousOption>();
	}
};
static_assert(alignof(USelectPreviousOption) == 0x000008, "Wrong alignment on USelectPreviousOption");
static_assert(sizeof(USelectPreviousOption) == 0x000030, "Wrong size on USelectPreviousOption");

// Class Stalker2.PlayerItemsSounds
// 0x0020 (0x0050 - 0x0030)
class UPlayerItemsSounds final : public UDataAsset
{
public:
	class UAkAudioEvent*                          SFXPickUp;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SFXPickUpCloth;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SFXDrop;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SFXUse;                                            // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerItemsSounds">();
	}
	static class UPlayerItemsSounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerItemsSounds>();
	}
};
static_assert(alignof(UPlayerItemsSounds) == 0x000008, "Wrong alignment on UPlayerItemsSounds");
static_assert(sizeof(UPlayerItemsSounds) == 0x000050, "Wrong size on UPlayerItemsSounds");
static_assert(offsetof(UPlayerItemsSounds, SFXPickUp) == 0x000030, "Member 'UPlayerItemsSounds::SFXPickUp' has a wrong offset!");
static_assert(offsetof(UPlayerItemsSounds, SFXPickUpCloth) == 0x000038, "Member 'UPlayerItemsSounds::SFXPickUpCloth' has a wrong offset!");
static_assert(offsetof(UPlayerItemsSounds, SFXDrop) == 0x000040, "Member 'UPlayerItemsSounds::SFXDrop' has a wrong offset!");
static_assert(offsetof(UPlayerItemsSounds, SFXUse) == 0x000048, "Member 'UPlayerItemsSounds::SFXUse' has a wrong offset!");

// Class Stalker2.ApplySettingsAction
// 0x0000 (0x0030 - 0x0030)
class UApplySettingsAction final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplySettingsAction">();
	}
	static class UApplySettingsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplySettingsAction>();
	}
};
static_assert(alignof(UApplySettingsAction) == 0x000008, "Wrong alignment on UApplySettingsAction");
static_assert(sizeof(UApplySettingsAction) == 0x000030, "Wrong size on UApplySettingsAction");

// Class Stalker2.ApplyFirstTimeSettingsAction
// 0x0000 (0x0030 - 0x0030)
class UApplyFirstTimeSettingsAction final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplyFirstTimeSettingsAction">();
	}
	static class UApplyFirstTimeSettingsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplyFirstTimeSettingsAction>();
	}
};
static_assert(alignof(UApplyFirstTimeSettingsAction) == 0x000008, "Wrong alignment on UApplyFirstTimeSettingsAction");
static_assert(sizeof(UApplyFirstTimeSettingsAction) == 0x000030, "Wrong size on UApplyFirstTimeSettingsAction");

// Class Stalker2.ResetToDefaultSettings
// 0x0000 (0x0030 - 0x0030)
class UResetToDefaultSettings final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResetToDefaultSettings">();
	}
	static class UResetToDefaultSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResetToDefaultSettings>();
	}
};
static_assert(alignof(UResetToDefaultSettings) == 0x000008, "Wrong alignment on UResetToDefaultSettings");
static_assert(sizeof(UResetToDefaultSettings) == 0x000030, "Wrong size on UResetToDefaultSettings");

// Class Stalker2.GoPreviousViewAction
// 0x0000 (0x0030 - 0x0030)
class UGoPreviousViewAction final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GoPreviousViewAction">();
	}
	static class UGoPreviousViewAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGoPreviousViewAction>();
	}
};
static_assert(alignof(UGoPreviousViewAction) == 0x000008, "Wrong alignment on UGoPreviousViewAction");
static_assert(sizeof(UGoPreviousViewAction) == 0x000030, "Wrong size on UGoPreviousViewAction");

// Class Stalker2.PDANotesDetails
// 0x00F8 (0x0370 - 0x0278)
class UPDANotesDetails final : public UWidgetBase
{
public:
	class UVerticalBox*                           NotesBox;                                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               AudioContainer;                                    // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BackgroundImage;                                   // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ImageContainer;                                    // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModifiableRichText*                    TitleText;                                         // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModifiableRichText*                    HintText;                                          // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModifiableRichText*                    HeaderText;                                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModifiableRichText*                    BodyText;                                          // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModifiableRichText*                    FooterText;                                        // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScrollBox*                             TextScroll;                                        // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckBoxWidget*                        AudioPlayButton;                                   // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           AudiologProgressBar;                               // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            AbsentNoteText;                                    // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            TimerText;                                         // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScrollMoveSpeed;                                   // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonVerticalBox*                     ParentVerticalBox;                                 // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x38];                                     // 0x02F8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                TopBorder;                                         // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BottomBorder;                                      // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                RightBorder;                                       // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                LeftBorder;                                        // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x20];                                     // 0x0350(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayNoteAudio(const bool bStart);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDANotesDetails">();
	}
	static class UPDANotesDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDANotesDetails>();
	}
};
static_assert(alignof(UPDANotesDetails) == 0x000008, "Wrong alignment on UPDANotesDetails");
static_assert(sizeof(UPDANotesDetails) == 0x000370, "Wrong size on UPDANotesDetails");
static_assert(offsetof(UPDANotesDetails, NotesBox) == 0x000278, "Member 'UPDANotesDetails::NotesBox' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, AudioContainer) == 0x000280, "Member 'UPDANotesDetails::AudioContainer' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, BackgroundImage) == 0x000288, "Member 'UPDANotesDetails::BackgroundImage' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, ImageContainer) == 0x000290, "Member 'UPDANotesDetails::ImageContainer' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, TitleText) == 0x000298, "Member 'UPDANotesDetails::TitleText' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, HintText) == 0x0002A0, "Member 'UPDANotesDetails::HintText' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, HeaderText) == 0x0002A8, "Member 'UPDANotesDetails::HeaderText' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, BodyText) == 0x0002B0, "Member 'UPDANotesDetails::BodyText' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, FooterText) == 0x0002B8, "Member 'UPDANotesDetails::FooterText' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, TextScroll) == 0x0002C0, "Member 'UPDANotesDetails::TextScroll' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, AudioPlayButton) == 0x0002C8, "Member 'UPDANotesDetails::AudioPlayButton' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, AudiologProgressBar) == 0x0002D0, "Member 'UPDANotesDetails::AudiologProgressBar' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, AbsentNoteText) == 0x0002D8, "Member 'UPDANotesDetails::AbsentNoteText' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, TimerText) == 0x0002E0, "Member 'UPDANotesDetails::TimerText' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, ScrollMoveSpeed) == 0x0002E8, "Member 'UPDANotesDetails::ScrollMoveSpeed' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, ParentVerticalBox) == 0x0002F0, "Member 'UPDANotesDetails::ParentVerticalBox' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, TopBorder) == 0x000330, "Member 'UPDANotesDetails::TopBorder' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, BottomBorder) == 0x000338, "Member 'UPDANotesDetails::BottomBorder' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, RightBorder) == 0x000340, "Member 'UPDANotesDetails::RightBorder' has a wrong offset!");
static_assert(offsetof(UPDANotesDetails, LeftBorder) == 0x000348, "Member 'UPDANotesDetails::LeftBorder' has a wrong offset!");

// Class Stalker2.PressSelectedOptionAction
// 0x0000 (0x0030 - 0x0030)
class UPressSelectedOptionAction final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PressSelectedOptionAction">();
	}
	static class UPressSelectedOptionAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPressSelectedOptionAction>();
	}
};
static_assert(alignof(UPressSelectedOptionAction) == 0x000008, "Wrong alignment on UPressSelectedOptionAction");
static_assert(sizeof(UPressSelectedOptionAction) == 0x000030, "Wrong size on UPressSelectedOptionAction");

// Class Stalker2.SettingsView
// 0x0158 (0x0420 - 0x02C8)
class USettingsView final : public UViewBaseExtended
{
public:
	class USettingsNavigationPanel*               NavigationPanel;                                   // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingsNavigationPanel*               NavigationPanelMapping;                            // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        NavPanelSwitcher;                                  // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        CategorySwitcher;                                  // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        NestingSwitcher;                                   // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            SettingName;                                       // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            SettingDescription;                                // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               SettingsVisualizationBox;                          // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULocalizedImage*                        SettingsVisualization;                             // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 DescriptionLine;                                   // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingsPage*                          KeyboardMapping;                                   // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SavePopupTitleSID;                                 // 0x0320(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SavePopupDescSID;                                  // 0x0330(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SavePopupButtonSID;                                // 0x0340(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExitPopupTitleSID;                                 // 0x0350(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExitPopupDescSID;                                  // 0x0360(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExitPopupButtonOkSID;                              // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExitPopupButtonNoSID;                              // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResetPopupTitleSID;                                // 0x0390(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResetPopupDescSID;                                 // 0x03A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResetPopupButtonOkSID;                             // 0x03B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResetPopupButtonNoSID;                             // 0x03C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExitToSettingsPopupTitleSID;                       // 0x03D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NeedRestartPopupDescSID;                           // 0x03E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F0[0x30];                                     // 0x03F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsView">();
	}
	static class USettingsView* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsView>();
	}
};
static_assert(alignof(USettingsView) == 0x000008, "Wrong alignment on USettingsView");
static_assert(sizeof(USettingsView) == 0x000420, "Wrong size on USettingsView");
static_assert(offsetof(USettingsView, NavigationPanel) == 0x0002C8, "Member 'USettingsView::NavigationPanel' has a wrong offset!");
static_assert(offsetof(USettingsView, NavigationPanelMapping) == 0x0002D0, "Member 'USettingsView::NavigationPanelMapping' has a wrong offset!");
static_assert(offsetof(USettingsView, NavPanelSwitcher) == 0x0002D8, "Member 'USettingsView::NavPanelSwitcher' has a wrong offset!");
static_assert(offsetof(USettingsView, CategorySwitcher) == 0x0002E0, "Member 'USettingsView::CategorySwitcher' has a wrong offset!");
static_assert(offsetof(USettingsView, NestingSwitcher) == 0x0002E8, "Member 'USettingsView::NestingSwitcher' has a wrong offset!");
static_assert(offsetof(USettingsView, SettingName) == 0x0002F0, "Member 'USettingsView::SettingName' has a wrong offset!");
static_assert(offsetof(USettingsView, SettingDescription) == 0x0002F8, "Member 'USettingsView::SettingDescription' has a wrong offset!");
static_assert(offsetof(USettingsView, SettingsVisualizationBox) == 0x000300, "Member 'USettingsView::SettingsVisualizationBox' has a wrong offset!");
static_assert(offsetof(USettingsView, SettingsVisualization) == 0x000308, "Member 'USettingsView::SettingsVisualization' has a wrong offset!");
static_assert(offsetof(USettingsView, DescriptionLine) == 0x000310, "Member 'USettingsView::DescriptionLine' has a wrong offset!");
static_assert(offsetof(USettingsView, KeyboardMapping) == 0x000318, "Member 'USettingsView::KeyboardMapping' has a wrong offset!");
static_assert(offsetof(USettingsView, SavePopupTitleSID) == 0x000320, "Member 'USettingsView::SavePopupTitleSID' has a wrong offset!");
static_assert(offsetof(USettingsView, SavePopupDescSID) == 0x000330, "Member 'USettingsView::SavePopupDescSID' has a wrong offset!");
static_assert(offsetof(USettingsView, SavePopupButtonSID) == 0x000340, "Member 'USettingsView::SavePopupButtonSID' has a wrong offset!");
static_assert(offsetof(USettingsView, ExitPopupTitleSID) == 0x000350, "Member 'USettingsView::ExitPopupTitleSID' has a wrong offset!");
static_assert(offsetof(USettingsView, ExitPopupDescSID) == 0x000360, "Member 'USettingsView::ExitPopupDescSID' has a wrong offset!");
static_assert(offsetof(USettingsView, ExitPopupButtonOkSID) == 0x000370, "Member 'USettingsView::ExitPopupButtonOkSID' has a wrong offset!");
static_assert(offsetof(USettingsView, ExitPopupButtonNoSID) == 0x000380, "Member 'USettingsView::ExitPopupButtonNoSID' has a wrong offset!");
static_assert(offsetof(USettingsView, ResetPopupTitleSID) == 0x000390, "Member 'USettingsView::ResetPopupTitleSID' has a wrong offset!");
static_assert(offsetof(USettingsView, ResetPopupDescSID) == 0x0003A0, "Member 'USettingsView::ResetPopupDescSID' has a wrong offset!");
static_assert(offsetof(USettingsView, ResetPopupButtonOkSID) == 0x0003B0, "Member 'USettingsView::ResetPopupButtonOkSID' has a wrong offset!");
static_assert(offsetof(USettingsView, ResetPopupButtonNoSID) == 0x0003C0, "Member 'USettingsView::ResetPopupButtonNoSID' has a wrong offset!");
static_assert(offsetof(USettingsView, ExitToSettingsPopupTitleSID) == 0x0003D0, "Member 'USettingsView::ExitToSettingsPopupTitleSID' has a wrong offset!");
static_assert(offsetof(USettingsView, NeedRestartPopupDescSID) == 0x0003E0, "Member 'USettingsView::NeedRestartPopupDescSID' has a wrong offset!");

// Class Stalker2.StartGameAction
// 0x0000 (0x0030 - 0x0030)
class UStartGameAction : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartGameAction">();
	}
	static class UStartGameAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartGameAction>();
	}
};
static_assert(alignof(UStartGameAction) == 0x000008, "Wrong alignment on UStartGameAction");
static_assert(sizeof(UStartGameAction) == 0x000030, "Wrong size on UStartGameAction");

// Class Stalker2.ResumeAction
// 0x0000 (0x0030 - 0x0030)
class UResumeAction final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResumeAction">();
	}
	static class UResumeAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResumeAction>();
	}
};
static_assert(alignof(UResumeAction) == 0x000008, "Wrong alignment on UResumeAction");
static_assert(sizeof(UResumeAction) == 0x000030, "Wrong size on UResumeAction");

// Class Stalker2.PlayerOpticScopeComponent
// 0x0010 (0x00B0 - 0x00A0)
class UPlayerOpticScopeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerOpticScopeComponent">();
	}
	static class UPlayerOpticScopeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerOpticScopeComponent>();
	}
};
static_assert(alignof(UPlayerOpticScopeComponent) == 0x000008, "Wrong alignment on UPlayerOpticScopeComponent");
static_assert(sizeof(UPlayerOpticScopeComponent) == 0x0000B0, "Wrong size on UPlayerOpticScopeComponent");

// Class Stalker2.QuitToMainMenuAction
// 0x0008 (0x0038 - 0x0030)
class UQuitToMainMenuAction final : public UMenuButtonActionBase
{
public:
	bool                                          bForceQuit;                                        // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuitToMainMenuAction">();
	}
	static class UQuitToMainMenuAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuitToMainMenuAction>();
	}
};
static_assert(alignof(UQuitToMainMenuAction) == 0x000008, "Wrong alignment on UQuitToMainMenuAction");
static_assert(sizeof(UQuitToMainMenuAction) == 0x000038, "Wrong size on UQuitToMainMenuAction");
static_assert(offsetof(UQuitToMainMenuAction, bForceQuit) == 0x000030, "Member 'UQuitToMainMenuAction::bForceQuit' has a wrong offset!");

// Class Stalker2.QuitAction
// 0x0000 (0x0030 - 0x0030)
class UQuitAction final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuitAction">();
	}
	static class UQuitAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuitAction>();
	}
};
static_assert(alignof(UQuitAction) == 0x000008, "Wrong alignment on UQuitAction");
static_assert(sizeof(UQuitAction) == 0x000030, "Wrong size on UQuitAction");

// Class Stalker2.LoadLastSaveAction
// 0x0000 (0x0030 - 0x0030)
class ULoadLastSaveAction final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadLastSaveAction">();
	}
	static class ULoadLastSaveAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadLastSaveAction>();
	}
};
static_assert(alignof(ULoadLastSaveAction) == 0x000008, "Wrong alignment on ULoadLastSaveAction");
static_assert(sizeof(ULoadLastSaveAction) == 0x000030, "Wrong size on ULoadLastSaveAction");

// Class Stalker2.SaveLoadActionBase
// 0x0090 (0x00C0 - 0x0030)
class USaveLoadActionBase : public UMenuButtonActionBase
{
public:
	uint8                                         Pad_30[0x90];                                      // 0x0030(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadActionBase">();
	}
	static class USaveLoadActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadActionBase>();
	}
};
static_assert(alignof(USaveLoadActionBase) == 0x000008, "Wrong alignment on USaveLoadActionBase");
static_assert(sizeof(USaveLoadActionBase) == 0x0000C0, "Wrong size on USaveLoadActionBase");

// Class Stalker2.LoadSaveAction
// 0x0000 (0x00C0 - 0x00C0)
class ULoadSaveAction final : public USaveLoadActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadSaveAction">();
	}
	static class ULoadSaveAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadSaveAction>();
	}
};
static_assert(alignof(ULoadSaveAction) == 0x000008, "Wrong alignment on ULoadSaveAction");
static_assert(sizeof(ULoadSaveAction) == 0x0000C0, "Wrong size on ULoadSaveAction");

// Class Stalker2.OverwriteSaveGameAction
// 0x0000 (0x00C0 - 0x00C0)
class UOverwriteSaveGameAction final : public USaveLoadActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OverwriteSaveGameAction">();
	}
	static class UOverwriteSaveGameAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOverwriteSaveGameAction>();
	}
};
static_assert(alignof(UOverwriteSaveGameAction) == 0x000008, "Wrong alignment on UOverwriteSaveGameAction");
static_assert(sizeof(UOverwriteSaveGameAction) == 0x0000C0, "Wrong size on UOverwriteSaveGameAction");

// Class Stalker2.SaveGameAction
// 0x0000 (0x00C0 - 0x00C0)
class USaveGameAction final : public USaveLoadActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveGameAction">();
	}
	static class USaveGameAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveGameAction>();
	}
};
static_assert(alignof(USaveGameAction) == 0x000008, "Wrong alignment on USaveGameAction");
static_assert(sizeof(USaveGameAction) == 0x0000C0, "Wrong size on USaveGameAction");

// Class Stalker2.QuickSaveGameAction
// 0x0000 (0x00C0 - 0x00C0)
class UQuickSaveGameAction final : public USaveLoadActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickSaveGameAction">();
	}
	static class UQuickSaveGameAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickSaveGameAction>();
	}
};
static_assert(alignof(UQuickSaveGameAction) == 0x000008, "Wrong alignment on UQuickSaveGameAction");
static_assert(sizeof(UQuickSaveGameAction) == 0x0000C0, "Wrong size on UQuickSaveGameAction");

// Class Stalker2.DeleteSaveAction
// 0x0000 (0x00C0 - 0x00C0)
class UDeleteSaveAction final : public USaveLoadActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeleteSaveAction">();
	}
	static class UDeleteSaveAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeleteSaveAction>();
	}
};
static_assert(alignof(UDeleteSaveAction) == 0x000008, "Wrong alignment on UDeleteSaveAction");
static_assert(sizeof(UDeleteSaveAction) == 0x0000C0, "Wrong size on UDeleteSaveAction");

// Class Stalker2.SetCampaign
// 0x0000 (0x0078 - 0x0078)
class USetCampaign final : public UGotoViewAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetCampaign">();
	}
	static class USetCampaign* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetCampaign>();
	}
};
static_assert(alignof(USetCampaign) == 0x000008, "Wrong alignment on USetCampaign");
static_assert(sizeof(USetCampaign) == 0x000078, "Wrong size on USetCampaign");

// Class Stalker2.SetCampaignWithoutDifficulty
// 0x0010 (0x0040 - 0x0030)
class USetCampaignWithoutDifficulty final : public UStartGameAction
{
public:
	class FString                                 DifficultyPrototypeSID;                            // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetCampaignWithoutDifficulty">();
	}
	static class USetCampaignWithoutDifficulty* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetCampaignWithoutDifficulty>();
	}
};
static_assert(alignof(USetCampaignWithoutDifficulty) == 0x000008, "Wrong alignment on USetCampaignWithoutDifficulty");
static_assert(sizeof(USetCampaignWithoutDifficulty) == 0x000040, "Wrong size on USetCampaignWithoutDifficulty");
static_assert(offsetof(USetCampaignWithoutDifficulty, DifficultyPrototypeSID) == 0x000030, "Member 'USetCampaignWithoutDifficulty::DifficultyPrototypeSID' has a wrong offset!");

// Class Stalker2.DeleteCampaign
// 0x0000 (0x0030 - 0x0030)
class UDeleteCampaign final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeleteCampaign">();
	}
	static class UDeleteCampaign* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeleteCampaign>();
	}
};
static_assert(alignof(UDeleteCampaign) == 0x000008, "Wrong alignment on UDeleteCampaign");
static_assert(sizeof(UDeleteCampaign) == 0x000030, "Wrong size on UDeleteCampaign");

// Class Stalker2.SetDifficulty
// 0x0010 (0x0040 - 0x0030)
class USetDifficulty : public UStartGameAction
{
public:
	class FString                                 DifficultySID;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetDifficulty">();
	}
	static class USetDifficulty* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetDifficulty>();
	}
};
static_assert(alignof(USetDifficulty) == 0x000008, "Wrong alignment on USetDifficulty");
static_assert(sizeof(USetDifficulty) == 0x000040, "Wrong size on USetDifficulty");
static_assert(offsetof(USetDifficulty, DifficultySID) == 0x000030, "Member 'USetDifficulty::DifficultySID' has a wrong offset!");

// Class Stalker2.NavArea_Interactive
// 0x0000 (0x0048 - 0x0048)
class UNavArea_Interactive final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Interactive">();
	}
	static class UNavArea_Interactive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Interactive>();
	}
};
static_assert(alignof(UNavArea_Interactive) == 0x000008, "Wrong alignment on UNavArea_Interactive");
static_assert(sizeof(UNavArea_Interactive) == 0x000048, "Wrong size on UNavArea_Interactive");

// Class Stalker2.SetDifficultyWithWarning
// 0x0010 (0x0050 - 0x0040)
class USetDifficultyWithWarning final : public USetDifficulty
{
public:
	class FString                                 WarningSID;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetDifficultyWithWarning">();
	}
	static class USetDifficultyWithWarning* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetDifficultyWithWarning>();
	}
};
static_assert(alignof(USetDifficultyWithWarning) == 0x000008, "Wrong alignment on USetDifficultyWithWarning");
static_assert(sizeof(USetDifficultyWithWarning) == 0x000050, "Wrong size on USetDifficultyWithWarning");
static_assert(offsetof(USetDifficultyWithWarning, WarningSID) == 0x000040, "Member 'USetDifficultyWithWarning::WarningSID' has a wrong offset!");

// Class Stalker2.ShowOverrideCampaignPopup
// 0x0070 (0x00A0 - 0x0030)
class UShowOverrideCampaignPopup final : public UMenuButtonActionBase
{
public:
	TSoftClassPtr<class UClass>                   DestinationAfterConfirm;                           // 0x0030(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 TitleSID;                                          // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DescriptionSID;                                    // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AcceptButtonNameSID;                               // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DeclineButtonNameSID;                              // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowOverrideCampaignPopup">();
	}
	static class UShowOverrideCampaignPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowOverrideCampaignPopup>();
	}
};
static_assert(alignof(UShowOverrideCampaignPopup) == 0x000008, "Wrong alignment on UShowOverrideCampaignPopup");
static_assert(sizeof(UShowOverrideCampaignPopup) == 0x0000A0, "Wrong size on UShowOverrideCampaignPopup");
static_assert(offsetof(UShowOverrideCampaignPopup, DestinationAfterConfirm) == 0x000030, "Member 'UShowOverrideCampaignPopup::DestinationAfterConfirm' has a wrong offset!");
static_assert(offsetof(UShowOverrideCampaignPopup, TitleSID) == 0x000060, "Member 'UShowOverrideCampaignPopup::TitleSID' has a wrong offset!");
static_assert(offsetof(UShowOverrideCampaignPopup, DescriptionSID) == 0x000070, "Member 'UShowOverrideCampaignPopup::DescriptionSID' has a wrong offset!");
static_assert(offsetof(UShowOverrideCampaignPopup, AcceptButtonNameSID) == 0x000080, "Member 'UShowOverrideCampaignPopup::AcceptButtonNameSID' has a wrong offset!");
static_assert(offsetof(UShowOverrideCampaignPopup, DeclineButtonNameSID) == 0x000090, "Member 'UShowOverrideCampaignPopup::DeclineButtonNameSID' has a wrong offset!");

// Class Stalker2.ShowPopupAction
// 0x0040 (0x0070 - 0x0030)
class UShowPopupAction final : public UMenuButtonActionBase
{
public:
	class FString                                 TitleSID;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DescriptionSID;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AcceptButtonNameSID;                               // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DeclineButtonNameSID;                              // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowPopupAction">();
	}
	static class UShowPopupAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowPopupAction>();
	}
};
static_assert(alignof(UShowPopupAction) == 0x000008, "Wrong alignment on UShowPopupAction");
static_assert(sizeof(UShowPopupAction) == 0x000070, "Wrong size on UShowPopupAction");
static_assert(offsetof(UShowPopupAction, TitleSID) == 0x000030, "Member 'UShowPopupAction::TitleSID' has a wrong offset!");
static_assert(offsetof(UShowPopupAction, DescriptionSID) == 0x000040, "Member 'UShowPopupAction::DescriptionSID' has a wrong offset!");
static_assert(offsetof(UShowPopupAction, AcceptButtonNameSID) == 0x000050, "Member 'UShowPopupAction::AcceptButtonNameSID' has a wrong offset!");
static_assert(offsetof(UShowPopupAction, DeclineButtonNameSID) == 0x000060, "Member 'UShowPopupAction::DeclineButtonNameSID' has a wrong offset!");

// Class Stalker2.PopupHintImage
// 0x0018 (0x0290 - 0x0278)
class UPopupHintImage : public UWidgetBase
{
public:
	class UHintImageKeyboard*                     HintImageKeyboard;                                 // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               SizeBox;                                           // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScaleBox*                              ScaleBox;                                          // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupHintImage">();
	}
	static class UPopupHintImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupHintImage>();
	}
};
static_assert(alignof(UPopupHintImage) == 0x000008, "Wrong alignment on UPopupHintImage");
static_assert(sizeof(UPopupHintImage) == 0x000290, "Wrong size on UPopupHintImage");
static_assert(offsetof(UPopupHintImage, HintImageKeyboard) == 0x000278, "Member 'UPopupHintImage::HintImageKeyboard' has a wrong offset!");
static_assert(offsetof(UPopupHintImage, SizeBox) == 0x000280, "Member 'UPopupHintImage::SizeBox' has a wrong offset!");
static_assert(offsetof(UPopupHintImage, ScaleBox) == 0x000288, "Member 'UPopupHintImage::ScaleBox' has a wrong offset!");

// Class Stalker2.ShowOverrideCampaignPopupGameStart
// 0x0050 (0x0080 - 0x0030)
class UShowOverrideCampaignPopupGameStart final : public UMenuButtonActionBase
{
public:
	class FString                                 DifficultyPrototypeSID;                            // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 TitleSID;                                          // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DescriptionSID;                                    // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AcceptButtonNameSID;                               // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DeclineButtonNameSID;                              // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowOverrideCampaignPopupGameStart">();
	}
	static class UShowOverrideCampaignPopupGameStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowOverrideCampaignPopupGameStart>();
	}
};
static_assert(alignof(UShowOverrideCampaignPopupGameStart) == 0x000008, "Wrong alignment on UShowOverrideCampaignPopupGameStart");
static_assert(sizeof(UShowOverrideCampaignPopupGameStart) == 0x000080, "Wrong size on UShowOverrideCampaignPopupGameStart");
static_assert(offsetof(UShowOverrideCampaignPopupGameStart, DifficultyPrototypeSID) == 0x000030, "Member 'UShowOverrideCampaignPopupGameStart::DifficultyPrototypeSID' has a wrong offset!");
static_assert(offsetof(UShowOverrideCampaignPopupGameStart, TitleSID) == 0x000040, "Member 'UShowOverrideCampaignPopupGameStart::TitleSID' has a wrong offset!");
static_assert(offsetof(UShowOverrideCampaignPopupGameStart, DescriptionSID) == 0x000050, "Member 'UShowOverrideCampaignPopupGameStart::DescriptionSID' has a wrong offset!");
static_assert(offsetof(UShowOverrideCampaignPopupGameStart, AcceptButtonNameSID) == 0x000060, "Member 'UShowOverrideCampaignPopupGameStart::AcceptButtonNameSID' has a wrong offset!");
static_assert(offsetof(UShowOverrideCampaignPopupGameStart, DeclineButtonNameSID) == 0x000070, "Member 'UShowOverrideCampaignPopupGameStart::DeclineButtonNameSID' has a wrong offset!");

// Class Stalker2.OpenModBrowser
// 0x0030 (0x0060 - 0x0030)
class UOpenModBrowser final : public UMenuButtonActionBase
{
public:
	TSoftClassPtr<class UClass>                   ModBrowserDummyViewWidget;                         // 0x0030(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenModBrowser">();
	}
	static class UOpenModBrowser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenModBrowser>();
	}
};
static_assert(alignof(UOpenModBrowser) == 0x000008, "Wrong alignment on UOpenModBrowser");
static_assert(sizeof(UOpenModBrowser) == 0x000060, "Wrong size on UOpenModBrowser");
static_assert(offsetof(UOpenModBrowser, ModBrowserDummyViewWidget) == 0x000030, "Member 'UOpenModBrowser::ModBrowserDummyViewWidget' has a wrong offset!");

// Class Stalker2.SafeZoneApply
// 0x0000 (0x0030 - 0x0030)
class USafeZoneApply final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SafeZoneApply">();
	}
	static class USafeZoneApply* GetDefaultObj()
	{
		return GetDefaultObjImpl<USafeZoneApply>();
	}
};
static_assert(alignof(USafeZoneApply) == 0x000008, "Wrong alignment on USafeZoneApply");
static_assert(sizeof(USafeZoneApply) == 0x000030, "Wrong size on USafeZoneApply");

// Class Stalker2.SafeZoneReset
// 0x0000 (0x0030 - 0x0030)
class USafeZoneReset final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SafeZoneReset">();
	}
	static class USafeZoneReset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USafeZoneReset>();
	}
};
static_assert(alignof(USafeZoneReset) == 0x000008, "Wrong alignment on USafeZoneReset");
static_assert(sizeof(USafeZoneReset) == 0x000030, "Wrong size on USafeZoneReset");

// Class Stalker2.DoNothing
// 0x0000 (0x0030 - 0x0030)
class UDoNothing final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoNothing">();
	}
	static class UDoNothing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoNothing>();
	}
};
static_assert(alignof(UDoNothing) == 0x000008, "Wrong alignment on UDoNothing");
static_assert(sizeof(UDoNothing) == 0x000030, "Wrong size on UDoNothing");

// Class Stalker2.ApplySettings
// 0x0000 (0x0030 - 0x0030)
class UApplySettings final : public UStartGameAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplySettings">();
	}
	static class UApplySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplySettings>();
	}
};
static_assert(alignof(UApplySettings) == 0x000008, "Wrong alignment on UApplySettings");
static_assert(sizeof(UApplySettings) == 0x000030, "Wrong size on UApplySettings");

// Class Stalker2.OpenSettingsSubTab
// 0x0000 (0x0030 - 0x0030)
class UOpenSettingsSubTab final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenSettingsSubTab">();
	}
	static class UOpenSettingsSubTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenSettingsSubTab>();
	}
};
static_assert(alignof(UOpenSettingsSubTab) == 0x000008, "Wrong alignment on UOpenSettingsSubTab");
static_assert(sizeof(UOpenSettingsSubTab) == 0x000030, "Wrong size on UOpenSettingsSubTab");

// Class Stalker2.BackToSettings
// 0x0000 (0x0030 - 0x0030)
class UBackToSettings final : public UMenuButtonActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackToSettings">();
	}
	static class UBackToSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackToSettings>();
	}
};
static_assert(alignof(UBackToSettings) == 0x000008, "Wrong alignment on UBackToSettings");
static_assert(sizeof(UBackToSettings) == 0x000030, "Wrong size on UBackToSettings");

// Class Stalker2.WeaponAttachAnimCollection
// 0x00B8 (0x00E0 - 0x0028)
class UWeaponAttachAnimCollection final : public UObject
{
public:
	struct FComplexAttachAnimations               AttachAnimations;                                  // 0x0028(0x00B8)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAttachAnimCollection">();
	}
	static class UWeaponAttachAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAttachAnimCollection>();
	}
};
static_assert(alignof(UWeaponAttachAnimCollection) == 0x000008, "Wrong alignment on UWeaponAttachAnimCollection");
static_assert(sizeof(UWeaponAttachAnimCollection) == 0x0000E0, "Wrong size on UWeaponAttachAnimCollection");
static_assert(offsetof(UWeaponAttachAnimCollection, AttachAnimations) == 0x000028, "Member 'UWeaponAttachAnimCollection::AttachAnimations' has a wrong offset!");

// Class Stalker2.MenuButtonModel
// 0x0028 (0x0058 - 0x0030)
class UMenuButtonModel : public UDataAsset
{
public:
	TArray<struct FMenuButtonData>                ButtonDataList;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UHintControllerBase>        LegendButtonWidgetClass;                           // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FShortcutData>                  SubViewShortcuts;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuButtonModel">();
	}
	static class UMenuButtonModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuButtonModel>();
	}
};
static_assert(alignof(UMenuButtonModel) == 0x000008, "Wrong alignment on UMenuButtonModel");
static_assert(sizeof(UMenuButtonModel) == 0x000058, "Wrong size on UMenuButtonModel");
static_assert(offsetof(UMenuButtonModel, ButtonDataList) == 0x000030, "Member 'UMenuButtonModel::ButtonDataList' has a wrong offset!");
static_assert(offsetof(UMenuButtonModel, LegendButtonWidgetClass) == 0x000040, "Member 'UMenuButtonModel::LegendButtonWidgetClass' has a wrong offset!");
static_assert(offsetof(UMenuButtonModel, SubViewShortcuts) == 0x000048, "Member 'UMenuButtonModel::SubViewShortcuts' has a wrong offset!");

// Class Stalker2.MenuLegendSubView
// 0x0030 (0x02A8 - 0x0278)
class UMenuLegendSubView : public UChildViewBase
{
public:
	class UAsyncHintBox*                          LegendSubViewPanel;                                // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAsyncHintBox*                          LegendButtonPanel;                                 // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHintControllerBase*>            LegendSubViewWidgets;                              // 0x0288(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UHintControllerBase*>            LegendButtonWidgets;                               // 0x0298(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuLegendSubView">();
	}
	static class UMenuLegendSubView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuLegendSubView>();
	}
};
static_assert(alignof(UMenuLegendSubView) == 0x000008, "Wrong alignment on UMenuLegendSubView");
static_assert(sizeof(UMenuLegendSubView) == 0x0002A8, "Wrong size on UMenuLegendSubView");
static_assert(offsetof(UMenuLegendSubView, LegendSubViewPanel) == 0x000278, "Member 'UMenuLegendSubView::LegendSubViewPanel' has a wrong offset!");
static_assert(offsetof(UMenuLegendSubView, LegendButtonPanel) == 0x000280, "Member 'UMenuLegendSubView::LegendButtonPanel' has a wrong offset!");
static_assert(offsetof(UMenuLegendSubView, LegendSubViewWidgets) == 0x000288, "Member 'UMenuLegendSubView::LegendSubViewWidgets' has a wrong offset!");
static_assert(offsetof(UMenuLegendSubView, LegendButtonWidgets) == 0x000298, "Member 'UMenuLegendSubView::LegendButtonWidgets' has a wrong offset!");

// Class Stalker2.MenuMainBackgroundVideo
// 0x00D8 (0x0350 - 0x0278)
class UMenuMainBackgroundVideo final : public UUserWidget
{
public:
	TSoftObjectPtr<class UMediaSource>            BackgroundVideo;                                   // 0x0278(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMediaSource>            BackgroundVideoSecond;                             // 0x02A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBinkMediaPlayer*                       BinkMediaPlayer;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 BlackoutImage;                                     // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Border;                                            // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EBorderType, TSoftObjectPtr<class UTexture2D>> BorderImages;                                // 0x0300(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void PlayVideo(class UMediaSource* VideoToPlay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuMainBackgroundVideo">();
	}
	static class UMenuMainBackgroundVideo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuMainBackgroundVideo>();
	}
};
static_assert(alignof(UMenuMainBackgroundVideo) == 0x000008, "Wrong alignment on UMenuMainBackgroundVideo");
static_assert(sizeof(UMenuMainBackgroundVideo) == 0x000350, "Wrong size on UMenuMainBackgroundVideo");
static_assert(offsetof(UMenuMainBackgroundVideo, BackgroundVideo) == 0x000278, "Member 'UMenuMainBackgroundVideo::BackgroundVideo' has a wrong offset!");
static_assert(offsetof(UMenuMainBackgroundVideo, BackgroundVideoSecond) == 0x0002A8, "Member 'UMenuMainBackgroundVideo::BackgroundVideoSecond' has a wrong offset!");
static_assert(offsetof(UMenuMainBackgroundVideo, BinkMediaPlayer) == 0x0002D8, "Member 'UMenuMainBackgroundVideo::BinkMediaPlayer' has a wrong offset!");
static_assert(offsetof(UMenuMainBackgroundVideo, BlackoutImage) == 0x0002F0, "Member 'UMenuMainBackgroundVideo::BlackoutImage' has a wrong offset!");
static_assert(offsetof(UMenuMainBackgroundVideo, Border) == 0x0002F8, "Member 'UMenuMainBackgroundVideo::Border' has a wrong offset!");
static_assert(offsetof(UMenuMainBackgroundVideo, BorderImages) == 0x000300, "Member 'UMenuMainBackgroundVideo::BorderImages' has a wrong offset!");

// Class Stalker2.MenuNavigationPanelBase
// 0x0038 (0x02B0 - 0x0278)
class UMenuNavigationPanelBase final : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelWidget*                           SlotContainer;                                     // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsNavigationButton*              HoveredButton;                                     // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USettingsNavigationButton*>      Buttons;                                           // 0x02A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void OnButtonPressed(class USettingsNavigationButton* PressedButton);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuNavigationPanelBase">();
	}
	static class UMenuNavigationPanelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuNavigationPanelBase>();
	}
};
static_assert(alignof(UMenuNavigationPanelBase) == 0x000008, "Wrong alignment on UMenuNavigationPanelBase");
static_assert(sizeof(UMenuNavigationPanelBase) == 0x0002B0, "Wrong size on UMenuNavigationPanelBase");
static_assert(offsetof(UMenuNavigationPanelBase, SlotContainer) == 0x000290, "Member 'UMenuNavigationPanelBase::SlotContainer' has a wrong offset!");
static_assert(offsetof(UMenuNavigationPanelBase, HoveredButton) == 0x000298, "Member 'UMenuNavigationPanelBase::HoveredButton' has a wrong offset!");
static_assert(offsetof(UMenuNavigationPanelBase, Buttons) == 0x0002A0, "Member 'UMenuNavigationPanelBase::Buttons' has a wrong offset!");

// Class Stalker2.EditorMaterialParameterConfig
// 0x0028 (0x0050 - 0x0028)
class UEditorMaterialParameterConfig final : public UObject
{
public:
	struct FSoftObjectPath                        TexturePath;                                       // 0x0028(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorMaterialParameterConfig">();
	}
	static class UEditorMaterialParameterConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorMaterialParameterConfig>();
	}
};
static_assert(alignof(UEditorMaterialParameterConfig) == 0x000008, "Wrong alignment on UEditorMaterialParameterConfig");
static_assert(sizeof(UEditorMaterialParameterConfig) == 0x000050, "Wrong size on UEditorMaterialParameterConfig");
static_assert(offsetof(UEditorMaterialParameterConfig, TexturePath) == 0x000028, "Member 'UEditorMaterialParameterConfig::TexturePath' has a wrong offset!");
static_assert(offsetof(UEditorMaterialParameterConfig, ParameterName) == 0x000048, "Member 'UEditorMaterialParameterConfig::ParameterName' has a wrong offset!");

// Class Stalker2.PlayerDefaultAnimCollection
// 0x02E0 (0x0308 - 0x0028)
class UPlayerDefaultAnimCollection final : public UObject
{
public:
	class UPlayerAnimCollection*                  PlayerAnimCollection;                              // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 PlayerAnimBlueprint;                               // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEquipUnequipAnimations                EquipUnequip;                                      // 0x0038(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FInspectArtifactAnimations             InspectArtifactAnimations;                         // 0x0050(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDragDeadBodyAnimations                DragDeadBodyAnimations;                            // 0x0060(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPlayerDeathAnimations                 DeathAnimations;                                   // 0x0070(0x00F0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FPlayerDialogAnimations                Dialog;                                            // 0x0160(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FPlayerGuitarAnimations                GuitarAnimations;                                  // 0x01B0(0x0108)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<EDodgeSide, class UAnimMontage*>         DodgeAnimations;                                   // 0x02B8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDefaultAnimCollection">();
	}
	static class UPlayerDefaultAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDefaultAnimCollection>();
	}
};
static_assert(alignof(UPlayerDefaultAnimCollection) == 0x000008, "Wrong alignment on UPlayerDefaultAnimCollection");
static_assert(sizeof(UPlayerDefaultAnimCollection) == 0x000308, "Wrong size on UPlayerDefaultAnimCollection");
static_assert(offsetof(UPlayerDefaultAnimCollection, PlayerAnimCollection) == 0x000028, "Member 'UPlayerDefaultAnimCollection::PlayerAnimCollection' has a wrong offset!");
static_assert(offsetof(UPlayerDefaultAnimCollection, PlayerAnimBlueprint) == 0x000030, "Member 'UPlayerDefaultAnimCollection::PlayerAnimBlueprint' has a wrong offset!");
static_assert(offsetof(UPlayerDefaultAnimCollection, EquipUnequip) == 0x000038, "Member 'UPlayerDefaultAnimCollection::EquipUnequip' has a wrong offset!");
static_assert(offsetof(UPlayerDefaultAnimCollection, InspectArtifactAnimations) == 0x000050, "Member 'UPlayerDefaultAnimCollection::InspectArtifactAnimations' has a wrong offset!");
static_assert(offsetof(UPlayerDefaultAnimCollection, DragDeadBodyAnimations) == 0x000060, "Member 'UPlayerDefaultAnimCollection::DragDeadBodyAnimations' has a wrong offset!");
static_assert(offsetof(UPlayerDefaultAnimCollection, DeathAnimations) == 0x000070, "Member 'UPlayerDefaultAnimCollection::DeathAnimations' has a wrong offset!");
static_assert(offsetof(UPlayerDefaultAnimCollection, Dialog) == 0x000160, "Member 'UPlayerDefaultAnimCollection::Dialog' has a wrong offset!");
static_assert(offsetof(UPlayerDefaultAnimCollection, GuitarAnimations) == 0x0001B0, "Member 'UPlayerDefaultAnimCollection::GuitarAnimations' has a wrong offset!");
static_assert(offsetof(UPlayerDefaultAnimCollection, DodgeAnimations) == 0x0002B8, "Member 'UPlayerDefaultAnimCollection::DodgeAnimations' has a wrong offset!");

// Class Stalker2.GroomEditor
// 0x00A0 (0x00C8 - 0x0028)
class UGroomEditor final : public UObject
{
public:
	TArray<class UGroomEditor*>                   AdditionalGrooms;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MaterialPath;                                      // 0x0038(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GroomPath;                                         // 0x0058(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        GroomBindingPath;                                  // 0x0078(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Weight;                                            // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         VariationIndex;                                    // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   GroomSID;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCustomDataVariationsEditor*>    CustomData;                                        // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UMeshGeneratorMaterialSlotEditor*> Materials;                                       // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroomEditor">();
	}
	static class UGroomEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroomEditor>();
	}
};
static_assert(alignof(UGroomEditor) == 0x000008, "Wrong alignment on UGroomEditor");
static_assert(sizeof(UGroomEditor) == 0x0000C8, "Wrong size on UGroomEditor");
static_assert(offsetof(UGroomEditor, AdditionalGrooms) == 0x000028, "Member 'UGroomEditor::AdditionalGrooms' has a wrong offset!");
static_assert(offsetof(UGroomEditor, MaterialPath) == 0x000038, "Member 'UGroomEditor::MaterialPath' has a wrong offset!");
static_assert(offsetof(UGroomEditor, GroomPath) == 0x000058, "Member 'UGroomEditor::GroomPath' has a wrong offset!");
static_assert(offsetof(UGroomEditor, GroomBindingPath) == 0x000078, "Member 'UGroomEditor::GroomBindingPath' has a wrong offset!");
static_assert(offsetof(UGroomEditor, Weight) == 0x000098, "Member 'UGroomEditor::Weight' has a wrong offset!");
static_assert(offsetof(UGroomEditor, VariationIndex) == 0x00009C, "Member 'UGroomEditor::VariationIndex' has a wrong offset!");
static_assert(offsetof(UGroomEditor, GroomSID) == 0x0000A0, "Member 'UGroomEditor::GroomSID' has a wrong offset!");
static_assert(offsetof(UGroomEditor, CustomData) == 0x0000A8, "Member 'UGroomEditor::CustomData' has a wrong offset!");
static_assert(offsetof(UGroomEditor, Materials) == 0x0000B8, "Member 'UGroomEditor::Materials' has a wrong offset!");

// Class Stalker2.GroomCategoryEditor
// 0x0018 (0x0040 - 0x0028)
class UGroomCategoryEditor final : public UObject
{
public:
	class FName                                   CategoryName;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGroomEditor*>                   Variations;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroomCategoryEditor">();
	}
	static class UGroomCategoryEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroomCategoryEditor>();
	}
};
static_assert(alignof(UGroomCategoryEditor) == 0x000008, "Wrong alignment on UGroomCategoryEditor");
static_assert(sizeof(UGroomCategoryEditor) == 0x000040, "Wrong size on UGroomCategoryEditor");
static_assert(offsetof(UGroomCategoryEditor, CategoryName) == 0x000028, "Member 'UGroomCategoryEditor::CategoryName' has a wrong offset!");
static_assert(offsetof(UGroomCategoryEditor, Variations) == 0x000030, "Member 'UGroomCategoryEditor::Variations' has a wrong offset!");

// Class Stalker2.MaterialGroupEditor
// 0x0030 (0x0058 - 0x0028)
class UMaterialGroupEditor final : public UObject
{
public:
	struct FSoftObjectPath                        MaterialPath;                                      // 0x0028(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         VariationIndex;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockedInVisualizer;                              // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialGroupEditor">();
	}
	static class UMaterialGroupEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialGroupEditor>();
	}
};
static_assert(alignof(UMaterialGroupEditor) == 0x000008, "Wrong alignment on UMaterialGroupEditor");
static_assert(sizeof(UMaterialGroupEditor) == 0x000058, "Wrong size on UMaterialGroupEditor");
static_assert(offsetof(UMaterialGroupEditor, MaterialPath) == 0x000028, "Member 'UMaterialGroupEditor::MaterialPath' has a wrong offset!");
static_assert(offsetof(UMaterialGroupEditor, VariationIndex) == 0x000048, "Member 'UMaterialGroupEditor::VariationIndex' has a wrong offset!");
static_assert(offsetof(UMaterialGroupEditor, bBlockedInVisualizer) == 0x00004C, "Member 'UMaterialGroupEditor::bBlockedInVisualizer' has a wrong offset!");
static_assert(offsetof(UMaterialGroupEditor, Weight) == 0x000050, "Member 'UMaterialGroupEditor::Weight' has a wrong offset!");

// Class Stalker2.ProjectileSubsystem
// 0x0058 (0x0100 - 0x00A8)
class UProjectileSubsystem final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x58];                                      // 0x00A8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileSubsystem">();
	}
	static class UProjectileSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileSubsystem>();
	}
};
static_assert(alignof(UProjectileSubsystem) == 0x000008, "Wrong alignment on UProjectileSubsystem");
static_assert(sizeof(UProjectileSubsystem) == 0x000100, "Wrong size on UProjectileSubsystem");

// Class Stalker2.CustomDataEditor
// 0x0020 (0x0048 - 0x0028)
class UCustomDataEditor final : public UObject
{
public:
	float                                         ParameterValue;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Weight;                                            // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         VariationIndex;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockedInVisualizer;                              // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEditorMaterialParameterConfig*> MaterialParameterConfigs;                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomDataEditor">();
	}
	static class UCustomDataEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomDataEditor>();
	}
};
static_assert(alignof(UCustomDataEditor) == 0x000008, "Wrong alignment on UCustomDataEditor");
static_assert(sizeof(UCustomDataEditor) == 0x000048, "Wrong size on UCustomDataEditor");
static_assert(offsetof(UCustomDataEditor, ParameterValue) == 0x000028, "Member 'UCustomDataEditor::ParameterValue' has a wrong offset!");
static_assert(offsetof(UCustomDataEditor, Weight) == 0x00002C, "Member 'UCustomDataEditor::Weight' has a wrong offset!");
static_assert(offsetof(UCustomDataEditor, VariationIndex) == 0x000030, "Member 'UCustomDataEditor::VariationIndex' has a wrong offset!");
static_assert(offsetof(UCustomDataEditor, bBlockedInVisualizer) == 0x000034, "Member 'UCustomDataEditor::bBlockedInVisualizer' has a wrong offset!");
static_assert(offsetof(UCustomDataEditor, MaterialParameterConfigs) == 0x000038, "Member 'UCustomDataEditor::MaterialParameterConfigs' has a wrong offset!");

// Class Stalker2.TopazScannerComponent
// 0x0030 (0x00E8 - 0x00B8)
class UTopazScannerComponent final : public UGuidActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const ETopazScannerState NewState)> OnTopazStateChanged;           // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ETopazScannerState                            InitialState;                                      // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScanningTime;                                      // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeState();

	ETopazScannerState GetCurrentState() const;
	float GetStateStartTimestamp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TopazScannerComponent">();
	}
	static class UTopazScannerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTopazScannerComponent>();
	}
};
static_assert(alignof(UTopazScannerComponent) == 0x000008, "Wrong alignment on UTopazScannerComponent");
static_assert(sizeof(UTopazScannerComponent) == 0x0000E8, "Wrong size on UTopazScannerComponent");
static_assert(offsetof(UTopazScannerComponent, OnTopazStateChanged) == 0x0000C0, "Member 'UTopazScannerComponent::OnTopazStateChanged' has a wrong offset!");
static_assert(offsetof(UTopazScannerComponent, InitialState) == 0x0000D0, "Member 'UTopazScannerComponent::InitialState' has a wrong offset!");
static_assert(offsetof(UTopazScannerComponent, ScanningTime) == 0x0000D4, "Member 'UTopazScannerComponent::ScanningTime' has a wrong offset!");

// Class Stalker2.CustomDataVariationsEditor
// 0x0030 (0x0058 - 0x0028)
class UCustomDataVariationsEditor final : public UObject
{
public:
	int32                                         ParameterID;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ParameterName;                                     // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MaterialGroup;                                     // 0x0034(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         VariationStartingIndex;                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         VariationCount;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldBeAppliedOnMesh;                            // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECustomDataDistribution                       Distribution;                                      // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCustomDataEditor*>              Variations;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomDataVariationsEditor">();
	}
	static class UCustomDataVariationsEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomDataVariationsEditor>();
	}
};
static_assert(alignof(UCustomDataVariationsEditor) == 0x000008, "Wrong alignment on UCustomDataVariationsEditor");
static_assert(sizeof(UCustomDataVariationsEditor) == 0x000058, "Wrong size on UCustomDataVariationsEditor");
static_assert(offsetof(UCustomDataVariationsEditor, ParameterID) == 0x000028, "Member 'UCustomDataVariationsEditor::ParameterID' has a wrong offset!");
static_assert(offsetof(UCustomDataVariationsEditor, ParameterName) == 0x00002C, "Member 'UCustomDataVariationsEditor::ParameterName' has a wrong offset!");
static_assert(offsetof(UCustomDataVariationsEditor, MaterialGroup) == 0x000034, "Member 'UCustomDataVariationsEditor::MaterialGroup' has a wrong offset!");
static_assert(offsetof(UCustomDataVariationsEditor, VariationStartingIndex) == 0x00003C, "Member 'UCustomDataVariationsEditor::VariationStartingIndex' has a wrong offset!");
static_assert(offsetof(UCustomDataVariationsEditor, VariationCount) == 0x000040, "Member 'UCustomDataVariationsEditor::VariationCount' has a wrong offset!");
static_assert(offsetof(UCustomDataVariationsEditor, bShouldBeAppliedOnMesh) == 0x000044, "Member 'UCustomDataVariationsEditor::bShouldBeAppliedOnMesh' has a wrong offset!");
static_assert(offsetof(UCustomDataVariationsEditor, Distribution) == 0x000045, "Member 'UCustomDataVariationsEditor::Distribution' has a wrong offset!");
static_assert(offsetof(UCustomDataVariationsEditor, Variations) == 0x000048, "Member 'UCustomDataVariationsEditor::Variations' has a wrong offset!");

// Class Stalker2.TimedLoadingScreenWidget
// 0x0048 (0x02F0 - 0x02A8)
class UTimedLoadingScreenWidget : public UBaseLoadingScreenWidget
{
public:
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UThrobber*                              LoadingIndicator;                                  // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ContentImage;                                      // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeTime;                                          // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x24];                                     // 0x02CC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedLoadingScreenWidget">();
	}
	static class UTimedLoadingScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimedLoadingScreenWidget>();
	}
};
static_assert(alignof(UTimedLoadingScreenWidget) == 0x000008, "Wrong alignment on UTimedLoadingScreenWidget");
static_assert(sizeof(UTimedLoadingScreenWidget) == 0x0002F0, "Wrong size on UTimedLoadingScreenWidget");
static_assert(offsetof(UTimedLoadingScreenWidget, LoadingIndicator) == 0x0002B8, "Member 'UTimedLoadingScreenWidget::LoadingIndicator' has a wrong offset!");
static_assert(offsetof(UTimedLoadingScreenWidget, ContentImage) == 0x0002C0, "Member 'UTimedLoadingScreenWidget::ContentImage' has a wrong offset!");
static_assert(offsetof(UTimedLoadingScreenWidget, FadeTime) == 0x0002C8, "Member 'UTimedLoadingScreenWidget::FadeTime' has a wrong offset!");

// Class Stalker2.MeshGeneratorBodyMeshEditor
// 0x0190 (0x01B8 - 0x0028)
class UMeshGeneratorBodyMeshEditor final : public UObject
{
public:
	TSet<class FName>                             BlockingGroomSIDs;                                 // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 BodyMeshSID;                                       // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        MeshPath;                                          // 0x0088(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        AnimPath;                                          // 0x00A8(0x0020)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Weight;                                            // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSkeletal;                                       // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BlockingSlots;                                     // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           BlockingAttaches;                                  // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSet<class FName>                             BlockingGroom;                                     // 0x00F0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FString                                 ItemPrototypeSID;                                  // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBodyMeshType                                 Type;                                              // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMeshGeneratorBodyMeshEditor*>   AdditionalMeshes;                                  // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 MeshGeneratorSID;                                  // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCustomLODSync;                                 // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESyncOption                                   LODSyncOption;                                     // 0x0179(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17A[0x6];                                      // 0x017A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 LODSyncMapping;                                    // 0x0180(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   HumanReadableName;                                 // 0x0190(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMeshGeneratorMaterialSlotEditor*> Materials;                                       // 0x0198(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UGroomCategoryEditor*>           Grooms;                                            // 0x01A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshGeneratorBodyMeshEditor">();
	}
	static class UMeshGeneratorBodyMeshEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshGeneratorBodyMeshEditor>();
	}
};
static_assert(alignof(UMeshGeneratorBodyMeshEditor) == 0x000008, "Wrong alignment on UMeshGeneratorBodyMeshEditor");
static_assert(sizeof(UMeshGeneratorBodyMeshEditor) == 0x0001B8, "Wrong size on UMeshGeneratorBodyMeshEditor");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, BlockingGroomSIDs) == 0x000028, "Member 'UMeshGeneratorBodyMeshEditor::BlockingGroomSIDs' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, BodyMeshSID) == 0x000078, "Member 'UMeshGeneratorBodyMeshEditor::BodyMeshSID' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, MeshPath) == 0x000088, "Member 'UMeshGeneratorBodyMeshEditor::MeshPath' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, AnimPath) == 0x0000A8, "Member 'UMeshGeneratorBodyMeshEditor::AnimPath' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, Weight) == 0x0000C8, "Member 'UMeshGeneratorBodyMeshEditor::Weight' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, bIsSkeletal) == 0x0000CC, "Member 'UMeshGeneratorBodyMeshEditor::bIsSkeletal' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, BlockingSlots) == 0x0000D0, "Member 'UMeshGeneratorBodyMeshEditor::BlockingSlots' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, BlockingAttaches) == 0x0000E0, "Member 'UMeshGeneratorBodyMeshEditor::BlockingAttaches' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, BlockingGroom) == 0x0000F0, "Member 'UMeshGeneratorBodyMeshEditor::BlockingGroom' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, ItemPrototypeSID) == 0x000140, "Member 'UMeshGeneratorBodyMeshEditor::ItemPrototypeSID' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, Type) == 0x000150, "Member 'UMeshGeneratorBodyMeshEditor::Type' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, AdditionalMeshes) == 0x000158, "Member 'UMeshGeneratorBodyMeshEditor::AdditionalMeshes' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, MeshGeneratorSID) == 0x000168, "Member 'UMeshGeneratorBodyMeshEditor::MeshGeneratorSID' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, bUseCustomLODSync) == 0x000178, "Member 'UMeshGeneratorBodyMeshEditor::bUseCustomLODSync' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, LODSyncOption) == 0x000179, "Member 'UMeshGeneratorBodyMeshEditor::LODSyncOption' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, LODSyncMapping) == 0x000180, "Member 'UMeshGeneratorBodyMeshEditor::LODSyncMapping' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, HumanReadableName) == 0x000190, "Member 'UMeshGeneratorBodyMeshEditor::HumanReadableName' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, Materials) == 0x000198, "Member 'UMeshGeneratorBodyMeshEditor::Materials' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodyMeshEditor, Grooms) == 0x0001A8, "Member 'UMeshGeneratorBodyMeshEditor::Grooms' has a wrong offset!");

// Class Stalker2.MeshGeneratorBodySlotEditor
// 0x0020 (0x0048 - 0x0028)
class UMeshGeneratorBodySlotEditor final : public UObject
{
public:
	int32                                         SelectedIndex;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMeshGeneratorBodyMeshEditor*>   MeshArray;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshGeneratorBodySlotEditor">();
	}
	static class UMeshGeneratorBodySlotEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshGeneratorBodySlotEditor>();
	}
};
static_assert(alignof(UMeshGeneratorBodySlotEditor) == 0x000008, "Wrong alignment on UMeshGeneratorBodySlotEditor");
static_assert(sizeof(UMeshGeneratorBodySlotEditor) == 0x000048, "Wrong size on UMeshGeneratorBodySlotEditor");
static_assert(offsetof(UMeshGeneratorBodySlotEditor, SelectedIndex) == 0x000028, "Member 'UMeshGeneratorBodySlotEditor::SelectedIndex' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodySlotEditor, SlotName) == 0x00002C, "Member 'UMeshGeneratorBodySlotEditor::SlotName' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorBodySlotEditor, MeshArray) == 0x000038, "Member 'UMeshGeneratorBodySlotEditor::MeshArray' has a wrong offset!");

// Class Stalker2.MeshGeneratorMaterialSlotEditor
// 0x0030 (0x0058 - 0x0028)
class UMeshGeneratorMaterialSlotEditor final : public UObject
{
public:
	class FName                                   MaterialGroup;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialGroupEditor*>           MaterialGroupArray;                                // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         MaterialSlot;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCustomDataVariationsEditor*>    CustomData;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshGeneratorMaterialSlotEditor">();
	}
	static class UMeshGeneratorMaterialSlotEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshGeneratorMaterialSlotEditor>();
	}
};
static_assert(alignof(UMeshGeneratorMaterialSlotEditor) == 0x000008, "Wrong alignment on UMeshGeneratorMaterialSlotEditor");
static_assert(sizeof(UMeshGeneratorMaterialSlotEditor) == 0x000058, "Wrong size on UMeshGeneratorMaterialSlotEditor");
static_assert(offsetof(UMeshGeneratorMaterialSlotEditor, MaterialGroup) == 0x000028, "Member 'UMeshGeneratorMaterialSlotEditor::MaterialGroup' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorMaterialSlotEditor, MaterialGroupArray) == 0x000030, "Member 'UMeshGeneratorMaterialSlotEditor::MaterialGroupArray' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorMaterialSlotEditor, MaterialSlot) == 0x000040, "Member 'UMeshGeneratorMaterialSlotEditor::MaterialSlot' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorMaterialSlotEditor, CustomData) == 0x000048, "Member 'UMeshGeneratorMaterialSlotEditor::CustomData' has a wrong offset!");

// Class Stalker2.NavModifiersManagementSubsystem
// 0x3070 (0x30A0 - 0x0030)
class UNavModifiersManagementSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, class AGSCNavModifierVolume*> VolumesMap;                                     // 0x0080(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x2FA0];                                    // 0x00D0(0x2FA0)(Fixing Size After Last Property [ Dumper-7 ])
	class ARecastNavMesh*                         CachedDefaultRecast;                               // 0x3070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3078[0x28];                                    // 0x3078(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavModifiersManagementSubsystem">();
	}
	static class UNavModifiersManagementSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavModifiersManagementSubsystem>();
	}
};
static_assert(alignof(UNavModifiersManagementSubsystem) == 0x000008, "Wrong alignment on UNavModifiersManagementSubsystem");
static_assert(sizeof(UNavModifiersManagementSubsystem) == 0x0030A0, "Wrong size on UNavModifiersManagementSubsystem");
static_assert(offsetof(UNavModifiersManagementSubsystem, VolumesMap) == 0x000080, "Member 'UNavModifiersManagementSubsystem::VolumesMap' has a wrong offset!");
static_assert(offsetof(UNavModifiersManagementSubsystem, CachedDefaultRecast) == 0x003070, "Member 'UNavModifiersManagementSubsystem::CachedDefaultRecast' has a wrong offset!");

// Class Stalker2.MeshGeneratorEditor
// 0x0058 (0x0080 - 0x0028)
class UMeshGeneratorEditor final : public UObject
{
public:
	class FName                                   SID;                                               // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ParentMeshGeneratorSID;                            // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ParentItemGeneratorSID;                            // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMeshGeneratorBodySlotEditor*>   GeneratorBodySlots;                                // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UMeshGeneratorMaterialSlotEditor*> Materials;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UCustomDataVariationsEditor*>    CustomData;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UGroomCategoryEditor*>           Grooms;                                            // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshGeneratorEditor">();
	}
	static class UMeshGeneratorEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshGeneratorEditor>();
	}
};
static_assert(alignof(UMeshGeneratorEditor) == 0x000008, "Wrong alignment on UMeshGeneratorEditor");
static_assert(sizeof(UMeshGeneratorEditor) == 0x000080, "Wrong size on UMeshGeneratorEditor");
static_assert(offsetof(UMeshGeneratorEditor, SID) == 0x000028, "Member 'UMeshGeneratorEditor::SID' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorEditor, ParentMeshGeneratorSID) == 0x000030, "Member 'UMeshGeneratorEditor::ParentMeshGeneratorSID' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorEditor, ParentItemGeneratorSID) == 0x000038, "Member 'UMeshGeneratorEditor::ParentItemGeneratorSID' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorEditor, GeneratorBodySlots) == 0x000040, "Member 'UMeshGeneratorEditor::GeneratorBodySlots' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorEditor, Materials) == 0x000050, "Member 'UMeshGeneratorEditor::Materials' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorEditor, CustomData) == 0x000060, "Member 'UMeshGeneratorEditor::CustomData' has a wrong offset!");
static_assert(offsetof(UMeshGeneratorEditor, Grooms) == 0x000070, "Member 'UMeshGeneratorEditor::Grooms' has a wrong offset!");

// Class Stalker2.ObjPrototypeEditor
// 0x0020 (0x0048 - 0x0028)
class UObjPrototypeEditor final : public UObject
{
public:
	class FString                                 SID;                                               // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ItemGeneratorSID;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjPrototypeEditor">();
	}
	static class UObjPrototypeEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjPrototypeEditor>();
	}
};
static_assert(alignof(UObjPrototypeEditor) == 0x000008, "Wrong alignment on UObjPrototypeEditor");
static_assert(sizeof(UObjPrototypeEditor) == 0x000048, "Wrong size on UObjPrototypeEditor");
static_assert(offsetof(UObjPrototypeEditor, SID) == 0x000028, "Member 'UObjPrototypeEditor::SID' has a wrong offset!");
static_assert(offsetof(UObjPrototypeEditor, ItemGeneratorSID) == 0x000038, "Member 'UObjPrototypeEditor::ItemGeneratorSID' has a wrong offset!");

// Class Stalker2.FileObjPrototypesEditor
// 0x0010 (0x0038 - 0x0028)
class UFileObjPrototypesEditor final : public UObject
{
public:
	TArray<class UObjPrototypeEditor*>            ObjPrototypes;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FileObjPrototypesEditor">();
	}
	static class UFileObjPrototypesEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFileObjPrototypesEditor>();
	}
};
static_assert(alignof(UFileObjPrototypesEditor) == 0x000008, "Wrong alignment on UFileObjPrototypesEditor");
static_assert(sizeof(UFileObjPrototypesEditor) == 0x000038, "Wrong size on UFileObjPrototypesEditor");
static_assert(offsetof(UFileObjPrototypesEditor, ObjPrototypes) == 0x000028, "Member 'UFileObjPrototypesEditor::ObjPrototypes' has a wrong offset!");

// Class Stalker2.PreBlendCinematicComponent
// 0x0090 (0x00B8 - 0x0028)
class UPreBlendCinematicComponent final : public UObject
{
public:
	uint8                                         Pad_28[0x90];                                      // 0x0028(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreBlendCinematicComponent">();
	}
	static class UPreBlendCinematicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreBlendCinematicComponent>();
	}
};
static_assert(alignof(UPreBlendCinematicComponent) == 0x000008, "Wrong alignment on UPreBlendCinematicComponent");
static_assert(sizeof(UPreBlendCinematicComponent) == 0x0000B8, "Wrong size on UPreBlendCinematicComponent");

// Class Stalker2.MeshSoundPlacerManager
// 0x00C8 (0x0170 - 0x00A8)
class UMeshSoundPlacerManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0xC8];                                      // 0x00A8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSoundPlacerManager">();
	}
	static class UMeshSoundPlacerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSoundPlacerManager>();
	}
};
static_assert(alignof(UMeshSoundPlacerManager) == 0x000008, "Wrong alignment on UMeshSoundPlacerManager");
static_assert(sizeof(UMeshSoundPlacerManager) == 0x000170, "Wrong size on UMeshSoundPlacerManager");

// Class Stalker2.UIDActor_MistAnomaly
// 0x0010 (0x02A8 - 0x0298)
class AUIDActor_MistAnomaly : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActor_MistAnomaly">();
	}
	static class AUIDActor_MistAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDActor_MistAnomaly>();
	}
};
static_assert(alignof(AUIDActor_MistAnomaly) == 0x000008, "Wrong alignment on AUIDActor_MistAnomaly");
static_assert(sizeof(AUIDActor_MistAnomaly) == 0x0002A8, "Wrong size on AUIDActor_MistAnomaly");

// Class Stalker2.MistAnomaly
// 0x0050 (0x02F8 - 0x02A8)
class AMistAnomaly final : public AUIDActor_MistAnomaly
{
public:
	TArray<struct FEffectPrototypeSID>            PlayerEffectSIDs;                                  // 0x02A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         WeatherSpeedFactor;                                // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  Guid;                                              // 0x02BC(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      SaveCapsuleComponent;                              // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnomalyBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);
	void OnAnomalyEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex);
	void OnPlayerEnter();
	void OnPlayerExit();
	void OnPlayerTeleport();
	void OnSaveBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);
	void SetTeleportationEnabled(const bool InbTeleportationEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MistAnomaly">();
	}
	static class AMistAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMistAnomaly>();
	}
};
static_assert(alignof(AMistAnomaly) == 0x000008, "Wrong alignment on AMistAnomaly");
static_assert(sizeof(AMistAnomaly) == 0x0002F8, "Wrong size on AMistAnomaly");
static_assert(offsetof(AMistAnomaly, PlayerEffectSIDs) == 0x0002A8, "Member 'AMistAnomaly::PlayerEffectSIDs' has a wrong offset!");
static_assert(offsetof(AMistAnomaly, WeatherSpeedFactor) == 0x0002B8, "Member 'AMistAnomaly::WeatherSpeedFactor' has a wrong offset!");
static_assert(offsetof(AMistAnomaly, Guid) == 0x0002BC, "Member 'AMistAnomaly::Guid' has a wrong offset!");
static_assert(offsetof(AMistAnomaly, CapsuleComponent) == 0x0002D0, "Member 'AMistAnomaly::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AMistAnomaly, SaveCapsuleComponent) == 0x0002D8, "Member 'AMistAnomaly::SaveCapsuleComponent' has a wrong offset!");

// Class Stalker2.QuestTaskNotification
// 0x0090 (0x0308 - 0x0278)
class UQuestTaskNotification final : public UWidgetBase
{
public:
	class URichTextWidget*                        TextWidget;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 TrackingStage;                                     // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 CanceledStage;                                     // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 FailedStage;                                       // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 FinishedStage;                                     // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 UntrackingStage;                                   // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AppearAnim;                                        // 0x02A8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       FailAnim;                                          // 0x02B0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       FinishedAnim;                                      // 0x02B8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       CancelAnim;                                        // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x20];                                     // 0x02C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       LastAnim;                                          // 0x02E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        QuestStateSwitcher;                                // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PlayTaskAnimation(const EQuestTaskAnimationType AnimationType, const bool bWithSound);
	void PostPlayTaskAnimation(const EQuestTaskAnimationType AnimationType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestTaskNotification">();
	}
	static class UQuestTaskNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestTaskNotification>();
	}
};
static_assert(alignof(UQuestTaskNotification) == 0x000008, "Wrong alignment on UQuestTaskNotification");
static_assert(sizeof(UQuestTaskNotification) == 0x000308, "Wrong size on UQuestTaskNotification");
static_assert(offsetof(UQuestTaskNotification, TextWidget) == 0x000278, "Member 'UQuestTaskNotification::TextWidget' has a wrong offset!");
static_assert(offsetof(UQuestTaskNotification, TrackingStage) == 0x000280, "Member 'UQuestTaskNotification::TrackingStage' has a wrong offset!");
static_assert(offsetof(UQuestTaskNotification, CanceledStage) == 0x000288, "Member 'UQuestTaskNotification::CanceledStage' has a wrong offset!");
static_assert(offsetof(UQuestTaskNotification, FailedStage) == 0x000290, "Member 'UQuestTaskNotification::FailedStage' has a wrong offset!");
static_assert(offsetof(UQuestTaskNotification, FinishedStage) == 0x000298, "Member 'UQuestTaskNotification::FinishedStage' has a wrong offset!");
static_assert(offsetof(UQuestTaskNotification, UntrackingStage) == 0x0002A0, "Member 'UQuestTaskNotification::UntrackingStage' has a wrong offset!");
static_assert(offsetof(UQuestTaskNotification, AppearAnim) == 0x0002A8, "Member 'UQuestTaskNotification::AppearAnim' has a wrong offset!");
static_assert(offsetof(UQuestTaskNotification, FailAnim) == 0x0002B0, "Member 'UQuestTaskNotification::FailAnim' has a wrong offset!");
static_assert(offsetof(UQuestTaskNotification, FinishedAnim) == 0x0002B8, "Member 'UQuestTaskNotification::FinishedAnim' has a wrong offset!");
static_assert(offsetof(UQuestTaskNotification, CancelAnim) == 0x0002C0, "Member 'UQuestTaskNotification::CancelAnim' has a wrong offset!");
static_assert(offsetof(UQuestTaskNotification, LastAnim) == 0x0002E8, "Member 'UQuestTaskNotification::LastAnim' has a wrong offset!");
static_assert(offsetof(UQuestTaskNotification, QuestStateSwitcher) == 0x000300, "Member 'UQuestTaskNotification::QuestStateSwitcher' has a wrong offset!");

// Class Stalker2.ModifiableRichText
// 0x0108 (0x0380 - 0x0278)
class UModifiableRichText : public UWidgetBase
{
public:
	float                                         LineHeightPercentage;                              // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URichTextWidget*                        RichText;                                          // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableList;                                       // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ClosureTag;                                        // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListPointTag;                                      // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListItemTag;                                       // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListItemClosureTag;                                // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListNumericTag;                                    // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ClouseTags;                                        // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         OpenTags;                                          // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 BodyTag;                                           // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PointTag;                                          // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDoubleLineSettings>            DoubleLineTags;                                    // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShoudUseDefaultStyle;                             // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DefaultStyleId;                                    // 0x0338(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEnableDefaultText;                                // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DefaultText;                                       // 0x0358(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         WrappingTextAt;                                    // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TagSize;                                           // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WrappingTextAtEULA;                                // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShoudLoadLocalization;                            // 0x037C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37D[0x3];                                      // 0x037D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class FText GetNextLine();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModifiableRichText">();
	}
	static class UModifiableRichText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModifiableRichText>();
	}
};
static_assert(alignof(UModifiableRichText) == 0x000008, "Wrong alignment on UModifiableRichText");
static_assert(sizeof(UModifiableRichText) == 0x000380, "Wrong size on UModifiableRichText");
static_assert(offsetof(UModifiableRichText, LineHeightPercentage) == 0x000278, "Member 'UModifiableRichText::LineHeightPercentage' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, RichText) == 0x000280, "Member 'UModifiableRichText::RichText' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, bEnableList) == 0x000288, "Member 'UModifiableRichText::bEnableList' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, ClosureTag) == 0x000290, "Member 'UModifiableRichText::ClosureTag' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, ListPointTag) == 0x0002A0, "Member 'UModifiableRichText::ListPointTag' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, ListItemTag) == 0x0002B0, "Member 'UModifiableRichText::ListItemTag' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, ListItemClosureTag) == 0x0002C0, "Member 'UModifiableRichText::ListItemClosureTag' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, ListNumericTag) == 0x0002D0, "Member 'UModifiableRichText::ListNumericTag' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, ClouseTags) == 0x0002E0, "Member 'UModifiableRichText::ClouseTags' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, OpenTags) == 0x0002F0, "Member 'UModifiableRichText::OpenTags' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, BodyTag) == 0x000300, "Member 'UModifiableRichText::BodyTag' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, PointTag) == 0x000310, "Member 'UModifiableRichText::PointTag' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, DoubleLineTags) == 0x000320, "Member 'UModifiableRichText::DoubleLineTags' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, bShoudUseDefaultStyle) == 0x000330, "Member 'UModifiableRichText::bShoudUseDefaultStyle' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, DefaultStyleId) == 0x000338, "Member 'UModifiableRichText::DefaultStyleId' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, bEnableDefaultText) == 0x000350, "Member 'UModifiableRichText::bEnableDefaultText' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, DefaultText) == 0x000358, "Member 'UModifiableRichText::DefaultText' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, WrappingTextAt) == 0x000370, "Member 'UModifiableRichText::WrappingTextAt' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, TagSize) == 0x000374, "Member 'UModifiableRichText::TagSize' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, WrappingTextAtEULA) == 0x000378, "Member 'UModifiableRichText::WrappingTextAtEULA' has a wrong offset!");
static_assert(offsetof(UModifiableRichText, bShoudLoadLocalization) == 0x00037C, "Member 'UModifiableRichText::bShoudLoadLocalization' has a wrong offset!");

// Class Stalker2.AchievementTracker_HoarderBase
// 0x0058 (0x0090 - 0x0038)
class UAchievementTracker_HoarderBase : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_HoarderBase">();
	}
	static class UAchievementTracker_HoarderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_HoarderBase>();
	}
};
static_assert(alignof(UAchievementTracker_HoarderBase) == 0x000008, "Wrong alignment on UAchievementTracker_HoarderBase");
static_assert(sizeof(UAchievementTracker_HoarderBase) == 0x000090, "Wrong size on UAchievementTracker_HoarderBase");

// Class Stalker2.AchievementTracker_ArtifactBaseHoarder
// 0x0000 (0x0090 - 0x0090)
class UAchievementTracker_ArtifactBaseHoarder : public UAchievementTracker_HoarderBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_ArtifactBaseHoarder">();
	}
	static class UAchievementTracker_ArtifactBaseHoarder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_ArtifactBaseHoarder>();
	}
};
static_assert(alignof(UAchievementTracker_ArtifactBaseHoarder) == 0x000008, "Wrong alignment on UAchievementTracker_ArtifactBaseHoarder");
static_assert(sizeof(UAchievementTracker_ArtifactBaseHoarder) == 0x000090, "Wrong size on UAchievementTracker_ArtifactBaseHoarder");

// Class Stalker2.ModioAuthView
// 0x0008 (0x0490 - 0x0488)
class UModioAuthView final : public UModioCommonAuthView
{
public:
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioAuthView">();
	}
	static class UModioAuthView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioAuthView>();
	}
};
static_assert(alignof(UModioAuthView) == 0x000008, "Wrong alignment on UModioAuthView");
static_assert(sizeof(UModioAuthView) == 0x000490, "Wrong size on UModioAuthView");

// Class Stalker2.AchievementTracker_HeadshotStreak
// 0x0038 (0x0070 - 0x0038)
class UAchievementTracker_HeadshotStreak final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_HeadshotStreak">();
	}
	static class UAchievementTracker_HeadshotStreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_HeadshotStreak>();
	}
};
static_assert(alignof(UAchievementTracker_HeadshotStreak) == 0x000008, "Wrong alignment on UAchievementTracker_HeadshotStreak");
static_assert(sizeof(UAchievementTracker_HeadshotStreak) == 0x000070, "Wrong size on UAchievementTracker_HeadshotStreak");

// Class Stalker2.ModioCategorySelectionBox
// 0x0038 (0x02D8 - 0x02A0)
class UModioCategorySelectionBox final : public UCommonUserWidget
{
public:
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelWidget*                           CheckboxPanel;                                     // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UModioCategorySelectionBoxEntry*> CheckboxList;                                     // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UModioCategorySelectionBoxEntry*        SelectedCheckbox;                                  // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioCategorySelectionBox">();
	}
	static class UModioCategorySelectionBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioCategorySelectionBox>();
	}
};
static_assert(alignof(UModioCategorySelectionBox) == 0x000008, "Wrong alignment on UModioCategorySelectionBox");
static_assert(sizeof(UModioCategorySelectionBox) == 0x0002D8, "Wrong size on UModioCategorySelectionBox");
static_assert(offsetof(UModioCategorySelectionBox, CheckboxPanel) == 0x0002B8, "Member 'UModioCategorySelectionBox::CheckboxPanel' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBox, CheckboxList) == 0x0002C0, "Member 'UModioCategorySelectionBox::CheckboxList' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBox, SelectedCheckbox) == 0x0002D0, "Member 'UModioCategorySelectionBox::SelectedCheckbox' has a wrong offset!");

// Class Stalker2.ModioCategorySelectionBoxEntry
// 0x00A0 (0x1830 - 0x1790)
class UModioCategorySelectionBoxEntry final : public UModioCommonButtonBase
{
public:
	uint8                                         Pad_1790[0x10];                                    // 0x1790(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCheckBoxWidget*                        DummyCheckbox;                                     // 0x17A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            CheckboxNameText;                                  // 0x17A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HoverAnimation;                                    // 0x17B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       PressAnimation;                                    // 0x17B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CategoryTag;                                       // 0x17C0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoverAnimationSpeedMultiplier;                     // 0x17D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HideHoverAnimationSpeedMultiplier;                 // 0x17D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PressButtonAnimationSpeed;                         // 0x17D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCheckedOnInit;                                   // 0x17DC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnableLocalization;                                // 0x17DD(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17DE[0x2];                                     // 0x17DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CheckboxName;                                      // 0x17E0(0x0018)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class FString                                 CheckboxNameLocalizationSID;                       // 0x17F8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CheckedStyleIdActive;                              // 0x1808(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CheckedStyleIdInactive;                            // 0x1810(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   UncheckedStyleIdActive;                            // 0x1818(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   UncheckedStyleIdInactive;                          // 0x1820(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1828[0x8];                                     // 0x1828(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioCategorySelectionBoxEntry">();
	}
	static class UModioCategorySelectionBoxEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioCategorySelectionBoxEntry>();
	}
};
static_assert(alignof(UModioCategorySelectionBoxEntry) == 0x000010, "Wrong alignment on UModioCategorySelectionBoxEntry");
static_assert(sizeof(UModioCategorySelectionBoxEntry) == 0x001830, "Wrong size on UModioCategorySelectionBoxEntry");
static_assert(offsetof(UModioCategorySelectionBoxEntry, DummyCheckbox) == 0x0017A0, "Member 'UModioCategorySelectionBoxEntry::DummyCheckbox' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, CheckboxNameText) == 0x0017A8, "Member 'UModioCategorySelectionBoxEntry::CheckboxNameText' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, HoverAnimation) == 0x0017B0, "Member 'UModioCategorySelectionBoxEntry::HoverAnimation' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, PressAnimation) == 0x0017B8, "Member 'UModioCategorySelectionBoxEntry::PressAnimation' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, CategoryTag) == 0x0017C0, "Member 'UModioCategorySelectionBoxEntry::CategoryTag' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, HoverAnimationSpeedMultiplier) == 0x0017D0, "Member 'UModioCategorySelectionBoxEntry::HoverAnimationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, HideHoverAnimationSpeedMultiplier) == 0x0017D4, "Member 'UModioCategorySelectionBoxEntry::HideHoverAnimationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, PressButtonAnimationSpeed) == 0x0017D8, "Member 'UModioCategorySelectionBoxEntry::PressButtonAnimationSpeed' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, IsCheckedOnInit) == 0x0017DC, "Member 'UModioCategorySelectionBoxEntry::IsCheckedOnInit' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, EnableLocalization) == 0x0017DD, "Member 'UModioCategorySelectionBoxEntry::EnableLocalization' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, CheckboxName) == 0x0017E0, "Member 'UModioCategorySelectionBoxEntry::CheckboxName' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, CheckboxNameLocalizationSID) == 0x0017F8, "Member 'UModioCategorySelectionBoxEntry::CheckboxNameLocalizationSID' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, CheckedStyleIdActive) == 0x001808, "Member 'UModioCategorySelectionBoxEntry::CheckedStyleIdActive' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, CheckedStyleIdInactive) == 0x001810, "Member 'UModioCategorySelectionBoxEntry::CheckedStyleIdInactive' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, UncheckedStyleIdActive) == 0x001818, "Member 'UModioCategorySelectionBoxEntry::UncheckedStyleIdActive' has a wrong offset!");
static_assert(offsetof(UModioCategorySelectionBoxEntry, UncheckedStyleIdInactive) == 0x001820, "Member 'UModioCategorySelectionBoxEntry::UncheckedStyleIdInactive' has a wrong offset!");

// Class Stalker2.ModioEmailAuthCodePopup
// 0x0018 (0x0470 - 0x0458)
class UModioEmailAuthCodePopup final : public UModioCommonEmailAuthCodeViewBase
{
public:
	class UTextWidget*                            ValidationText;                                    // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UModioCommonCodeInputTextBox*           CodeInputTextBox;                                  // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioEmailAuthCodePopup">();
	}
	static class UModioEmailAuthCodePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioEmailAuthCodePopup>();
	}
};
static_assert(alignof(UModioEmailAuthCodePopup) == 0x000008, "Wrong alignment on UModioEmailAuthCodePopup");
static_assert(sizeof(UModioEmailAuthCodePopup) == 0x000470, "Wrong size on UModioEmailAuthCodePopup");
static_assert(offsetof(UModioEmailAuthCodePopup, ValidationText) == 0x000458, "Member 'UModioEmailAuthCodePopup::ValidationText' has a wrong offset!");
static_assert(offsetof(UModioEmailAuthCodePopup, CodeInputTextBox) == 0x000460, "Member 'UModioEmailAuthCodePopup::CodeInputTextBox' has a wrong offset!");

// Class Stalker2.ModioEmailAuthLoadingPopup
// 0x0008 (0x0440 - 0x0438)
class UModioEmailAuthLoadingPopup final : public UModioCommonEmailAuthLoadingViewBase
{
public:
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioEmailAuthLoadingPopup">();
	}
	static class UModioEmailAuthLoadingPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioEmailAuthLoadingPopup>();
	}
};
static_assert(alignof(UModioEmailAuthLoadingPopup) == 0x000008, "Wrong alignment on UModioEmailAuthLoadingPopup");
static_assert(sizeof(UModioEmailAuthLoadingPopup) == 0x000440, "Wrong size on UModioEmailAuthLoadingPopup");

// Class Stalker2.ModioEmailAuthPopup
// 0x0018 (0x0470 - 0x0458)
class UModioEmailAuthPopup final : public UModioCommonEmailAuthViewBase
{
public:
	class UTextWidget*                            ValidationText;                                    // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UModioCommonEditableTextBox*            EmailTextBox;                                      // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEditableTextBoxTextChanged(const class FText& Text);

	class FString GetEmail() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioEmailAuthPopup">();
	}
	static class UModioEmailAuthPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioEmailAuthPopup>();
	}
};
static_assert(alignof(UModioEmailAuthPopup) == 0x000008, "Wrong alignment on UModioEmailAuthPopup");
static_assert(sizeof(UModioEmailAuthPopup) == 0x000470, "Wrong size on UModioEmailAuthPopup");
static_assert(offsetof(UModioEmailAuthPopup, ValidationText) == 0x000458, "Member 'UModioEmailAuthPopup::ValidationText' has a wrong offset!");
static_assert(offsetof(UModioEmailAuthPopup, EmailTextBox) == 0x000460, "Member 'UModioEmailAuthPopup::EmailTextBox' has a wrong offset!");

// Class Stalker2.ModioFeaturedView
// 0x0000 (0x0520 - 0x0520)
class UModioFeaturedView final : public UModioCommonFeaturedView
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioFeaturedView">();
	}
	static class UModioFeaturedView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioFeaturedView>();
	}
};
static_assert(alignof(UModioFeaturedView) == 0x000008, "Wrong alignment on UModioFeaturedView");
static_assert(sizeof(UModioFeaturedView) == 0x000520, "Wrong size on UModioFeaturedView");

// Class Stalker2.NavArea_Scripted
// 0x0000 (0x0048 - 0x0048)
class UNavArea_Scripted : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Scripted">();
	}
	static class UNavArea_Scripted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Scripted>();
	}
};
static_assert(alignof(UNavArea_Scripted) == 0x000008, "Wrong alignment on UNavArea_Scripted");
static_assert(sizeof(UNavArea_Scripted) == 0x000048, "Wrong size on UNavArea_Scripted");

// Class Stalker2.ModioFilteredModListView
// 0x0008 (0x05F0 - 0x05E8)
class UModioFilteredModListView final : public UModioCommonFilteredModListView
{
public:
	class UModioModListPageInfo*                  PageInfo;                                          // 0x05E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioFilteredModListView">();
	}
	static class UModioFilteredModListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioFilteredModListView>();
	}
};
static_assert(alignof(UModioFilteredModListView) == 0x000008, "Wrong alignment on UModioFilteredModListView");
static_assert(sizeof(UModioFilteredModListView) == 0x0005F0, "Wrong size on UModioFilteredModListView");
static_assert(offsetof(UModioFilteredModListView, PageInfo) == 0x0005E8, "Member 'UModioFilteredModListView::PageInfo' has a wrong offset!");

// Class Stalker2.ModioFilterNavigationButton
// 0x00A0 (0x1830 - 0x1790)
class UModioFilterNavigationButton final : public UModioCommonButtonBase
{
public:
	uint8                                         Pad_1790[0x8];                                     // 0x1790(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 SelectLine;                                        // 0x1798(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 IconImage;                                         // 0x17A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            TextWidget;                                        // 0x17A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLocalisation;                               // 0x17B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B1[0x7];                                     // 0x17B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ButtonLocalizationSID;                             // 0x17B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x17C8(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bEnableSelectAnimation;                            // 0x17E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableByDefault;                                  // 0x17E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17E2[0x2];                                     // 0x17E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ButtonIndex;                                       // 0x17E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetStyleIdHover;                                   // 0x17E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetStyleIdUnHover;                                 // 0x17F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            SetStyleIconTintHover;                             // 0x17F8(0x0014)(Edit, NativeAccessSpecifierPublic)
	struct FSlateColor                            SetStyleIconTintUnhover;                           // 0x180C(0x0014)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             SetStyleIconImageTexture;                          // 0x1820(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1828[0x8];                                     // 0x1828(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioFilterNavigationButton">();
	}
	static class UModioFilterNavigationButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioFilterNavigationButton>();
	}
};
static_assert(alignof(UModioFilterNavigationButton) == 0x000010, "Wrong alignment on UModioFilterNavigationButton");
static_assert(sizeof(UModioFilterNavigationButton) == 0x001830, "Wrong size on UModioFilterNavigationButton");
static_assert(offsetof(UModioFilterNavigationButton, SelectLine) == 0x001798, "Member 'UModioFilterNavigationButton::SelectLine' has a wrong offset!");
static_assert(offsetof(UModioFilterNavigationButton, IconImage) == 0x0017A0, "Member 'UModioFilterNavigationButton::IconImage' has a wrong offset!");
static_assert(offsetof(UModioFilterNavigationButton, TextWidget) == 0x0017A8, "Member 'UModioFilterNavigationButton::TextWidget' has a wrong offset!");
static_assert(offsetof(UModioFilterNavigationButton, bEnableLocalisation) == 0x0017B0, "Member 'UModioFilterNavigationButton::bEnableLocalisation' has a wrong offset!");
static_assert(offsetof(UModioFilterNavigationButton, ButtonLocalizationSID) == 0x0017B8, "Member 'UModioFilterNavigationButton::ButtonLocalizationSID' has a wrong offset!");
static_assert(offsetof(UModioFilterNavigationButton, DisplayText) == 0x0017C8, "Member 'UModioFilterNavigationButton::DisplayText' has a wrong offset!");
static_assert(offsetof(UModioFilterNavigationButton, bEnableSelectAnimation) == 0x0017E0, "Member 'UModioFilterNavigationButton::bEnableSelectAnimation' has a wrong offset!");
static_assert(offsetof(UModioFilterNavigationButton, bEnableByDefault) == 0x0017E1, "Member 'UModioFilterNavigationButton::bEnableByDefault' has a wrong offset!");
static_assert(offsetof(UModioFilterNavigationButton, ButtonIndex) == 0x0017E4, "Member 'UModioFilterNavigationButton::ButtonIndex' has a wrong offset!");
static_assert(offsetof(UModioFilterNavigationButton, SetStyleIdHover) == 0x0017E8, "Member 'UModioFilterNavigationButton::SetStyleIdHover' has a wrong offset!");
static_assert(offsetof(UModioFilterNavigationButton, SetStyleIdUnHover) == 0x0017F0, "Member 'UModioFilterNavigationButton::SetStyleIdUnHover' has a wrong offset!");
static_assert(offsetof(UModioFilterNavigationButton, SetStyleIconTintHover) == 0x0017F8, "Member 'UModioFilterNavigationButton::SetStyleIconTintHover' has a wrong offset!");
static_assert(offsetof(UModioFilterNavigationButton, SetStyleIconTintUnhover) == 0x00180C, "Member 'UModioFilterNavigationButton::SetStyleIconTintUnhover' has a wrong offset!");
static_assert(offsetof(UModioFilterNavigationButton, SetStyleIconImageTexture) == 0x001820, "Member 'UModioFilterNavigationButton::SetStyleIconImageTexture' has a wrong offset!");

// Class Stalker2.ModioFilterNavigationPanel
// 0x0028 (0x02C8 - 0x02A0)
class UModioFilterNavigationPanel : public UCommonUserWidget
{
public:
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelWidget*                           SlotContainer;                                     // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonClicked(const int32 ButtonIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioFilterNavigationPanel">();
	}
	static class UModioFilterNavigationPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioFilterNavigationPanel>();
	}
};
static_assert(alignof(UModioFilterNavigationPanel) == 0x000008, "Wrong alignment on UModioFilterNavigationPanel");
static_assert(sizeof(UModioFilterNavigationPanel) == 0x0002C8, "Wrong size on UModioFilterNavigationPanel");
static_assert(offsetof(UModioFilterNavigationPanel, SlotContainer) == 0x0002B8, "Member 'UModioFilterNavigationPanel::SlotContainer' has a wrong offset!");

// Class Stalker2.ModioFirstFilterNavigationPanel
// 0x0000 (0x02C8 - 0x02C8)
class UModioFirstFilterNavigationPanel final : public UModioFilterNavigationPanel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioFirstFilterNavigationPanel">();
	}
	static class UModioFirstFilterNavigationPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioFirstFilterNavigationPanel>();
	}
};
static_assert(alignof(UModioFirstFilterNavigationPanel) == 0x000008, "Wrong alignment on UModioFirstFilterNavigationPanel");
static_assert(sizeof(UModioFirstFilterNavigationPanel) == 0x0002C8, "Wrong size on UModioFirstFilterNavigationPanel");

// Class Stalker2.ModioSecondFilterNavigationPanel
// 0x0000 (0x02C8 - 0x02C8)
class UModioSecondFilterNavigationPanel final : public UModioFilterNavigationPanel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioSecondFilterNavigationPanel">();
	}
	static class UModioSecondFilterNavigationPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioSecondFilterNavigationPanel>();
	}
};
static_assert(alignof(UModioSecondFilterNavigationPanel) == 0x000008, "Wrong alignment on UModioSecondFilterNavigationPanel");
static_assert(sizeof(UModioSecondFilterNavigationPanel) == 0x0002C8, "Wrong size on UModioSecondFilterNavigationPanel");

// Class Stalker2.PossessedObjectComponent
// 0x0230 (0x07C0 - 0x0590)
class UPossessedObjectComponent final : public USphereComponent
{
public:
	uint8                                         Pad_588[0x118];                                    // 0x0588(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          FloatingStartSound;                                // 0x06A0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          FloatingStopSound;                                 // 0x06A8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         FloatingVFX;                                       // 0x06B0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      FloatingVFXComponent;                              // 0x06B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           SoundComponent;                                    // 0x06C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C8[0xF8];                                     // 0x06C8(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSphereComponentBeginOverlap(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnSphereComponentHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PossessedObjectComponent">();
	}
	static class UPossessedObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPossessedObjectComponent>();
	}
};
static_assert(alignof(UPossessedObjectComponent) == 0x000010, "Wrong alignment on UPossessedObjectComponent");
static_assert(sizeof(UPossessedObjectComponent) == 0x0007C0, "Wrong size on UPossessedObjectComponent");
static_assert(offsetof(UPossessedObjectComponent, FloatingStartSound) == 0x0006A0, "Member 'UPossessedObjectComponent::FloatingStartSound' has a wrong offset!");
static_assert(offsetof(UPossessedObjectComponent, FloatingStopSound) == 0x0006A8, "Member 'UPossessedObjectComponent::FloatingStopSound' has a wrong offset!");
static_assert(offsetof(UPossessedObjectComponent, FloatingVFX) == 0x0006B0, "Member 'UPossessedObjectComponent::FloatingVFX' has a wrong offset!");
static_assert(offsetof(UPossessedObjectComponent, FloatingVFXComponent) == 0x0006B8, "Member 'UPossessedObjectComponent::FloatingVFXComponent' has a wrong offset!");
static_assert(offsetof(UPossessedObjectComponent, SoundComponent) == 0x0006C0, "Member 'UPossessedObjectComponent::SoundComponent' has a wrong offset!");

// Class Stalker2.ModioGenericModEntry
// 0x0090 (0x0630 - 0x05A0)
class UModioGenericModEntry final : public UModioCommonGenericModEntry
{
public:
	class UModioGenericModEntryRating*            Rating;                                            // 0x05A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            ModAuthorText;                                     // 0x05A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            ByText;                                            // 0x05B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           ModIncompatiblePanel;                              // 0x05B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SelectedOperationTrackerImageColorTint;            // 0x05C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           UnselectedOperationTrackerImageColorTint;          // 0x05D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           UnselectedOperationTrackerImageColorTintError;     // 0x05E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SelectedByTextColor;                               // 0x05F0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           UnselectedByTextColor;                             // 0x0600(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SelectedModAuthorTextColor;                        // 0x0610(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           UnselectedModAuthorTextColor;                      // 0x0620(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioGenericModEntry">();
	}
	static class UModioGenericModEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioGenericModEntry>();
	}
};
static_assert(alignof(UModioGenericModEntry) == 0x000008, "Wrong alignment on UModioGenericModEntry");
static_assert(sizeof(UModioGenericModEntry) == 0x000630, "Wrong size on UModioGenericModEntry");
static_assert(offsetof(UModioGenericModEntry, Rating) == 0x0005A0, "Member 'UModioGenericModEntry::Rating' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntry, ModAuthorText) == 0x0005A8, "Member 'UModioGenericModEntry::ModAuthorText' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntry, ByText) == 0x0005B0, "Member 'UModioGenericModEntry::ByText' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntry, ModIncompatiblePanel) == 0x0005B8, "Member 'UModioGenericModEntry::ModIncompatiblePanel' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntry, SelectedOperationTrackerImageColorTint) == 0x0005C0, "Member 'UModioGenericModEntry::SelectedOperationTrackerImageColorTint' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntry, UnselectedOperationTrackerImageColorTint) == 0x0005D0, "Member 'UModioGenericModEntry::UnselectedOperationTrackerImageColorTint' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntry, UnselectedOperationTrackerImageColorTintError) == 0x0005E0, "Member 'UModioGenericModEntry::UnselectedOperationTrackerImageColorTintError' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntry, SelectedByTextColor) == 0x0005F0, "Member 'UModioGenericModEntry::SelectedByTextColor' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntry, UnselectedByTextColor) == 0x000600, "Member 'UModioGenericModEntry::UnselectedByTextColor' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntry, SelectedModAuthorTextColor) == 0x000610, "Member 'UModioGenericModEntry::SelectedModAuthorTextColor' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntry, UnselectedModAuthorTextColor) == 0x000620, "Member 'UModioGenericModEntry::UnselectedModAuthorTextColor' has a wrong offset!");

// Class Stalker2.ModioGenericModEntryOperationTrackerUserWidget
// 0x0018 (0x0500 - 0x04E8)
class UModioGenericModEntryOperationTrackerUserWidget final : public UModioCommonModOperationTrackerUserWidget
{
public:
	struct FLinearColor                           DefaultImageColorTint;                             // 0x04E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioGenericModEntryOperationTrackerUserWidget">();
	}
	static class UModioGenericModEntryOperationTrackerUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioGenericModEntryOperationTrackerUserWidget>();
	}
};
static_assert(alignof(UModioGenericModEntryOperationTrackerUserWidget) == 0x000008, "Wrong alignment on UModioGenericModEntryOperationTrackerUserWidget");
static_assert(sizeof(UModioGenericModEntryOperationTrackerUserWidget) == 0x000500, "Wrong size on UModioGenericModEntryOperationTrackerUserWidget");
static_assert(offsetof(UModioGenericModEntryOperationTrackerUserWidget, DefaultImageColorTint) == 0x0004E8, "Member 'UModioGenericModEntryOperationTrackerUserWidget::DefaultImageColorTint' has a wrong offset!");

// Class Stalker2.ModioGenericModEntryRating
// 0x0068 (0x0308 - 0x02A0)
class UModioGenericModEntryRating final : public UCommonUserWidget
{
public:
	class UPanelWidget*                           StarImagesPanel;                                   // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StarImageTexture;                                  // 0x02A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            StarActiveHoveredColor;                            // 0x02B0(0x0014)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            StarInactiveHoveredColor;                          // 0x02C4(0x0014)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            StarActiveUnhoveredColor;                          // 0x02D8(0x0014)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            StarInactiveUnhoveredColor;                        // 0x02EC(0x0014)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioGenericModEntryRating">();
	}
	static class UModioGenericModEntryRating* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioGenericModEntryRating>();
	}
};
static_assert(alignof(UModioGenericModEntryRating) == 0x000008, "Wrong alignment on UModioGenericModEntryRating");
static_assert(sizeof(UModioGenericModEntryRating) == 0x000308, "Wrong size on UModioGenericModEntryRating");
static_assert(offsetof(UModioGenericModEntryRating, StarImagesPanel) == 0x0002A0, "Member 'UModioGenericModEntryRating::StarImagesPanel' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntryRating, StarImageTexture) == 0x0002A8, "Member 'UModioGenericModEntryRating::StarImageTexture' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntryRating, StarActiveHoveredColor) == 0x0002B0, "Member 'UModioGenericModEntryRating::StarActiveHoveredColor' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntryRating, StarInactiveHoveredColor) == 0x0002C4, "Member 'UModioGenericModEntryRating::StarInactiveHoveredColor' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntryRating, StarActiveUnhoveredColor) == 0x0002D8, "Member 'UModioGenericModEntryRating::StarActiveUnhoveredColor' has a wrong offset!");
static_assert(offsetof(UModioGenericModEntryRating, StarInactiveUnhoveredColor) == 0x0002EC, "Member 'UModioGenericModEntryRating::StarInactiveUnhoveredColor' has a wrong offset!");

// Class Stalker2.RazerChromaSettings
// 0x03E8 (0x0420 - 0x0038)
class URazerChromaSettings final : public UDeveloperSettings
{
public:
	class FString                                 ContentBasePath;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnimationSuffix;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         SupportedDevices;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         OneTimeEventLifetime;                              // 0x0068(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRazerChromaEvent                      KillEvent;                                         // 0x0070(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      UseConsumableEvent;                                // 0x0088(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      AchievementUnlockedEvent;                          // 0x00A0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      QuestNotificationEvent;                            // 0x00B8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      SystemNotificationEvent;                           // 0x00D0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      PlayerNoticedEvent;                                // 0x00E8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      SaveGameEvent;                                     // 0x0100(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ArtifactPickupEvent;                               // 0x0118(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ArtifactVisualizedEvent;                           // 0x0130(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      DetectorPingEvent;                                 // 0x0148(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ChangeFireTypeEvent;                               // 0x0160(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ChangeAmmoTypeEvent;                               // 0x0178(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ChangeWeaponEvent;                                 // 0x0190(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ToggleUnderbarrelEvent;                            // 0x01A8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      LooseShootEvent;                                   // 0x01C0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FRazerChromaDamageSettings>     DamageEvents;                                      // 0x01D8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ActivePDAEvent;                                    // 0x01E8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ActiveInventoryEvent;                              // 0x0200(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ActiveLootingEvent;                                // 0x0218(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ActiveItemSelectorEvent;                           // 0x0230(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ActiveAttachSelectorEvent;                         // 0x0248(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ActivePauseEvent;                                  // 0x0260(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ActiveCreditsEvent;                                // 0x0278(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ActiveSleepEvent;                                  // 0x0290(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      OverweightEvent;                                   // 0x02A8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      SprintEvent;                                       // 0x02C0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      DeathEvent;                                        // 0x02D8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      IdleEvent;                                         // 0x02F0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      ReloadEvent;                                       // 0x0308(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      NoAmmoEvent;                                       // 0x0320(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      WeaponJammedEvent;                                 // 0x0338(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      AudioLogEvent;                                     // 0x0350(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRazerChromaEvent                      HoldBreathEvent;                                   // 0x0368(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EVitalType, struct FRazerChromaVitalsSettings> VitalsEvents;                                // 0x0380(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FRazerChromaEvent> CinematicEvents;                             // 0x03D0(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RazerChromaSettings">();
	}
	static class URazerChromaSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URazerChromaSettings>();
	}
};
static_assert(alignof(URazerChromaSettings) == 0x000008, "Wrong alignment on URazerChromaSettings");
static_assert(sizeof(URazerChromaSettings) == 0x000420, "Wrong size on URazerChromaSettings");
static_assert(offsetof(URazerChromaSettings, ContentBasePath) == 0x000038, "Member 'URazerChromaSettings::ContentBasePath' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, AnimationSuffix) == 0x000048, "Member 'URazerChromaSettings::AnimationSuffix' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, SupportedDevices) == 0x000058, "Member 'URazerChromaSettings::SupportedDevices' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, OneTimeEventLifetime) == 0x000068, "Member 'URazerChromaSettings::OneTimeEventLifetime' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, KillEvent) == 0x000070, "Member 'URazerChromaSettings::KillEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, UseConsumableEvent) == 0x000088, "Member 'URazerChromaSettings::UseConsumableEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, AchievementUnlockedEvent) == 0x0000A0, "Member 'URazerChromaSettings::AchievementUnlockedEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, QuestNotificationEvent) == 0x0000B8, "Member 'URazerChromaSettings::QuestNotificationEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, SystemNotificationEvent) == 0x0000D0, "Member 'URazerChromaSettings::SystemNotificationEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, PlayerNoticedEvent) == 0x0000E8, "Member 'URazerChromaSettings::PlayerNoticedEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, SaveGameEvent) == 0x000100, "Member 'URazerChromaSettings::SaveGameEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ArtifactPickupEvent) == 0x000118, "Member 'URazerChromaSettings::ArtifactPickupEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ArtifactVisualizedEvent) == 0x000130, "Member 'URazerChromaSettings::ArtifactVisualizedEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, DetectorPingEvent) == 0x000148, "Member 'URazerChromaSettings::DetectorPingEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ChangeFireTypeEvent) == 0x000160, "Member 'URazerChromaSettings::ChangeFireTypeEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ChangeAmmoTypeEvent) == 0x000178, "Member 'URazerChromaSettings::ChangeAmmoTypeEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ChangeWeaponEvent) == 0x000190, "Member 'URazerChromaSettings::ChangeWeaponEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ToggleUnderbarrelEvent) == 0x0001A8, "Member 'URazerChromaSettings::ToggleUnderbarrelEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, LooseShootEvent) == 0x0001C0, "Member 'URazerChromaSettings::LooseShootEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, DamageEvents) == 0x0001D8, "Member 'URazerChromaSettings::DamageEvents' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ActivePDAEvent) == 0x0001E8, "Member 'URazerChromaSettings::ActivePDAEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ActiveInventoryEvent) == 0x000200, "Member 'URazerChromaSettings::ActiveInventoryEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ActiveLootingEvent) == 0x000218, "Member 'URazerChromaSettings::ActiveLootingEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ActiveItemSelectorEvent) == 0x000230, "Member 'URazerChromaSettings::ActiveItemSelectorEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ActiveAttachSelectorEvent) == 0x000248, "Member 'URazerChromaSettings::ActiveAttachSelectorEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ActivePauseEvent) == 0x000260, "Member 'URazerChromaSettings::ActivePauseEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ActiveCreditsEvent) == 0x000278, "Member 'URazerChromaSettings::ActiveCreditsEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ActiveSleepEvent) == 0x000290, "Member 'URazerChromaSettings::ActiveSleepEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, OverweightEvent) == 0x0002A8, "Member 'URazerChromaSettings::OverweightEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, SprintEvent) == 0x0002C0, "Member 'URazerChromaSettings::SprintEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, DeathEvent) == 0x0002D8, "Member 'URazerChromaSettings::DeathEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, IdleEvent) == 0x0002F0, "Member 'URazerChromaSettings::IdleEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, ReloadEvent) == 0x000308, "Member 'URazerChromaSettings::ReloadEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, NoAmmoEvent) == 0x000320, "Member 'URazerChromaSettings::NoAmmoEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, WeaponJammedEvent) == 0x000338, "Member 'URazerChromaSettings::WeaponJammedEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, AudioLogEvent) == 0x000350, "Member 'URazerChromaSettings::AudioLogEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, HoldBreathEvent) == 0x000368, "Member 'URazerChromaSettings::HoldBreathEvent' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, VitalsEvents) == 0x000380, "Member 'URazerChromaSettings::VitalsEvents' has a wrong offset!");
static_assert(offsetof(URazerChromaSettings, CinematicEvents) == 0x0003D0, "Member 'URazerChromaSettings::CinematicEvents' has a wrong offset!");

// Class Stalker2.ModioLegendModel
// 0x0010 (0x0068 - 0x0058)
class UModioLegendModel final : public UMenuButtonModel
{
public:
	TArray<struct FShortcutData>                  SubViewShortcutsRightSide;                         // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioLegendModel">();
	}
	static class UModioLegendModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioLegendModel>();
	}
};
static_assert(alignof(UModioLegendModel) == 0x000008, "Wrong alignment on UModioLegendModel");
static_assert(sizeof(UModioLegendModel) == 0x000068, "Wrong size on UModioLegendModel");
static_assert(offsetof(UModioLegendModel, SubViewShortcutsRightSide) == 0x000058, "Member 'UModioLegendModel::SubViewShortcutsRightSide' has a wrong offset!");

// Class Stalker2.ModioLegendSubView
// 0x0218 (0x04C0 - 0x02A8)
class UModioLegendSubView final : public UMenuLegendSubView
{
public:
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UModioSearchField*                      SearchField;                                       // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FModioLegendData                       LegendData;                                        // 0x02C0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x1F0];                                    // 0x02D0(0x01F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioLegendSubView">();
	}
	static class UModioLegendSubView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioLegendSubView>();
	}
};
static_assert(alignof(UModioLegendSubView) == 0x000008, "Wrong alignment on UModioLegendSubView");
static_assert(sizeof(UModioLegendSubView) == 0x0004C0, "Wrong size on UModioLegendSubView");
static_assert(offsetof(UModioLegendSubView, SearchField) == 0x0002B8, "Member 'UModioLegendSubView::SearchField' has a wrong offset!");
static_assert(offsetof(UModioLegendSubView, LegendData) == 0x0002C0, "Member 'UModioLegendSubView::LegendData' has a wrong offset!");

// Class Stalker2.ModioModBrowser
// 0x00E8 (0x05E8 - 0x0500)
class UModioModBrowser final : public UModioCommonModBrowser
{
public:
	uint8                                         Pad_500[0x10];                                     // 0x0500(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UModioLegendSubView*                    LegendSubView;                                     // 0x0510(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UModioCategorySelectionBox*             CategorySelectionBox;                              // 0x0518(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UModioFirstFilterNavigationPanel*       FirstFilterNavigationPanel;                        // 0x0520(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UModioSecondFilterNavigationPanel*      SecondFilterNavigationPanel;                       // 0x0528(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeInBlurAnim;                                    // 0x0530(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_538[0xB0];                                     // 0x0538(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioModBrowser">();
	}
	static class UModioModBrowser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioModBrowser>();
	}
};
static_assert(alignof(UModioModBrowser) == 0x000008, "Wrong alignment on UModioModBrowser");
static_assert(sizeof(UModioModBrowser) == 0x0005E8, "Wrong size on UModioModBrowser");
static_assert(offsetof(UModioModBrowser, LegendSubView) == 0x000510, "Member 'UModioModBrowser::LegendSubView' has a wrong offset!");
static_assert(offsetof(UModioModBrowser, CategorySelectionBox) == 0x000518, "Member 'UModioModBrowser::CategorySelectionBox' has a wrong offset!");
static_assert(offsetof(UModioModBrowser, FirstFilterNavigationPanel) == 0x000520, "Member 'UModioModBrowser::FirstFilterNavigationPanel' has a wrong offset!");
static_assert(offsetof(UModioModBrowser, SecondFilterNavigationPanel) == 0x000528, "Member 'UModioModBrowser::SecondFilterNavigationPanel' has a wrong offset!");
static_assert(offsetof(UModioModBrowser, FadeInBlurAnim) == 0x000530, "Member 'UModioModBrowser::FadeInBlurAnim' has a wrong offset!");

// Class Stalker2.ModioModBrowserDummySubView
// 0x0008 (0x02D8 - 0x02D0)
class UModioModBrowserDummySubView final : public UMenuSubViewBase
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioModBrowserDummySubView">();
	}
	static class UModioModBrowserDummySubView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioModBrowserDummySubView>();
	}
};
static_assert(alignof(UModioModBrowserDummySubView) == 0x000008, "Wrong alignment on UModioModBrowserDummySubView");
static_assert(sizeof(UModioModBrowserDummySubView) == 0x0002D8, "Wrong size on UModioModBrowserDummySubView");

// Class Stalker2.ModioModBrowserLoadingIndicator
// 0x0030 (0x02A8 - 0x0278)
class UModioModBrowserLoadingIndicator final : public UUserWidget
{
public:
	class USizeBox*                               SpinnerImageSizeBox;                               // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SpinnerImage;                                      // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       SpinnerAnim;                                       // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpinnerAnimSpeed;                                  // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              size;                                              // 0x0298(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioModBrowserLoadingIndicator">();
	}
	static class UModioModBrowserLoadingIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioModBrowserLoadingIndicator>();
	}
};
static_assert(alignof(UModioModBrowserLoadingIndicator) == 0x000008, "Wrong alignment on UModioModBrowserLoadingIndicator");
static_assert(sizeof(UModioModBrowserLoadingIndicator) == 0x0002A8, "Wrong size on UModioModBrowserLoadingIndicator");
static_assert(offsetof(UModioModBrowserLoadingIndicator, SpinnerImageSizeBox) == 0x000278, "Member 'UModioModBrowserLoadingIndicator::SpinnerImageSizeBox' has a wrong offset!");
static_assert(offsetof(UModioModBrowserLoadingIndicator, SpinnerImage) == 0x000280, "Member 'UModioModBrowserLoadingIndicator::SpinnerImage' has a wrong offset!");
static_assert(offsetof(UModioModBrowserLoadingIndicator, SpinnerAnim) == 0x000288, "Member 'UModioModBrowserLoadingIndicator::SpinnerAnim' has a wrong offset!");
static_assert(offsetof(UModioModBrowserLoadingIndicator, SpinnerAnimSpeed) == 0x000290, "Member 'UModioModBrowserLoadingIndicator::SpinnerAnimSpeed' has a wrong offset!");
static_assert(offsetof(UModioModBrowserLoadingIndicator, size) == 0x000298, "Member 'UModioModBrowserLoadingIndicator::size' has a wrong offset!");

// Class Stalker2.ModioModDetailsView
// 0x00B8 (0x0698 - 0x05E0)
class UModioModDetailsView final : public UModioCommonModDetailsView
{
public:
	class UTextWidget*                            AuthorTextLabel;                                   // 0x05E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            AuthorText;                                        // 0x05E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            TagsTextLabel;                                     // 0x05F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            TagsText;                                          // 0x05F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            RatedTextLabel;                                    // 0x0600(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            RatedText;                                         // 0x0608(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            FileSizeTextLabel;                                 // 0x0610(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            ReleaseDateTextLabel;                              // 0x0618(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            LastUpdatedTextLabel;                              // 0x0620(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            ErrorMessageText;                                  // 0x0628(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         ErrorMessageHorizontalBox;                         // 0x0630(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UModioGenericModEntryRating*            Rating;                                            // 0x0638(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LikeImage;                                         // 0x0640(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DislikeImage;                                      // 0x0648(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           ModIncompatibleInfoPanel;                          // 0x0650(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            ActiveRatingImageTint;                             // 0x0658(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            InactiveRatingImageTint;                           // 0x066C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           OperationTrackerImageColorTintError;               // 0x0680(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_690[0x8];                                      // 0x0690(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioModDetailsView">();
	}
	static class UModioModDetailsView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioModDetailsView>();
	}
};
static_assert(alignof(UModioModDetailsView) == 0x000008, "Wrong alignment on UModioModDetailsView");
static_assert(sizeof(UModioModDetailsView) == 0x000698, "Wrong size on UModioModDetailsView");
static_assert(offsetof(UModioModDetailsView, AuthorTextLabel) == 0x0005E0, "Member 'UModioModDetailsView::AuthorTextLabel' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, AuthorText) == 0x0005E8, "Member 'UModioModDetailsView::AuthorText' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, TagsTextLabel) == 0x0005F0, "Member 'UModioModDetailsView::TagsTextLabel' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, TagsText) == 0x0005F8, "Member 'UModioModDetailsView::TagsText' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, RatedTextLabel) == 0x000600, "Member 'UModioModDetailsView::RatedTextLabel' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, RatedText) == 0x000608, "Member 'UModioModDetailsView::RatedText' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, FileSizeTextLabel) == 0x000610, "Member 'UModioModDetailsView::FileSizeTextLabel' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, ReleaseDateTextLabel) == 0x000618, "Member 'UModioModDetailsView::ReleaseDateTextLabel' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, LastUpdatedTextLabel) == 0x000620, "Member 'UModioModDetailsView::LastUpdatedTextLabel' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, ErrorMessageText) == 0x000628, "Member 'UModioModDetailsView::ErrorMessageText' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, ErrorMessageHorizontalBox) == 0x000630, "Member 'UModioModDetailsView::ErrorMessageHorizontalBox' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, Rating) == 0x000638, "Member 'UModioModDetailsView::Rating' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, LikeImage) == 0x000640, "Member 'UModioModDetailsView::LikeImage' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, DislikeImage) == 0x000648, "Member 'UModioModDetailsView::DislikeImage' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, ModIncompatibleInfoPanel) == 0x000650, "Member 'UModioModDetailsView::ModIncompatibleInfoPanel' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, ActiveRatingImageTint) == 0x000658, "Member 'UModioModDetailsView::ActiveRatingImageTint' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, InactiveRatingImageTint) == 0x00066C, "Member 'UModioModDetailsView::InactiveRatingImageTint' has a wrong offset!");
static_assert(offsetof(UModioModDetailsView, OperationTrackerImageColorTintError) == 0x000680, "Member 'UModioModDetailsView::OperationTrackerImageColorTintError' has a wrong offset!");

// Class Stalker2.ModioModListPageInfo
// 0x0018 (0x02B8 - 0x02A0)
class UModioModListPageInfo final : public UCommonUserWidget
{
public:
	class UTextWidget*                            PageInfoText;                                      // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintNavigationLeft;                                // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintNavigationRight;                               // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioModListPageInfo">();
	}
	static class UModioModListPageInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioModListPageInfo>();
	}
};
static_assert(alignof(UModioModListPageInfo) == 0x000008, "Wrong alignment on UModioModListPageInfo");
static_assert(sizeof(UModioModListPageInfo) == 0x0002B8, "Wrong size on UModioModListPageInfo");
static_assert(offsetof(UModioModListPageInfo, PageInfoText) == 0x0002A0, "Member 'UModioModListPageInfo::PageInfoText' has a wrong offset!");
static_assert(offsetof(UModioModListPageInfo, HintNavigationLeft) == 0x0002A8, "Member 'UModioModListPageInfo::HintNavigationLeft' has a wrong offset!");
static_assert(offsetof(UModioModListPageInfo, HintNavigationRight) == 0x0002B0, "Member 'UModioModListPageInfo::HintNavigationRight' has a wrong offset!");

// Class Stalker2.ModioModOperationTrackerUserWidget
// 0x0000 (0x04E8 - 0x04E8)
class UModioModOperationTrackerUserWidget final : public UModioCommonModOperationTrackerUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioModOperationTrackerUserWidget">();
	}
	static class UModioModOperationTrackerUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioModOperationTrackerUserWidget>();
	}
};
static_assert(alignof(UModioModOperationTrackerUserWidget) == 0x000008, "Wrong alignment on UModioModOperationTrackerUserWidget");
static_assert(sizeof(UModioModOperationTrackerUserWidget) == 0x0004E8, "Wrong size on UModioModOperationTrackerUserWidget");

// Class Stalker2.NotesPage
// 0x00E0 (0x0378 - 0x0298)
class UNotesPage final : public UPDAPage
{
public:
	class UPDANotesDetails*                       NoteDetails;                                       // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDANotesButton*                        ButtonAll;                                         // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDANotesButton*                        ButtonFlash;                                       // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDANotesButton*                        ButtonNotes;                                       // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDANotesButton*                        ButtonAudio;                                       // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDANotePanel*                          NotePanel;                                         // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                PlayAudioHint;                                     // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultOpenFilter;                                 // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotesSlotListScrollTime;                           // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ENoteType, struct FBackgroundSettings>   BackgroundSettings;                                // 0x02D8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x4];                                      // 0x0328(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ButtonActionLeft;                                  // 0x032C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ButtonActionRight;                                 // 0x0334(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMappingContext                               MappingContext;                                    // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x38];                                     // 0x0340(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClickButtonMenu(const class FName ButtonId);
	void ShowDetails(const bool bEmpty);
	void SlotTransitionUp();
	void UIPDANavigationButtonRelease();
	void UIPDANavigationDown();
	void UIPDANavigationLeft();
	void UIPDANavigatioNoteDown();
	void UIPDANavigatioNoteUp();
	void UIPDANavigationPlayAudio();
	void UIPDANavigationRight();
	void UIPDANavigationUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotesPage">();
	}
	static class UNotesPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotesPage>();
	}
};
static_assert(alignof(UNotesPage) == 0x000008, "Wrong alignment on UNotesPage");
static_assert(sizeof(UNotesPage) == 0x000378, "Wrong size on UNotesPage");
static_assert(offsetof(UNotesPage, NoteDetails) == 0x000298, "Member 'UNotesPage::NoteDetails' has a wrong offset!");
static_assert(offsetof(UNotesPage, ButtonAll) == 0x0002A0, "Member 'UNotesPage::ButtonAll' has a wrong offset!");
static_assert(offsetof(UNotesPage, ButtonFlash) == 0x0002A8, "Member 'UNotesPage::ButtonFlash' has a wrong offset!");
static_assert(offsetof(UNotesPage, ButtonNotes) == 0x0002B0, "Member 'UNotesPage::ButtonNotes' has a wrong offset!");
static_assert(offsetof(UNotesPage, ButtonAudio) == 0x0002B8, "Member 'UNotesPage::ButtonAudio' has a wrong offset!");
static_assert(offsetof(UNotesPage, NotePanel) == 0x0002C0, "Member 'UNotesPage::NotePanel' has a wrong offset!");
static_assert(offsetof(UNotesPage, PlayAudioHint) == 0x0002C8, "Member 'UNotesPage::PlayAudioHint' has a wrong offset!");
static_assert(offsetof(UNotesPage, DefaultOpenFilter) == 0x0002D0, "Member 'UNotesPage::DefaultOpenFilter' has a wrong offset!");
static_assert(offsetof(UNotesPage, NotesSlotListScrollTime) == 0x0002D4, "Member 'UNotesPage::NotesSlotListScrollTime' has a wrong offset!");
static_assert(offsetof(UNotesPage, BackgroundSettings) == 0x0002D8, "Member 'UNotesPage::BackgroundSettings' has a wrong offset!");
static_assert(offsetof(UNotesPage, ButtonActionLeft) == 0x00032C, "Member 'UNotesPage::ButtonActionLeft' has a wrong offset!");
static_assert(offsetof(UNotesPage, ButtonActionRight) == 0x000334, "Member 'UNotesPage::ButtonActionRight' has a wrong offset!");
static_assert(offsetof(UNotesPage, MappingContext) == 0x00033C, "Member 'UNotesPage::MappingContext' has a wrong offset!");

// Class Stalker2.ModioModTileView
// 0x0010 (0x0E60 - 0x0E50)
class UModioModTileView final : public UModioCommonModTileView
{
public:
	uint8                                         Pad_E50[0x10];                                     // 0x0E50(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioModTileView">();
	}
	static class UModioModTileView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioModTileView>();
	}
};
static_assert(alignof(UModioModTileView) == 0x000010, "Wrong alignment on UModioModTileView");
static_assert(sizeof(UModioModTileView) == 0x000E60, "Wrong size on UModioModTileView");

// Class Stalker2.ModioSearchField
// 0x0020 (0x02C0 - 0x02A0)
class UModioSearchField final : public UCommonUserWidget
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UHintInputController*                   SearchHint;                                        // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UModioCommonEditableTextBox*            SearchTextBox;                                     // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleOnTextCommitted(const class FText& Text, const ETextCommit CommitMethod);

	class FString GetSearchKeywords() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioSearchField">();
	}
	static class UModioSearchField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioSearchField>();
	}
};
static_assert(alignof(UModioSearchField) == 0x000008, "Wrong alignment on UModioSearchField");
static_assert(sizeof(UModioSearchField) == 0x0002C0, "Wrong size on UModioSearchField");
static_assert(offsetof(UModioSearchField, SearchHint) == 0x0002B0, "Member 'UModioSearchField::SearchHint' has a wrong offset!");
static_assert(offsetof(UModioSearchField, SearchTextBox) == 0x0002B8, "Member 'UModioSearchField::SearchTextBox' has a wrong offset!");

// Class Stalker2.ModioSearchResultsView
// 0x00A8 (0x0578 - 0x04D0)
class UModioSearchResultsView final : public UModioCommonSearchResultsView
{
public:
	uint8                                         Pad_4D0[0xA8];                                     // 0x04D0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioSearchResultsView">();
	}
	static class UModioSearchResultsView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioSearchResultsView>();
	}
};
static_assert(alignof(UModioSearchResultsView) == 0x000008, "Wrong alignment on UModioSearchResultsView");
static_assert(sizeof(UModioSearchResultsView) == 0x000578, "Wrong size on UModioSearchResultsView");

// Class Stalker2.ModioTermsOfUsePopup
// 0x0018 (0x0540 - 0x0528)
class UModioTermsOfUsePopup final : public UModioCommonTermsOfUseViewBase
{
public:
	class UHyperlinkButton*                       PrivacyPolicyButton;                               // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHyperlinkButton*                       TermsOfUseButton;                                  // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_538[0x8];                                      // 0x0538(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioTermsOfUsePopup">();
	}
	static class UModioTermsOfUsePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioTermsOfUsePopup>();
	}
};
static_assert(alignof(UModioTermsOfUsePopup) == 0x000008, "Wrong alignment on UModioTermsOfUsePopup");
static_assert(sizeof(UModioTermsOfUsePopup) == 0x000540, "Wrong size on UModioTermsOfUsePopup");
static_assert(offsetof(UModioTermsOfUsePopup, PrivacyPolicyButton) == 0x000528, "Member 'UModioTermsOfUsePopup::PrivacyPolicyButton' has a wrong offset!");
static_assert(offsetof(UModioTermsOfUsePopup, TermsOfUseButton) == 0x000530, "Member 'UModioTermsOfUsePopup::TermsOfUseButton' has a wrong offset!");

// Class Stalker2.ModioUserProfileWidget
// 0x0008 (0x0448 - 0x0440)
class UModioUserProfileWidget final : public UModioCommonUserProfileWidget
{
public:
	class UTextWidget*                            NickNameText;                                      // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioUserProfileWidget">();
	}
	static class UModioUserProfileWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioUserProfileWidget>();
	}
};
static_assert(alignof(UModioUserProfileWidget) == 0x000008, "Wrong alignment on UModioUserProfileWidget");
static_assert(sizeof(UModioUserProfileWidget) == 0x000448, "Wrong size on UModioUserProfileWidget");
static_assert(offsetof(UModioUserProfileWidget, NickNameText) == 0x000440, "Member 'UModioUserProfileWidget::NickNameText' has a wrong offset!");

// Class Stalker2.PDATutorialButton
// 0x0020 (0x0340 - 0x0320)
class UPDATutorialButton final : public UPDAButtonBase
{
public:
	class UImageWidget*                           ButtonIcon;                                        // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTutorialFilterSettings                FilterSettings;                                    // 0x0328(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ShouldEnableStailManager;                          // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDATutorialButton">();
	}
	static class UPDATutorialButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDATutorialButton>();
	}
};
static_assert(alignof(UPDATutorialButton) == 0x000008, "Wrong alignment on UPDATutorialButton");
static_assert(sizeof(UPDATutorialButton) == 0x000340, "Wrong size on UPDATutorialButton");
static_assert(offsetof(UPDATutorialButton, ButtonIcon) == 0x000320, "Member 'UPDATutorialButton::ButtonIcon' has a wrong offset!");
static_assert(offsetof(UPDATutorialButton, FilterSettings) == 0x000328, "Member 'UPDATutorialButton::FilterSettings' has a wrong offset!");
static_assert(offsetof(UPDATutorialButton, ShouldEnableStailManager) == 0x000330, "Member 'UPDATutorialButton::ShouldEnableStailManager' has a wrong offset!");
static_assert(offsetof(UPDATutorialButton, Icon) == 0x000338, "Member 'UPDATutorialButton::Icon' has a wrong offset!");

// Class Stalker2.MouthComponent
// 0x0298 (0x0338 - 0x00A0)
class UMouthComponent final : public UActorComponent
{
public:
	TSoftObjectPtr<class UCurveFloat>             StaminaCurve;                                      // 0x00A0(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UCurveFloat>             HealthCurve;                                       // 0x00D0(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UCurveFloat>             StaminaIntensityCurve;                             // 0x0100(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UCurveFloat>             HealthIntensityCurve;                              // 0x0130(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkRtpc>                 StaminaIntensityRTPC;                              // 0x0160(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkRtpc>                 HealthIntensityRTPC;                               // 0x0190(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           BreathInhale;                                      // 0x01C0(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           BreathExhale;                                      // 0x01F0(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkSwitchValue>          DefaultBreathType;                                 // 0x0220(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkSwitchValue>          HoldBreathBreathType;                              // 0x0250(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APC*                                    OwnerObj;                                          // 0x0280(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                StaminaRTPC;                                       // 0x0288(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                HealthRTPC;                                        // 0x0290(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            HealthBreathCurve;                                 // 0x0298(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            StaminaBreathCurve;                                // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            HealthBreathIntensityCurve;                        // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            StaminaBreathIntensityCurve;                       // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         DefaultBreathTypeSwitch;                           // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkSwitchValue*                         HoldBreathBreathTypeSwitch;                        // 0x02C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x70];                                     // 0x02C8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MouthComponent">();
	}
	static class UMouthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMouthComponent>();
	}
};
static_assert(alignof(UMouthComponent) == 0x000008, "Wrong alignment on UMouthComponent");
static_assert(sizeof(UMouthComponent) == 0x000338, "Wrong size on UMouthComponent");
static_assert(offsetof(UMouthComponent, StaminaCurve) == 0x0000A0, "Member 'UMouthComponent::StaminaCurve' has a wrong offset!");
static_assert(offsetof(UMouthComponent, HealthCurve) == 0x0000D0, "Member 'UMouthComponent::HealthCurve' has a wrong offset!");
static_assert(offsetof(UMouthComponent, StaminaIntensityCurve) == 0x000100, "Member 'UMouthComponent::StaminaIntensityCurve' has a wrong offset!");
static_assert(offsetof(UMouthComponent, HealthIntensityCurve) == 0x000130, "Member 'UMouthComponent::HealthIntensityCurve' has a wrong offset!");
static_assert(offsetof(UMouthComponent, StaminaIntensityRTPC) == 0x000160, "Member 'UMouthComponent::StaminaIntensityRTPC' has a wrong offset!");
static_assert(offsetof(UMouthComponent, HealthIntensityRTPC) == 0x000190, "Member 'UMouthComponent::HealthIntensityRTPC' has a wrong offset!");
static_assert(offsetof(UMouthComponent, BreathInhale) == 0x0001C0, "Member 'UMouthComponent::BreathInhale' has a wrong offset!");
static_assert(offsetof(UMouthComponent, BreathExhale) == 0x0001F0, "Member 'UMouthComponent::BreathExhale' has a wrong offset!");
static_assert(offsetof(UMouthComponent, DefaultBreathType) == 0x000220, "Member 'UMouthComponent::DefaultBreathType' has a wrong offset!");
static_assert(offsetof(UMouthComponent, HoldBreathBreathType) == 0x000250, "Member 'UMouthComponent::HoldBreathBreathType' has a wrong offset!");
static_assert(offsetof(UMouthComponent, OwnerObj) == 0x000280, "Member 'UMouthComponent::OwnerObj' has a wrong offset!");
static_assert(offsetof(UMouthComponent, StaminaRTPC) == 0x000288, "Member 'UMouthComponent::StaminaRTPC' has a wrong offset!");
static_assert(offsetof(UMouthComponent, HealthRTPC) == 0x000290, "Member 'UMouthComponent::HealthRTPC' has a wrong offset!");
static_assert(offsetof(UMouthComponent, HealthBreathCurve) == 0x000298, "Member 'UMouthComponent::HealthBreathCurve' has a wrong offset!");
static_assert(offsetof(UMouthComponent, StaminaBreathCurve) == 0x0002A0, "Member 'UMouthComponent::StaminaBreathCurve' has a wrong offset!");
static_assert(offsetof(UMouthComponent, HealthBreathIntensityCurve) == 0x0002A8, "Member 'UMouthComponent::HealthBreathIntensityCurve' has a wrong offset!");
static_assert(offsetof(UMouthComponent, StaminaBreathIntensityCurve) == 0x0002B0, "Member 'UMouthComponent::StaminaBreathIntensityCurve' has a wrong offset!");
static_assert(offsetof(UMouthComponent, DefaultBreathTypeSwitch) == 0x0002B8, "Member 'UMouthComponent::DefaultBreathTypeSwitch' has a wrong offset!");
static_assert(offsetof(UMouthComponent, HoldBreathBreathTypeSwitch) == 0x0002C0, "Member 'UMouthComponent::HoldBreathBreathTypeSwitch' has a wrong offset!");

// Class Stalker2.MoveIPU
// 0x0000 (0x0040 - 0x0040)
class UMoveIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveIPU">();
	}
	static class UMoveIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveIPU>();
	}
};
static_assert(alignof(UMoveIPU) == 0x000008, "Wrong alignment on UMoveIPU");
static_assert(sizeof(UMoveIPU) == 0x000040, "Wrong size on UMoveIPU");

// Class Stalker2.MovementComponentExt
// 0x01F0 (0x0290 - 0x00A0)
class UMovementComponentExt final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x98];                                      // 0x00A0(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrototypeSID                          CameraShakeEffectPrototype;                        // 0x0138(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxCameraShakeDistance;                            // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CameraShakeEffectCurve;                            // 0x0180(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x88];                                     // 0x0188(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRtpc*                                WaterDepthRtpc;                                    // 0x0210(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x20];                                     // 0x0218(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkSoundEvent;                                      // 0x0238(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x20];                                     // 0x0240(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkSwitchValue*                         AkSurfaceSwitch;                                   // 0x0260(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x20];                                     // 0x0268(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkSwitchValue*                         AkMovementBehaviourSwitch;                         // 0x0288(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementComponentExt">();
	}
	static class UMovementComponentExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementComponentExt>();
	}
};
static_assert(alignof(UMovementComponentExt) == 0x000008, "Wrong alignment on UMovementComponentExt");
static_assert(sizeof(UMovementComponentExt) == 0x000290, "Wrong size on UMovementComponentExt");
static_assert(offsetof(UMovementComponentExt, CameraShakeEffectPrototype) == 0x000138, "Member 'UMovementComponentExt::CameraShakeEffectPrototype' has a wrong offset!");
static_assert(offsetof(UMovementComponentExt, MaxCameraShakeDistance) == 0x000178, "Member 'UMovementComponentExt::MaxCameraShakeDistance' has a wrong offset!");
static_assert(offsetof(UMovementComponentExt, CameraShakeEffectCurve) == 0x000180, "Member 'UMovementComponentExt::CameraShakeEffectCurve' has a wrong offset!");
static_assert(offsetof(UMovementComponentExt, WaterDepthRtpc) == 0x000210, "Member 'UMovementComponentExt::WaterDepthRtpc' has a wrong offset!");
static_assert(offsetof(UMovementComponentExt, AkSoundEvent) == 0x000238, "Member 'UMovementComponentExt::AkSoundEvent' has a wrong offset!");
static_assert(offsetof(UMovementComponentExt, AkSurfaceSwitch) == 0x000260, "Member 'UMovementComponentExt::AkSurfaceSwitch' has a wrong offset!");
static_assert(offsetof(UMovementComponentExt, AkMovementBehaviourSwitch) == 0x000288, "Member 'UMovementComponentExt::AkMovementBehaviourSwitch' has a wrong offset!");

// Class Stalker2.MovementPathBuilderTestingActor
// 0x0150 (0x0508 - 0x03B8)
class AMovementPathBuilderTestingActor final : public ANavigationTestingActor
{
public:
	EPathBuilderPathType                          PathType;                                          // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxPathLength;                                     // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVelocityDebug>                 Velocities;                                        // 0x03C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint64                                        DesirableVelocitiesMask;                           // 0x03D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDetailedDrawing;                                  // 0x03D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowCircles;                                      // 0x03D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowKeyPoints;                                    // 0x03DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowPathSectors;                                  // 0x03DB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowPathFilteredSectors;                          // 0x03DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DD[0x3];                                      // 0x03DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CircleRadius;                                      // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationAngle;                                     // 0x03E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bClockwise;                                        // 0x03E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSmoothPath;                                       // 0x03E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCorridor;                                         // 0x03EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowNavmeshSegmentTest;                           // 0x03EB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDebugRestrictionSettings              RestrictionSettings;                               // 0x03F0(0x0020)(Edit, NativeAccessSpecifierPrivate)
	class AActor*                                 ExpensiveActor;                                    // 0x0410(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        DrawPathIndex;                                     // 0x0418(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowSampled;                                      // 0x041C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41D[0xE3];                                     // 0x041D(0x00E3)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdvancedPathfindingTime;                           // 0x0500(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_504[0x4];                                      // 0x0504(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementPathBuilderTestingActor">();
	}
	static class AMovementPathBuilderTestingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMovementPathBuilderTestingActor>();
	}
};
static_assert(alignof(AMovementPathBuilderTestingActor) == 0x000008, "Wrong alignment on AMovementPathBuilderTestingActor");
static_assert(sizeof(AMovementPathBuilderTestingActor) == 0x000508, "Wrong size on AMovementPathBuilderTestingActor");
static_assert(offsetof(AMovementPathBuilderTestingActor, PathType) == 0x0003B8, "Member 'AMovementPathBuilderTestingActor::PathType' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, MaxPathLength) == 0x0003BC, "Member 'AMovementPathBuilderTestingActor::MaxPathLength' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, Velocities) == 0x0003C0, "Member 'AMovementPathBuilderTestingActor::Velocities' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, DesirableVelocitiesMask) == 0x0003D0, "Member 'AMovementPathBuilderTestingActor::DesirableVelocitiesMask' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, bDetailedDrawing) == 0x0003D8, "Member 'AMovementPathBuilderTestingActor::bDetailedDrawing' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, bShowCircles) == 0x0003D9, "Member 'AMovementPathBuilderTestingActor::bShowCircles' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, bShowKeyPoints) == 0x0003DA, "Member 'AMovementPathBuilderTestingActor::bShowKeyPoints' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, bShowPathSectors) == 0x0003DB, "Member 'AMovementPathBuilderTestingActor::bShowPathSectors' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, bShowPathFilteredSectors) == 0x0003DC, "Member 'AMovementPathBuilderTestingActor::bShowPathFilteredSectors' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, CircleRadius) == 0x0003E0, "Member 'AMovementPathBuilderTestingActor::CircleRadius' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, RotationAngle) == 0x0003E4, "Member 'AMovementPathBuilderTestingActor::RotationAngle' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, bClockwise) == 0x0003E8, "Member 'AMovementPathBuilderTestingActor::bClockwise' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, bSmoothPath) == 0x0003E9, "Member 'AMovementPathBuilderTestingActor::bSmoothPath' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, bCorridor) == 0x0003EA, "Member 'AMovementPathBuilderTestingActor::bCorridor' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, bShowNavmeshSegmentTest) == 0x0003EB, "Member 'AMovementPathBuilderTestingActor::bShowNavmeshSegmentTest' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, RestrictionSettings) == 0x0003F0, "Member 'AMovementPathBuilderTestingActor::RestrictionSettings' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, ExpensiveActor) == 0x000410, "Member 'AMovementPathBuilderTestingActor::ExpensiveActor' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, DrawPathIndex) == 0x000418, "Member 'AMovementPathBuilderTestingActor::DrawPathIndex' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, bShowSampled) == 0x00041C, "Member 'AMovementPathBuilderTestingActor::bShowSampled' has a wrong offset!");
static_assert(offsetof(AMovementPathBuilderTestingActor, AdvancedPathfindingTime) == 0x000500, "Member 'AMovementPathBuilderTestingActor::AdvancedPathfindingTime' has a wrong offset!");

// Class Stalker2.MultiClickComponent
// 0x0030 (0x01F8 - 0x01C8)
class UMultiClickComponent final : public UInteractionComponent
{
public:
	struct FMultiClickInteractionData             InteractionData;                                   // 0x01C8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F0[0x8];                                      // 0x01F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiClickComponent">();
	}
	static class UMultiClickComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiClickComponent>();
	}
};
static_assert(alignof(UMultiClickComponent) == 0x000008, "Wrong alignment on UMultiClickComponent");
static_assert(sizeof(UMultiClickComponent) == 0x0001F8, "Wrong size on UMultiClickComponent");
static_assert(offsetof(UMultiClickComponent, InteractionData) == 0x0001C8, "Member 'UMultiClickComponent::InteractionData' has a wrong offset!");

// Class Stalker2.MultiClickIPU
// 0x0008 (0x0048 - 0x0040)
class UMultiClickIPU final : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiClickIPU">();
	}
	static class UMultiClickIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiClickIPU>();
	}
};
static_assert(alignof(UMultiClickIPU) == 0x000008, "Wrong alignment on UMultiClickIPU");
static_assert(sizeof(UMultiClickIPU) == 0x000048, "Wrong size on UMultiClickIPU");

// Class Stalker2.MusicManager
// 0x00B8 (0x0130 - 0x0078)
class UMusicManager final : public UBaseManager
{
public:
	class UAkAudioEvent*                          GameMusicEvent;                                    // 0x0078(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkRtpc*                                MusicVolumeSlider;                                 // 0x0080(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0xA8];                                      // 0x0088(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicManager">();
	}
	static class UMusicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusicManager>();
	}
};
static_assert(alignof(UMusicManager) == 0x000008, "Wrong alignment on UMusicManager");
static_assert(sizeof(UMusicManager) == 0x000130, "Wrong size on UMusicManager");
static_assert(offsetof(UMusicManager, GameMusicEvent) == 0x000078, "Member 'UMusicManager::GameMusicEvent' has a wrong offset!");
static_assert(offsetof(UMusicManager, MusicVolumeSlider) == 0x000080, "Member 'UMusicManager::MusicVolumeSlider' has a wrong offset!");

// Class Stalker2.PDAQuestRewardSlot
// 0x0008 (0x0280 - 0x0278)
class UPDAQuestRewardSlot final : public UWidgetBase
{
public:
	class UImage*                                 RewardIcon;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAQuestRewardSlot">();
	}
	static class UPDAQuestRewardSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAQuestRewardSlot>();
	}
};
static_assert(alignof(UPDAQuestRewardSlot) == 0x000008, "Wrong alignment on UPDAQuestRewardSlot");
static_assert(sizeof(UPDAQuestRewardSlot) == 0x000280, "Wrong size on UPDAQuestRewardSlot");
static_assert(offsetof(UPDAQuestRewardSlot, RewardIcon) == 0x000278, "Member 'UPDAQuestRewardSlot::RewardIcon' has a wrong offset!");

// Class Stalker2.MusicVolume
// 0x0040 (0x0318 - 0x02D8)
class AMusicVolume final : public AVolume
{
public:
	EMusicState                                   MusicState;                                        // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RegionSIDGlobalVariable;                           // 0x02DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAkSwitchValue>          AmbientStateMusicSwitch;                           // 0x02E8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicVolume">();
	}
	static class AMusicVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMusicVolume>();
	}
};
static_assert(alignof(AMusicVolume) == 0x000008, "Wrong alignment on AMusicVolume");
static_assert(sizeof(AMusicVolume) == 0x000318, "Wrong size on AMusicVolume");
static_assert(offsetof(AMusicVolume, MusicState) == 0x0002D8, "Member 'AMusicVolume::MusicState' has a wrong offset!");
static_assert(offsetof(AMusicVolume, RegionSIDGlobalVariable) == 0x0002DC, "Member 'AMusicVolume::RegionSIDGlobalVariable' has a wrong offset!");
static_assert(offsetof(AMusicVolume, AmbientStateMusicSwitch) == 0x0002E8, "Member 'AMusicVolume::AmbientStateMusicSwitch' has a wrong offset!");

// Class Stalker2.NameDistributor
// 0x0050 (0x00C8 - 0x0078)
class UNameDistributor final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x50];                                      // 0x0078(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NameDistributor">();
	}
	static class UNameDistributor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNameDistributor>();
	}
};
static_assert(alignof(UNameDistributor) == 0x000008, "Wrong alignment on UNameDistributor");
static_assert(sizeof(UNameDistributor) == 0x0000C8, "Wrong size on UNameDistributor");

// Class Stalker2.NavArea_RadiationFields
// 0x0000 (0x0048 - 0x0048)
class UNavArea_RadiationFields final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_RadiationFields">();
	}
	static class UNavArea_RadiationFields* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_RadiationFields>();
	}
};
static_assert(alignof(UNavArea_RadiationFields) == 0x000008, "Wrong alignment on UNavArea_RadiationFields");
static_assert(sizeof(UNavArea_RadiationFields) == 0x000048, "Wrong size on UNavArea_RadiationFields");

// Class Stalker2.NavigationPanel
// 0x00D8 (0x0350 - 0x0278)
class UNavigationPanel final : public UWidgetBase
{
public:
	class UPanelWidget*                           SlotContainer;                                     // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEnableClick;                                // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldSelectDefaultSlot;                          // 0x0281(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_282[0x2];                                      // 0x0282(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultSlotIndex;                                  // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldStopOthersInputs;                           // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBindClick;                                  // 0x0289(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A[0x2];                                      // 0x028A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MoveToNextSlotAction;                              // 0x028C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoveToPreviousSlotAction;                          // 0x0294(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreInputOnPause;                               // 0x029C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLoopMove;                                   // 0x029D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29E[0x2];                                      // 0x029E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PDASectionSwitch;                                  // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnChangeSelectSlot;                                // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 InIndexButton)> OnSlotClicked;                               // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHintInputController*                   PrevPageHint;                                      // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   NextPageHint;                                      // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x78];                                     // 0x02D8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClickMenuButton(const class FName InButtonId);
	void InitClickTransition(class FName ButtonId);
	void MoveSelectSlotToNextSlot();
	void MoveSelectSlotToPreviousSlot();
	void TransitSelectSlotBack();
	void TransitSelectSlotForward();
	void TransitSelectSlotRelease();
	void TransitToNextSlot();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationPanel">();
	}
	static class UNavigationPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationPanel>();
	}
};
static_assert(alignof(UNavigationPanel) == 0x000008, "Wrong alignment on UNavigationPanel");
static_assert(sizeof(UNavigationPanel) == 0x000350, "Wrong size on UNavigationPanel");
static_assert(offsetof(UNavigationPanel, SlotContainer) == 0x000278, "Member 'UNavigationPanel::SlotContainer' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, bShouldEnableClick) == 0x000280, "Member 'UNavigationPanel::bShouldEnableClick' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, bShouldSelectDefaultSlot) == 0x000281, "Member 'UNavigationPanel::bShouldSelectDefaultSlot' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, DefaultSlotIndex) == 0x000284, "Member 'UNavigationPanel::DefaultSlotIndex' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, bShouldStopOthersInputs) == 0x000288, "Member 'UNavigationPanel::bShouldStopOthersInputs' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, bShouldBindClick) == 0x000289, "Member 'UNavigationPanel::bShouldBindClick' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, MoveToNextSlotAction) == 0x00028C, "Member 'UNavigationPanel::MoveToNextSlotAction' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, MoveToPreviousSlotAction) == 0x000294, "Member 'UNavigationPanel::MoveToPreviousSlotAction' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, bIgnoreInputOnPause) == 0x00029C, "Member 'UNavigationPanel::bIgnoreInputOnPause' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, bShouldLoopMove) == 0x00029D, "Member 'UNavigationPanel::bShouldLoopMove' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, PDASectionSwitch) == 0x0002A0, "Member 'UNavigationPanel::PDASectionSwitch' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, OnChangeSelectSlot) == 0x0002A8, "Member 'UNavigationPanel::OnChangeSelectSlot' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, OnSlotClicked) == 0x0002B8, "Member 'UNavigationPanel::OnSlotClicked' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, PrevPageHint) == 0x0002C8, "Member 'UNavigationPanel::PrevPageHint' has a wrong offset!");
static_assert(offsetof(UNavigationPanel, NextPageHint) == 0x0002D0, "Member 'UNavigationPanel::NextPageHint' has a wrong offset!");

// Class Stalker2.NiagaraDataInterfaceAkEvent
// 0x0010 (0x0048 - 0x0038)
class UNiagaraDataInterfaceAkEvent final : public UNiagaraDataInterface
{
public:
	class UAkAudioEvent*                          Event;                                             // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopEvent;                                         // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraDataInterfaceAkEvent">();
	}
	static class UNiagaraDataInterfaceAkEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraDataInterfaceAkEvent>();
	}
};
static_assert(alignof(UNiagaraDataInterfaceAkEvent) == 0x000008, "Wrong alignment on UNiagaraDataInterfaceAkEvent");
static_assert(sizeof(UNiagaraDataInterfaceAkEvent) == 0x000048, "Wrong size on UNiagaraDataInterfaceAkEvent");
static_assert(offsetof(UNiagaraDataInterfaceAkEvent, Event) == 0x000038, "Member 'UNiagaraDataInterfaceAkEvent::Event' has a wrong offset!");
static_assert(offsetof(UNiagaraDataInterfaceAkEvent, StopEvent) == 0x000040, "Member 'UNiagaraDataInterfaceAkEvent::StopEvent' has a wrong offset!");

// Class Stalker2.NiagaraTerrainOffsetProvider
// 0x0008 (0x0108 - 0x0100)
class UNiagaraTerrainOffsetProvider final : public UNiagaraParameterProvider
{
public:
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraTerrainOffsetProvider">();
	}
	static class UNiagaraTerrainOffsetProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraTerrainOffsetProvider>();
	}
};
static_assert(alignof(UNiagaraTerrainOffsetProvider) == 0x000008, "Wrong alignment on UNiagaraTerrainOffsetProvider");
static_assert(sizeof(UNiagaraTerrainOffsetProvider) == 0x000108, "Wrong size on UNiagaraTerrainOffsetProvider");

// Class Stalker2.NoteMouseIPU
// 0x0000 (0x0040 - 0x0040)
class UNoteMouseIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NoteMouseIPU">();
	}
	static class UNoteMouseIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNoteMouseIPU>();
	}
};
static_assert(alignof(UNoteMouseIPU) == 0x000008, "Wrong alignment on UNoteMouseIPU");
static_assert(sizeof(UNoteMouseIPU) == 0x000040, "Wrong size on UNoteMouseIPU");

// Class Stalker2.NotesIPU
// 0x0000 (0x0040 - 0x0040)
class UNotesIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotesIPU">();
	}
	static class UNotesIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotesIPU>();
	}
};
static_assert(alignof(UNotesIPU) == 0x000008, "Wrong alignment on UNotesIPU");
static_assert(sizeof(UNotesIPU) == 0x000040, "Wrong size on UNotesIPU");

// Class Stalker2.NPCComponent
// 0x0008 (0x0200 - 0x01F8)
class UNPCComponent final : public USingleClickComponent
{
public:
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCComponent">();
	}
	static class UNPCComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCComponent>();
	}
};
static_assert(alignof(UNPCComponent) == 0x000008, "Wrong alignment on UNPCComponent");
static_assert(sizeof(UNPCComponent) == 0x000200, "Wrong size on UNPCComponent");

// Class Stalker2.ObjBase
// 0x0000 (0x0000 - 0x0000)
class IObjBase final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjBase">();
	}
	static class IObjBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<IObjBase>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IObjBase) == 0x000001, "Wrong alignment on IObjBase");
static_assert(sizeof(IObjBase) == 0x000001, "Wrong size on IObjBase");

// Class Stalker2.PauseMenuSubView
// 0x0000 (0x02D0 - 0x02D0)
class UPauseMenuSubView final : public UMenuSubViewBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseMenuSubView">();
	}
	static class UPauseMenuSubView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPauseMenuSubView>();
	}
};
static_assert(alignof(UPauseMenuSubView) == 0x000008, "Wrong alignment on UPauseMenuSubView");
static_assert(sizeof(UPauseMenuSubView) == 0x0002D0, "Wrong size on UPauseMenuSubView");

// Class Stalker2.PDAArrowButton
// 0x0020 (0x02E0 - 0x02C0)
class UPDAArrowButton final : public UButtonBase
{
public:
	class UImage*                                 ArrowIcon;                                         // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ClickAnimation;                                    // 0x02C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClickAnimSpeed;                                    // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShoudBlockClickAnim;                              // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShoudHoverOpacity;                                // 0x02D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D6[0x2];                                      // 0x02D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoverOpacity;                                      // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnHoverOpacity;                                    // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAArrowButton">();
	}
	static class UPDAArrowButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAArrowButton>();
	}
};
static_assert(alignof(UPDAArrowButton) == 0x000008, "Wrong alignment on UPDAArrowButton");
static_assert(sizeof(UPDAArrowButton) == 0x0002E0, "Wrong size on UPDAArrowButton");
static_assert(offsetof(UPDAArrowButton, ArrowIcon) == 0x0002C0, "Member 'UPDAArrowButton::ArrowIcon' has a wrong offset!");
static_assert(offsetof(UPDAArrowButton, ClickAnimation) == 0x0002C8, "Member 'UPDAArrowButton::ClickAnimation' has a wrong offset!");
static_assert(offsetof(UPDAArrowButton, ClickAnimSpeed) == 0x0002D0, "Member 'UPDAArrowButton::ClickAnimSpeed' has a wrong offset!");
static_assert(offsetof(UPDAArrowButton, bShoudBlockClickAnim) == 0x0002D4, "Member 'UPDAArrowButton::bShoudBlockClickAnim' has a wrong offset!");
static_assert(offsetof(UPDAArrowButton, bShoudHoverOpacity) == 0x0002D5, "Member 'UPDAArrowButton::bShoudHoverOpacity' has a wrong offset!");
static_assert(offsetof(UPDAArrowButton, HoverOpacity) == 0x0002D8, "Member 'UPDAArrowButton::HoverOpacity' has a wrong offset!");
static_assert(offsetof(UPDAArrowButton, UnHoverOpacity) == 0x0002DC, "Member 'UPDAArrowButton::UnHoverOpacity' has a wrong offset!");

// Class Stalker2.PDAQuestDetails
// 0x0268 (0x04E0 - 0x0278)
class UPDAQuestDetails final : public UChildViewBase
{
public:
	class UVerticalBox*                           QuestInfoBox;                                      // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 QuestLogo;                                         // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            TaskText;                                          // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            DescriptionText;                                   // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            RewardText;                                        // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           RewardBlock;                                       // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDAQuestDescription*                   DescriptionQuest;                                  // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            QuestNameText;                                     // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            QuestStatusText;                                   // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         RewardContainer;                                   // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDAQuestTaskContainer*                 TaskContainer;                                     // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EJournalState, struct FQuestStatusSettings> StatusSettings;                                 // 0x02D0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             DefaultQuestIcon;                                  // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EJournalState, struct FTaskStatusSettings> TaskStatusSettings;                              // 0x0328(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FQuestStageSelectSettings              SelectedStatusSettings;                            // 0x0378(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuestStageSelectSettings              UnSelectedStatusSettings;                          // 0x03A0(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EQuestRewardType, class UTexture2D*>     RewardSettings;                                    // 0x03C8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   StyleTextIdMain;                                   // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StyleTextIdSecondary;                              // 0x0420(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StyleIdTaitlMain;                                  // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StyleIdTaitlSecondary;                             // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StyleTextIdDefault;                                // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TaskListSizeMax;                                   // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TaskLocalizationSID;                               // 0x0448(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DescriptionLocalizationSID;                        // 0x0458(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RewardLocalizationSID;                             // 0x0468(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsHovered, EDetailsElementType ElementType)> OnHoveredDetailsElement; // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnUpdateQuestList;                                 // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStageSlotHover;                                  // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x38];                                     // 0x04A8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StageClick(class UPDAQuestTaskSlot* InSlot);
	void UpdateDescriptionHover(bool bIsHovered);
	void UpdateStageHover(bool bIsStageHovered);
	void UpdateStageSlotHover();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAQuestDetails">();
	}
	static class UPDAQuestDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAQuestDetails>();
	}
};
static_assert(alignof(UPDAQuestDetails) == 0x000008, "Wrong alignment on UPDAQuestDetails");
static_assert(sizeof(UPDAQuestDetails) == 0x0004E0, "Wrong size on UPDAQuestDetails");
static_assert(offsetof(UPDAQuestDetails, QuestInfoBox) == 0x000278, "Member 'UPDAQuestDetails::QuestInfoBox' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, QuestLogo) == 0x000280, "Member 'UPDAQuestDetails::QuestLogo' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, TaskText) == 0x000288, "Member 'UPDAQuestDetails::TaskText' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, DescriptionText) == 0x000290, "Member 'UPDAQuestDetails::DescriptionText' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, RewardText) == 0x000298, "Member 'UPDAQuestDetails::RewardText' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, RewardBlock) == 0x0002A0, "Member 'UPDAQuestDetails::RewardBlock' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, DescriptionQuest) == 0x0002A8, "Member 'UPDAQuestDetails::DescriptionQuest' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, QuestNameText) == 0x0002B0, "Member 'UPDAQuestDetails::QuestNameText' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, QuestStatusText) == 0x0002B8, "Member 'UPDAQuestDetails::QuestStatusText' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, RewardContainer) == 0x0002C0, "Member 'UPDAQuestDetails::RewardContainer' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, TaskContainer) == 0x0002C8, "Member 'UPDAQuestDetails::TaskContainer' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, StatusSettings) == 0x0002D0, "Member 'UPDAQuestDetails::StatusSettings' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, DefaultQuestIcon) == 0x000320, "Member 'UPDAQuestDetails::DefaultQuestIcon' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, TaskStatusSettings) == 0x000328, "Member 'UPDAQuestDetails::TaskStatusSettings' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, SelectedStatusSettings) == 0x000378, "Member 'UPDAQuestDetails::SelectedStatusSettings' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, UnSelectedStatusSettings) == 0x0003A0, "Member 'UPDAQuestDetails::UnSelectedStatusSettings' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, RewardSettings) == 0x0003C8, "Member 'UPDAQuestDetails::RewardSettings' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, StyleTextIdMain) == 0x000418, "Member 'UPDAQuestDetails::StyleTextIdMain' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, StyleTextIdSecondary) == 0x000420, "Member 'UPDAQuestDetails::StyleTextIdSecondary' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, StyleIdTaitlMain) == 0x000428, "Member 'UPDAQuestDetails::StyleIdTaitlMain' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, StyleIdTaitlSecondary) == 0x000430, "Member 'UPDAQuestDetails::StyleIdTaitlSecondary' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, StyleTextIdDefault) == 0x000438, "Member 'UPDAQuestDetails::StyleTextIdDefault' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, TaskListSizeMax) == 0x000440, "Member 'UPDAQuestDetails::TaskListSizeMax' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, TaskLocalizationSID) == 0x000448, "Member 'UPDAQuestDetails::TaskLocalizationSID' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, DescriptionLocalizationSID) == 0x000458, "Member 'UPDAQuestDetails::DescriptionLocalizationSID' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, RewardLocalizationSID) == 0x000468, "Member 'UPDAQuestDetails::RewardLocalizationSID' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, OnHoveredDetailsElement) == 0x000478, "Member 'UPDAQuestDetails::OnHoveredDetailsElement' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, OnUpdateQuestList) == 0x000488, "Member 'UPDAQuestDetails::OnUpdateQuestList' has a wrong offset!");
static_assert(offsetof(UPDAQuestDetails, OnStageSlotHover) == 0x000498, "Member 'UPDAQuestDetails::OnStageSlotHover' has a wrong offset!");

// Class Stalker2.PDAQuestSlot
// 0x0070 (0x0370 - 0x0300)
class UPDAQuestSlot final : public UPDASlotBase
{
public:
	class UTextWidget*                            RegionText;                                        // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            PlayText;                                          // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 OutSlotIndex)> OnQuestSlotClick;                             // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 OutSlotIndex)> OnChangeSlotSelectQuest;                      // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         SelectStageHoverOpacity;                           // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HintLocalizationSIDEnable;                         // 0x0338(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HintLocalizationSIDDisabled;                       // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_358[0x18];                                     // 0x0358(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAQuestSlot">();
	}
	static class UPDAQuestSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAQuestSlot>();
	}
};
static_assert(alignof(UPDAQuestSlot) == 0x000008, "Wrong alignment on UPDAQuestSlot");
static_assert(sizeof(UPDAQuestSlot) == 0x000370, "Wrong size on UPDAQuestSlot");
static_assert(offsetof(UPDAQuestSlot, RegionText) == 0x000300, "Member 'UPDAQuestSlot::RegionText' has a wrong offset!");
static_assert(offsetof(UPDAQuestSlot, PlayText) == 0x000308, "Member 'UPDAQuestSlot::PlayText' has a wrong offset!");
static_assert(offsetof(UPDAQuestSlot, OnQuestSlotClick) == 0x000310, "Member 'UPDAQuestSlot::OnQuestSlotClick' has a wrong offset!");
static_assert(offsetof(UPDAQuestSlot, OnChangeSlotSelectQuest) == 0x000320, "Member 'UPDAQuestSlot::OnChangeSlotSelectQuest' has a wrong offset!");
static_assert(offsetof(UPDAQuestSlot, SelectStageHoverOpacity) == 0x000330, "Member 'UPDAQuestSlot::SelectStageHoverOpacity' has a wrong offset!");
static_assert(offsetof(UPDAQuestSlot, HintLocalizationSIDEnable) == 0x000338, "Member 'UPDAQuestSlot::HintLocalizationSIDEnable' has a wrong offset!");
static_assert(offsetof(UPDAQuestSlot, HintLocalizationSIDDisabled) == 0x000348, "Member 'UPDAQuestSlot::HintLocalizationSIDDisabled' has a wrong offset!");

// Class Stalker2.PDATextBorder
// 0x0028 (0x02A0 - 0x0278)
class UPDATextBorder final : public UWidgetBase
{
public:
	class UImage*                                 LeftBorder;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 RightBorder;                                       // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            BorderText;                                        // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SizeLine;                                          // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDATextBorder">();
	}
	static class UPDATextBorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDATextBorder>();
	}
};
static_assert(alignof(UPDATextBorder) == 0x000008, "Wrong alignment on UPDATextBorder");
static_assert(sizeof(UPDATextBorder) == 0x0002A0, "Wrong size on UPDATextBorder");
static_assert(offsetof(UPDATextBorder, LeftBorder) == 0x000278, "Member 'UPDATextBorder::LeftBorder' has a wrong offset!");
static_assert(offsetof(UPDATextBorder, RightBorder) == 0x000280, "Member 'UPDATextBorder::RightBorder' has a wrong offset!");
static_assert(offsetof(UPDATextBorder, BorderText) == 0x000288, "Member 'UPDATextBorder::BorderText' has a wrong offset!");
static_assert(offsetof(UPDATextBorder, SizeLine) == 0x000290, "Member 'UPDATextBorder::SizeLine' has a wrong offset!");

// Class Stalker2.PDATutorialPanel
// 0x0090 (0x0370 - 0x02E0)
class UPDATutorialPanel final : public UPDASlotPanelBase
{
public:
	class USizeBox*                               AbsentTutorialSizeBox;                             // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x28];                                     // 0x02E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPDATutorialCategory, struct FSlotFilterSettings> SlotFilterSettings;                       // 0x0310(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDATutorialPanel">();
	}
	static class UPDATutorialPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDATutorialPanel>();
	}
};
static_assert(alignof(UPDATutorialPanel) == 0x000008, "Wrong alignment on UPDATutorialPanel");
static_assert(sizeof(UPDATutorialPanel) == 0x000370, "Wrong size on UPDATutorialPanel");
static_assert(offsetof(UPDATutorialPanel, AbsentTutorialSizeBox) == 0x0002E0, "Member 'UPDATutorialPanel::AbsentTutorialSizeBox' has a wrong offset!");
static_assert(offsetof(UPDATutorialPanel, SlotFilterSettings) == 0x000310, "Member 'UPDATutorialPanel::SlotFilterSettings' has a wrong offset!");

// Class Stalker2.PDAUpgradePanel
// 0x0070 (0x0350 - 0x02E0)
class UPDAUpgradePanel final : public UPDASlotPanelBase
{
public:
	class UUpgradeMenuWidget*                     UpgradeMenu;                                       // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPDATextBorder*                         EquipedBorder;                                     // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDATextBorder*                         UnEquipedBorder;                                   // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EquipedBorderLocalizationSID;                      // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UnEquipedBorderLocalizationSID;                    // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UpgradeColor;                                      // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_330[0x20];                                     // 0x0330(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAUpgradePanel">();
	}
	static class UPDAUpgradePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAUpgradePanel>();
	}
};
static_assert(alignof(UPDAUpgradePanel) == 0x000008, "Wrong alignment on UPDAUpgradePanel");
static_assert(sizeof(UPDAUpgradePanel) == 0x000350, "Wrong size on UPDAUpgradePanel");
static_assert(offsetof(UPDAUpgradePanel, UpgradeMenu) == 0x0002E0, "Member 'UPDAUpgradePanel::UpgradeMenu' has a wrong offset!");
static_assert(offsetof(UPDAUpgradePanel, EquipedBorder) == 0x0002F0, "Member 'UPDAUpgradePanel::EquipedBorder' has a wrong offset!");
static_assert(offsetof(UPDAUpgradePanel, UnEquipedBorder) == 0x0002F8, "Member 'UPDAUpgradePanel::UnEquipedBorder' has a wrong offset!");
static_assert(offsetof(UPDAUpgradePanel, EquipedBorderLocalizationSID) == 0x000300, "Member 'UPDAUpgradePanel::EquipedBorderLocalizationSID' has a wrong offset!");
static_assert(offsetof(UPDAUpgradePanel, UnEquipedBorderLocalizationSID) == 0x000310, "Member 'UPDAUpgradePanel::UnEquipedBorderLocalizationSID' has a wrong offset!");
static_assert(offsetof(UPDAUpgradePanel, UpgradeColor) == 0x000320, "Member 'UPDAUpgradePanel::UpgradeColor' has a wrong offset!");

// Class Stalker2.PDAUpgradesButton
// 0x0018 (0x0338 - 0x0320)
class UPDAUpgradesButton final : public UPDAButtonBase
{
public:
	class UImageWidget*                           ButtonIcon;                                        // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUpgradeFilterSettings                 FilterSettings;                                    // 0x0328(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ShouldEnableStailManager;                          // 0x032A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32B[0x5];                                      // 0x032B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAUpgradesButton">();
	}
	static class UPDAUpgradesButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAUpgradesButton>();
	}
};
static_assert(alignof(UPDAUpgradesButton) == 0x000008, "Wrong alignment on UPDAUpgradesButton");
static_assert(sizeof(UPDAUpgradesButton) == 0x000338, "Wrong size on UPDAUpgradesButton");
static_assert(offsetof(UPDAUpgradesButton, ButtonIcon) == 0x000320, "Member 'UPDAUpgradesButton::ButtonIcon' has a wrong offset!");
static_assert(offsetof(UPDAUpgradesButton, FilterSettings) == 0x000328, "Member 'UPDAUpgradesButton::FilterSettings' has a wrong offset!");
static_assert(offsetof(UPDAUpgradesButton, ShouldEnableStailManager) == 0x00032A, "Member 'UPDAUpgradesButton::ShouldEnableStailManager' has a wrong offset!");
static_assert(offsetof(UPDAUpgradesButton, Icon) == 0x000330, "Member 'UPDAUpgradesButton::Icon' has a wrong offset!");

// Class Stalker2.PDAUpgradesSlot
// 0x0078 (0x0378 - 0x0300)
class UPDAUpgradesSlot final : public UPDASlotBase
{
public:
	TMulticastInlineDelegate<void(int32 OutSlotIndex)> OnUpgradeSlotClick;                           // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTextWidget*                            RegionText;                                        // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImageWidget*                           ButtonIcon;                                        // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultIconColor;                                  // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StyleIdWeapon;                                     // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StyleArmor;                                        // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StyleHelmet;                                       // 0x0340(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StyleDetector;                                     // 0x0348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x28];                                     // 0x0350(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PDAUpgradesSlot">();
	}
	static class UPDAUpgradesSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPDAUpgradesSlot>();
	}
};
static_assert(alignof(UPDAUpgradesSlot) == 0x000008, "Wrong alignment on UPDAUpgradesSlot");
static_assert(sizeof(UPDAUpgradesSlot) == 0x000378, "Wrong size on UPDAUpgradesSlot");
static_assert(offsetof(UPDAUpgradesSlot, OnUpgradeSlotClick) == 0x000300, "Member 'UPDAUpgradesSlot::OnUpgradeSlotClick' has a wrong offset!");
static_assert(offsetof(UPDAUpgradesSlot, RegionText) == 0x000310, "Member 'UPDAUpgradesSlot::RegionText' has a wrong offset!");
static_assert(offsetof(UPDAUpgradesSlot, ButtonIcon) == 0x000318, "Member 'UPDAUpgradesSlot::ButtonIcon' has a wrong offset!");
static_assert(offsetof(UPDAUpgradesSlot, DefaultIconColor) == 0x000320, "Member 'UPDAUpgradesSlot::DefaultIconColor' has a wrong offset!");
static_assert(offsetof(UPDAUpgradesSlot, StyleIdWeapon) == 0x000330, "Member 'UPDAUpgradesSlot::StyleIdWeapon' has a wrong offset!");
static_assert(offsetof(UPDAUpgradesSlot, StyleArmor) == 0x000338, "Member 'UPDAUpgradesSlot::StyleArmor' has a wrong offset!");
static_assert(offsetof(UPDAUpgradesSlot, StyleHelmet) == 0x000340, "Member 'UPDAUpgradesSlot::StyleHelmet' has a wrong offset!");
static_assert(offsetof(UPDAUpgradesSlot, StyleDetector) == 0x000348, "Member 'UPDAUpgradesSlot::StyleDetector' has a wrong offset!");

// Class Stalker2.PhysicsInteractionComponent
// 0x0070 (0x0110 - 0x00A0)
class UPhysicsInteractionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLoadDefaultPrototypeOnBeginPlay;                  // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateWaterContactController;                     // 0x00A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateWetnessComponent;                           // 0x00AA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x1D];                                      // 0x00AB(0x001D)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         WaterContactNiagaraSystemVFX;                      // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PhysicsInteractionPrototypeSID;                    // 0x00D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x28];                                      // 0x00E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsInteractionComponent">();
	}
	static class UPhysicsInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsInteractionComponent>();
	}
};
static_assert(alignof(UPhysicsInteractionComponent) == 0x000008, "Wrong alignment on UPhysicsInteractionComponent");
static_assert(sizeof(UPhysicsInteractionComponent) == 0x000110, "Wrong size on UPhysicsInteractionComponent");
static_assert(offsetof(UPhysicsInteractionComponent, bLoadDefaultPrototypeOnBeginPlay) == 0x0000A8, "Member 'UPhysicsInteractionComponent::bLoadDefaultPrototypeOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UPhysicsInteractionComponent, bCreateWaterContactController) == 0x0000A9, "Member 'UPhysicsInteractionComponent::bCreateWaterContactController' has a wrong offset!");
static_assert(offsetof(UPhysicsInteractionComponent, bCreateWetnessComponent) == 0x0000AA, "Member 'UPhysicsInteractionComponent::bCreateWetnessComponent' has a wrong offset!");
static_assert(offsetof(UPhysicsInteractionComponent, WaterContactNiagaraSystemVFX) == 0x0000C8, "Member 'UPhysicsInteractionComponent::WaterContactNiagaraSystemVFX' has a wrong offset!");
static_assert(offsetof(UPhysicsInteractionComponent, PhysicsInteractionPrototypeSID) == 0x0000D8, "Member 'UPhysicsInteractionComponent::PhysicsInteractionPrototypeSID' has a wrong offset!");

// Class Stalker2.PlatformSwitcher
// 0x0008 (0x01F8 - 0x01F0)
class UPlatformSwitcher final : public UPlatformSwitcherBase
{
public:
	bool                                          bChildrenView;                                     // 0x01F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformSwitcher">();
	}
	static class UPlatformSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformSwitcher>();
	}
};
static_assert(alignof(UPlatformSwitcher) == 0x000008, "Wrong alignment on UPlatformSwitcher");
static_assert(sizeof(UPlatformSwitcher) == 0x0001F8, "Wrong size on UPlatformSwitcher");
static_assert(offsetof(UPlatformSwitcher, bChildrenView) == 0x0001F0, "Member 'UPlatformSwitcher::bChildrenView' has a wrong offset!");

// Class Stalker2.PlayerContextualAction
// 0x0020 (0x02B8 - 0x0298)
class APlayerContextualAction final : public AActor
{
public:
	class USingleClickComponent*                  SingleClickComponent;                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraPitchMin;                                    // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraPitchMax;                                    // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraYawMin;                                      // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraYawMax;                                      // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionEnd();
	void ActionStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerContextualAction">();
	}
	static class APlayerContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerContextualAction>();
	}
};
static_assert(alignof(APlayerContextualAction) == 0x000008, "Wrong alignment on APlayerContextualAction");
static_assert(sizeof(APlayerContextualAction) == 0x0002B8, "Wrong size on APlayerContextualAction");
static_assert(offsetof(APlayerContextualAction, SingleClickComponent) == 0x000298, "Member 'APlayerContextualAction::SingleClickComponent' has a wrong offset!");
static_assert(offsetof(APlayerContextualAction, CameraPitchMin) == 0x0002A0, "Member 'APlayerContextualAction::CameraPitchMin' has a wrong offset!");
static_assert(offsetof(APlayerContextualAction, CameraPitchMax) == 0x0002A4, "Member 'APlayerContextualAction::CameraPitchMax' has a wrong offset!");
static_assert(offsetof(APlayerContextualAction, CameraYawMin) == 0x0002A8, "Member 'APlayerContextualAction::CameraYawMin' has a wrong offset!");
static_assert(offsetof(APlayerContextualAction, CameraYawMax) == 0x0002AC, "Member 'APlayerContextualAction::CameraYawMax' has a wrong offset!");

// Class Stalker2.PlayerEnhancedInputComponent
// 0x0008 (0x0168 - 0x0160)
class UPlayerEnhancedInputComponent final : public UEnhancedInputComponent
{
public:
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerEnhancedInputComponent">();
	}
	static class UPlayerEnhancedInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerEnhancedInputComponent>();
	}
};
static_assert(alignof(UPlayerEnhancedInputComponent) == 0x000008, "Wrong alignment on UPlayerEnhancedInputComponent");
static_assert(sizeof(UPlayerEnhancedInputComponent) == 0x000168, "Wrong size on UPlayerEnhancedInputComponent");

// Class Stalker2.PlayerInteractionComponent
// 0x0040 (0x00E0 - 0x00A0)
class UPlayerInteractionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x40];                                      // 0x00A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInteractionComponent">();
	}
	static class UPlayerInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInteractionComponent>();
	}
};
static_assert(alignof(UPlayerInteractionComponent) == 0x000008, "Wrong alignment on UPlayerInteractionComponent");
static_assert(sizeof(UPlayerInteractionComponent) == 0x0000E0, "Wrong size on UPlayerInteractionComponent");

// Class Stalker2.PlayerLaserSightComponent
// 0x0010 (0x0150 - 0x0140)
class UPlayerLaserSightComponent final : public ULaserSightComponent
{
public:
	class APC*                                    PlayerOwner;                                       // 0x0140(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLaserSightComponent">();
	}
	static class UPlayerLaserSightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerLaserSightComponent>();
	}
};
static_assert(alignof(UPlayerLaserSightComponent) == 0x000010, "Wrong alignment on UPlayerLaserSightComponent");
static_assert(sizeof(UPlayerLaserSightComponent) == 0x000150, "Wrong size on UPlayerLaserSightComponent");
static_assert(offsetof(UPlayerLaserSightComponent, PlayerOwner) == 0x000140, "Member 'UPlayerLaserSightComponent::PlayerOwner' has a wrong offset!");

// Class Stalker2.PlayerKnifeAnimCollection
// 0x02E8 (0x0310 - 0x0028)
class UPlayerKnifeAnimCollection final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerKnifeInternalAnimations         InternalAnimations;                                // 0x0030(0x00B0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FPlayerWeaponAnimations                WeaponAnimations;                                  // 0x00E0(0x0230)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerKnifeAnimCollection">();
	}
	static class UPlayerKnifeAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerKnifeAnimCollection>();
	}
};
static_assert(alignof(UPlayerKnifeAnimCollection) == 0x000008, "Wrong alignment on UPlayerKnifeAnimCollection");
static_assert(sizeof(UPlayerKnifeAnimCollection) == 0x000310, "Wrong size on UPlayerKnifeAnimCollection");
static_assert(offsetof(UPlayerKnifeAnimCollection, InternalAnimations) == 0x000030, "Member 'UPlayerKnifeAnimCollection::InternalAnimations' has a wrong offset!");
static_assert(offsetof(UPlayerKnifeAnimCollection, WeaponAnimations) == 0x0000E0, "Member 'UPlayerKnifeAnimCollection::WeaponAnimations' has a wrong offset!");

// Class Stalker2.PlayVideoWidget
// 0x0068 (0x02E0 - 0x0278)
class UPlayVideoWidget final : public UUserWidget
{
public:
	uint8                                         Pad_278[0x38];                                     // 0x0278(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class USkipHintView*                          SkipHint;                                          // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            SubtitleTextWidget;                                // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBinkMediaPlayer*                       BinkMediaPlayer;                                   // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x18];                                     // 0x02C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndVideo();
	void SkipVideo();

	float GetVideoDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayVideoWidget">();
	}
	static class UPlayVideoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayVideoWidget>();
	}
};
static_assert(alignof(UPlayVideoWidget) == 0x000008, "Wrong alignment on UPlayVideoWidget");
static_assert(sizeof(UPlayVideoWidget) == 0x0002E0, "Wrong size on UPlayVideoWidget");
static_assert(offsetof(UPlayVideoWidget, SkipHint) == 0x0002B0, "Member 'UPlayVideoWidget::SkipHint' has a wrong offset!");
static_assert(offsetof(UPlayVideoWidget, SubtitleTextWidget) == 0x0002B8, "Member 'UPlayVideoWidget::SubtitleTextWidget' has a wrong offset!");
static_assert(offsetof(UPlayVideoWidget, BinkMediaPlayer) == 0x0002C0, "Member 'UPlayVideoWidget::BinkMediaPlayer' has a wrong offset!");

// Class Stalker2.PoppyField
// 0x0000 (0x02A8 - 0x02A8)
class APoppyField final : public AUIDActor_PoppyFieldAnomaly
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoppyField">();
	}
	static class APoppyField* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoppyField>();
	}
};
static_assert(alignof(APoppyField) == 0x000008, "Wrong alignment on APoppyField");
static_assert(sizeof(APoppyField) == 0x0002A8, "Wrong size on APoppyField");

// Class Stalker2.PopupView
// 0x0030 (0x02F8 - 0x02C8)
class UPopupView : public UViewBaseExtended
{
public:
	class UOverlay*                               PopupOverlay;                                      // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PopupViewZOrder;                                   // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPopupBase*                             ActivePopupWidget;                                 // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cancel();
	void Confirm();
	void Discard();
	void Retry();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupView">();
	}
	static class UPopupView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupView>();
	}
};
static_assert(alignof(UPopupView) == 0x000008, "Wrong alignment on UPopupView");
static_assert(sizeof(UPopupView) == 0x0002F8, "Wrong size on UPopupView");
static_assert(offsetof(UPopupView, PopupOverlay) == 0x0002C8, "Member 'UPopupView::PopupOverlay' has a wrong offset!");
static_assert(offsetof(UPopupView, PopupViewZOrder) == 0x0002D0, "Member 'UPopupView::PopupViewZOrder' has a wrong offset!");
static_assert(offsetof(UPopupView, ActivePopupWidget) == 0x0002D8, "Member 'UPopupView::ActivePopupWidget' has a wrong offset!");

// Class Stalker2.PossessedShootingWeaponComponent
// 0x0130 (0x01D0 - 0x00A0)
class UPossessedShootingWeaponComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0xF0];                                      // 0x00A0(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           WeaponAkComponent;                                 // 0x0190(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          FireAudioEvent;                                    // 0x0198(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          FireEventLoop;                                     // 0x01A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          CurrentFireEvent;                                  // 0x01A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          BreakAudioEvent;                                   // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFXSystemComponent*                     WeaponMuzzleComponent;                             // 0x01B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PossessedShootingWeaponComponent">();
	}
	static class UPossessedShootingWeaponComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPossessedShootingWeaponComponent>();
	}
};
static_assert(alignof(UPossessedShootingWeaponComponent) == 0x000008, "Wrong alignment on UPossessedShootingWeaponComponent");
static_assert(sizeof(UPossessedShootingWeaponComponent) == 0x0001D0, "Wrong size on UPossessedShootingWeaponComponent");
static_assert(offsetof(UPossessedShootingWeaponComponent, WeaponAkComponent) == 0x000190, "Member 'UPossessedShootingWeaponComponent::WeaponAkComponent' has a wrong offset!");
static_assert(offsetof(UPossessedShootingWeaponComponent, FireAudioEvent) == 0x000198, "Member 'UPossessedShootingWeaponComponent::FireAudioEvent' has a wrong offset!");
static_assert(offsetof(UPossessedShootingWeaponComponent, FireEventLoop) == 0x0001A0, "Member 'UPossessedShootingWeaponComponent::FireEventLoop' has a wrong offset!");
static_assert(offsetof(UPossessedShootingWeaponComponent, CurrentFireEvent) == 0x0001A8, "Member 'UPossessedShootingWeaponComponent::CurrentFireEvent' has a wrong offset!");
static_assert(offsetof(UPossessedShootingWeaponComponent, BreakAudioEvent) == 0x0001B0, "Member 'UPossessedShootingWeaponComponent::BreakAudioEvent' has a wrong offset!");
static_assert(offsetof(UPossessedShootingWeaponComponent, WeaponMuzzleComponent) == 0x0001B8, "Member 'UPossessedShootingWeaponComponent::WeaponMuzzleComponent' has a wrong offset!");

// Class Stalker2.PresentationSubsystem
// 0x0070 (0x00A0 - 0x0030)
class UPresentationSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GoToMainMenu();
	void ResumeGame();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentationSubsystem">();
	}
	static class UPresentationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresentationSubsystem>();
	}
};
static_assert(alignof(UPresentationSubsystem) == 0x000008, "Wrong alignment on UPresentationSubsystem");
static_assert(sizeof(UPresentationSubsystem) == 0x0000A0, "Wrong size on UPresentationSubsystem");

// Class Stalker2.Projectile
// 0x0258 (0x04F0 - 0x0298)
class alignas(0x10) AProjectile final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       CollisionComp;                                     // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x218];                                    // 0x02A8(0x0218)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          FlybySound;                                        // 0x04C0(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x28];                                     // 0x04C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlap(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile">();
	}
	static class AProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile>();
	}
};
static_assert(alignof(AProjectile) == 0x000010, "Wrong alignment on AProjectile");
static_assert(sizeof(AProjectile) == 0x0004F0, "Wrong size on AProjectile");
static_assert(offsetof(AProjectile, CollisionComp) == 0x0002A0, "Member 'AProjectile::CollisionComp' has a wrong offset!");
static_assert(offsetof(AProjectile, FlybySound) == 0x0004C0, "Member 'AProjectile::FlybySound' has a wrong offset!");

// Class Stalker2.ProximityGroupManager
// 0x0038 (0x00E0 - 0x00A8)
class UProximityGroupManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x38];                                      // 0x00A8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProximityGroupManager">();
	}
	static class UProximityGroupManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProximityGroupManager>();
	}
};
static_assert(alignof(UProximityGroupManager) == 0x000008, "Wrong alignment on UProximityGroupManager");
static_assert(sizeof(UProximityGroupManager) == 0x0000E0, "Wrong size on UProximityGroupManager");

// Class Stalker2.PSYControllerAnomaly
// 0x0000 (0x03B0 - 0x03B0)
class APSYControllerAnomaly final : public APSYAnomaly
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PSYControllerAnomaly">();
	}
	static class APSYControllerAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<APSYControllerAnomaly>();
	}
};
static_assert(alignof(APSYControllerAnomaly) == 0x000008, "Wrong alignment on APSYControllerAnomaly");
static_assert(sizeof(APSYControllerAnomaly) == 0x0003B0, "Wrong size on APSYControllerAnomaly");

// Class Stalker2.PsyPhantomComponent
// 0x00A0 (0x0140 - 0x00A0)
class UPsyPhantomComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondsToAppear;                                   // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondsToDisappear;                                // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PhatnomHeightChangeSpeedPerSecond;                 // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MaterialAlphaParameterName;                        // 0x00B4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VFXAlphaParameterName;                             // 0x00BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         ParticleOnSpawn;                                   // 0x00C8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         PhantomHitVFX;                                     // 0x00D0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         ParticleOnDeath;                                   // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         TrailsParticle;                                    // 0x00E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TrailsParticleScale;                               // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                RTPC;                                              // 0x0100(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          SpawnSound;                                        // 0x0108(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          DeathSound;                                        // 0x0110(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDissolveMaterials;                             // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnTimestamp;                                    // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeathTimestamp;                                    // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemComponent*                     TrailsFX;                                          // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       DynamicMaterials;                                  // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsyPhantomComponent">();
	}
	static class UPsyPhantomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsyPhantomComponent>();
	}
};
static_assert(alignof(UPsyPhantomComponent) == 0x000008, "Wrong alignment on UPsyPhantomComponent");
static_assert(sizeof(UPsyPhantomComponent) == 0x000140, "Wrong size on UPsyPhantomComponent");
static_assert(offsetof(UPsyPhantomComponent, SecondsToAppear) == 0x0000A8, "Member 'UPsyPhantomComponent::SecondsToAppear' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, SecondsToDisappear) == 0x0000AC, "Member 'UPsyPhantomComponent::SecondsToDisappear' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, PhatnomHeightChangeSpeedPerSecond) == 0x0000B0, "Member 'UPsyPhantomComponent::PhatnomHeightChangeSpeedPerSecond' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, MaterialAlphaParameterName) == 0x0000B4, "Member 'UPsyPhantomComponent::MaterialAlphaParameterName' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, VFXAlphaParameterName) == 0x0000BC, "Member 'UPsyPhantomComponent::VFXAlphaParameterName' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, ParticleOnSpawn) == 0x0000C8, "Member 'UPsyPhantomComponent::ParticleOnSpawn' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, PhantomHitVFX) == 0x0000D0, "Member 'UPsyPhantomComponent::PhantomHitVFX' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, ParticleOnDeath) == 0x0000D8, "Member 'UPsyPhantomComponent::ParticleOnDeath' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, TrailsParticle) == 0x0000E0, "Member 'UPsyPhantomComponent::TrailsParticle' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, TrailsParticleScale) == 0x0000E8, "Member 'UPsyPhantomComponent::TrailsParticleScale' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, RTPC) == 0x000100, "Member 'UPsyPhantomComponent::RTPC' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, SpawnSound) == 0x000108, "Member 'UPsyPhantomComponent::SpawnSound' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, DeathSound) == 0x000110, "Member 'UPsyPhantomComponent::DeathSound' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, bUseDissolveMaterials) == 0x000118, "Member 'UPsyPhantomComponent::bUseDissolveMaterials' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, SpawnTimestamp) == 0x00011C, "Member 'UPsyPhantomComponent::SpawnTimestamp' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, DeathTimestamp) == 0x000120, "Member 'UPsyPhantomComponent::DeathTimestamp' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, TrailsFX) == 0x000128, "Member 'UPsyPhantomComponent::TrailsFX' has a wrong offset!");
static_assert(offsetof(UPsyPhantomComponent, DynamicMaterials) == 0x000130, "Member 'UPsyPhantomComponent::DynamicMaterials' has a wrong offset!");

// Class Stalker2.QuestMenuWidget
// 0x0050 (0x02C8 - 0x0278)
class UQuestMenuWidget final : public UWidgetBase
{
public:
	class UTaskIcon*                              QuestIcon;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            QuestName;                                         // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            QuestLocation;                                     // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           QuestTaskList;                                     // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTaskMenuWidget>            TaskMenuWidgetClass;                               // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                TaskSlotPadding;                                   // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   MainQuestStyleID;                                  // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SecondaryQuestStyleID;                             // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TaskCap;                                           // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestMenuWidget">();
	}
	static class UQuestMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestMenuWidget>();
	}
};
static_assert(alignof(UQuestMenuWidget) == 0x000008, "Wrong alignment on UQuestMenuWidget");
static_assert(sizeof(UQuestMenuWidget) == 0x0002C8, "Wrong size on UQuestMenuWidget");
static_assert(offsetof(UQuestMenuWidget, QuestIcon) == 0x000278, "Member 'UQuestMenuWidget::QuestIcon' has a wrong offset!");
static_assert(offsetof(UQuestMenuWidget, QuestName) == 0x000280, "Member 'UQuestMenuWidget::QuestName' has a wrong offset!");
static_assert(offsetof(UQuestMenuWidget, QuestLocation) == 0x000288, "Member 'UQuestMenuWidget::QuestLocation' has a wrong offset!");
static_assert(offsetof(UQuestMenuWidget, QuestTaskList) == 0x000290, "Member 'UQuestMenuWidget::QuestTaskList' has a wrong offset!");
static_assert(offsetof(UQuestMenuWidget, TaskMenuWidgetClass) == 0x000298, "Member 'UQuestMenuWidget::TaskMenuWidgetClass' has a wrong offset!");
static_assert(offsetof(UQuestMenuWidget, TaskSlotPadding) == 0x0002A0, "Member 'UQuestMenuWidget::TaskSlotPadding' has a wrong offset!");
static_assert(offsetof(UQuestMenuWidget, MainQuestStyleID) == 0x0002B0, "Member 'UQuestMenuWidget::MainQuestStyleID' has a wrong offset!");
static_assert(offsetof(UQuestMenuWidget, SecondaryQuestStyleID) == 0x0002B8, "Member 'UQuestMenuWidget::SecondaryQuestStyleID' has a wrong offset!");
static_assert(offsetof(UQuestMenuWidget, TaskCap) == 0x0002C0, "Member 'UQuestMenuWidget::TaskCap' has a wrong offset!");

// Class Stalker2.QuestNotificationDataAsset
// 0x01A8 (0x01D8 - 0x0030)
class UQuestNotificationDataAsset final : public UDataAsset
{
public:
	bool                                          bEnableDelayBetweenNotifications;                  // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerRate;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayAfterShow;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextureParameterName;                              // 0x003C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoldTimeThreshold;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BackgroundImageTexture;                            // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             LeftLineTexture;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DotsLeftTexture;                                   // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DotsRightTexture;                                  // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                TaskClass;                                         // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTaskNumber;                                     // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTitleLen;                                       // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AppendedEndText;                                   // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EQuestState, struct FLinearColor>        ColorsPerState;                                    // 0x0088(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           HeaderColorMainQuest;                              // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HeaderColorSideQuest;                              // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                TaskPadding;                                       // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             TrackQuestIcon;                                    // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             UntrackQuestIcon;                                  // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NotNecessaryStyleId;                               // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StyleTextIdMain;                                   // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NotNecessaryLocalizationSID;                       // 0x0130(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDelayForHide;                               // 0x0140(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QuestNotificationLifeTime;                         // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuestNotificationLifeTimeTimerRate;                // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OpenJournalString;                                 // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TrackQuestString;                                  // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UnTrackQuestString;                                // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QuestUpdatedL10n;                                  // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QuestFailedL10n;                                   // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QuestFinishedL10n;                                 // 0x01A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QuestCancelledL10n;                                // 0x01B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewQuestL10n;                                      // 0x01C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingTimeAfterHintAction;                      // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestNotificationDataAsset">();
	}
	static class UQuestNotificationDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestNotificationDataAsset>();
	}
};
static_assert(alignof(UQuestNotificationDataAsset) == 0x000008, "Wrong alignment on UQuestNotificationDataAsset");
static_assert(sizeof(UQuestNotificationDataAsset) == 0x0001D8, "Wrong size on UQuestNotificationDataAsset");
static_assert(offsetof(UQuestNotificationDataAsset, bEnableDelayBetweenNotifications) == 0x000030, "Member 'UQuestNotificationDataAsset::bEnableDelayBetweenNotifications' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, TimerRate) == 0x000034, "Member 'UQuestNotificationDataAsset::TimerRate' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, DelayAfterShow) == 0x000038, "Member 'UQuestNotificationDataAsset::DelayAfterShow' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, TextureParameterName) == 0x00003C, "Member 'UQuestNotificationDataAsset::TextureParameterName' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, HoldTimeThreshold) == 0x000044, "Member 'UQuestNotificationDataAsset::HoldTimeThreshold' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, BackgroundImageTexture) == 0x000048, "Member 'UQuestNotificationDataAsset::BackgroundImageTexture' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, LeftLineTexture) == 0x000050, "Member 'UQuestNotificationDataAsset::LeftLineTexture' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, DotsLeftTexture) == 0x000058, "Member 'UQuestNotificationDataAsset::DotsLeftTexture' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, DotsRightTexture) == 0x000060, "Member 'UQuestNotificationDataAsset::DotsRightTexture' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, TaskClass) == 0x000068, "Member 'UQuestNotificationDataAsset::TaskClass' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, MaxTaskNumber) == 0x000070, "Member 'UQuestNotificationDataAsset::MaxTaskNumber' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, MaxTitleLen) == 0x000074, "Member 'UQuestNotificationDataAsset::MaxTitleLen' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, AppendedEndText) == 0x000078, "Member 'UQuestNotificationDataAsset::AppendedEndText' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, ColorsPerState) == 0x000088, "Member 'UQuestNotificationDataAsset::ColorsPerState' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, HeaderColorMainQuest) == 0x0000D8, "Member 'UQuestNotificationDataAsset::HeaderColorMainQuest' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, HeaderColorSideQuest) == 0x0000E8, "Member 'UQuestNotificationDataAsset::HeaderColorSideQuest' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, TaskPadding) == 0x0000F8, "Member 'UQuestNotificationDataAsset::TaskPadding' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, TrackQuestIcon) == 0x000108, "Member 'UQuestNotificationDataAsset::TrackQuestIcon' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, UntrackQuestIcon) == 0x000110, "Member 'UQuestNotificationDataAsset::UntrackQuestIcon' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, NotNecessaryStyleId) == 0x000118, "Member 'UQuestNotificationDataAsset::NotNecessaryStyleId' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, StyleTextIdMain) == 0x000128, "Member 'UQuestNotificationDataAsset::StyleTextIdMain' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, NotNecessaryLocalizationSID) == 0x000130, "Member 'UQuestNotificationDataAsset::NotNecessaryLocalizationSID' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, bEnableDelayForHide) == 0x000140, "Member 'UQuestNotificationDataAsset::bEnableDelayForHide' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, QuestNotificationLifeTime) == 0x000144, "Member 'UQuestNotificationDataAsset::QuestNotificationLifeTime' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, QuestNotificationLifeTimeTimerRate) == 0x000148, "Member 'UQuestNotificationDataAsset::QuestNotificationLifeTimeTimerRate' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, OpenJournalString) == 0x000150, "Member 'UQuestNotificationDataAsset::OpenJournalString' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, TrackQuestString) == 0x000160, "Member 'UQuestNotificationDataAsset::TrackQuestString' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, UnTrackQuestString) == 0x000170, "Member 'UQuestNotificationDataAsset::UnTrackQuestString' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, QuestUpdatedL10n) == 0x000180, "Member 'UQuestNotificationDataAsset::QuestUpdatedL10n' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, QuestFailedL10n) == 0x000190, "Member 'UQuestNotificationDataAsset::QuestFailedL10n' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, QuestFinishedL10n) == 0x0001A0, "Member 'UQuestNotificationDataAsset::QuestFinishedL10n' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, QuestCancelledL10n) == 0x0001B0, "Member 'UQuestNotificationDataAsset::QuestCancelledL10n' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, NewQuestL10n) == 0x0001C0, "Member 'UQuestNotificationDataAsset::NewQuestL10n' has a wrong offset!");
static_assert(offsetof(UQuestNotificationDataAsset, RemainingTimeAfterHintAction) == 0x0001D0, "Member 'UQuestNotificationDataAsset::RemainingTimeAfterHintAction' has a wrong offset!");

// Class Stalker2.QuickLoadIPU
// 0x0000 (0x0040 - 0x0040)
class UQuickLoadIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickLoadIPU">();
	}
	static class UQuickLoadIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickLoadIPU>();
	}
};
static_assert(alignof(UQuickLoadIPU) == 0x000008, "Wrong alignment on UQuickLoadIPU");
static_assert(sizeof(UQuickLoadIPU) == 0x000040, "Wrong size on UQuickLoadIPU");

// Class Stalker2.QuickSaveManager
// 0x0008 (0x0080 - 0x0078)
class UQuickSaveManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickSaveManager">();
	}
	static class UQuickSaveManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickSaveManager>();
	}
};
static_assert(alignof(UQuickSaveManager) == 0x000008, "Wrong alignment on UQuickSaveManager");
static_assert(sizeof(UQuickSaveManager) == 0x000080, "Wrong size on UQuickSaveManager");

// Class Stalker2.QuickSlot2IPU
// 0x0000 (0x0048 - 0x0048)
class UQuickSlot2IPU final : public UQuickSlotBaseIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickSlot2IPU">();
	}
	static class UQuickSlot2IPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickSlot2IPU>();
	}
};
static_assert(alignof(UQuickSlot2IPU) == 0x000008, "Wrong alignment on UQuickSlot2IPU");
static_assert(sizeof(UQuickSlot2IPU) == 0x000048, "Wrong size on UQuickSlot2IPU");

// Class Stalker2.QuickSlot4IPU
// 0x0000 (0x0048 - 0x0048)
class UQuickSlot4IPU final : public UQuickSlotBaseIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickSlot4IPU">();
	}
	static class UQuickSlot4IPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickSlot4IPU>();
	}
};
static_assert(alignof(UQuickSlot4IPU) == 0x000008, "Wrong alignment on UQuickSlot4IPU");
static_assert(sizeof(UQuickSlot4IPU) == 0x000048, "Wrong size on UQuickSlot4IPU");

// Class Stalker2.RatSwarm
// 0x0060 (0x0BB0 - 0x0B50)
class ARatSwarm final : public AAgent
{
public:
	class UAkRtpc*                                RatUnitsAmount;                                    // 0x0B48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                LocomotionUnitsAmount;                             // 0x0B50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                DiedUnitsAmount;                                   // 0x0B58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          RatVoice;                                          // 0x0B60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          RatLocomotionVoice;                                // 0x0B68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         AlertState;                                        // 0x0B70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         AttackState;                                       // 0x0B78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         EatingState;                                       // 0x0B80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         IdleState;                                         // 0x0B88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAISwarmComponent*                      RatsMeshComponent;                                 // 0x0B90(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B98[0x18];                                     // 0x0B98(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RatSwarm">();
	}
	static class ARatSwarm* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARatSwarm>();
	}
};
static_assert(alignof(ARatSwarm) == 0x000010, "Wrong alignment on ARatSwarm");
static_assert(sizeof(ARatSwarm) == 0x000BB0, "Wrong size on ARatSwarm");
static_assert(offsetof(ARatSwarm, RatUnitsAmount) == 0x000B48, "Member 'ARatSwarm::RatUnitsAmount' has a wrong offset!");
static_assert(offsetof(ARatSwarm, LocomotionUnitsAmount) == 0x000B50, "Member 'ARatSwarm::LocomotionUnitsAmount' has a wrong offset!");
static_assert(offsetof(ARatSwarm, DiedUnitsAmount) == 0x000B58, "Member 'ARatSwarm::DiedUnitsAmount' has a wrong offset!");
static_assert(offsetof(ARatSwarm, RatVoice) == 0x000B60, "Member 'ARatSwarm::RatVoice' has a wrong offset!");
static_assert(offsetof(ARatSwarm, RatLocomotionVoice) == 0x000B68, "Member 'ARatSwarm::RatLocomotionVoice' has a wrong offset!");
static_assert(offsetof(ARatSwarm, AlertState) == 0x000B70, "Member 'ARatSwarm::AlertState' has a wrong offset!");
static_assert(offsetof(ARatSwarm, AttackState) == 0x000B78, "Member 'ARatSwarm::AttackState' has a wrong offset!");
static_assert(offsetof(ARatSwarm, EatingState) == 0x000B80, "Member 'ARatSwarm::EatingState' has a wrong offset!");
static_assert(offsetof(ARatSwarm, IdleState) == 0x000B88, "Member 'ARatSwarm::IdleState' has a wrong offset!");
static_assert(offsetof(ARatSwarm, RatsMeshComponent) == 0x000B90, "Member 'ARatSwarm::RatsMeshComponent' has a wrong offset!");

// Class Stalker2.RazerSensaEventTracker
// 0x0070 (0x0098 - 0x0028)
class URazerSensaEventTracker final : public UObject
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class URazerSensaSubsystem*                   Subsystem;                                         // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RazerSensaEventTracker">();
	}
	static class URazerSensaEventTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<URazerSensaEventTracker>();
	}
};
static_assert(alignof(URazerSensaEventTracker) == 0x000008, "Wrong alignment on URazerSensaEventTracker");
static_assert(sizeof(URazerSensaEventTracker) == 0x000098, "Wrong size on URazerSensaEventTracker");
static_assert(offsetof(URazerSensaEventTracker, Subsystem) == 0x000088, "Member 'URazerSensaEventTracker::Subsystem' has a wrong offset!");

// Class Stalker2.RazerSensaSubsystem
// 0x0028 (0x0058 - 0x0030)
class URazerSensaSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URazerSensaEventTracker*                EventTracker;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RazerSensaSubsystem">();
	}
	static class URazerSensaSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URazerSensaSubsystem>();
	}
};
static_assert(alignof(URazerSensaSubsystem) == 0x000008, "Wrong alignment on URazerSensaSubsystem");
static_assert(sizeof(URazerSensaSubsystem) == 0x000058, "Wrong size on URazerSensaSubsystem");
static_assert(offsetof(URazerSensaSubsystem, EventTracker) == 0x000040, "Member 'URazerSensaSubsystem::EventTracker' has a wrong offset!");

// Class Stalker2.ReferenceHolderBase
// 0x0078 (0x0310 - 0x0298)
class AReferenceHolderBase final : public AActor
{
public:
	TMap<struct FSoftObjectPath, class UClass*>   ObjectsReferences;                                 // 0x0298(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AssetPath;                                         // 0x02E8(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckAssetReferences();
	void UpdateObjectReferences();

	void ValidateGatheredReferences() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReferenceHolderBase">();
	}
	static class AReferenceHolderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReferenceHolderBase>();
	}
};
static_assert(alignof(AReferenceHolderBase) == 0x000008, "Wrong alignment on AReferenceHolderBase");
static_assert(sizeof(AReferenceHolderBase) == 0x000310, "Wrong size on AReferenceHolderBase");
static_assert(offsetof(AReferenceHolderBase, ObjectsReferences) == 0x000298, "Member 'AReferenceHolderBase::ObjectsReferences' has a wrong offset!");
static_assert(offsetof(AReferenceHolderBase, AssetPath) == 0x0002E8, "Member 'AReferenceHolderBase::AssetPath' has a wrong offset!");

// Class Stalker2.RestorableComponent
// 0x0000 (0x0000 - 0x0000)
class IRestorableComponent final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RestorableComponent">();
	}
	static class IRestorableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRestorableComponent>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRestorableComponent) == 0x000001, "Wrong alignment on IRestorableComponent");
static_assert(sizeof(IRestorableComponent) == 0x000001, "Wrong size on IRestorableComponent");

// Class Stalker2.RightClickMenuWidget
// 0x0088 (0x0300 - 0x0278)
class URightClickMenuWidget final : public UUserWidget
{
public:
	class UVerticalBox*                           Menu;                                              // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Left_NoTile;                                       // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Right_NoTile;                                      // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                MenuItemWidgetClass;                               // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       RadiationMark;                                     // 0x0298(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x40];                                     // 0x02A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NoTileBordersElementsNum;                          // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E4[0x1C];                                     // 0x02E4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnItemClicked(const struct FRightClickMenuItemData& Data);
	void OnItemHover(const struct FRightClickMenuItemData& Data, const bool bInHover);
	void OnNoItemClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RightClickMenuWidget">();
	}
	static class URightClickMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URightClickMenuWidget>();
	}
};
static_assert(alignof(URightClickMenuWidget) == 0x000008, "Wrong alignment on URightClickMenuWidget");
static_assert(sizeof(URightClickMenuWidget) == 0x000300, "Wrong size on URightClickMenuWidget");
static_assert(offsetof(URightClickMenuWidget, Menu) == 0x000278, "Member 'URightClickMenuWidget::Menu' has a wrong offset!");
static_assert(offsetof(URightClickMenuWidget, Left_NoTile) == 0x000280, "Member 'URightClickMenuWidget::Left_NoTile' has a wrong offset!");
static_assert(offsetof(URightClickMenuWidget, Right_NoTile) == 0x000288, "Member 'URightClickMenuWidget::Right_NoTile' has a wrong offset!");
static_assert(offsetof(URightClickMenuWidget, MenuItemWidgetClass) == 0x000290, "Member 'URightClickMenuWidget::MenuItemWidgetClass' has a wrong offset!");
static_assert(offsetof(URightClickMenuWidget, RadiationMark) == 0x000298, "Member 'URightClickMenuWidget::RadiationMark' has a wrong offset!");
static_assert(offsetof(URightClickMenuWidget, NoTileBordersElementsNum) == 0x0002E0, "Member 'URightClickMenuWidget::NoTileBordersElementsNum' has a wrong offset!");

// Class Stalker2.S2TargetMeleeSectorComponent
// 0x0000 (0x0150 - 0x0150)
class US2TargetMeleeSectorComponent final : public UTargetMeleeSectorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S2TargetMeleeSectorComponent">();
	}
	static class US2TargetMeleeSectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<US2TargetMeleeSectorComponent>();
	}
};
static_assert(alignof(US2TargetMeleeSectorComponent) == 0x000008, "Wrong alignment on US2TargetMeleeSectorComponent");
static_assert(sizeof(US2TargetMeleeSectorComponent) == 0x000150, "Wrong size on US2TargetMeleeSectorComponent");

// Class Stalker2.SafeZoneButton
// 0x0000 (0x0278 - 0x0278)
class USafeZoneButton final : public UWidgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SafeZoneButton">();
	}
	static class USafeZoneButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<USafeZoneButton>();
	}
};
static_assert(alignof(USafeZoneButton) == 0x000008, "Wrong alignment on USafeZoneButton");
static_assert(sizeof(USafeZoneButton) == 0x000278, "Wrong size on USafeZoneButton");

// Class Stalker2.SafeZoneWidget
// 0x0060 (0x0330 - 0x02D0)
class USafeZoneWidget final : public UMenuSubViewBase
{
public:
	float                                         Speed;                                             // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinScale;                                          // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxScale;                                          // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinValue;                                          // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxX;                                              // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxY;                                              // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DefaultScale;                                      // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ValueX;                                            // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImageWidget*                           LeftTopCorner;                                     // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImageWidget*                           RightTopCorner;                                    // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImageWidget*                           LeftDownCorner;                                    // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImageWidget*                           RightDownCorner;                                   // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImageWidget*                           Border;                                            // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleEditSafeZoneMoveBordersDecreaseHeight();
	void HandleEditSafeZoneMoveBordersDecreaseWidth();
	void HandleEditSafeZoneMoveBordersIncreaseHeight();
	void HandleEditSafeZoneMoveBordersIncreaseWidth();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SafeZoneWidget">();
	}
	static class USafeZoneWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USafeZoneWidget>();
	}
};
static_assert(alignof(USafeZoneWidget) == 0x000008, "Wrong alignment on USafeZoneWidget");
static_assert(sizeof(USafeZoneWidget) == 0x000330, "Wrong size on USafeZoneWidget");
static_assert(offsetof(USafeZoneWidget, Speed) == 0x0002D0, "Member 'USafeZoneWidget::Speed' has a wrong offset!");
static_assert(offsetof(USafeZoneWidget, MinScale) == 0x0002D4, "Member 'USafeZoneWidget::MinScale' has a wrong offset!");
static_assert(offsetof(USafeZoneWidget, MaxScale) == 0x0002D8, "Member 'USafeZoneWidget::MaxScale' has a wrong offset!");
static_assert(offsetof(USafeZoneWidget, MinValue) == 0x0002DC, "Member 'USafeZoneWidget::MinValue' has a wrong offset!");
static_assert(offsetof(USafeZoneWidget, MaxValue) == 0x0002E0, "Member 'USafeZoneWidget::MaxValue' has a wrong offset!");
static_assert(offsetof(USafeZoneWidget, MaxX) == 0x0002E4, "Member 'USafeZoneWidget::MaxX' has a wrong offset!");
static_assert(offsetof(USafeZoneWidget, MaxY) == 0x0002E8, "Member 'USafeZoneWidget::MaxY' has a wrong offset!");
static_assert(offsetof(USafeZoneWidget, DefaultScale) == 0x0002F0, "Member 'USafeZoneWidget::DefaultScale' has a wrong offset!");
static_assert(offsetof(USafeZoneWidget, ValueX) == 0x0002F8, "Member 'USafeZoneWidget::ValueX' has a wrong offset!");
static_assert(offsetof(USafeZoneWidget, LeftTopCorner) == 0x000300, "Member 'USafeZoneWidget::LeftTopCorner' has a wrong offset!");
static_assert(offsetof(USafeZoneWidget, RightTopCorner) == 0x000308, "Member 'USafeZoneWidget::RightTopCorner' has a wrong offset!");
static_assert(offsetof(USafeZoneWidget, LeftDownCorner) == 0x000310, "Member 'USafeZoneWidget::LeftDownCorner' has a wrong offset!");
static_assert(offsetof(USafeZoneWidget, RightDownCorner) == 0x000318, "Member 'USafeZoneWidget::RightDownCorner' has a wrong offset!");
static_assert(offsetof(USafeZoneWidget, Border) == 0x000320, "Member 'USafeZoneWidget::Border' has a wrong offset!");

// Class Stalker2.SaveLoadManager
// 0x0118 (0x0190 - 0x0078)
class USaveLoadManager final : public UBaseManager
{
public:
	class USaveLoadIO*                            SaveLoadIO;                                        // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0xB8];                                      // 0x0080(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class FString>              DLCUserFriendlyNames;                              // 0x0138(0x0050)(Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadManager">();
	}
	static class USaveLoadManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadManager>();
	}
};
static_assert(alignof(USaveLoadManager) == 0x000008, "Wrong alignment on USaveLoadManager");
static_assert(sizeof(USaveLoadManager) == 0x000190, "Wrong size on USaveLoadManager");
static_assert(offsetof(USaveLoadManager, SaveLoadIO) == 0x000078, "Member 'USaveLoadManager::SaveLoadIO' has a wrong offset!");
static_assert(offsetof(USaveLoadManager, DLCUserFriendlyNames) == 0x000138, "Member 'USaveLoadManager::DLCUserFriendlyNames' has a wrong offset!");

// Class Stalker2.SaveLoadNotificationBase
// 0x0088 (0x0300 - 0x0278)
class USaveLoadNotificationBase : public UWidgetBase
{
public:
	class UWidgetAnimation*                       FadeInAnimation;                                   // 0x0278(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       FadeOutAnimation;                                  // 0x0280(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       BlinkingAnimation;                                 // 0x0288(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x20];                                     // 0x0290(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextWidget*                            Title;                                             // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            Description;                                       // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBox;                                           // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Icon;                                              // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SingleLineDescWidth;                               // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TwoLineDescWidth;                                  // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThreeLineDescWidth;                                // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimerRate;                                         // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             FloppyDisk;                                        // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BrokenFloppyDisk;                                  // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadNotificationBase">();
	}
	static class USaveLoadNotificationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadNotificationBase>();
	}
};
static_assert(alignof(USaveLoadNotificationBase) == 0x000008, "Wrong alignment on USaveLoadNotificationBase");
static_assert(sizeof(USaveLoadNotificationBase) == 0x000300, "Wrong size on USaveLoadNotificationBase");
static_assert(offsetof(USaveLoadNotificationBase, FadeInAnimation) == 0x000278, "Member 'USaveLoadNotificationBase::FadeInAnimation' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationBase, FadeOutAnimation) == 0x000280, "Member 'USaveLoadNotificationBase::FadeOutAnimation' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationBase, BlinkingAnimation) == 0x000288, "Member 'USaveLoadNotificationBase::BlinkingAnimation' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationBase, Title) == 0x0002B0, "Member 'USaveLoadNotificationBase::Title' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationBase, Description) == 0x0002B8, "Member 'USaveLoadNotificationBase::Description' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationBase, SizeBox) == 0x0002C0, "Member 'USaveLoadNotificationBase::SizeBox' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationBase, Icon) == 0x0002C8, "Member 'USaveLoadNotificationBase::Icon' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationBase, SingleLineDescWidth) == 0x0002D0, "Member 'USaveLoadNotificationBase::SingleLineDescWidth' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationBase, TwoLineDescWidth) == 0x0002D4, "Member 'USaveLoadNotificationBase::TwoLineDescWidth' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationBase, ThreeLineDescWidth) == 0x0002D8, "Member 'USaveLoadNotificationBase::ThreeLineDescWidth' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationBase, TimerRate) == 0x0002DC, "Member 'USaveLoadNotificationBase::TimerRate' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationBase, FloppyDisk) == 0x0002E0, "Member 'USaveLoadNotificationBase::FloppyDisk' has a wrong offset!");
static_assert(offsetof(USaveLoadNotificationBase, BrokenFloppyDisk) == 0x0002E8, "Member 'USaveLoadNotificationBase::BrokenFloppyDisk' has a wrong offset!");

// Class Stalker2.SaveSlotButton
// 0x00E0 (0x03E0 - 0x0300)
class USaveSlotButton final : public UMenuButtonBase
{
public:
	class UImage*                                 Thumbnail;                                         // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Background;                                        // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CompatibilityImage;                                // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableTextBox*                       SaveName;                                          // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            DateTime;                                          // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            GameDuration;                                      // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            SaveTypeText;                                      // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            LocationName;                                      // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FShortcutData>                  RenameStateShortcuts;                              // 0x0340(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class FString                                 DateTimeFormat;                                    // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GameDurationTimeFormat;                            // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           CompatibleSaveColor;                               // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           PartiallyCompatibleSaveColor;                      // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NonCompatibleSaveColor;                            // 0x0390(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UTexture2D>>      SaveIcons;                                         // 0x03A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>              CorruptedSaveThumbnail;                            // 0x03B0(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveSlotButton">();
	}
	static class USaveSlotButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveSlotButton>();
	}
};
static_assert(alignof(USaveSlotButton) == 0x000008, "Wrong alignment on USaveSlotButton");
static_assert(sizeof(USaveSlotButton) == 0x0003E0, "Wrong size on USaveSlotButton");
static_assert(offsetof(USaveSlotButton, Thumbnail) == 0x000300, "Member 'USaveSlotButton::Thumbnail' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, Background) == 0x000308, "Member 'USaveSlotButton::Background' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, CompatibilityImage) == 0x000310, "Member 'USaveSlotButton::CompatibilityImage' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, SaveName) == 0x000318, "Member 'USaveSlotButton::SaveName' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, DateTime) == 0x000320, "Member 'USaveSlotButton::DateTime' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, GameDuration) == 0x000328, "Member 'USaveSlotButton::GameDuration' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, SaveTypeText) == 0x000330, "Member 'USaveSlotButton::SaveTypeText' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, LocationName) == 0x000338, "Member 'USaveSlotButton::LocationName' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, RenameStateShortcuts) == 0x000340, "Member 'USaveSlotButton::RenameStateShortcuts' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, DateTimeFormat) == 0x000350, "Member 'USaveSlotButton::DateTimeFormat' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, GameDurationTimeFormat) == 0x000360, "Member 'USaveSlotButton::GameDurationTimeFormat' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, CompatibleSaveColor) == 0x000370, "Member 'USaveSlotButton::CompatibleSaveColor' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, PartiallyCompatibleSaveColor) == 0x000380, "Member 'USaveSlotButton::PartiallyCompatibleSaveColor' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, NonCompatibleSaveColor) == 0x000390, "Member 'USaveSlotButton::NonCompatibleSaveColor' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, SaveIcons) == 0x0003A0, "Member 'USaveSlotButton::SaveIcons' has a wrong offset!");
static_assert(offsetof(USaveSlotButton, CorruptedSaveThumbnail) == 0x0003B0, "Member 'USaveSlotButton::CorruptedSaveThumbnail' has a wrong offset!");

// Class Stalker2.SelectionVolumeBox
// 0x0000 (0x02A0 - 0x02A0)
class ASelectionVolumeBox final : public ASelectionVolumeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectionVolumeBox">();
	}
	static class ASelectionVolumeBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASelectionVolumeBox>();
	}
};
static_assert(alignof(ASelectionVolumeBox) == 0x000008, "Wrong alignment on ASelectionVolumeBox");
static_assert(sizeof(ASelectionVolumeBox) == 0x0002A0, "Wrong size on ASelectionVolumeBox");

// Class Stalker2.SettingsNavigationButton
// 0x0078 (0x0338 - 0x02C0)
class USettingsNavigationButton final : public UButtonBase
{
public:
	class UImage*                                 SelectLine;                                        // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            ButtonText;                                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLocalisation;                               // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ButtonLocalizationSID;                             // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x02E8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEnableSelectAnimation;                            // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableByDefault;                                  // 0x0301(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_302[0x2];                                      // 0x0302(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ButtonIndex;                                       // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetStyleIdHover;                                   // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetStyleIdUnHover;                                 // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldHideOnPresentation;                         // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESettingCategoryType                          Category;                                          // 0x0319(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePopupOnSlotSwitch;                          // 0x031A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31B[0x1D];                                     // 0x031B(0x001D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsNavigationButton">();
	}
	static class USettingsNavigationButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsNavigationButton>();
	}
};
static_assert(alignof(USettingsNavigationButton) == 0x000008, "Wrong alignment on USettingsNavigationButton");
static_assert(sizeof(USettingsNavigationButton) == 0x000338, "Wrong size on USettingsNavigationButton");
static_assert(offsetof(USettingsNavigationButton, SelectLine) == 0x0002C0, "Member 'USettingsNavigationButton::SelectLine' has a wrong offset!");
static_assert(offsetof(USettingsNavigationButton, ButtonText) == 0x0002C8, "Member 'USettingsNavigationButton::ButtonText' has a wrong offset!");
static_assert(offsetof(USettingsNavigationButton, bEnableLocalisation) == 0x0002D0, "Member 'USettingsNavigationButton::bEnableLocalisation' has a wrong offset!");
static_assert(offsetof(USettingsNavigationButton, ButtonLocalizationSID) == 0x0002D8, "Member 'USettingsNavigationButton::ButtonLocalizationSID' has a wrong offset!");
static_assert(offsetof(USettingsNavigationButton, DisplayText) == 0x0002E8, "Member 'USettingsNavigationButton::DisplayText' has a wrong offset!");
static_assert(offsetof(USettingsNavigationButton, bEnableSelectAnimation) == 0x000300, "Member 'USettingsNavigationButton::bEnableSelectAnimation' has a wrong offset!");
static_assert(offsetof(USettingsNavigationButton, bEnableByDefault) == 0x000301, "Member 'USettingsNavigationButton::bEnableByDefault' has a wrong offset!");
static_assert(offsetof(USettingsNavigationButton, ButtonIndex) == 0x000304, "Member 'USettingsNavigationButton::ButtonIndex' has a wrong offset!");
static_assert(offsetof(USettingsNavigationButton, SetStyleIdHover) == 0x000308, "Member 'USettingsNavigationButton::SetStyleIdHover' has a wrong offset!");
static_assert(offsetof(USettingsNavigationButton, SetStyleIdUnHover) == 0x000310, "Member 'USettingsNavigationButton::SetStyleIdUnHover' has a wrong offset!");
static_assert(offsetof(USettingsNavigationButton, bShouldHideOnPresentation) == 0x000318, "Member 'USettingsNavigationButton::bShouldHideOnPresentation' has a wrong offset!");
static_assert(offsetof(USettingsNavigationButton, Category) == 0x000319, "Member 'USettingsNavigationButton::Category' has a wrong offset!");
static_assert(offsetof(USettingsNavigationButton, bEnablePopupOnSlotSwitch) == 0x00031A, "Member 'USettingsNavigationButton::bEnablePopupOnSlotSwitch' has a wrong offset!");

// Class Stalker2.ShootingWeaponComponent
// 0x00B0 (0x0350 - 0x02A0)
class UShootingWeaponComponent final : public USceneComponent
{
public:
	struct FPrototypeSID                          WeaponPrototypeSID;                                // 0x02A0(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x70];                                     // 0x02E0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Shoot();
	void ShootWithOwnerOverride(class UObject* OwnerOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShootingWeaponComponent">();
	}
	static class UShootingWeaponComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShootingWeaponComponent>();
	}
};
static_assert(alignof(UShootingWeaponComponent) == 0x000010, "Wrong alignment on UShootingWeaponComponent");
static_assert(sizeof(UShootingWeaponComponent) == 0x000350, "Wrong size on UShootingWeaponComponent");
static_assert(offsetof(UShootingWeaponComponent, WeaponPrototypeSID) == 0x0002A0, "Member 'UShootingWeaponComponent::WeaponPrototypeSID' has a wrong offset!");

// Class Stalker2.SkipDialogIPU
// 0x0000 (0x0040 - 0x0040)
class USkipDialogIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkipDialogIPU">();
	}
	static class USkipDialogIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkipDialogIPU>();
	}
};
static_assert(alignof(USkipDialogIPU) == 0x000008, "Wrong alignment on USkipDialogIPU");
static_assert(sizeof(USkipDialogIPU) == 0x000040, "Wrong size on USkipDialogIPU");

// Class Stalker2.SkipHintView
// 0x0070 (0x0338 - 0x02C8)
class USkipHintView final : public UViewBaseExtended
{
public:
	class USizeBox*                               ButtonHintSkip;                                    // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextBlock*                         SkipTextHint;                                      // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HoldSkipLocSID;                                    // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PressSkipLocSID;                                   // 0x02E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       SkipFadeAnimation;                                 // 0x02F8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationSpeed;                                    // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideSkipHintLifeBond;                              // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x30];                                     // 0x0308(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkipHintView">();
	}
	static class USkipHintView* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkipHintView>();
	}
};
static_assert(alignof(USkipHintView) == 0x000008, "Wrong alignment on USkipHintView");
static_assert(sizeof(USkipHintView) == 0x000338, "Wrong size on USkipHintView");
static_assert(offsetof(USkipHintView, ButtonHintSkip) == 0x0002C8, "Member 'USkipHintView::ButtonHintSkip' has a wrong offset!");
static_assert(offsetof(USkipHintView, SkipTextHint) == 0x0002D0, "Member 'USkipHintView::SkipTextHint' has a wrong offset!");
static_assert(offsetof(USkipHintView, HoldSkipLocSID) == 0x0002D8, "Member 'USkipHintView::HoldSkipLocSID' has a wrong offset!");
static_assert(offsetof(USkipHintView, PressSkipLocSID) == 0x0002E8, "Member 'USkipHintView::PressSkipLocSID' has a wrong offset!");
static_assert(offsetof(USkipHintView, SkipFadeAnimation) == 0x0002F8, "Member 'USkipHintView::SkipFadeAnimation' has a wrong offset!");
static_assert(offsetof(USkipHintView, AnimationSpeed) == 0x000300, "Member 'USkipHintView::AnimationSpeed' has a wrong offset!");
static_assert(offsetof(USkipHintView, HideSkipHintLifeBond) == 0x000304, "Member 'USkipHintView::HideSkipHintLifeBond' has a wrong offset!");

// Class Stalker2.SoapBubbleAnomaly
// 0x0068 (0x0400 - 0x0398)
class ASoapBubbleAnomaly final : public AAnomaly
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          SoapBubbleDamage;                                  // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          SoapBubbleDestroy;                                 // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          SoapBubbleParticleDestroy;                         // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         SoapBubbleParticleExplosion;                       // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SoapBubbleParticleMaterial;                        // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            SoapBubbleParticleMesh;                            // 0x03C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SoapBubble;                                        // 0x03D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       SoapBubbleBoundSphere;                             // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      SoapBubbleExplosionParticle;                       // 0x03E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            InterpolationCurve;                                // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x10];                                     // 0x03F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorCollided(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoapBubbleAnomaly">();
	}
	static class ASoapBubbleAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASoapBubbleAnomaly>();
	}
};
static_assert(alignof(ASoapBubbleAnomaly) == 0x000008, "Wrong alignment on ASoapBubbleAnomaly");
static_assert(sizeof(ASoapBubbleAnomaly) == 0x000400, "Wrong size on ASoapBubbleAnomaly");
static_assert(offsetof(ASoapBubbleAnomaly, SoapBubbleDamage) == 0x0003A0, "Member 'ASoapBubbleAnomaly::SoapBubbleDamage' has a wrong offset!");
static_assert(offsetof(ASoapBubbleAnomaly, SoapBubbleDestroy) == 0x0003A8, "Member 'ASoapBubbleAnomaly::SoapBubbleDestroy' has a wrong offset!");
static_assert(offsetof(ASoapBubbleAnomaly, SoapBubbleParticleDestroy) == 0x0003B0, "Member 'ASoapBubbleAnomaly::SoapBubbleParticleDestroy' has a wrong offset!");
static_assert(offsetof(ASoapBubbleAnomaly, SoapBubbleParticleExplosion) == 0x0003B8, "Member 'ASoapBubbleAnomaly::SoapBubbleParticleExplosion' has a wrong offset!");
static_assert(offsetof(ASoapBubbleAnomaly, SoapBubbleParticleMaterial) == 0x0003C0, "Member 'ASoapBubbleAnomaly::SoapBubbleParticleMaterial' has a wrong offset!");
static_assert(offsetof(ASoapBubbleAnomaly, SoapBubbleParticleMesh) == 0x0003C8, "Member 'ASoapBubbleAnomaly::SoapBubbleParticleMesh' has a wrong offset!");
static_assert(offsetof(ASoapBubbleAnomaly, SoapBubble) == 0x0003D0, "Member 'ASoapBubbleAnomaly::SoapBubble' has a wrong offset!");
static_assert(offsetof(ASoapBubbleAnomaly, SoapBubbleBoundSphere) == 0x0003D8, "Member 'ASoapBubbleAnomaly::SoapBubbleBoundSphere' has a wrong offset!");
static_assert(offsetof(ASoapBubbleAnomaly, SoapBubbleExplosionParticle) == 0x0003E0, "Member 'ASoapBubbleAnomaly::SoapBubbleExplosionParticle' has a wrong offset!");
static_assert(offsetof(ASoapBubbleAnomaly, InterpolationCurve) == 0x0003E8, "Member 'ASoapBubbleAnomaly::InterpolationCurve' has a wrong offset!");

// Class Stalker2.Stalker2PlayerController
// 0x0410 (0x0C80 - 0x0870)
class AStalker2PlayerController final : public APlayerController
{
public:
	uint8                                         Pad_870[0x400];                                    // 0x0870(0x0400)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelevanceFOVADD;                                   // 0x0C70(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GuaranteedRelevanceDistance;                       // 0x0C74(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C78[0x8];                                      // 0x0C78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Stalker2PlayerController">();
	}
	static class AStalker2PlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStalker2PlayerController>();
	}
};
static_assert(alignof(AStalker2PlayerController) == 0x000008, "Wrong alignment on AStalker2PlayerController");
static_assert(sizeof(AStalker2PlayerController) == 0x000C80, "Wrong size on AStalker2PlayerController");
static_assert(offsetof(AStalker2PlayerController, RelevanceFOVADD) == 0x000C70, "Member 'AStalker2PlayerController::RelevanceFOVADD' has a wrong offset!");
static_assert(offsetof(AStalker2PlayerController, GuaranteedRelevanceDistance) == 0x000C74, "Member 'AStalker2PlayerController::GuaranteedRelevanceDistance' has a wrong offset!");

// Class Stalker2.StaticEnvironmentNiagaraComponent
// 0x0020 (0x0850 - 0x0830)
class UStaticEnvironmentNiagaraComponent final : public UEnvironmentNiagaraComponent
{
public:
	class FName                                   PrototypeName;                                     // 0x0830(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_838[0x10];                                     // 0x0838(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EStaticParticleType                           ParticleType;                                      // 0x0848(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_849[0x7];                                      // 0x0849(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticEnvironmentNiagaraComponent">();
	}
	static class UStaticEnvironmentNiagaraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticEnvironmentNiagaraComponent>();
	}
};
static_assert(alignof(UStaticEnvironmentNiagaraComponent) == 0x000010, "Wrong alignment on UStaticEnvironmentNiagaraComponent");
static_assert(sizeof(UStaticEnvironmentNiagaraComponent) == 0x000850, "Wrong size on UStaticEnvironmentNiagaraComponent");
static_assert(offsetof(UStaticEnvironmentNiagaraComponent, PrototypeName) == 0x000830, "Member 'UStaticEnvironmentNiagaraComponent::PrototypeName' has a wrong offset!");
static_assert(offsetof(UStaticEnvironmentNiagaraComponent, ParticleType) == 0x000848, "Member 'UStaticEnvironmentNiagaraComponent::ParticleType' has a wrong offset!");

// Class Stalker2.StatPanel
// 0x0160 (0x03D8 - 0x0278)
class UStatPanel final : public UChildViewBase
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               VitalsOverlay;                                     // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStatSlot*                              StatWeight;                                        // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStatSlot*                              StatSleep;                                         // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStatSlot*                              StatHunger;                                        // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStatSlot*                              StatBleeding;                                      // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           HPProgress;                                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           HPProgressWhite;                                   // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           HPProgressDark;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           Stamina;                                           // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RadiationProgress;                                 // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       BlinkingStaminaAnim;                               // 0x02D0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       BlinkingHPAnim;                                    // 0x02D8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       VitalsOverlayHideAnim;                             // 0x02E0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       VitalsOverlayShowAnim;                             // 0x02E8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStatPanelDataAsset*                    SettingsAsset;                                     // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorWeight;                                       // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorOverWeight;                                   // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           HeavyIconColor;                                    // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MediumIconColor;                                   // 0x0328(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           LightIconColor;                                    // 0x0338(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            HPProgressCurve;                                   // 0x0348(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x88];                                     // 0x0350(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateAllStats();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatPanel">();
	}
	static class UStatPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatPanel>();
	}
};
static_assert(alignof(UStatPanel) == 0x000008, "Wrong alignment on UStatPanel");
static_assert(sizeof(UStatPanel) == 0x0003D8, "Wrong size on UStatPanel");
static_assert(offsetof(UStatPanel, VitalsOverlay) == 0x000280, "Member 'UStatPanel::VitalsOverlay' has a wrong offset!");
static_assert(offsetof(UStatPanel, StatWeight) == 0x000288, "Member 'UStatPanel::StatWeight' has a wrong offset!");
static_assert(offsetof(UStatPanel, StatSleep) == 0x000290, "Member 'UStatPanel::StatSleep' has a wrong offset!");
static_assert(offsetof(UStatPanel, StatHunger) == 0x000298, "Member 'UStatPanel::StatHunger' has a wrong offset!");
static_assert(offsetof(UStatPanel, StatBleeding) == 0x0002A0, "Member 'UStatPanel::StatBleeding' has a wrong offset!");
static_assert(offsetof(UStatPanel, HPProgress) == 0x0002A8, "Member 'UStatPanel::HPProgress' has a wrong offset!");
static_assert(offsetof(UStatPanel, HPProgressWhite) == 0x0002B0, "Member 'UStatPanel::HPProgressWhite' has a wrong offset!");
static_assert(offsetof(UStatPanel, HPProgressDark) == 0x0002B8, "Member 'UStatPanel::HPProgressDark' has a wrong offset!");
static_assert(offsetof(UStatPanel, Stamina) == 0x0002C0, "Member 'UStatPanel::Stamina' has a wrong offset!");
static_assert(offsetof(UStatPanel, RadiationProgress) == 0x0002C8, "Member 'UStatPanel::RadiationProgress' has a wrong offset!");
static_assert(offsetof(UStatPanel, BlinkingStaminaAnim) == 0x0002D0, "Member 'UStatPanel::BlinkingStaminaAnim' has a wrong offset!");
static_assert(offsetof(UStatPanel, BlinkingHPAnim) == 0x0002D8, "Member 'UStatPanel::BlinkingHPAnim' has a wrong offset!");
static_assert(offsetof(UStatPanel, VitalsOverlayHideAnim) == 0x0002E0, "Member 'UStatPanel::VitalsOverlayHideAnim' has a wrong offset!");
static_assert(offsetof(UStatPanel, VitalsOverlayShowAnim) == 0x0002E8, "Member 'UStatPanel::VitalsOverlayShowAnim' has a wrong offset!");
static_assert(offsetof(UStatPanel, SettingsAsset) == 0x0002F0, "Member 'UStatPanel::SettingsAsset' has a wrong offset!");
static_assert(offsetof(UStatPanel, ColorWeight) == 0x0002F8, "Member 'UStatPanel::ColorWeight' has a wrong offset!");
static_assert(offsetof(UStatPanel, ColorOverWeight) == 0x000308, "Member 'UStatPanel::ColorOverWeight' has a wrong offset!");
static_assert(offsetof(UStatPanel, HeavyIconColor) == 0x000318, "Member 'UStatPanel::HeavyIconColor' has a wrong offset!");
static_assert(offsetof(UStatPanel, MediumIconColor) == 0x000328, "Member 'UStatPanel::MediumIconColor' has a wrong offset!");
static_assert(offsetof(UStatPanel, LightIconColor) == 0x000338, "Member 'UStatPanel::LightIconColor' has a wrong offset!");
static_assert(offsetof(UStatPanel, HPProgressCurve) == 0x000348, "Member 'UStatPanel::HPProgressCurve' has a wrong offset!");

// Class Stalker2.StatPanelDataAsset
// 0x0068 (0x0098 - 0x0030)
class UStatPanelDataAsset final : public UDataAsset
{
public:
	float                                         HealthBarReduce;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthBarUpdate;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthBarUpdateDelay;                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthBarCriticalLevel;                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthBarCriticalSpeed;                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthBarRestoreSpeed;                             // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthBarFadeOut;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthBarFadeIn;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnImmidiatlyDeathWhiteBarReduceDelay;              // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatPanelHideDelay;                                // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OngoingDamageWhiteBarReduceDelay;                  // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaminaBarCriticalLevel;                           // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaminaBarCriticalSpeed;                           // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadBarGrowSpeed;                                   // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadBarRestoreSpeed;                                // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RadBarProgressParameterName;                       // 0x006C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BleedingFadeOut;                                   // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BleedingFadeIn;                                    // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverloadFadeOut;                                   // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverloadFadeIn;                                    // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HungerFadeOut;                                     // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HungerFadeIn;                                      // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SleepinessFadeOut;                                 // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SleepinessFadeIn;                                  // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatPanelDataAsset">();
	}
	static class UStatPanelDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatPanelDataAsset>();
	}
};
static_assert(alignof(UStatPanelDataAsset) == 0x000008, "Wrong alignment on UStatPanelDataAsset");
static_assert(sizeof(UStatPanelDataAsset) == 0x000098, "Wrong size on UStatPanelDataAsset");
static_assert(offsetof(UStatPanelDataAsset, HealthBarReduce) == 0x000030, "Member 'UStatPanelDataAsset::HealthBarReduce' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, HealthBarUpdate) == 0x000034, "Member 'UStatPanelDataAsset::HealthBarUpdate' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, HealthBarUpdateDelay) == 0x000038, "Member 'UStatPanelDataAsset::HealthBarUpdateDelay' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, HealthBarCriticalLevel) == 0x00003C, "Member 'UStatPanelDataAsset::HealthBarCriticalLevel' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, HealthBarCriticalSpeed) == 0x000040, "Member 'UStatPanelDataAsset::HealthBarCriticalSpeed' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, HealthBarRestoreSpeed) == 0x000044, "Member 'UStatPanelDataAsset::HealthBarRestoreSpeed' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, HealthBarFadeOut) == 0x000048, "Member 'UStatPanelDataAsset::HealthBarFadeOut' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, HealthBarFadeIn) == 0x00004C, "Member 'UStatPanelDataAsset::HealthBarFadeIn' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, OnImmidiatlyDeathWhiteBarReduceDelay) == 0x000050, "Member 'UStatPanelDataAsset::OnImmidiatlyDeathWhiteBarReduceDelay' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, StatPanelHideDelay) == 0x000054, "Member 'UStatPanelDataAsset::StatPanelHideDelay' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, OngoingDamageWhiteBarReduceDelay) == 0x000058, "Member 'UStatPanelDataAsset::OngoingDamageWhiteBarReduceDelay' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, StaminaBarCriticalLevel) == 0x00005C, "Member 'UStatPanelDataAsset::StaminaBarCriticalLevel' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, StaminaBarCriticalSpeed) == 0x000060, "Member 'UStatPanelDataAsset::StaminaBarCriticalSpeed' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, RadBarGrowSpeed) == 0x000064, "Member 'UStatPanelDataAsset::RadBarGrowSpeed' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, RadBarRestoreSpeed) == 0x000068, "Member 'UStatPanelDataAsset::RadBarRestoreSpeed' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, RadBarProgressParameterName) == 0x00006C, "Member 'UStatPanelDataAsset::RadBarProgressParameterName' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, BleedingFadeOut) == 0x000074, "Member 'UStatPanelDataAsset::BleedingFadeOut' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, BleedingFadeIn) == 0x000078, "Member 'UStatPanelDataAsset::BleedingFadeIn' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, OverloadFadeOut) == 0x00007C, "Member 'UStatPanelDataAsset::OverloadFadeOut' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, OverloadFadeIn) == 0x000080, "Member 'UStatPanelDataAsset::OverloadFadeIn' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, HungerFadeOut) == 0x000084, "Member 'UStatPanelDataAsset::HungerFadeOut' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, HungerFadeIn) == 0x000088, "Member 'UStatPanelDataAsset::HungerFadeIn' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, SleepinessFadeOut) == 0x00008C, "Member 'UStatPanelDataAsset::SleepinessFadeOut' has a wrong offset!");
static_assert(offsetof(UStatPanelDataAsset, SleepinessFadeIn) == 0x000090, "Member 'UStatPanelDataAsset::SleepinessFadeIn' has a wrong offset!");

// Class Stalker2.StatPanelDebug
// 0x0048 (0x02C0 - 0x0278)
class UStatPanelDebug final : public UChildViewBase
{
public:
	class UProgressBar*                           ProgressHP;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           ProgressRadiation;                                 // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           ProgressStamina;                                   // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           ProgressPsy;                                       // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             HPText;                                            // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             RadiationText;                                     // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             StaminaText;                                       // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             PsyText;                                           // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateAllStats();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatPanelDebug">();
	}
	static class UStatPanelDebug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatPanelDebug>();
	}
};
static_assert(alignof(UStatPanelDebug) == 0x000008, "Wrong alignment on UStatPanelDebug");
static_assert(sizeof(UStatPanelDebug) == 0x0002C0, "Wrong size on UStatPanelDebug");
static_assert(offsetof(UStatPanelDebug, ProgressHP) == 0x000278, "Member 'UStatPanelDebug::ProgressHP' has a wrong offset!");
static_assert(offsetof(UStatPanelDebug, ProgressRadiation) == 0x000280, "Member 'UStatPanelDebug::ProgressRadiation' has a wrong offset!");
static_assert(offsetof(UStatPanelDebug, ProgressStamina) == 0x000288, "Member 'UStatPanelDebug::ProgressStamina' has a wrong offset!");
static_assert(offsetof(UStatPanelDebug, ProgressPsy) == 0x000290, "Member 'UStatPanelDebug::ProgressPsy' has a wrong offset!");
static_assert(offsetof(UStatPanelDebug, HPText) == 0x000298, "Member 'UStatPanelDebug::HPText' has a wrong offset!");
static_assert(offsetof(UStatPanelDebug, RadiationText) == 0x0002A0, "Member 'UStatPanelDebug::RadiationText' has a wrong offset!");
static_assert(offsetof(UStatPanelDebug, StaminaText) == 0x0002A8, "Member 'UStatPanelDebug::StaminaText' has a wrong offset!");
static_assert(offsetof(UStatPanelDebug, PsyText) == 0x0002B0, "Member 'UStatPanelDebug::PsyText' has a wrong offset!");

// Class Stalker2.StealthKillComponent
// 0x0090 (0x0130 - 0x00A0)
class UStealthKillComponent final : public UActorComponent
{
public:
	class APC*                                    OwnerPlayer;                                       // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            StealthKillSnapCurve;                              // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x80];                                      // 0x00B0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StealthKillComponent">();
	}
	static class UStealthKillComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStealthKillComponent>();
	}
};
static_assert(alignof(UStealthKillComponent) == 0x000008, "Wrong alignment on UStealthKillComponent");
static_assert(sizeof(UStealthKillComponent) == 0x000130, "Wrong size on UStealthKillComponent");
static_assert(offsetof(UStealthKillComponent, OwnerPlayer) == 0x0000A0, "Member 'UStealthKillComponent::OwnerPlayer' has a wrong offset!");
static_assert(offsetof(UStealthKillComponent, StealthKillSnapCurve) == 0x0000A8, "Member 'UStealthKillComponent::StealthKillSnapCurve' has a wrong offset!");

// Class Stalker2.SteamWorkshopSubsystem
// 0x0000 (0x0030 - 0x0030)
class USteamWorkshopSubsystem final : public UModSubsystemBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamWorkshopSubsystem">();
	}
	static class USteamWorkshopSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamWorkshopSubsystem>();
	}
};
static_assert(alignof(USteamWorkshopSubsystem) == 0x000008, "Wrong alignment on USteamWorkshopSubsystem");
static_assert(sizeof(USteamWorkshopSubsystem) == 0x000030, "Wrong size on USteamWorkshopSubsystem");

// Class Stalker2.StrandGenerator
// 0x00C8 (0x0360 - 0x0298)
class AStrandGenerator final : public AActor
{
public:
	class USplineComponent*                       Spline;                                            // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSplinePointMeshData                   MeshData;                                          // 0x02A0(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<int32, struct FSplinePointMeshData>      MeshOverrides;                                     // 0x0308(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bUseStartSeparator;                                // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseStopSeparator;                                 // 0x0359(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAutoAdjusting;                                 // 0x035A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyRightAngle;                                   // 0x035B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FStrandFinalData GetFinalStrandData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StrandGenerator">();
	}
	static class AStrandGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStrandGenerator>();
	}
};
static_assert(alignof(AStrandGenerator) == 0x000008, "Wrong alignment on AStrandGenerator");
static_assert(sizeof(AStrandGenerator) == 0x000360, "Wrong size on AStrandGenerator");
static_assert(offsetof(AStrandGenerator, Spline) == 0x000298, "Member 'AStrandGenerator::Spline' has a wrong offset!");
static_assert(offsetof(AStrandGenerator, MeshData) == 0x0002A0, "Member 'AStrandGenerator::MeshData' has a wrong offset!");
static_assert(offsetof(AStrandGenerator, MeshOverrides) == 0x000308, "Member 'AStrandGenerator::MeshOverrides' has a wrong offset!");
static_assert(offsetof(AStrandGenerator, bUseStartSeparator) == 0x000358, "Member 'AStrandGenerator::bUseStartSeparator' has a wrong offset!");
static_assert(offsetof(AStrandGenerator, bUseStopSeparator) == 0x000359, "Member 'AStrandGenerator::bUseStopSeparator' has a wrong offset!");
static_assert(offsetof(AStrandGenerator, bUseAutoAdjusting) == 0x00035A, "Member 'AStrandGenerator::bUseAutoAdjusting' has a wrong offset!");
static_assert(offsetof(AStrandGenerator, bOnlyRightAngle) == 0x00035B, "Member 'AStrandGenerator::bOnlyRightAngle' has a wrong offset!");

// Class Stalker2.StreamingDistanceOverridingVolume
// 0x0368 (0x0640 - 0x02D8)
class AStreamingDistanceOverridingVolume final : public AVolume
{
public:
	class AStreamingDistanceOverridingVolume*     MainVolume;                                        // 0x02D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOverrideLifeGridVisionRadius                 OverrideLifeGridVisionRadiusPC;                    // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOverrideLifeGridVisionRadius                 OverrideLifeGridVisionRadiusXBox;                  // 0x02E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOverrideLifeGridVisionRadius                 OverrideLifeGridVisionRadiusXBoxSeriesS;           // 0x02E2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E3[0x5];                                      // 0x02E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FGridInfo>                        OverridingStreamingGridsInfosPC;                   // 0x02E8(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TSet<struct FGridInfo>                        OverridingStreamingGridsInfosXBox;                 // 0x0338(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TSet<struct FGridInfo>                        OverridingStreamingGridsInfosXBoxSeriesS;          // 0x0388(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TSet<class FName>                             EnabledDataLayers;                                 // 0x03D8(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TSet<class FName>                             DisabledDataLayers;                                // 0x0428(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TSet<struct FActorDataLayer>                  EnabledDynamicDataLayers;                          // 0x0478(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TSet<struct FActorDataLayer>                  DisabledDynamicDataLayers;                         // 0x04C8(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TSet<class AStreamingGatewayVolume*>          EntryTriggers;                                     // 0x0518(0x0050)(Edit, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<class AStreamingGatewayVolume*>          ExitTriggers;                                      // 0x0568(0x0050)(Edit, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPrivate)
	double                                        OverridingTime;                                    // 0x05B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VolumePriority;                                    // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UDataLayerInstance*>               OverridedDataLayerInstances;                       // 0x05C8(0x0050)(NativeAccessSpecifierPrivate)
	float                                         FallbackStreamingBlockRestoreRate;                 // 0x0618(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_61C[0x1C];                                     // 0x061C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverridingDistantTreeCullDistanceScale;            // 0x0638(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_63C[0x4];                                      // 0x063C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);
	void UpdateStreamingConfiguration();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamingDistanceOverridingVolume">();
	}
	static class AStreamingDistanceOverridingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStreamingDistanceOverridingVolume>();
	}
};
static_assert(alignof(AStreamingDistanceOverridingVolume) == 0x000008, "Wrong alignment on AStreamingDistanceOverridingVolume");
static_assert(sizeof(AStreamingDistanceOverridingVolume) == 0x000640, "Wrong size on AStreamingDistanceOverridingVolume");
static_assert(offsetof(AStreamingDistanceOverridingVolume, MainVolume) == 0x0002D8, "Member 'AStreamingDistanceOverridingVolume::MainVolume' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, OverrideLifeGridVisionRadiusPC) == 0x0002E0, "Member 'AStreamingDistanceOverridingVolume::OverrideLifeGridVisionRadiusPC' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, OverrideLifeGridVisionRadiusXBox) == 0x0002E1, "Member 'AStreamingDistanceOverridingVolume::OverrideLifeGridVisionRadiusXBox' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, OverrideLifeGridVisionRadiusXBoxSeriesS) == 0x0002E2, "Member 'AStreamingDistanceOverridingVolume::OverrideLifeGridVisionRadiusXBoxSeriesS' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, OverridingStreamingGridsInfosPC) == 0x0002E8, "Member 'AStreamingDistanceOverridingVolume::OverridingStreamingGridsInfosPC' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, OverridingStreamingGridsInfosXBox) == 0x000338, "Member 'AStreamingDistanceOverridingVolume::OverridingStreamingGridsInfosXBox' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, OverridingStreamingGridsInfosXBoxSeriesS) == 0x000388, "Member 'AStreamingDistanceOverridingVolume::OverridingStreamingGridsInfosXBoxSeriesS' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, EnabledDataLayers) == 0x0003D8, "Member 'AStreamingDistanceOverridingVolume::EnabledDataLayers' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, DisabledDataLayers) == 0x000428, "Member 'AStreamingDistanceOverridingVolume::DisabledDataLayers' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, EnabledDynamicDataLayers) == 0x000478, "Member 'AStreamingDistanceOverridingVolume::EnabledDynamicDataLayers' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, DisabledDynamicDataLayers) == 0x0004C8, "Member 'AStreamingDistanceOverridingVolume::DisabledDynamicDataLayers' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, EntryTriggers) == 0x000518, "Member 'AStreamingDistanceOverridingVolume::EntryTriggers' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, ExitTriggers) == 0x000568, "Member 'AStreamingDistanceOverridingVolume::ExitTriggers' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, OverridingTime) == 0x0005B8, "Member 'AStreamingDistanceOverridingVolume::OverridingTime' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, VolumePriority) == 0x0005C0, "Member 'AStreamingDistanceOverridingVolume::VolumePriority' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, OverridedDataLayerInstances) == 0x0005C8, "Member 'AStreamingDistanceOverridingVolume::OverridedDataLayerInstances' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, FallbackStreamingBlockRestoreRate) == 0x000618, "Member 'AStreamingDistanceOverridingVolume::FallbackStreamingBlockRestoreRate' has a wrong offset!");
static_assert(offsetof(AStreamingDistanceOverridingVolume, OverridingDistantTreeCullDistanceScale) == 0x000638, "Member 'AStreamingDistanceOverridingVolume::OverridingDistantTreeCullDistanceScale' has a wrong offset!");

// Class Stalker2.StreamingGatewayVolume
// 0x0000 (0x02D8 - 0x02D8)
class AStreamingGatewayVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamingGatewayVolume">();
	}
	static class AStreamingGatewayVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStreamingGatewayVolume>();
	}
};
static_assert(alignof(AStreamingGatewayVolume) == 0x000008, "Wrong alignment on AStreamingGatewayVolume");
static_assert(sizeof(AStreamingGatewayVolume) == 0x0002D8, "Wrong size on AStreamingGatewayVolume");

// Class Stalker2.StrelokBossComponent
// 0x00A8 (0x0148 - 0x00A0)
class UStrelokBossComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0xA8];                                      // 0x00A0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDashAbilityUsed(const bool bAbilityUsed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StrelokBossComponent">();
	}
	static class UStrelokBossComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStrelokBossComponent>();
	}
};
static_assert(alignof(UStrelokBossComponent) == 0x000008, "Wrong alignment on UStrelokBossComponent");
static_assert(sizeof(UStrelokBossComponent) == 0x000148, "Wrong size on UStrelokBossComponent");

// Class Stalker2.StrelokBossfightController
// 0x00F0 (0x0388 - 0x0298)
class AStrelokBossfightController final : public AActor
{
public:
	class UBoxComponent*                          ControllerVolume;                                  // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalReceiverComponent*               SignalReceiverComponent;                           // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AnomalySpawnNum;                                   // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnomalySpawnDelay;                                 // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EAnomalyElementType, class UNiagaraSystem*> AnomalyElementVFXMap;                           // 0x02B0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TLazyObjectPtr<class AActor>>          AnomalySpawners;                                   // 0x0300(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<class FString>                           AnomalyFieldsSIDs;                                 // 0x0310(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x28];                                     // 0x0360(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SpawnAnomalyField();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StrelokBossfightController">();
	}
	static class AStrelokBossfightController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStrelokBossfightController>();
	}
};
static_assert(alignof(AStrelokBossfightController) == 0x000008, "Wrong alignment on AStrelokBossfightController");
static_assert(sizeof(AStrelokBossfightController) == 0x000388, "Wrong size on AStrelokBossfightController");
static_assert(offsetof(AStrelokBossfightController, ControllerVolume) == 0x000298, "Member 'AStrelokBossfightController::ControllerVolume' has a wrong offset!");
static_assert(offsetof(AStrelokBossfightController, SignalReceiverComponent) == 0x0002A0, "Member 'AStrelokBossfightController::SignalReceiverComponent' has a wrong offset!");
static_assert(offsetof(AStrelokBossfightController, AnomalySpawnNum) == 0x0002A8, "Member 'AStrelokBossfightController::AnomalySpawnNum' has a wrong offset!");
static_assert(offsetof(AStrelokBossfightController, AnomalySpawnDelay) == 0x0002AC, "Member 'AStrelokBossfightController::AnomalySpawnDelay' has a wrong offset!");
static_assert(offsetof(AStrelokBossfightController, AnomalyElementVFXMap) == 0x0002B0, "Member 'AStrelokBossfightController::AnomalyElementVFXMap' has a wrong offset!");
static_assert(offsetof(AStrelokBossfightController, AnomalySpawners) == 0x000300, "Member 'AStrelokBossfightController::AnomalySpawners' has a wrong offset!");
static_assert(offsetof(AStrelokBossfightController, AnomalyFieldsSIDs) == 0x000310, "Member 'AStrelokBossfightController::AnomalyFieldsSIDs' has a wrong offset!");

// Class Stalker2.SubtitleView
// 0x01A0 (0x0468 - 0x02C8)
class USubtitleView final : public UViewBaseExtended
{
public:
	class UDebugTextWidgetBase*                   DebugLenSpeaker;                                   // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugTextWidgetBase*                   DebugLenSubtitle;                                  // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugTextWidgetBase*                   DebugRowSpeaker;                                   // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugTextWidgetBase*                   DebugRowSubtitle;                                  // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            SpeakerDialogText;                                 // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            TwoPoint;                                          // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         NameBox;                                           // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBorder*                                SubtitileBorder;                                   // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               SubtitileContainer;                                // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            TextDialog;                                        // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharToShow;                                        // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedCharToShow;                                   // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ESubtitlesSize, class FName>             SubtitleNames;                                     // 0x0320(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ESubtitlesSize, class FName>             SpeakerSubtitleNames;                              // 0x0370(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         AnimationSpeed;                                    // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideSkipHintLifeBond;                              // 0x03C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              BackgroundTexture;                                 // 0x03C8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x70];                                     // 0x03F8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitleView">();
	}
	static class USubtitleView* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitleView>();
	}
};
static_assert(alignof(USubtitleView) == 0x000008, "Wrong alignment on USubtitleView");
static_assert(sizeof(USubtitleView) == 0x000468, "Wrong size on USubtitleView");
static_assert(offsetof(USubtitleView, DebugLenSpeaker) == 0x0002C8, "Member 'USubtitleView::DebugLenSpeaker' has a wrong offset!");
static_assert(offsetof(USubtitleView, DebugLenSubtitle) == 0x0002D0, "Member 'USubtitleView::DebugLenSubtitle' has a wrong offset!");
static_assert(offsetof(USubtitleView, DebugRowSpeaker) == 0x0002D8, "Member 'USubtitleView::DebugRowSpeaker' has a wrong offset!");
static_assert(offsetof(USubtitleView, DebugRowSubtitle) == 0x0002E0, "Member 'USubtitleView::DebugRowSubtitle' has a wrong offset!");
static_assert(offsetof(USubtitleView, SpeakerDialogText) == 0x0002E8, "Member 'USubtitleView::SpeakerDialogText' has a wrong offset!");
static_assert(offsetof(USubtitleView, TwoPoint) == 0x0002F0, "Member 'USubtitleView::TwoPoint' has a wrong offset!");
static_assert(offsetof(USubtitleView, NameBox) == 0x0002F8, "Member 'USubtitleView::NameBox' has a wrong offset!");
static_assert(offsetof(USubtitleView, SubtitileBorder) == 0x000300, "Member 'USubtitleView::SubtitileBorder' has a wrong offset!");
static_assert(offsetof(USubtitleView, SubtitileContainer) == 0x000308, "Member 'USubtitleView::SubtitileContainer' has a wrong offset!");
static_assert(offsetof(USubtitleView, TextDialog) == 0x000310, "Member 'USubtitleView::TextDialog' has a wrong offset!");
static_assert(offsetof(USubtitleView, CharToShow) == 0x000318, "Member 'USubtitleView::CharToShow' has a wrong offset!");
static_assert(offsetof(USubtitleView, SpeedCharToShow) == 0x00031C, "Member 'USubtitleView::SpeedCharToShow' has a wrong offset!");
static_assert(offsetof(USubtitleView, SubtitleNames) == 0x000320, "Member 'USubtitleView::SubtitleNames' has a wrong offset!");
static_assert(offsetof(USubtitleView, SpeakerSubtitleNames) == 0x000370, "Member 'USubtitleView::SpeakerSubtitleNames' has a wrong offset!");
static_assert(offsetof(USubtitleView, AnimationSpeed) == 0x0003C0, "Member 'USubtitleView::AnimationSpeed' has a wrong offset!");
static_assert(offsetof(USubtitleView, HideSkipHintLifeBond) == 0x0003C4, "Member 'USubtitleView::HideSkipHintLifeBond' has a wrong offset!");
static_assert(offsetof(USubtitleView, BackgroundTexture) == 0x0003C8, "Member 'USubtitleView::BackgroundTexture' has a wrong offset!");

// Class Stalker2.SummonStateComponent
// 0x0050 (0x00F0 - 0x00A0)
class USummonStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x50];                                      // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonStateComponent">();
	}
	static class USummonStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonStateComponent>();
	}
};
static_assert(alignof(USummonStateComponent) == 0x000008, "Wrong alignment on USummonStateComponent");
static_assert(sizeof(USummonStateComponent) == 0x0000F0, "Wrong size on USummonStateComponent");

// Class Stalker2.SwapWeaponIPU
// 0x0000 (0x0040 - 0x0040)
class USwapWeaponIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwapWeaponIPU">();
	}
	static class USwapWeaponIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwapWeaponIPU>();
	}
};
static_assert(alignof(USwapWeaponIPU) == 0x000008, "Wrong alignment on USwapWeaponIPU");
static_assert(sizeof(USwapWeaponIPU) == 0x000040, "Wrong size on USwapWeaponIPU");

// Class Stalker2.SystemNotificationItem
// 0x0258 (0x04D0 - 0x0278)
class USystemNotificationItem final : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x30];                                     // 0x0278(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWasVoiceNotePlayed;                               // 0x02A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       MoveUpAnim;                                        // 0x02B0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       MoveFromDownAnim;                                  // 0x02B8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       HideAnim;                                          // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AppearAnim;                                        // 0x02C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextWidget*                        Title;                                             // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Description;                                       // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   Hint;                                              // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Icon;                                              // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        AudiologSwitcher;                                  // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         VoiceHorizontalBox;                                // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           AudiologProgressBar;                               // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AudiologDuration;                                  // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AudiologCurrentDuration;                           // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BackgroundBody;                                    // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BackgroundTop;                                     // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BackgroundDown;                                    // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                AppearanceLayer;                                   // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                AppearanceLine;                                    // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           General;                                           // 0x0340(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           green;                                             // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           red;                                               // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RegularHeight;                                     // 0x0370(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HeightWithHint;                                    // 0x0374(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNotificationModel                     NotificationModel;                                 // 0x0378(0x0078)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class FText                                   Play;                                              // 0x03F0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   Stop;                                              // 0x0408(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         OneLineNotificationAlignment;                      // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EHintType, class FString>                HintSIDs;                                          // 0x0428(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         InactiveHintTransparency;                          // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47C[0x54];                                     // 0x047C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetModel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SystemNotificationItem">();
	}
	static class USystemNotificationItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USystemNotificationItem>();
	}
};
static_assert(alignof(USystemNotificationItem) == 0x000008, "Wrong alignment on USystemNotificationItem");
static_assert(sizeof(USystemNotificationItem) == 0x0004D0, "Wrong size on USystemNotificationItem");
static_assert(offsetof(USystemNotificationItem, bWasVoiceNotePlayed) == 0x0002A8, "Member 'USystemNotificationItem::bWasVoiceNotePlayed' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, MoveUpAnim) == 0x0002B0, "Member 'USystemNotificationItem::MoveUpAnim' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, MoveFromDownAnim) == 0x0002B8, "Member 'USystemNotificationItem::MoveFromDownAnim' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, HideAnim) == 0x0002C0, "Member 'USystemNotificationItem::HideAnim' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, AppearAnim) == 0x0002C8, "Member 'USystemNotificationItem::AppearAnim' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, Title) == 0x0002D0, "Member 'USystemNotificationItem::Title' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, Description) == 0x0002D8, "Member 'USystemNotificationItem::Description' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, Hint) == 0x0002E0, "Member 'USystemNotificationItem::Hint' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, Icon) == 0x0002E8, "Member 'USystemNotificationItem::Icon' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, AudiologSwitcher) == 0x0002F0, "Member 'USystemNotificationItem::AudiologSwitcher' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, VoiceHorizontalBox) == 0x0002F8, "Member 'USystemNotificationItem::VoiceHorizontalBox' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, AudiologProgressBar) == 0x000300, "Member 'USystemNotificationItem::AudiologProgressBar' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, AudiologDuration) == 0x000308, "Member 'USystemNotificationItem::AudiologDuration' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, AudiologCurrentDuration) == 0x000310, "Member 'USystemNotificationItem::AudiologCurrentDuration' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, BackgroundBody) == 0x000318, "Member 'USystemNotificationItem::BackgroundBody' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, BackgroundTop) == 0x000320, "Member 'USystemNotificationItem::BackgroundTop' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, BackgroundDown) == 0x000328, "Member 'USystemNotificationItem::BackgroundDown' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, AppearanceLayer) == 0x000330, "Member 'USystemNotificationItem::AppearanceLayer' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, AppearanceLine) == 0x000338, "Member 'USystemNotificationItem::AppearanceLine' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, General) == 0x000340, "Member 'USystemNotificationItem::General' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, green) == 0x000350, "Member 'USystemNotificationItem::green' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, red) == 0x000360, "Member 'USystemNotificationItem::red' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, RegularHeight) == 0x000370, "Member 'USystemNotificationItem::RegularHeight' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, HeightWithHint) == 0x000374, "Member 'USystemNotificationItem::HeightWithHint' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, NotificationModel) == 0x000378, "Member 'USystemNotificationItem::NotificationModel' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, Play) == 0x0003F0, "Member 'USystemNotificationItem::Play' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, Stop) == 0x000408, "Member 'USystemNotificationItem::Stop' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, OneLineNotificationAlignment) == 0x000420, "Member 'USystemNotificationItem::OneLineNotificationAlignment' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, HintSIDs) == 0x000428, "Member 'USystemNotificationItem::HintSIDs' has a wrong offset!");
static_assert(offsetof(USystemNotificationItem, InactiveHintTransparency) == 0x000478, "Member 'USystemNotificationItem::InactiveHintTransparency' has a wrong offset!");

// Class Stalker2.SystemNotificationWidget
// 0x0238 (0x04B0 - 0x0278)
class alignas(0x10) USystemNotificationWidget final : public UWidgetBase
{
public:
	class UVerticalBox*                           VerticalBox;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<ESystemNotificationIconType, TSoftObjectPtr<class UTexture2D>> NotificationIcons;           // 0x0280(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class USystemNotificationItem>    SystemNotificationItemClass;                       // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SystemNotificationsMax;                            // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ItemLifespanByIndex;                               // 0x02E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FString                                 Received;                                          // 0x02F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 Lost;                                              // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 Coordinates;                                       // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 NewNote;                                           // 0x0320(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 NewStash;                                          // 0x0330(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 NewRegionName;                                     // 0x0340(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 NewBlueprint;                                      // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MoneyText;                                         // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 EncyclopediaUpdated;                               // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   TitleFormatForItems;                               // 0x0380(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   TitleFormat;                                       // 0x0398(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x10];                                     // 0x03B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QueueDelay;                                        // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimerRate;                                         // 0x03C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveUpAnimMultiplier;                              // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AppearAnimMultiplier;                              // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HideAnimMultiplier;                                // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         WorldMapStashZoom;                                 // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxTitleLen;                                       // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EndText;                                           // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0xC0];                                     // 0x03F0(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CenterMapOnLocation();
	void InputCancel();
	void NotificationClickHandler();
	void OnSystemNotificationActionCompleted(const struct FNotificationModel& Model);
	void ProceedInput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SystemNotificationWidget">();
	}
	static class USystemNotificationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USystemNotificationWidget>();
	}
};
static_assert(alignof(USystemNotificationWidget) == 0x000010, "Wrong alignment on USystemNotificationWidget");
static_assert(sizeof(USystemNotificationWidget) == 0x0004B0, "Wrong size on USystemNotificationWidget");
static_assert(offsetof(USystemNotificationWidget, VerticalBox) == 0x000278, "Member 'USystemNotificationWidget::VerticalBox' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, NotificationIcons) == 0x000280, "Member 'USystemNotificationWidget::NotificationIcons' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, SystemNotificationItemClass) == 0x0002D0, "Member 'USystemNotificationWidget::SystemNotificationItemClass' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, SystemNotificationsMax) == 0x0002D8, "Member 'USystemNotificationWidget::SystemNotificationsMax' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, ItemLifespanByIndex) == 0x0002E0, "Member 'USystemNotificationWidget::ItemLifespanByIndex' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, Received) == 0x0002F0, "Member 'USystemNotificationWidget::Received' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, Lost) == 0x000300, "Member 'USystemNotificationWidget::Lost' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, Coordinates) == 0x000310, "Member 'USystemNotificationWidget::Coordinates' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, NewNote) == 0x000320, "Member 'USystemNotificationWidget::NewNote' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, NewStash) == 0x000330, "Member 'USystemNotificationWidget::NewStash' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, NewRegionName) == 0x000340, "Member 'USystemNotificationWidget::NewRegionName' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, NewBlueprint) == 0x000350, "Member 'USystemNotificationWidget::NewBlueprint' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, MoneyText) == 0x000360, "Member 'USystemNotificationWidget::MoneyText' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, EncyclopediaUpdated) == 0x000370, "Member 'USystemNotificationWidget::EncyclopediaUpdated' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, TitleFormatForItems) == 0x000380, "Member 'USystemNotificationWidget::TitleFormatForItems' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, TitleFormat) == 0x000398, "Member 'USystemNotificationWidget::TitleFormat' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, QueueDelay) == 0x0003C0, "Member 'USystemNotificationWidget::QueueDelay' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, TimerRate) == 0x0003C4, "Member 'USystemNotificationWidget::TimerRate' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, MoveUpAnimMultiplier) == 0x0003C8, "Member 'USystemNotificationWidget::MoveUpAnimMultiplier' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, AppearAnimMultiplier) == 0x0003CC, "Member 'USystemNotificationWidget::AppearAnimMultiplier' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, HideAnimMultiplier) == 0x0003D0, "Member 'USystemNotificationWidget::HideAnimMultiplier' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, WorldMapStashZoom) == 0x0003D4, "Member 'USystemNotificationWidget::WorldMapStashZoom' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, MaxTitleLen) == 0x0003D8, "Member 'USystemNotificationWidget::MaxTitleLen' has a wrong offset!");
static_assert(offsetof(USystemNotificationWidget, EndText) == 0x0003E0, "Member 'USystemNotificationWidget::EndText' has a wrong offset!");

// Class Stalker2.TacticalFlashlightComponent
// 0x0000 (0x0188 - 0x0188)
class UTacticalFlashlightComponent final : public UFlashlightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TacticalFlashlightComponent">();
	}
	static class UTacticalFlashlightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTacticalFlashlightComponent>();
	}
};
static_assert(alignof(UTacticalFlashlightComponent) == 0x000008, "Wrong alignment on UTacticalFlashlightComponent");
static_assert(sizeof(UTacticalFlashlightComponent) == 0x000188, "Wrong size on UTacticalFlashlightComponent");

// Class Stalker2.TacticalPathfindingTest
// 0x0048 (0x02E0 - 0x0298)
class ATacticalPathfindingTest final : public AActor
{
public:
	double                                        CoversExploreDistance;                             // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ExposedLengthBias;                                 // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ExposedLengthPower;                                // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ConcealedLengthBias;                               // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ConcealedLengthPower;                              // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTacticalNavigation;                            // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAgentType                                    TestingAgentType;                                  // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseSimplifiedCovers;                              // 0x02D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TacticalPathfindingTest">();
	}
	static class ATacticalPathfindingTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATacticalPathfindingTest>();
	}
};
static_assert(alignof(ATacticalPathfindingTest) == 0x000008, "Wrong alignment on ATacticalPathfindingTest");
static_assert(sizeof(ATacticalPathfindingTest) == 0x0002E0, "Wrong size on ATacticalPathfindingTest");
static_assert(offsetof(ATacticalPathfindingTest, CoversExploreDistance) == 0x000298, "Member 'ATacticalPathfindingTest::CoversExploreDistance' has a wrong offset!");
static_assert(offsetof(ATacticalPathfindingTest, ExposedLengthBias) == 0x0002A0, "Member 'ATacticalPathfindingTest::ExposedLengthBias' has a wrong offset!");
static_assert(offsetof(ATacticalPathfindingTest, ExposedLengthPower) == 0x0002A8, "Member 'ATacticalPathfindingTest::ExposedLengthPower' has a wrong offset!");
static_assert(offsetof(ATacticalPathfindingTest, ConcealedLengthBias) == 0x0002B0, "Member 'ATacticalPathfindingTest::ConcealedLengthBias' has a wrong offset!");
static_assert(offsetof(ATacticalPathfindingTest, ConcealedLengthPower) == 0x0002B8, "Member 'ATacticalPathfindingTest::ConcealedLengthPower' has a wrong offset!");
static_assert(offsetof(ATacticalPathfindingTest, bUseTacticalNavigation) == 0x0002C0, "Member 'ATacticalPathfindingTest::bUseTacticalNavigation' has a wrong offset!");
static_assert(offsetof(ATacticalPathfindingTest, TestingAgentType) == 0x0002C4, "Member 'ATacticalPathfindingTest::TestingAgentType' has a wrong offset!");
static_assert(offsetof(ATacticalPathfindingTest, bUseSimplifiedCovers) == 0x0002D8, "Member 'ATacticalPathfindingTest::bUseSimplifiedCovers' has a wrong offset!");

// Class Stalker2.TaskIcon
// 0x0030 (0x02A8 - 0x0278)
class UTaskIcon final : public UWidgetBase
{
public:
	struct FVector2f                              DesiredSize;                                       // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               IconSize;                                          // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SelectedMarker;                                    // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TaskMarker;                                        // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MainQuestColorStyleID;                             // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SecondaryQuestColorStyleID;                        // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaskIcon">();
	}
	static class UTaskIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTaskIcon>();
	}
};
static_assert(alignof(UTaskIcon) == 0x000008, "Wrong alignment on UTaskIcon");
static_assert(sizeof(UTaskIcon) == 0x0002A8, "Wrong size on UTaskIcon");
static_assert(offsetof(UTaskIcon, DesiredSize) == 0x000278, "Member 'UTaskIcon::DesiredSize' has a wrong offset!");
static_assert(offsetof(UTaskIcon, IconSize) == 0x000280, "Member 'UTaskIcon::IconSize' has a wrong offset!");
static_assert(offsetof(UTaskIcon, SelectedMarker) == 0x000288, "Member 'UTaskIcon::SelectedMarker' has a wrong offset!");
static_assert(offsetof(UTaskIcon, TaskMarker) == 0x000290, "Member 'UTaskIcon::TaskMarker' has a wrong offset!");
static_assert(offsetof(UTaskIcon, MainQuestColorStyleID) == 0x000298, "Member 'UTaskIcon::MainQuestColorStyleID' has a wrong offset!");
static_assert(offsetof(UTaskIcon, SecondaryQuestColorStyleID) == 0x0002A0, "Member 'UTaskIcon::SecondaryQuestColorStyleID' has a wrong offset!");

// Class Stalker2.TaskListMenuWidget
// 0x0048 (0x02C0 - 0x0278)
class UTaskListMenuWidget final : public UWidgetBase
{
public:
	struct FVector2f                              WidgetSize;                                        // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               WidgetSizeBox;                                     // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         MainTasksTitle;                                    // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SecondaryTaskTitle;                                // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           MainTasks;                                         // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SecondaryTasks;                                    // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           MainTasksBox;                                      // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SecondaryTasksBox;                                 // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UQuestMenuWidget>           QuestMenuWidgetClass;                              // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaskListMenuWidget">();
	}
	static class UTaskListMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTaskListMenuWidget>();
	}
};
static_assert(alignof(UTaskListMenuWidget) == 0x000008, "Wrong alignment on UTaskListMenuWidget");
static_assert(sizeof(UTaskListMenuWidget) == 0x0002C0, "Wrong size on UTaskListMenuWidget");
static_assert(offsetof(UTaskListMenuWidget, WidgetSize) == 0x000278, "Member 'UTaskListMenuWidget::WidgetSize' has a wrong offset!");
static_assert(offsetof(UTaskListMenuWidget, WidgetSizeBox) == 0x000280, "Member 'UTaskListMenuWidget::WidgetSizeBox' has a wrong offset!");
static_assert(offsetof(UTaskListMenuWidget, MainTasksTitle) == 0x000288, "Member 'UTaskListMenuWidget::MainTasksTitle' has a wrong offset!");
static_assert(offsetof(UTaskListMenuWidget, SecondaryTaskTitle) == 0x000290, "Member 'UTaskListMenuWidget::SecondaryTaskTitle' has a wrong offset!");
static_assert(offsetof(UTaskListMenuWidget, MainTasks) == 0x000298, "Member 'UTaskListMenuWidget::MainTasks' has a wrong offset!");
static_assert(offsetof(UTaskListMenuWidget, SecondaryTasks) == 0x0002A0, "Member 'UTaskListMenuWidget::SecondaryTasks' has a wrong offset!");
static_assert(offsetof(UTaskListMenuWidget, MainTasksBox) == 0x0002A8, "Member 'UTaskListMenuWidget::MainTasksBox' has a wrong offset!");
static_assert(offsetof(UTaskListMenuWidget, SecondaryTasksBox) == 0x0002B0, "Member 'UTaskListMenuWidget::SecondaryTasksBox' has a wrong offset!");
static_assert(offsetof(UTaskListMenuWidget, QuestMenuWidgetClass) == 0x0002B8, "Member 'UTaskListMenuWidget::QuestMenuWidgetClass' has a wrong offset!");

// Class Stalker2.TaskMenuWidget
// 0x0038 (0x02B0 - 0x0278)
class UTaskMenuWidget final : public UWidgetBase
{
public:
	class UTaskIcon*                              TaskIcon;                                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            TaskText;                                          // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 OptionalPostfixSID;                                // 0x0288(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaskMenuWidget">();
	}
	static class UTaskMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTaskMenuWidget>();
	}
};
static_assert(alignof(UTaskMenuWidget) == 0x000008, "Wrong alignment on UTaskMenuWidget");
static_assert(sizeof(UTaskMenuWidget) == 0x0002B0, "Wrong size on UTaskMenuWidget");
static_assert(offsetof(UTaskMenuWidget, TaskIcon) == 0x000278, "Member 'UTaskMenuWidget::TaskIcon' has a wrong offset!");
static_assert(offsetof(UTaskMenuWidget, TaskText) == 0x000280, "Member 'UTaskMenuWidget::TaskText' has a wrong offset!");
static_assert(offsetof(UTaskMenuWidget, OptionalPostfixSID) == 0x000288, "Member 'UTaskMenuWidget::OptionalPostfixSID' has a wrong offset!");

// Class Stalker2.Teleport
// 0x01E8 (0x0480 - 0x0298)
class ATeleport final : public AActor
{
public:
	class USceneComponent*                        DefaultRoot;                                       // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          EnterPoint;                                        // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      TeleportVFX;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      TeleportActivationVFX;                             // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           TeleportAudioComponent;                            // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignalSenderComponent*                 PostTeleportSignalSender;                          // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           TeleportIdleEvent;                                 // 0x02C8(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           TeleportInEvent;                                   // 0x02F8(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAkAudioEvent>           TeleportOutEvent;                                  // 0x0328(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPrototypeSID                          TeleportPrototypeSID;                              // 0x0358(0x0040)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EndPoint;                                          // 0x03A0(0x0060)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSafeTeleport;                                     // 0x0400(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_401[0x3];                                      // 0x0401(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActiveParticleDuration;                            // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x78];                                     // 0x0408(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Teleport">();
	}
	static class ATeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeleport>();
	}
};
static_assert(alignof(ATeleport) == 0x000010, "Wrong alignment on ATeleport");
static_assert(sizeof(ATeleport) == 0x000480, "Wrong size on ATeleport");
static_assert(offsetof(ATeleport, DefaultRoot) == 0x000298, "Member 'ATeleport::DefaultRoot' has a wrong offset!");
static_assert(offsetof(ATeleport, EnterPoint) == 0x0002A0, "Member 'ATeleport::EnterPoint' has a wrong offset!");
static_assert(offsetof(ATeleport, TeleportVFX) == 0x0002A8, "Member 'ATeleport::TeleportVFX' has a wrong offset!");
static_assert(offsetof(ATeleport, TeleportActivationVFX) == 0x0002B0, "Member 'ATeleport::TeleportActivationVFX' has a wrong offset!");
static_assert(offsetof(ATeleport, TeleportAudioComponent) == 0x0002B8, "Member 'ATeleport::TeleportAudioComponent' has a wrong offset!");
static_assert(offsetof(ATeleport, PostTeleportSignalSender) == 0x0002C0, "Member 'ATeleport::PostTeleportSignalSender' has a wrong offset!");
static_assert(offsetof(ATeleport, TeleportIdleEvent) == 0x0002C8, "Member 'ATeleport::TeleportIdleEvent' has a wrong offset!");
static_assert(offsetof(ATeleport, TeleportInEvent) == 0x0002F8, "Member 'ATeleport::TeleportInEvent' has a wrong offset!");
static_assert(offsetof(ATeleport, TeleportOutEvent) == 0x000328, "Member 'ATeleport::TeleportOutEvent' has a wrong offset!");
static_assert(offsetof(ATeleport, TeleportPrototypeSID) == 0x000358, "Member 'ATeleport::TeleportPrototypeSID' has a wrong offset!");
static_assert(offsetof(ATeleport, EndPoint) == 0x0003A0, "Member 'ATeleport::EndPoint' has a wrong offset!");
static_assert(offsetof(ATeleport, bSafeTeleport) == 0x000400, "Member 'ATeleport::bSafeTeleport' has a wrong offset!");
static_assert(offsetof(ATeleport, ActiveParticleDuration) == 0x000404, "Member 'ATeleport::ActiveParticleDuration' has a wrong offset!");

// Class Stalker2.TeleportManager
// 0x0130 (0x01A8 - 0x0078)
class UTeleportManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x130];                                     // 0x0078(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportManager">();
	}
	static class UTeleportManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeleportManager>();
	}
};
static_assert(alignof(UTeleportManager) == 0x000008, "Wrong alignment on UTeleportManager");
static_assert(sizeof(UTeleportManager) == 0x0001A8, "Wrong size on UTeleportManager");

// Class Stalker2.TeleportPoint
// 0x0020 (0x02B8 - 0x0298)
class ATeleportPoint final : public AActor
{
public:
	class FString                                 Name_0;                                            // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBillboardComponent*                    SpriteComponent;                                   // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArrowComponent*                        ArrowComponent;                                    // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportPoint">();
	}
	static class ATeleportPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeleportPoint>();
	}
};
static_assert(alignof(ATeleportPoint) == 0x000008, "Wrong alignment on ATeleportPoint");
static_assert(sizeof(ATeleportPoint) == 0x0002B8, "Wrong size on ATeleportPoint");
static_assert(offsetof(ATeleportPoint, Name_0) == 0x000298, "Member 'ATeleportPoint::Name_0' has a wrong offset!");
static_assert(offsetof(ATeleportPoint, SpriteComponent) == 0x0002A8, "Member 'ATeleportPoint::SpriteComponent' has a wrong offset!");
static_assert(offsetof(ATeleportPoint, ArrowComponent) == 0x0002B0, "Member 'ATeleportPoint::ArrowComponent' has a wrong offset!");

// Class Stalker2.TextureTools
// 0x0000 (0x00A0 - 0x00A0)
class UTextureTools final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextureTools">();
	}
	static class UTextureTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextureTools>();
	}
};
static_assert(alignof(UTextureTools) == 0x000008, "Wrong alignment on UTextureTools");
static_assert(sizeof(UTextureTools) == 0x0000A0, "Wrong size on UTextureTools");

// Class Stalker2.TextWidget
// 0x0438 (0x06F0 - 0x02B8)
class UTextWidget : public ULocalizationWidget
{
public:
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultWrapText;                                   // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DefaultText;                                       // 0x02D8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bUseWrappingFromStyle;                             // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStyleManager;                               // 0x02F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F2[0xE];                                      // 0x02F2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTextSettings                          TextSettings;                                      // 0x0300(0x03C0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEnableScroll;                                     // 0x06C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C1[0x7];                                      // 0x06C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonTextBlock*                       CommonTextObj;                                     // 0x06C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlotScaleSettings                     TextScaleSettings;                                 // 0x06D0(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E4[0xC];                                      // 0x06E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetText();
	void SetText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextWidget">();
	}
	static class UTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextWidget>();
	}
};
static_assert(alignof(UTextWidget) == 0x000010, "Wrong alignment on UTextWidget");
static_assert(sizeof(UTextWidget) == 0x0006F0, "Wrong size on UTextWidget");
static_assert(offsetof(UTextWidget, DefaultWrapText) == 0x0002D0, "Member 'UTextWidget::DefaultWrapText' has a wrong offset!");
static_assert(offsetof(UTextWidget, DefaultText) == 0x0002D8, "Member 'UTextWidget::DefaultText' has a wrong offset!");
static_assert(offsetof(UTextWidget, bUseWrappingFromStyle) == 0x0002F0, "Member 'UTextWidget::bUseWrappingFromStyle' has a wrong offset!");
static_assert(offsetof(UTextWidget, bEnableStyleManager) == 0x0002F1, "Member 'UTextWidget::bEnableStyleManager' has a wrong offset!");
static_assert(offsetof(UTextWidget, TextSettings) == 0x000300, "Member 'UTextWidget::TextSettings' has a wrong offset!");
static_assert(offsetof(UTextWidget, bEnableScroll) == 0x0006C0, "Member 'UTextWidget::bEnableScroll' has a wrong offset!");
static_assert(offsetof(UTextWidget, CommonTextObj) == 0x0006C8, "Member 'UTextWidget::CommonTextObj' has a wrong offset!");
static_assert(offsetof(UTextWidget, TextScaleSettings) == 0x0006D0, "Member 'UTextWidget::TextScaleSettings' has a wrong offset!");

// Class Stalker2.ThreatIndicator
// 0x0068 (0x02E0 - 0x0278)
class UThreatIndicator final : public UChildViewBase
{
public:
	class UOverlay*                               ThreatsOverlay;                                    // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThreatIndicatorShowDistance;                       // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ThreatPointerCap;                                  // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FThreatPointerSettings                 ThreatPointerSettings;                             // 0x0288(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ThreatsUpdateInterval;                             // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UThreatPointer>             ThreatPointerWidgetClass;                          // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UThreatPointer*>                 ActiveThreatPointers;                              // 0x02B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x18];                                     // 0x02C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThreatIndicator">();
	}
	static class UThreatIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreatIndicator>();
	}
};
static_assert(alignof(UThreatIndicator) == 0x000008, "Wrong alignment on UThreatIndicator");
static_assert(sizeof(UThreatIndicator) == 0x0002E0, "Wrong size on UThreatIndicator");
static_assert(offsetof(UThreatIndicator, ThreatsOverlay) == 0x000278, "Member 'UThreatIndicator::ThreatsOverlay' has a wrong offset!");
static_assert(offsetof(UThreatIndicator, ThreatIndicatorShowDistance) == 0x000280, "Member 'UThreatIndicator::ThreatIndicatorShowDistance' has a wrong offset!");
static_assert(offsetof(UThreatIndicator, ThreatPointerCap) == 0x000284, "Member 'UThreatIndicator::ThreatPointerCap' has a wrong offset!");
static_assert(offsetof(UThreatIndicator, ThreatPointerSettings) == 0x000288, "Member 'UThreatIndicator::ThreatPointerSettings' has a wrong offset!");
static_assert(offsetof(UThreatIndicator, ThreatsUpdateInterval) == 0x0002A8, "Member 'UThreatIndicator::ThreatsUpdateInterval' has a wrong offset!");
static_assert(offsetof(UThreatIndicator, ThreatPointerWidgetClass) == 0x0002B0, "Member 'UThreatIndicator::ThreatPointerWidgetClass' has a wrong offset!");
static_assert(offsetof(UThreatIndicator, ActiveThreatPointers) == 0x0002B8, "Member 'UThreatIndicator::ActiveThreatPointers' has a wrong offset!");

// Class Stalker2.ThreatPointer
// 0x0050 (0x02C8 - 0x0278)
class UThreatPointer final : public UWidgetBase
{
public:
	class UWidgetAnimation*                       AlertAnimation;                                    // 0x0278(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ThreatLevelVisualizer;                             // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               CircleSize;                                        // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x38];                                     // 0x0290(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThreatPointer">();
	}
	static class UThreatPointer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreatPointer>();
	}
};
static_assert(alignof(UThreatPointer) == 0x000008, "Wrong alignment on UThreatPointer");
static_assert(sizeof(UThreatPointer) == 0x0002C8, "Wrong size on UThreatPointer");
static_assert(offsetof(UThreatPointer, AlertAnimation) == 0x000278, "Member 'UThreatPointer::AlertAnimation' has a wrong offset!");
static_assert(offsetof(UThreatPointer, ThreatLevelVisualizer) == 0x000280, "Member 'UThreatPointer::ThreatLevelVisualizer' has a wrong offset!");
static_assert(offsetof(UThreatPointer, CircleSize) == 0x000288, "Member 'UThreatPointer::CircleSize' has a wrong offset!");

// Class Stalker2.TilingGridBack
// 0x0020 (0x0298 - 0x0278)
class UTilingGridBack final : public UUserWidget
{
public:
	class USizeBox*                               FullSizeBox;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              VisibleSize;                                       // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BorderSize;                                        // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TilingGridBack">();
	}
	static class UTilingGridBack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTilingGridBack>();
	}
};
static_assert(alignof(UTilingGridBack) == 0x000008, "Wrong alignment on UTilingGridBack");
static_assert(sizeof(UTilingGridBack) == 0x000298, "Wrong size on UTilingGridBack");
static_assert(offsetof(UTilingGridBack, FullSizeBox) == 0x000278, "Member 'UTilingGridBack::FullSizeBox' has a wrong offset!");
static_assert(offsetof(UTilingGridBack, VisibleSize) == 0x000280, "Member 'UTilingGridBack::VisibleSize' has a wrong offset!");
static_assert(offsetof(UTilingGridBack, BorderSize) == 0x000290, "Member 'UTilingGridBack::BorderSize' has a wrong offset!");

// Class Stalker2.TimeManager
// 0x00C0 (0x0138 - 0x0078)
class UTimeManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x1];                                       // 0x0078(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsPaused;                                         // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              CurrentDate;                                       // 0x0080(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDateTime                              WeatherDate;                                       // 0x0088(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        GameTimeSecondsDouble;                             // 0x0090(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        WeatherTimeSeconds;                                // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        GameTimeSeconds;                                   // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RealTime;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastTickDeltaTimeNormalized;                       // 0x00AC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CustomDeltaTime;                                   // 0x00B0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpeedFactor;                                       // 0x00B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WeatherSpeedFactor;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FrameRate;                                         // 0x00BC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         TickCounter;                                       // 0x00C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FixedFPS;                                          // 0x00C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GameHours;                                         // 0x00CC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GameMinutes;                                       // 0x00D0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GameSecondsClamped;                                // 0x00D4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDay;                                              // 0x00D8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartDate;                                         // 0x00E0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         UnixTime;                                          // 0x00E8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         LastUnixTimeUpdateTick;                            // 0x00F0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            WeatherTimeCoefficientCurve;                       // 0x00F8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x38];                                     // 0x0100(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeManager">();
	}
	static class UTimeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeManager>();
	}
};
static_assert(alignof(UTimeManager) == 0x000008, "Wrong alignment on UTimeManager");
static_assert(sizeof(UTimeManager) == 0x000138, "Wrong size on UTimeManager");
static_assert(offsetof(UTimeManager, bIsPaused) == 0x000079, "Member 'UTimeManager::bIsPaused' has a wrong offset!");
static_assert(offsetof(UTimeManager, CurrentDate) == 0x000080, "Member 'UTimeManager::CurrentDate' has a wrong offset!");
static_assert(offsetof(UTimeManager, WeatherDate) == 0x000088, "Member 'UTimeManager::WeatherDate' has a wrong offset!");
static_assert(offsetof(UTimeManager, GameTimeSecondsDouble) == 0x000090, "Member 'UTimeManager::GameTimeSecondsDouble' has a wrong offset!");
static_assert(offsetof(UTimeManager, WeatherTimeSeconds) == 0x000098, "Member 'UTimeManager::WeatherTimeSeconds' has a wrong offset!");
static_assert(offsetof(UTimeManager, GameTimeSeconds) == 0x0000A0, "Member 'UTimeManager::GameTimeSeconds' has a wrong offset!");
static_assert(offsetof(UTimeManager, RealTime) == 0x0000A8, "Member 'UTimeManager::RealTime' has a wrong offset!");
static_assert(offsetof(UTimeManager, LastTickDeltaTimeNormalized) == 0x0000AC, "Member 'UTimeManager::LastTickDeltaTimeNormalized' has a wrong offset!");
static_assert(offsetof(UTimeManager, CustomDeltaTime) == 0x0000B0, "Member 'UTimeManager::CustomDeltaTime' has a wrong offset!");
static_assert(offsetof(UTimeManager, SpeedFactor) == 0x0000B4, "Member 'UTimeManager::SpeedFactor' has a wrong offset!");
static_assert(offsetof(UTimeManager, WeatherSpeedFactor) == 0x0000B8, "Member 'UTimeManager::WeatherSpeedFactor' has a wrong offset!");
static_assert(offsetof(UTimeManager, FrameRate) == 0x0000BC, "Member 'UTimeManager::FrameRate' has a wrong offset!");
static_assert(offsetof(UTimeManager, TickCounter) == 0x0000C0, "Member 'UTimeManager::TickCounter' has a wrong offset!");
static_assert(offsetof(UTimeManager, FixedFPS) == 0x0000C8, "Member 'UTimeManager::FixedFPS' has a wrong offset!");
static_assert(offsetof(UTimeManager, GameHours) == 0x0000CC, "Member 'UTimeManager::GameHours' has a wrong offset!");
static_assert(offsetof(UTimeManager, GameMinutes) == 0x0000D0, "Member 'UTimeManager::GameMinutes' has a wrong offset!");
static_assert(offsetof(UTimeManager, GameSecondsClamped) == 0x0000D4, "Member 'UTimeManager::GameSecondsClamped' has a wrong offset!");
static_assert(offsetof(UTimeManager, bDay) == 0x0000D8, "Member 'UTimeManager::bDay' has a wrong offset!");
static_assert(offsetof(UTimeManager, StartDate) == 0x0000E0, "Member 'UTimeManager::StartDate' has a wrong offset!");
static_assert(offsetof(UTimeManager, UnixTime) == 0x0000E8, "Member 'UTimeManager::UnixTime' has a wrong offset!");
static_assert(offsetof(UTimeManager, LastUnixTimeUpdateTick) == 0x0000F0, "Member 'UTimeManager::LastUnixTimeUpdateTick' has a wrong offset!");
static_assert(offsetof(UTimeManager, WeatherTimeCoefficientCurve) == 0x0000F8, "Member 'UTimeManager::WeatherTimeCoefficientCurve' has a wrong offset!");

// Class Stalker2.TimeoutSpeechComponent
// 0x0010 (0x0090 - 0x0080)
class UTimeoutSpeechComponent final : public USpeechComponent
{
public:
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeoutSpeechComponent">();
	}
	static class UTimeoutSpeechComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeoutSpeechComponent>();
	}
};
static_assert(alignof(UTimeoutSpeechComponent) == 0x000008, "Wrong alignment on UTimeoutSpeechComponent");
static_assert(sizeof(UTimeoutSpeechComponent) == 0x000090, "Wrong size on UTimeoutSpeechComponent");

// Class Stalker2.ToggleButton
// 0x00C8 (0x0340 - 0x0278)
class UToggleButton final : public ULockableComponent
{
public:
	float                                         CurrentValue;                                      // 0x0278(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldConsumeItemOnOpen;                          // 0x027C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseInBothSides;                                   // 0x027D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27E[0x2];                                      // 0x027E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   ToggleButtonHandleMesh;                            // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ToggleButtonCurve;                                 // 0x0288(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ToggleButtonCurveReverse;                          // 0x0290(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0xA8];                                     // 0x0298(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeToggleButtonPosition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToggleButton">();
	}
	static class UToggleButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToggleButton>();
	}
};
static_assert(alignof(UToggleButton) == 0x000008, "Wrong alignment on UToggleButton");
static_assert(sizeof(UToggleButton) == 0x000340, "Wrong size on UToggleButton");
static_assert(offsetof(UToggleButton, CurrentValue) == 0x000278, "Member 'UToggleButton::CurrentValue' has a wrong offset!");
static_assert(offsetof(UToggleButton, bShouldConsumeItemOnOpen) == 0x00027C, "Member 'UToggleButton::bShouldConsumeItemOnOpen' has a wrong offset!");
static_assert(offsetof(UToggleButton, bUseInBothSides) == 0x00027D, "Member 'UToggleButton::bUseInBothSides' has a wrong offset!");
static_assert(offsetof(UToggleButton, ToggleButtonHandleMesh) == 0x000280, "Member 'UToggleButton::ToggleButtonHandleMesh' has a wrong offset!");
static_assert(offsetof(UToggleButton, ToggleButtonCurve) == 0x000288, "Member 'UToggleButton::ToggleButtonCurve' has a wrong offset!");
static_assert(offsetof(UToggleButton, ToggleButtonCurveReverse) == 0x000290, "Member 'UToggleButton::ToggleButtonCurveReverse' has a wrong offset!");

// Class Stalker2.ToggleHeldItemIPU
// 0x0000 (0x0040 - 0x0040)
class UToggleHeldItemIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToggleHeldItemIPU">();
	}
	static class UToggleHeldItemIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToggleHeldItemIPU>();
	}
};
static_assert(alignof(UToggleHeldItemIPU) == 0x000008, "Wrong alignment on UToggleHeldItemIPU");
static_assert(sizeof(UToggleHeldItemIPU) == 0x000040, "Wrong size on UToggleHeldItemIPU");

// Class Stalker2.TopazScanner
// 0x01D8 (0x04C0 - 0x02E8)
class ATopazScanner final : public AInteractableObject
{
public:
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    InvisibleScannerCollision;                         // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTopazSingleClickComponent*             SingleClickComponent;                              // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTopazScannerComponent*                 ScannerComponent;                                  // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrototypeSID                          RewardItemSID;                                     // 0x0308(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStationary;                                       // 0x0348(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTopazScannerVFX                       InactiveVFX;                                       // 0x0350(0x00A0)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FTopazScannerVFX                       ActiveVFX;                                         // 0x03F0(0x00A0)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         SievertsCenterValue;                               // 0x0490(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SievertsDeviation;                                 // 0x0494(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SievertsChangeFrequency;                           // 0x0498(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSuccessfulScanner;                                // 0x049C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49D[0x23];                                     // 0x049D(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStateChanged(const ETopazScannerState NewState);

	bool IsStationary() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TopazScanner">();
	}
	static class ATopazScanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATopazScanner>();
	}
};
static_assert(alignof(ATopazScanner) == 0x000010, "Wrong alignment on ATopazScanner");
static_assert(sizeof(ATopazScanner) == 0x0004C0, "Wrong size on ATopazScanner");
static_assert(offsetof(ATopazScanner, SkeletalMesh) == 0x0002E8, "Member 'ATopazScanner::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ATopazScanner, InvisibleScannerCollision) == 0x0002F0, "Member 'ATopazScanner::InvisibleScannerCollision' has a wrong offset!");
static_assert(offsetof(ATopazScanner, SingleClickComponent) == 0x0002F8, "Member 'ATopazScanner::SingleClickComponent' has a wrong offset!");
static_assert(offsetof(ATopazScanner, ScannerComponent) == 0x000300, "Member 'ATopazScanner::ScannerComponent' has a wrong offset!");
static_assert(offsetof(ATopazScanner, RewardItemSID) == 0x000308, "Member 'ATopazScanner::RewardItemSID' has a wrong offset!");
static_assert(offsetof(ATopazScanner, bStationary) == 0x000348, "Member 'ATopazScanner::bStationary' has a wrong offset!");
static_assert(offsetof(ATopazScanner, InactiveVFX) == 0x000350, "Member 'ATopazScanner::InactiveVFX' has a wrong offset!");
static_assert(offsetof(ATopazScanner, ActiveVFX) == 0x0003F0, "Member 'ATopazScanner::ActiveVFX' has a wrong offset!");
static_assert(offsetof(ATopazScanner, SievertsCenterValue) == 0x000490, "Member 'ATopazScanner::SievertsCenterValue' has a wrong offset!");
static_assert(offsetof(ATopazScanner, SievertsDeviation) == 0x000494, "Member 'ATopazScanner::SievertsDeviation' has a wrong offset!");
static_assert(offsetof(ATopazScanner, SievertsChangeFrequency) == 0x000498, "Member 'ATopazScanner::SievertsChangeFrequency' has a wrong offset!");
static_assert(offsetof(ATopazScanner, bSuccessfulScanner) == 0x00049C, "Member 'ATopazScanner::bSuccessfulScanner' has a wrong offset!");

// Class Stalker2.TouchComponent
// 0x0008 (0x00A8 - 0x00A0)
class UTouchComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TouchComponent">();
	}
	static class UTouchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTouchComponent>();
	}
};
static_assert(alignof(UTouchComponent) == 0x000008, "Wrong alignment on UTouchComponent");
static_assert(sizeof(UTouchComponent) == 0x0000A8, "Wrong size on UTouchComponent");

// Class Stalker2.ToxicCloudAnomaly
// 0x0080 (0x0418 - 0x0398)
class AToxicCloudAnomaly final : public AAnomaly
{
public:
	uint8                                         Pad_398[0x38];                                     // 0x0398(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   CollisionMesh;                                     // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      CloudParticle;                                     // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ImpactParticle;                                    // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHittableComponent*                     HittableComponent;                                 // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ToxicCloudSoundEvent;                              // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AppearSoundEvent;                                  // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          DisappearSoundEvent;                               // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x10];                                     // 0x0408(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToxicCloudAnomaly">();
	}
	static class AToxicCloudAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AToxicCloudAnomaly>();
	}
};
static_assert(alignof(AToxicCloudAnomaly) == 0x000008, "Wrong alignment on AToxicCloudAnomaly");
static_assert(sizeof(AToxicCloudAnomaly) == 0x000418, "Wrong size on AToxicCloudAnomaly");
static_assert(offsetof(AToxicCloudAnomaly, CollisionMesh) == 0x0003D0, "Member 'AToxicCloudAnomaly::CollisionMesh' has a wrong offset!");
static_assert(offsetof(AToxicCloudAnomaly, CloudParticle) == 0x0003D8, "Member 'AToxicCloudAnomaly::CloudParticle' has a wrong offset!");
static_assert(offsetof(AToxicCloudAnomaly, ImpactParticle) == 0x0003E0, "Member 'AToxicCloudAnomaly::ImpactParticle' has a wrong offset!");
static_assert(offsetof(AToxicCloudAnomaly, HittableComponent) == 0x0003E8, "Member 'AToxicCloudAnomaly::HittableComponent' has a wrong offset!");
static_assert(offsetof(AToxicCloudAnomaly, ToxicCloudSoundEvent) == 0x0003F0, "Member 'AToxicCloudAnomaly::ToxicCloudSoundEvent' has a wrong offset!");
static_assert(offsetof(AToxicCloudAnomaly, AppearSoundEvent) == 0x0003F8, "Member 'AToxicCloudAnomaly::AppearSoundEvent' has a wrong offset!");
static_assert(offsetof(AToxicCloudAnomaly, DisappearSoundEvent) == 0x000400, "Member 'AToxicCloudAnomaly::DisappearSoundEvent' has a wrong offset!");

// Class Stalker2.AchievementTracker_DoStealthKills
// 0x0008 (0x0040 - 0x0038)
class UAchievementTracker_DoStealthKills final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_DoStealthKills">();
	}
	static class UAchievementTracker_DoStealthKills* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_DoStealthKills>();
	}
};
static_assert(alignof(UAchievementTracker_DoStealthKills) == 0x000008, "Wrong alignment on UAchievementTracker_DoStealthKills");
static_assert(sizeof(UAchievementTracker_DoStealthKills) == 0x000040, "Wrong size on UAchievementTracker_DoStealthKills");

// Class Stalker2.AchievementTracker_DoHeadshots
// 0x0008 (0x0040 - 0x0038)
class UAchievementTracker_DoHeadshots final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_DoHeadshots">();
	}
	static class UAchievementTracker_DoHeadshots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_DoHeadshots>();
	}
};
static_assert(alignof(UAchievementTracker_DoHeadshots) == 0x000008, "Wrong alignment on UAchievementTracker_DoHeadshots");
static_assert(sizeof(UAchievementTracker_DoHeadshots) == 0x000040, "Wrong size on UAchievementTracker_DoHeadshots");

// Class Stalker2.AchievementTracker_PurchaseUpgrade
// 0x0008 (0x0040 - 0x0038)
class UAchievementTracker_PurchaseUpgrade final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_PurchaseUpgrade">();
	}
	static class UAchievementTracker_PurchaseUpgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_PurchaseUpgrade>();
	}
};
static_assert(alignof(UAchievementTracker_PurchaseUpgrade) == 0x000008, "Wrong alignment on UAchievementTracker_PurchaseUpgrade");
static_assert(sizeof(UAchievementTracker_PurchaseUpgrade) == 0x000040, "Wrong size on UAchievementTracker_PurchaseUpgrade");

// Class Stalker2.AchievementTracker_RoyalFlush
// 0x0028 (0x0060 - 0x0038)
class UAchievementTracker_RoyalFlush final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_RoyalFlush">();
	}
	static class UAchievementTracker_RoyalFlush* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_RoyalFlush>();
	}
};
static_assert(alignof(UAchievementTracker_RoyalFlush) == 0x000008, "Wrong alignment on UAchievementTracker_RoyalFlush");
static_assert(sizeof(UAchievementTracker_RoyalFlush) == 0x000060, "Wrong size on UAchievementTracker_RoyalFlush");

// Class Stalker2.AchievementTracker_MutantHunter
// 0x0058 (0x0090 - 0x0038)
class UAchievementTracker_MutantHunter final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_MutantHunter">();
	}
	static class UAchievementTracker_MutantHunter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_MutantHunter>();
	}
};
static_assert(alignof(UAchievementTracker_MutantHunter) == 0x000008, "Wrong alignment on UAchievementTracker_MutantHunter");
static_assert(sizeof(UAchievementTracker_MutantHunter) == 0x000090, "Wrong size on UAchievementTracker_MutantHunter");

// Class Stalker2.AchievementTracker_BreakEquipment
// 0x0008 (0x0040 - 0x0038)
class UAchievementTracker_BreakEquipment final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_BreakEquipment">();
	}
	static class UAchievementTracker_BreakEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_BreakEquipment>();
	}
};
static_assert(alignof(UAchievementTracker_BreakEquipment) == 0x000008, "Wrong alignment on UAchievementTracker_BreakEquipment");
static_assert(sizeof(UAchievementTracker_BreakEquipment) == 0x000040, "Wrong size on UAchievementTracker_BreakEquipment");

// Class Stalker2.AchievementTracker_Demoman
// 0x0008 (0x0040 - 0x0038)
class UAchievementTracker_Demoman final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_Demoman">();
	}
	static class UAchievementTracker_Demoman* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_Demoman>();
	}
};
static_assert(alignof(UAchievementTracker_Demoman) == 0x000008, "Wrong alignment on UAchievementTracker_Demoman");
static_assert(sizeof(UAchievementTracker_Demoman) == 0x000040, "Wrong size on UAchievementTracker_Demoman");

// Class Stalker2.AchievementTracker_ArtiHoarder
// 0x0000 (0x0090 - 0x0090)
class UAchievementTracker_ArtiHoarder final : public UAchievementTracker_ArtifactBaseHoarder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_ArtiHoarder">();
	}
	static class UAchievementTracker_ArtiHoarder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_ArtiHoarder>();
	}
};
static_assert(alignof(UAchievementTracker_ArtiHoarder) == 0x000008, "Wrong alignment on UAchievementTracker_ArtiHoarder");
static_assert(sizeof(UAchievementTracker_ArtiHoarder) == 0x000090, "Wrong size on UAchievementTracker_ArtiHoarder");

// Class Stalker2.AchievementTracker_ArchiHoarder
// 0x0000 (0x0090 - 0x0090)
class UAchievementTracker_ArchiHoarder final : public UAchievementTracker_ArtifactBaseHoarder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_ArchiHoarder">();
	}
	static class UAchievementTracker_ArchiHoarder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_ArchiHoarder>();
	}
};
static_assert(alignof(UAchievementTracker_ArchiHoarder) == 0x000008, "Wrong alignment on UAchievementTracker_ArchiHoarder");
static_assert(sizeof(UAchievementTracker_ArchiHoarder) == 0x000090, "Wrong size on UAchievementTracker_ArchiHoarder");

// Class Stalker2.AchievementTracker_BlueHoarder
// 0x0000 (0x0090 - 0x0090)
class UAchievementTracker_BlueHoarder final : public UAchievementTracker_HoarderBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_BlueHoarder">();
	}
	static class UAchievementTracker_BlueHoarder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_BlueHoarder>();
	}
};
static_assert(alignof(UAchievementTracker_BlueHoarder) == 0x000008, "Wrong alignment on UAchievementTracker_BlueHoarder");
static_assert(sizeof(UAchievementTracker_BlueHoarder) == 0x000090, "Wrong size on UAchievementTracker_BlueHoarder");

// Class Stalker2.AchievementTracker_Discovery
// 0x0058 (0x0090 - 0x0038)
class UAchievementTracker_Discovery final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_Discovery">();
	}
	static class UAchievementTracker_Discovery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_Discovery>();
	}
};
static_assert(alignof(UAchievementTracker_Discovery) == 0x000008, "Wrong alignment on UAchievementTracker_Discovery");
static_assert(sizeof(UAchievementTracker_Discovery) == 0x000090, "Wrong size on UAchievementTracker_Discovery");

// Class Stalker2.AchievementTracker_LonerShooter
// 0x0010 (0x0048 - 0x0038)
class UAchievementTracker_LonerShooter final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_LonerShooter">();
	}
	static class UAchievementTracker_LonerShooter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_LonerShooter>();
	}
};
static_assert(alignof(UAchievementTracker_LonerShooter) == 0x000008, "Wrong alignment on UAchievementTracker_LonerShooter");
static_assert(sizeof(UAchievementTracker_LonerShooter) == 0x000048, "Wrong size on UAchievementTracker_LonerShooter");

// Class Stalker2.AchievementTracker_NoObstacleTooBig
// 0x0008 (0x0040 - 0x0038)
class UAchievementTracker_NoObstacleTooBig final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_NoObstacleTooBig">();
	}
	static class UAchievementTracker_NoObstacleTooBig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_NoObstacleTooBig>();
	}
};
static_assert(alignof(UAchievementTracker_NoObstacleTooBig) == 0x000008, "Wrong alignment on UAchievementTracker_NoObstacleTooBig");
static_assert(sizeof(UAchievementTracker_NoObstacleTooBig) == 0x000040, "Wrong size on UAchievementTracker_NoObstacleTooBig");

// Class Stalker2.AchievementTracker_DrunkMaster
// 0x0010 (0x0048 - 0x0038)
class UAchievementTracker_DrunkMaster final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_DrunkMaster">();
	}
	static class UAchievementTracker_DrunkMaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_DrunkMaster>();
	}
};
static_assert(alignof(UAchievementTracker_DrunkMaster) == 0x000008, "Wrong alignment on UAchievementTracker_DrunkMaster");
static_assert(sizeof(UAchievementTracker_DrunkMaster) == 0x000048, "Wrong size on UAchievementTracker_DrunkMaster");

// Class Stalker2.AchievementTracker_MerryGoRound
// 0x0008 (0x0040 - 0x0038)
class UAchievementTracker_MerryGoRound final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_MerryGoRound">();
	}
	static class UAchievementTracker_MerryGoRound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_MerryGoRound>();
	}
};
static_assert(alignof(UAchievementTracker_MerryGoRound) == 0x000008, "Wrong alignment on UAchievementTracker_MerryGoRound");
static_assert(sizeof(UAchievementTracker_MerryGoRound) == 0x000040, "Wrong size on UAchievementTracker_MerryGoRound");

// Class Stalker2.AchievementTracker_WipedOut
// 0x0020 (0x0058 - 0x0038)
class UAchievementTracker_WipedOut final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_WipedOut">();
	}
	static class UAchievementTracker_WipedOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_WipedOut>();
	}
};
static_assert(alignof(UAchievementTracker_WipedOut) == 0x000008, "Wrong alignment on UAchievementTracker_WipedOut");
static_assert(sizeof(UAchievementTracker_WipedOut) == 0x000058, "Wrong size on UAchievementTracker_WipedOut");

// Class Stalker2.AchievementTracker_CanOpener
// 0x0018 (0x0050 - 0x0038)
class UAchievementTracker_CanOpener final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_CanOpener">();
	}
	static class UAchievementTracker_CanOpener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_CanOpener>();
	}
};
static_assert(alignof(UAchievementTracker_CanOpener) == 0x000008, "Wrong alignment on UAchievementTracker_CanOpener");
static_assert(sizeof(UAchievementTracker_CanOpener) == 0x000050, "Wrong size on UAchievementTracker_CanOpener");

// Class Stalker2.AchievementTracker_CouponsToBurn
// 0x0008 (0x0040 - 0x0038)
class UAchievementTracker_CouponsToBurn final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_CouponsToBurn">();
	}
	static class UAchievementTracker_CouponsToBurn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_CouponsToBurn>();
	}
};
static_assert(alignof(UAchievementTracker_CouponsToBurn) == 0x000008, "Wrong alignment on UAchievementTracker_CouponsToBurn");
static_assert(sizeof(UAchievementTracker_CouponsToBurn) == 0x000040, "Wrong size on UAchievementTracker_CouponsToBurn");

// Class Stalker2.AchievementTracker_Bouncy
// 0x0010 (0x0048 - 0x0038)
class UAchievementTracker_Bouncy final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_Bouncy">();
	}
	static class UAchievementTracker_Bouncy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_Bouncy>();
	}
};
static_assert(alignof(UAchievementTracker_Bouncy) == 0x000008, "Wrong alignment on UAchievementTracker_Bouncy");
static_assert(sizeof(UAchievementTracker_Bouncy) == 0x000048, "Wrong size on UAchievementTracker_Bouncy");

// Class Stalker2.AchievementTracker_SneakyClearLair
// 0x0010 (0x0048 - 0x0038)
class UAchievementTracker_SneakyClearLair final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_SneakyClearLair">();
	}
	static class UAchievementTracker_SneakyClearLair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_SneakyClearLair>();
	}
};
static_assert(alignof(UAchievementTracker_SneakyClearLair) == 0x000008, "Wrong alignment on UAchievementTracker_SneakyClearLair");
static_assert(sizeof(UAchievementTracker_SneakyClearLair) == 0x000048, "Wrong size on UAchievementTracker_SneakyClearLair");

// Class Stalker2.AchievementTracker_FinishSquad
// 0x0010 (0x0048 - 0x0038)
class UAchievementTracker_FinishSquad final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_FinishSquad">();
	}
	static class UAchievementTracker_FinishSquad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_FinishSquad>();
	}
};
static_assert(alignof(UAchievementTracker_FinishSquad) == 0x000008, "Wrong alignment on UAchievementTracker_FinishSquad");
static_assert(sizeof(UAchievementTracker_FinishSquad) == 0x000048, "Wrong size on UAchievementTracker_FinishSquad");

// Class Stalker2.AchievementTracker_Lockpick
// 0x0008 (0x0040 - 0x0038)
class UAchievementTracker_Lockpick final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_Lockpick">();
	}
	static class UAchievementTracker_Lockpick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_Lockpick>();
	}
};
static_assert(alignof(UAchievementTracker_Lockpick) == 0x000008, "Wrong alignment on UAchievementTracker_Lockpick");
static_assert(sizeof(UAchievementTracker_Lockpick) == 0x000040, "Wrong size on UAchievementTracker_Lockpick");

// Class Stalker2.AchievementTracker_SitNearBonfire
// 0x0008 (0x0040 - 0x0038)
class UAchievementTracker_SitNearBonfire final : public UAchievementTracker
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementTracker_SitNearBonfire">();
	}
	static class UAchievementTracker_SitNearBonfire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementTracker_SitNearBonfire>();
	}
};
static_assert(alignof(UAchievementTracker_SitNearBonfire) == 0x000008, "Wrong alignment on UAchievementTracker_SitNearBonfire");
static_assert(sizeof(UAchievementTracker_SitNearBonfire) == 0x000040, "Wrong size on UAchievementTracker_SitNearBonfire");

// Class Stalker2.TraderEquipmentSlot
// 0x0020 (0x0660 - 0x0640)
class UTraderEquipmentSlot final : public UEquipmentSlot
{
public:
	struct FLinearColor                           CantBuyHighlight;                                  // 0x0638(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           DefaultHighlightColor;                             // 0x0648(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_658[0x8];                                      // 0x0658(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraderEquipmentSlot">();
	}
	static class UTraderEquipmentSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraderEquipmentSlot>();
	}
};
static_assert(alignof(UTraderEquipmentSlot) == 0x000010, "Wrong alignment on UTraderEquipmentSlot");
static_assert(sizeof(UTraderEquipmentSlot) == 0x000660, "Wrong size on UTraderEquipmentSlot");
static_assert(offsetof(UTraderEquipmentSlot, CantBuyHighlight) == 0x000638, "Member 'UTraderEquipmentSlot::CantBuyHighlight' has a wrong offset!");
static_assert(offsetof(UTraderEquipmentSlot, DefaultHighlightColor) == 0x000648, "Member 'UTraderEquipmentSlot::DefaultHighlightColor' has a wrong offset!");

// Class Stalker2.TraderGridSlot
// 0x0020 (0x05A0 - 0x0580)
class UTraderGridSlot final : public UCustomGridSlot
{
public:
	struct FLinearColor                           CantBuyHighlight;                                  // 0x0578(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           DefaultHighlightColor;                             // 0x0588(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraderGridSlot">();
	}
	static class UTraderGridSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraderGridSlot>();
	}
};
static_assert(alignof(UTraderGridSlot) == 0x000010, "Wrong alignment on UTraderGridSlot");
static_assert(sizeof(UTraderGridSlot) == 0x0005A0, "Wrong size on UTraderGridSlot");
static_assert(offsetof(UTraderGridSlot, CantBuyHighlight) == 0x000578, "Member 'UTraderGridSlot::CantBuyHighlight' has a wrong offset!");
static_assert(offsetof(UTraderGridSlot, DefaultHighlightColor) == 0x000588, "Member 'UTraderGridSlot::DefaultHighlightColor' has a wrong offset!");

// Class Stalker2.TradeView
// 0x0080 (0x1448 - 0x13C8)
class UTradeView final : public UInventoryNew
{
public:
	class UCustomGrid*                            TraderGridWidget;                                  // 0x13C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomGrid*                            SellGridWidget;                                    // 0x13D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomGrid*                            BuyGridWidget;                                     // 0x13D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            TradeConfirmInfoText;                              // 0x13E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            TradeResultMoney;                                  // 0x13E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            TradeResultWeight;                                 // 0x13F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            TradeResultWeightUnits;                            // 0x13F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlatformSwitcher*                      TraderButtonSwitcher;                              // 0x1400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   ButtonHintConfirmTrade;                            // 0x1408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   ButtonHintCancelTrade;                             // 0x1410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   HintBuy;                                           // 0x1418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintSell;                                          // 0x1420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HintReturn;                                        // 0x1428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1430[0x18];                                    // 0x1430(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCancelTradeHoldReleased();
	void OnCancelTradeHoldTriggered();
	void OnConfirmTradeHoldReleased();
	void OnConfirmTradeHoldTriggered();
	void SellOrBuyReturnItemAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeView">();
	}
	static class UTradeView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeView>();
	}
};
static_assert(alignof(UTradeView) == 0x000008, "Wrong alignment on UTradeView");
static_assert(sizeof(UTradeView) == 0x001448, "Wrong size on UTradeView");
static_assert(offsetof(UTradeView, TraderGridWidget) == 0x0013C8, "Member 'UTradeView::TraderGridWidget' has a wrong offset!");
static_assert(offsetof(UTradeView, SellGridWidget) == 0x0013D0, "Member 'UTradeView::SellGridWidget' has a wrong offset!");
static_assert(offsetof(UTradeView, BuyGridWidget) == 0x0013D8, "Member 'UTradeView::BuyGridWidget' has a wrong offset!");
static_assert(offsetof(UTradeView, TradeConfirmInfoText) == 0x0013E0, "Member 'UTradeView::TradeConfirmInfoText' has a wrong offset!");
static_assert(offsetof(UTradeView, TradeResultMoney) == 0x0013E8, "Member 'UTradeView::TradeResultMoney' has a wrong offset!");
static_assert(offsetof(UTradeView, TradeResultWeight) == 0x0013F0, "Member 'UTradeView::TradeResultWeight' has a wrong offset!");
static_assert(offsetof(UTradeView, TradeResultWeightUnits) == 0x0013F8, "Member 'UTradeView::TradeResultWeightUnits' has a wrong offset!");
static_assert(offsetof(UTradeView, TraderButtonSwitcher) == 0x001400, "Member 'UTradeView::TraderButtonSwitcher' has a wrong offset!");
static_assert(offsetof(UTradeView, ButtonHintConfirmTrade) == 0x001408, "Member 'UTradeView::ButtonHintConfirmTrade' has a wrong offset!");
static_assert(offsetof(UTradeView, ButtonHintCancelTrade) == 0x001410, "Member 'UTradeView::ButtonHintCancelTrade' has a wrong offset!");
static_assert(offsetof(UTradeView, HintBuy) == 0x001418, "Member 'UTradeView::HintBuy' has a wrong offset!");
static_assert(offsetof(UTradeView, HintSell) == 0x001420, "Member 'UTradeView::HintSell' has a wrong offset!");
static_assert(offsetof(UTradeView, HintReturn) == 0x001428, "Member 'UTradeView::HintReturn' has a wrong offset!");

// Class Stalker2.TriggerManager
// 0x0168 (0x0210 - 0x00A8)
class UTriggerManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x168];                                     // 0x00A8(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerManager">();
	}
	static class UTriggerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriggerManager>();
	}
};
static_assert(alignof(UTriggerManager) == 0x000008, "Wrong alignment on UTriggerManager");
static_assert(sizeof(UTriggerManager) == 0x000210, "Wrong size on UTriggerManager");

// Class Stalker2.TriplanarDecalComponent
// 0x0010 (0x0310 - 0x0300)
class UTriplanarDecalComponent final : public UDecalComponent
{
public:
	int32                                         NumberOfTraces;                                    // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             HeightMap;                                         // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriplanarDecalComponent">();
	}
	static class UTriplanarDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriplanarDecalComponent>();
	}
};
static_assert(alignof(UTriplanarDecalComponent) == 0x000010, "Wrong alignment on UTriplanarDecalComponent");
static_assert(sizeof(UTriplanarDecalComponent) == 0x000310, "Wrong size on UTriplanarDecalComponent");
static_assert(offsetof(UTriplanarDecalComponent, NumberOfTraces) == 0x000300, "Member 'UTriplanarDecalComponent::NumberOfTraces' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, HeightMap) == 0x000308, "Member 'UTriplanarDecalComponent::HeightMap' has a wrong offset!");

// Class Stalker2.TutorialAutonomic
// 0x0028 (0x0440 - 0x0418)
class UTutorialAutonomic final : public UTutorialBase
{
public:
	class UBorder*                                TextBackgroundBorder;                              // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMargin                                PaddingWithHint;                                   // 0x0420(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMargin                                PaddingWithoutHint;                                // 0x0430(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialAutonomic">();
	}
	static class UTutorialAutonomic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialAutonomic>();
	}
};
static_assert(alignof(UTutorialAutonomic) == 0x000008, "Wrong alignment on UTutorialAutonomic");
static_assert(sizeof(UTutorialAutonomic) == 0x000440, "Wrong size on UTutorialAutonomic");
static_assert(offsetof(UTutorialAutonomic, TextBackgroundBorder) == 0x000418, "Member 'UTutorialAutonomic::TextBackgroundBorder' has a wrong offset!");
static_assert(offsetof(UTutorialAutonomic, PaddingWithHint) == 0x000420, "Member 'UTutorialAutonomic::PaddingWithHint' has a wrong offset!");
static_assert(offsetof(UTutorialAutonomic, PaddingWithoutHint) == 0x000430, "Member 'UTutorialAutonomic::PaddingWithoutHint' has a wrong offset!");

// Class Stalker2.TutorialIPU
// 0x0000 (0x0040 - 0x0040)
class UTutorialIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialIPU">();
	}
	static class UTutorialIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialIPU>();
	}
};
static_assert(alignof(UTutorialIPU) == 0x000008, "Wrong alignment on UTutorialIPU");
static_assert(sizeof(UTutorialIPU) == 0x000040, "Wrong size on UTutorialIPU");

// Class Stalker2.TutorialSplash
// 0x0008 (0x0420 - 0x0418)
class UTutorialSplash final : public UTutorialBase
{
public:
	class URichTextBlock*                         TitleTutorText;                                    // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialSplash">();
	}
	static class UTutorialSplash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialSplash>();
	}
};
static_assert(alignof(UTutorialSplash) == 0x000008, "Wrong alignment on UTutorialSplash");
static_assert(sizeof(UTutorialSplash) == 0x000420, "Wrong size on UTutorialSplash");
static_assert(offsetof(UTutorialSplash, TitleTutorText) == 0x000418, "Member 'UTutorialSplash::TitleTutorText' has a wrong offset!");

// Class Stalker2.TwoSideProgressBar
// 0x0018 (0x02A0 - 0x0288)
class UTwoSideProgressBar final : public UAbstractProgressBar
{
public:
	class USlider*                                RightSlider;                                       // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USlider*                                LeftSlider;                                        // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ProgressLine;                                      // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwoSideProgressBar">();
	}
	static class UTwoSideProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwoSideProgressBar>();
	}
};
static_assert(alignof(UTwoSideProgressBar) == 0x000008, "Wrong alignment on UTwoSideProgressBar");
static_assert(sizeof(UTwoSideProgressBar) == 0x0002A0, "Wrong size on UTwoSideProgressBar");
static_assert(offsetof(UTwoSideProgressBar, RightSlider) == 0x000288, "Member 'UTwoSideProgressBar::RightSlider' has a wrong offset!");
static_assert(offsetof(UTwoSideProgressBar, LeftSlider) == 0x000290, "Member 'UTwoSideProgressBar::LeftSlider' has a wrong offset!");
static_assert(offsetof(UTwoSideProgressBar, ProgressLine) == 0x000298, "Member 'UTwoSideProgressBar::ProgressLine' has a wrong offset!");

// Class Stalker2.UIBaseManager
// 0x0D68 (0x0DE0 - 0x0078)
class UUIBaseManager : public UBaseManager
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EWidgetNameEx, TWeakObjectPtr<class UViewBase>> AllWidgets;                                 // 0x0088(0x0050)(ExportObject, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UViewBase*>                      OpenViews;                                         // 0x00D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UViewBase*>                      OpenViewsBuffer;                                   // 0x00E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UWaterElement*                          WaterElementWidget;                                // 0x00F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0xCD8];                                    // 0x0100(0x0CD8)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          LastAudioEvent;                                    // 0x0DD8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBaseManager">();
	}
	static class UUIBaseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBaseManager>();
	}
};
static_assert(alignof(UUIBaseManager) == 0x000008, "Wrong alignment on UUIBaseManager");
static_assert(sizeof(UUIBaseManager) == 0x000DE0, "Wrong size on UUIBaseManager");
static_assert(offsetof(UUIBaseManager, AllWidgets) == 0x000088, "Member 'UUIBaseManager::AllWidgets' has a wrong offset!");
static_assert(offsetof(UUIBaseManager, OpenViews) == 0x0000D8, "Member 'UUIBaseManager::OpenViews' has a wrong offset!");
static_assert(offsetof(UUIBaseManager, OpenViewsBuffer) == 0x0000E8, "Member 'UUIBaseManager::OpenViewsBuffer' has a wrong offset!");
static_assert(offsetof(UUIBaseManager, WaterElementWidget) == 0x0000F8, "Member 'UUIBaseManager::WaterElementWidget' has a wrong offset!");
static_assert(offsetof(UUIBaseManager, LastAudioEvent) == 0x000DD8, "Member 'UUIBaseManager::LastAudioEvent' has a wrong offset!");

// Class Stalker2.UIDActor_VortexArchAnomaly
// 0x0010 (0x02A8 - 0x0298)
class AUIDActor_VortexArchAnomaly : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDActor_VortexArchAnomaly">();
	}
	static class AUIDActor_VortexArchAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDActor_VortexArchAnomaly>();
	}
};
static_assert(alignof(AUIDActor_VortexArchAnomaly) == 0x000008, "Wrong alignment on AUIDActor_VortexArchAnomaly");
static_assert(sizeof(AUIDActor_VortexArchAnomaly) == 0x0002A8, "Wrong size on AUIDActor_VortexArchAnomaly");

// Class Stalker2.UIMainMenuManager
// 0x0000 (0x0DE0 - 0x0DE0)
class UUIMainMenuManager final : public UUIBaseManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMainMenuManager">();
	}
	static class UUIMainMenuManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMainMenuManager>();
	}
};
static_assert(alignof(UUIMainMenuManager) == 0x000008, "Wrong alignment on UUIMainMenuManager");
static_assert(sizeof(UUIMainMenuManager) == 0x000DE0, "Wrong size on UUIMainMenuManager");

// Class Stalker2.UIManagerEx
// 0x0218 (0x0FF8 - 0x0DE0)
class UUIManagerEx final : public UUIBaseManager
{
public:
	uint8                                         Pad_DE0[0x218];                                    // 0x0DE0(0x0218)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOpenLootMenu(const struct FItemContainerUID& InStorageItemContainerUID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIManagerEx">();
	}
	static class UUIManagerEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIManagerEx>();
	}
};
static_assert(alignof(UUIManagerEx) == 0x000008, "Wrong alignment on UUIManagerEx");
static_assert(sizeof(UUIManagerEx) == 0x000FF8, "Wrong size on UUIManagerEx");

// Class Stalker2.UISettingsWidget
// 0x0080 (0x0310 - 0x0290)
class UUISettingsWidget final : public USettingsPage
{
public:
	class USettingElementOnOff*                   Subtitle;                                          // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementSwitcher*                SubtitleSize;                                      // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingsElementPercent*                BackgroundOpacity;                                 // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingsElementPercent*                HUDOpacity;                                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   SubtitleName;                                      // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementSwitcher*                CrosshairType;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   HUD;                                               // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   ThreatIndicator;                                   // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   Crosshair;                                         // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   CrosshairColor;                                    // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   QuestNotification;                                 // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   Compass;                                           // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   AmmoCounter;                                       // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   SystemNotification;                                // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   QuickSlot;                                         // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettingElementOnOff*                   InteractDots;                                      // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISettingsWidget">();
	}
	static class UUISettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISettingsWidget>();
	}
};
static_assert(alignof(UUISettingsWidget) == 0x000008, "Wrong alignment on UUISettingsWidget");
static_assert(sizeof(UUISettingsWidget) == 0x000310, "Wrong size on UUISettingsWidget");
static_assert(offsetof(UUISettingsWidget, Subtitle) == 0x000290, "Member 'UUISettingsWidget::Subtitle' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, SubtitleSize) == 0x000298, "Member 'UUISettingsWidget::SubtitleSize' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, BackgroundOpacity) == 0x0002A0, "Member 'UUISettingsWidget::BackgroundOpacity' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, HUDOpacity) == 0x0002A8, "Member 'UUISettingsWidget::HUDOpacity' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, SubtitleName) == 0x0002B0, "Member 'UUISettingsWidget::SubtitleName' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, CrosshairType) == 0x0002B8, "Member 'UUISettingsWidget::CrosshairType' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, HUD) == 0x0002C0, "Member 'UUISettingsWidget::HUD' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, ThreatIndicator) == 0x0002C8, "Member 'UUISettingsWidget::ThreatIndicator' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, Crosshair) == 0x0002D0, "Member 'UUISettingsWidget::Crosshair' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, CrosshairColor) == 0x0002D8, "Member 'UUISettingsWidget::CrosshairColor' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, QuestNotification) == 0x0002E0, "Member 'UUISettingsWidget::QuestNotification' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, Compass) == 0x0002E8, "Member 'UUISettingsWidget::Compass' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, AmmoCounter) == 0x0002F0, "Member 'UUISettingsWidget::AmmoCounter' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, SystemNotification) == 0x0002F8, "Member 'UUISettingsWidget::SystemNotification' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, QuickSlot) == 0x000300, "Member 'UUISettingsWidget::QuickSlot' has a wrong offset!");
static_assert(offsetof(UUISettingsWidget, InteractDots) == 0x000308, "Member 'UUISettingsWidget::InteractDots' has a wrong offset!");

// Class Stalker2.UIStyleManager
// 0x0378 (0x03A0 - 0x0028)
class UUIStyleManager final : public UObject
{
public:
	class FString                                 PathToPlatformIconDT;                              // 0x0028(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToIconDT;                                      // 0x0038(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToCommonFontDT;                                // 0x0048(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToCommonStailDT;                               // 0x0058(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToProgresBarStailDT;                           // 0x0068(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToNPCRelationColorsDT;                         // 0x0078(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToNPCRelationColorsMarkerDT;                   // 0x0088(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToFactionIconsDT;                              // 0x0098(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToPCDefaultInputIconsDT;                       // 0x00A8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToPCDisabledInputIconsDT;                      // 0x00B8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShoudLoadTabe;                                    // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoadDataTableInConfig;                            // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x2D6];                                     // 0x00CA(0x02D6)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStyleManager">();
	}
	static class UUIStyleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStyleManager>();
	}
};
static_assert(alignof(UUIStyleManager) == 0x000008, "Wrong alignment on UUIStyleManager");
static_assert(sizeof(UUIStyleManager) == 0x0003A0, "Wrong size on UUIStyleManager");
static_assert(offsetof(UUIStyleManager, PathToPlatformIconDT) == 0x000028, "Member 'UUIStyleManager::PathToPlatformIconDT' has a wrong offset!");
static_assert(offsetof(UUIStyleManager, PathToIconDT) == 0x000038, "Member 'UUIStyleManager::PathToIconDT' has a wrong offset!");
static_assert(offsetof(UUIStyleManager, PathToCommonFontDT) == 0x000048, "Member 'UUIStyleManager::PathToCommonFontDT' has a wrong offset!");
static_assert(offsetof(UUIStyleManager, PathToCommonStailDT) == 0x000058, "Member 'UUIStyleManager::PathToCommonStailDT' has a wrong offset!");
static_assert(offsetof(UUIStyleManager, PathToProgresBarStailDT) == 0x000068, "Member 'UUIStyleManager::PathToProgresBarStailDT' has a wrong offset!");
static_assert(offsetof(UUIStyleManager, PathToNPCRelationColorsDT) == 0x000078, "Member 'UUIStyleManager::PathToNPCRelationColorsDT' has a wrong offset!");
static_assert(offsetof(UUIStyleManager, PathToNPCRelationColorsMarkerDT) == 0x000088, "Member 'UUIStyleManager::PathToNPCRelationColorsMarkerDT' has a wrong offset!");
static_assert(offsetof(UUIStyleManager, PathToFactionIconsDT) == 0x000098, "Member 'UUIStyleManager::PathToFactionIconsDT' has a wrong offset!");
static_assert(offsetof(UUIStyleManager, PathToPCDefaultInputIconsDT) == 0x0000A8, "Member 'UUIStyleManager::PathToPCDefaultInputIconsDT' has a wrong offset!");
static_assert(offsetof(UUIStyleManager, PathToPCDisabledInputIconsDT) == 0x0000B8, "Member 'UUIStyleManager::PathToPCDisabledInputIconsDT' has a wrong offset!");
static_assert(offsetof(UUIStyleManager, bShoudLoadTabe) == 0x0000C8, "Member 'UUIStyleManager::bShoudLoadTabe' has a wrong offset!");
static_assert(offsetof(UUIStyleManager, bLoadDataTableInConfig) == 0x0000C9, "Member 'UUIStyleManager::bLoadDataTableInConfig' has a wrong offset!");

// Class Stalker2.UpdateUIHintIPU
// 0x0018 (0x0058 - 0x0040)
class UUpdateUIHintIPU final : public UInputProcessingUnit
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateUIHintIPU">();
	}
	static class UUpdateUIHintIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateUIHintIPU>();
	}
};
static_assert(alignof(UUpdateUIHintIPU) == 0x000008, "Wrong alignment on UUpdateUIHintIPU");
static_assert(sizeof(UUpdateUIHintIPU) == 0x000058, "Wrong size on UUpdateUIHintIPU");

// Class Stalker2.UpgradeEffectWidget
// 0x0040 (0x02B8 - 0x0278)
class UUpgradeEffectWidget final : public UWidgetBase
{
public:
	class UImage*                                 EffectIcon;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             EffectText;                                        // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           PositiveEffectValueColor;                          // 0x0288(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           NegativeEffectValueColor;                          // 0x0298(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           NeutralEffectValueColor;                           // 0x02A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpgradeEffectWidget">();
	}
	static class UUpgradeEffectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpgradeEffectWidget>();
	}
};
static_assert(alignof(UUpgradeEffectWidget) == 0x000008, "Wrong alignment on UUpgradeEffectWidget");
static_assert(sizeof(UUpgradeEffectWidget) == 0x0002B8, "Wrong size on UUpgradeEffectWidget");
static_assert(offsetof(UUpgradeEffectWidget, EffectIcon) == 0x000278, "Member 'UUpgradeEffectWidget::EffectIcon' has a wrong offset!");
static_assert(offsetof(UUpgradeEffectWidget, EffectText) == 0x000280, "Member 'UUpgradeEffectWidget::EffectText' has a wrong offset!");
static_assert(offsetof(UUpgradeEffectWidget, PositiveEffectValueColor) == 0x000288, "Member 'UUpgradeEffectWidget::PositiveEffectValueColor' has a wrong offset!");
static_assert(offsetof(UUpgradeEffectWidget, NegativeEffectValueColor) == 0x000298, "Member 'UUpgradeEffectWidget::NegativeEffectValueColor' has a wrong offset!");
static_assert(offsetof(UUpgradeEffectWidget, NeutralEffectValueColor) == 0x0002A8, "Member 'UUpgradeEffectWidget::NeutralEffectValueColor' has a wrong offset!");

// Class Stalker2.UpgradeItemTooltipWidget
// 0x00F0 (0x0368 - 0x0278)
class UUpgradeItemTooltipWidget final : public UUserWidget
{
public:
	class UTextBlock*                             TitleText;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             DescriptionText;                                   // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           MainVerticalBox;                                   // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           ContentVerticalBox;                                // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URichTextWidget*                        BlockingText;                                      // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 WeaponDurabilityIsTooLowL10n;                      // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 TechnicianCantMakeThisUpgradeL10n;                 // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 RequiredUpgradesL10n;                              // 0x02C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 BlockingUpgradesL10n;                              // 0x02D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 NotEnoughMoneyL10n;                                // 0x02E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 RequiredItemsL10n;                                 // 0x02F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 UpgradesBlueprintL10n;                             // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 UnableToInstallL10n;                               // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 NoUpgradesL10n;                                    // 0x0320(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 OrL10n;                                            // 0x0330(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUpgradeEffectWidget>       UpgradeEffectWidgetClass;                          // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUpgradeEffectWidget*>           EffectWidgets;                                     // 0x0348(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class FString                                 LastUpgradePrototypeSID;                           // 0x0358(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpgradeItemTooltipWidget">();
	}
	static class UUpgradeItemTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpgradeItemTooltipWidget>();
	}
};
static_assert(alignof(UUpgradeItemTooltipWidget) == 0x000008, "Wrong alignment on UUpgradeItemTooltipWidget");
static_assert(sizeof(UUpgradeItemTooltipWidget) == 0x000368, "Wrong size on UUpgradeItemTooltipWidget");
static_assert(offsetof(UUpgradeItemTooltipWidget, TitleText) == 0x000278, "Member 'UUpgradeItemTooltipWidget::TitleText' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, DescriptionText) == 0x000280, "Member 'UUpgradeItemTooltipWidget::DescriptionText' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, MainVerticalBox) == 0x000288, "Member 'UUpgradeItemTooltipWidget::MainVerticalBox' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, ContentVerticalBox) == 0x000290, "Member 'UUpgradeItemTooltipWidget::ContentVerticalBox' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, BlockingText) == 0x000298, "Member 'UUpgradeItemTooltipWidget::BlockingText' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, WeaponDurabilityIsTooLowL10n) == 0x0002A0, "Member 'UUpgradeItemTooltipWidget::WeaponDurabilityIsTooLowL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, TechnicianCantMakeThisUpgradeL10n) == 0x0002B0, "Member 'UUpgradeItemTooltipWidget::TechnicianCantMakeThisUpgradeL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, RequiredUpgradesL10n) == 0x0002C0, "Member 'UUpgradeItemTooltipWidget::RequiredUpgradesL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, BlockingUpgradesL10n) == 0x0002D0, "Member 'UUpgradeItemTooltipWidget::BlockingUpgradesL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, NotEnoughMoneyL10n) == 0x0002E0, "Member 'UUpgradeItemTooltipWidget::NotEnoughMoneyL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, RequiredItemsL10n) == 0x0002F0, "Member 'UUpgradeItemTooltipWidget::RequiredItemsL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, UpgradesBlueprintL10n) == 0x000300, "Member 'UUpgradeItemTooltipWidget::UpgradesBlueprintL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, UnableToInstallL10n) == 0x000310, "Member 'UUpgradeItemTooltipWidget::UnableToInstallL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, NoUpgradesL10n) == 0x000320, "Member 'UUpgradeItemTooltipWidget::NoUpgradesL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, OrL10n) == 0x000330, "Member 'UUpgradeItemTooltipWidget::OrL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, UpgradeEffectWidgetClass) == 0x000340, "Member 'UUpgradeItemTooltipWidget::UpgradeEffectWidgetClass' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, EffectWidgets) == 0x000348, "Member 'UUpgradeItemTooltipWidget::EffectWidgets' has a wrong offset!");
static_assert(offsetof(UUpgradeItemTooltipWidget, LastUpgradePrototypeSID) == 0x000358, "Member 'UUpgradeItemTooltipWidget::LastUpgradePrototypeSID' has a wrong offset!");

// Class Stalker2.UpgradeMenuWidget
// 0x0278 (0x04F0 - 0x0278)
class alignas(0x10) UUpgradeMenuWidget final : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x38];                                     // 0x0278(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EUpgradeTargetPartType, class UUpgradeSection*> Sections;                                   // 0x02B0(0x0050)(BlueprintVisible, ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UUpgradeSection*>                SectionWidgetsArray;                               // 0x0300(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           BlackFade;                                         // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ConfirmWarningPopupL10n;                           // 0x0320(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x40];                                     // 0x0330(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                UpgradeTooltipWidgetClass;                         // 0x0370(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHintInputController*                   RepairButton;                                      // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URepairPriceWidget*                     RepairPrice;                                       // 0x0380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHintInputController*                   HideInformationButton;                             // 0x0388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHintInputController*                   RemoveAttachmentButton;                            // 0x0390(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHintInputController*                   InSelectInstallAttachmentButton;                   // 0x0398(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUpgradeSlot*                           CurrentSlot;                                       // 0x03A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUpgradePriceWidget*                    PriceWidget;                                       // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            ItemNameText;                                      // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            PlayerMoneyText;                                   // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULayeredItemImage*                      UpgradedItemIcon;                                  // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasPanel;                                       // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemsStatsUpgrades*                    ItemTooltip;                                       // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUpgradeItemTooltipWidget*              UpgradeTooltipWidget;                              // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               ConfirmPopupContainer;                             // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UConfirmUpgradePopup*                   ConfirmUpgradePopup;                               // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImageWidget*                           IconDurability;                                    // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         PlayerMoneyBox;                                    // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TensileStrength;                                   // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RepairButtonL10N;                                  // 0x0408(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 PriceStyle;                                        // 0x0418(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CurrencyImageId;                                   // 0x0428(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUpgradeSection*                        LastActiveSection;                                 // 0x0438(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowInfoOnClick;                                  // 0x0440(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPriceWidgetEnabled;                               // 0x0441(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_442[0x6];                                      // 0x0442(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UUpgradeSection*                        LastHoveredSection;                                // 0x0448(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ItemSID;                                           // 0x0450(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSetPositions;                                     // 0x0460(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           SectionsCanvas;                                    // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 BlackWeaponFade;                                   // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x78];                                     // 0x0478(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeUpgradeModule();
	void ClearAttaches();
	void DrawAttaches(class UTexture2D* Texture, int32 AttachIndex);
	void LoadPrototypeEditor();
	void OnApplyUpgrade(const class FString& UpgradeID, class UUpgradeSlot* InCurrentSlot);
	struct FEventReply OnMouseBlackFadeDown(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent);
	void OnRepair();
	void OnRevertLastUpgrade();
	void OnSectionClicked(class UUpgradeSection* Section);
	void OnSectionFadeProgress(const float Alpha, const bool bIsShowing);
	void OnUpgradeClick(const class FString& UpgradeID, class UUpgradeSlot* InCurrentSlot);
	void OnUpgradeMouseEnter(const class FString& UpgradeID);
	void OnUpgradeMouseExit();
	void OnWeaponFadeProgress(const float Alpha, const bool bIsShowing);

	void LogSectionPositions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpgradeMenuWidget">();
	}
	static class UUpgradeMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpgradeMenuWidget>();
	}
};
static_assert(alignof(UUpgradeMenuWidget) == 0x000010, "Wrong alignment on UUpgradeMenuWidget");
static_assert(sizeof(UUpgradeMenuWidget) == 0x0004F0, "Wrong size on UUpgradeMenuWidget");
static_assert(offsetof(UUpgradeMenuWidget, Sections) == 0x0002B0, "Member 'UUpgradeMenuWidget::Sections' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, SectionWidgetsArray) == 0x000300, "Member 'UUpgradeMenuWidget::SectionWidgetsArray' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, BlackFade) == 0x000310, "Member 'UUpgradeMenuWidget::BlackFade' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, ConfirmWarningPopupL10n) == 0x000320, "Member 'UUpgradeMenuWidget::ConfirmWarningPopupL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, UpgradeTooltipWidgetClass) == 0x000370, "Member 'UUpgradeMenuWidget::UpgradeTooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, RepairButton) == 0x000378, "Member 'UUpgradeMenuWidget::RepairButton' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, RepairPrice) == 0x000380, "Member 'UUpgradeMenuWidget::RepairPrice' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, HideInformationButton) == 0x000388, "Member 'UUpgradeMenuWidget::HideInformationButton' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, RemoveAttachmentButton) == 0x000390, "Member 'UUpgradeMenuWidget::RemoveAttachmentButton' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, InSelectInstallAttachmentButton) == 0x000398, "Member 'UUpgradeMenuWidget::InSelectInstallAttachmentButton' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, CurrentSlot) == 0x0003A0, "Member 'UUpgradeMenuWidget::CurrentSlot' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, PriceWidget) == 0x0003A8, "Member 'UUpgradeMenuWidget::PriceWidget' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, ItemNameText) == 0x0003B0, "Member 'UUpgradeMenuWidget::ItemNameText' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, PlayerMoneyText) == 0x0003B8, "Member 'UUpgradeMenuWidget::PlayerMoneyText' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, UpgradedItemIcon) == 0x0003C0, "Member 'UUpgradeMenuWidget::UpgradedItemIcon' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, CanvasPanel) == 0x0003C8, "Member 'UUpgradeMenuWidget::CanvasPanel' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, ItemTooltip) == 0x0003D0, "Member 'UUpgradeMenuWidget::ItemTooltip' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, UpgradeTooltipWidget) == 0x0003D8, "Member 'UUpgradeMenuWidget::UpgradeTooltipWidget' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, ConfirmPopupContainer) == 0x0003E0, "Member 'UUpgradeMenuWidget::ConfirmPopupContainer' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, ConfirmUpgradePopup) == 0x0003E8, "Member 'UUpgradeMenuWidget::ConfirmUpgradePopup' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, IconDurability) == 0x0003F0, "Member 'UUpgradeMenuWidget::IconDurability' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, PlayerMoneyBox) == 0x0003F8, "Member 'UUpgradeMenuWidget::PlayerMoneyBox' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, TensileStrength) == 0x000400, "Member 'UUpgradeMenuWidget::TensileStrength' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, RepairButtonL10N) == 0x000408, "Member 'UUpgradeMenuWidget::RepairButtonL10N' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, PriceStyle) == 0x000418, "Member 'UUpgradeMenuWidget::PriceStyle' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, CurrencyImageId) == 0x000428, "Member 'UUpgradeMenuWidget::CurrencyImageId' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, LastActiveSection) == 0x000438, "Member 'UUpgradeMenuWidget::LastActiveSection' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, bShowInfoOnClick) == 0x000440, "Member 'UUpgradeMenuWidget::bShowInfoOnClick' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, bPriceWidgetEnabled) == 0x000441, "Member 'UUpgradeMenuWidget::bPriceWidgetEnabled' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, LastHoveredSection) == 0x000448, "Member 'UUpgradeMenuWidget::LastHoveredSection' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, ItemSID) == 0x000450, "Member 'UUpgradeMenuWidget::ItemSID' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, bSetPositions) == 0x000460, "Member 'UUpgradeMenuWidget::bSetPositions' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, SectionsCanvas) == 0x000468, "Member 'UUpgradeMenuWidget::SectionsCanvas' has a wrong offset!");
static_assert(offsetof(UUpgradeMenuWidget, BlackWeaponFade) == 0x000470, "Member 'UUpgradeMenuWidget::BlackWeaponFade' has a wrong offset!");

// Class Stalker2.UpgradePage
// 0x0100 (0x0398 - 0x0298)
class UUpgradePage final : public UPDAPage
{
public:
	class UPDAUpgradePanel*                       UpgradePanel;                                      // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDAUpgradesButton*                     ButtonAll;                                         // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDAUpgradesButton*                     ButtonWeapon;                                      // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDAUpgradesButton*                     ButtonArmor;                                       // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPDAUpgradesButton*                     ButtonHelmet;                                      // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUpgradeMenuWidget*                     UpgradeMenu;                                       // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   HintNavLeft;                                       // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   HintNavRight;                                      // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   HideInformation;                                   // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   RepairButton;                                      // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   RemoveAttachment;                                  // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   SelectInstalAttachment;                            // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   ButtonHintExit;                                    // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintInputController*                   NavigationHint;                                    // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        UpgradeSwitcher;                                   // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URepairPriceWidget*                     RepairPrice;                                       // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelectInput;                                       // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpgradesIndex;                                     // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmptyScreenIndex;                                  // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GreyValue;                                         // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ExitTextHintl10nSID;                               // 0x0330(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackTextHintl10nSID;                               // 0x0340(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPDAUpgradesButton*>             MenuButtons;                                       // 0x0358(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x4];                                      // 0x0368(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HintHoldTime;                                      // 0x036C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x28];                                     // 0x0370(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindConfirmPopup();
	void BindUpgradesNavigation();
	void ClearInput();
	void ClickButtonMenu(const class FName ButtonId);
	void HandleConfirmPopupBindings(bool InBind);
	void Hide();
	void Remove();
	void Repair();
	void UIPDANavigationButtonRelease();
	void UIPDANavigationDown();
	void UIPDANavigationLeft();
	void UIPDANavigationRight();
	void UIPDANavigationUp();
	void UIPDAUpgradesTreeNavigationBack();
	void UIPDAUpgradesTreeNavigationDown();
	void UIPDAUpgradesTreeNavigationLeft();
	void UIPDAUpgradesTreeNavigationRight();
	void UIPDAUpgradesTreeNavigationSelect();
	void UIPDAUpgradesTreeNavigationUp();
	void UnbindConfirmPopup();
	void UnbindUpgradesNavigation();
	void UpdatePanel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpgradePage">();
	}
	static class UUpgradePage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpgradePage>();
	}
};
static_assert(alignof(UUpgradePage) == 0x000008, "Wrong alignment on UUpgradePage");
static_assert(sizeof(UUpgradePage) == 0x000398, "Wrong size on UUpgradePage");
static_assert(offsetof(UUpgradePage, UpgradePanel) == 0x000298, "Member 'UUpgradePage::UpgradePanel' has a wrong offset!");
static_assert(offsetof(UUpgradePage, ButtonAll) == 0x0002A0, "Member 'UUpgradePage::ButtonAll' has a wrong offset!");
static_assert(offsetof(UUpgradePage, ButtonWeapon) == 0x0002A8, "Member 'UUpgradePage::ButtonWeapon' has a wrong offset!");
static_assert(offsetof(UUpgradePage, ButtonArmor) == 0x0002B0, "Member 'UUpgradePage::ButtonArmor' has a wrong offset!");
static_assert(offsetof(UUpgradePage, ButtonHelmet) == 0x0002B8, "Member 'UUpgradePage::ButtonHelmet' has a wrong offset!");
static_assert(offsetof(UUpgradePage, UpgradeMenu) == 0x0002C0, "Member 'UUpgradePage::UpgradeMenu' has a wrong offset!");
static_assert(offsetof(UUpgradePage, HintNavLeft) == 0x0002C8, "Member 'UUpgradePage::HintNavLeft' has a wrong offset!");
static_assert(offsetof(UUpgradePage, HintNavRight) == 0x0002D0, "Member 'UUpgradePage::HintNavRight' has a wrong offset!");
static_assert(offsetof(UUpgradePage, HideInformation) == 0x0002D8, "Member 'UUpgradePage::HideInformation' has a wrong offset!");
static_assert(offsetof(UUpgradePage, RepairButton) == 0x0002E0, "Member 'UUpgradePage::RepairButton' has a wrong offset!");
static_assert(offsetof(UUpgradePage, RemoveAttachment) == 0x0002E8, "Member 'UUpgradePage::RemoveAttachment' has a wrong offset!");
static_assert(offsetof(UUpgradePage, SelectInstalAttachment) == 0x0002F0, "Member 'UUpgradePage::SelectInstalAttachment' has a wrong offset!");
static_assert(offsetof(UUpgradePage, ButtonHintExit) == 0x0002F8, "Member 'UUpgradePage::ButtonHintExit' has a wrong offset!");
static_assert(offsetof(UUpgradePage, NavigationHint) == 0x000300, "Member 'UUpgradePage::NavigationHint' has a wrong offset!");
static_assert(offsetof(UUpgradePage, UpgradeSwitcher) == 0x000308, "Member 'UUpgradePage::UpgradeSwitcher' has a wrong offset!");
static_assert(offsetof(UUpgradePage, RepairPrice) == 0x000310, "Member 'UUpgradePage::RepairPrice' has a wrong offset!");
static_assert(offsetof(UUpgradePage, SelectInput) == 0x000318, "Member 'UUpgradePage::SelectInput' has a wrong offset!");
static_assert(offsetof(UUpgradePage, UpgradesIndex) == 0x000320, "Member 'UUpgradePage::UpgradesIndex' has a wrong offset!");
static_assert(offsetof(UUpgradePage, EmptyScreenIndex) == 0x000324, "Member 'UUpgradePage::EmptyScreenIndex' has a wrong offset!");
static_assert(offsetof(UUpgradePage, GreyValue) == 0x000328, "Member 'UUpgradePage::GreyValue' has a wrong offset!");
static_assert(offsetof(UUpgradePage, ExitTextHintl10nSID) == 0x000330, "Member 'UUpgradePage::ExitTextHintl10nSID' has a wrong offset!");
static_assert(offsetof(UUpgradePage, BackTextHintl10nSID) == 0x000340, "Member 'UUpgradePage::BackTextHintl10nSID' has a wrong offset!");
static_assert(offsetof(UUpgradePage, MenuButtons) == 0x000358, "Member 'UUpgradePage::MenuButtons' has a wrong offset!");
static_assert(offsetof(UUpgradePage, HintHoldTime) == 0x00036C, "Member 'UUpgradePage::HintHoldTime' has a wrong offset!");

// Class Stalker2.UpgradePriceWidget
// 0x0038 (0x02B0 - 0x0278)
class UUpgradePriceWidget final : public UWidgetBase
{
public:
	class UTextBlock*                             Price;                                             // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             Weight;                                            // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             Description;                                       // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 KgL10nSID;                                         // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 DescriptionL10nSID;                                // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpgradePriceWidget">();
	}
	static class UUpgradePriceWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpgradePriceWidget>();
	}
};
static_assert(alignof(UUpgradePriceWidget) == 0x000008, "Wrong alignment on UUpgradePriceWidget");
static_assert(sizeof(UUpgradePriceWidget) == 0x0002B0, "Wrong size on UUpgradePriceWidget");
static_assert(offsetof(UUpgradePriceWidget, Price) == 0x000278, "Member 'UUpgradePriceWidget::Price' has a wrong offset!");
static_assert(offsetof(UUpgradePriceWidget, Weight) == 0x000280, "Member 'UUpgradePriceWidget::Weight' has a wrong offset!");
static_assert(offsetof(UUpgradePriceWidget, Description) == 0x000288, "Member 'UUpgradePriceWidget::Description' has a wrong offset!");
static_assert(offsetof(UUpgradePriceWidget, KgL10nSID) == 0x000290, "Member 'UUpgradePriceWidget::KgL10nSID' has a wrong offset!");
static_assert(offsetof(UUpgradePriceWidget, DescriptionL10nSID) == 0x0002A0, "Member 'UUpgradePriceWidget::DescriptionL10nSID' has a wrong offset!");

// Class Stalker2.UpgradeSection
// 0x0150 (0x03C8 - 0x0278)
class UUpgradeSection final : public UWidgetBase
{
public:
	TMulticastInlineDelegate<void(class UUpgradeSection* ClickedSection)> OnSectionClicked;          // 0x0278(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsEnabledSection;                                 // 0x0288(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUpgradeTargetPartType                        TargetPart;                                        // 0x0289(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELineDirection                                UpgradesLineDirection;                             // 0x028A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELineDirection                                ModulesLineDirection;                              // 0x028B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DotHoverSize;                                      // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DotNormalSize;                                     // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const float Alpha, const bool bShowing)> OnAnimationProgress;      // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TArray<class UVerticalBox*>                   ModulesVerticalBoxes;                              // 0x02C0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UVerticalBox*>                   UpgradesVerticalBoxes;                             // 0x02D0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 ConnectionLineUpgrade;                             // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           UpgradesPanel;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ConnectionLineModule;                              // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ModulesPanel;                                      // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NewUpgradeNotification;                            // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             UpgradesTextBlock;                                 // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             ModulesTextBlock;                                  // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Dot;                                               // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                DotButton;                                         // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUpgradeSlot>               SlotWidgetClass;                                   // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUpgradesSettings*                      SettingsAsset;                                     // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUpgradeSlot*>                   Slots;                                             // 0x0338(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class FText                                   UpgradeL10n;                                       // 0x0348(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   ModulesL10n;                                       // 0x0360(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   NewNotificationL10n;                               // 0x0378(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x30];                                     // 0x0390(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUpgradeSlot*                           LastHighlightedSlot;                               // 0x03C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RebuildSections();
	void SectionClicked();
	void SectionHovered();
	void SectionUnhovered();
	void ToggleSection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpgradeSection">();
	}
	static class UUpgradeSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpgradeSection>();
	}
};
static_assert(alignof(UUpgradeSection) == 0x000008, "Wrong alignment on UUpgradeSection");
static_assert(sizeof(UUpgradeSection) == 0x0003C8, "Wrong size on UUpgradeSection");
static_assert(offsetof(UUpgradeSection, OnSectionClicked) == 0x000278, "Member 'UUpgradeSection::OnSectionClicked' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, bIsEnabledSection) == 0x000288, "Member 'UUpgradeSection::bIsEnabledSection' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, TargetPart) == 0x000289, "Member 'UUpgradeSection::TargetPart' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, UpgradesLineDirection) == 0x00028A, "Member 'UUpgradeSection::UpgradesLineDirection' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, ModulesLineDirection) == 0x00028B, "Member 'UUpgradeSection::ModulesLineDirection' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, DotHoverSize) == 0x000290, "Member 'UUpgradeSection::DotHoverSize' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, DotNormalSize) == 0x0002A0, "Member 'UUpgradeSection::DotNormalSize' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, OnAnimationProgress) == 0x0002B0, "Member 'UUpgradeSection::OnAnimationProgress' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, ModulesVerticalBoxes) == 0x0002C0, "Member 'UUpgradeSection::ModulesVerticalBoxes' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, UpgradesVerticalBoxes) == 0x0002D0, "Member 'UUpgradeSection::UpgradesVerticalBoxes' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, ConnectionLineUpgrade) == 0x0002E0, "Member 'UUpgradeSection::ConnectionLineUpgrade' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, UpgradesPanel) == 0x0002E8, "Member 'UUpgradeSection::UpgradesPanel' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, ConnectionLineModule) == 0x0002F0, "Member 'UUpgradeSection::ConnectionLineModule' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, ModulesPanel) == 0x0002F8, "Member 'UUpgradeSection::ModulesPanel' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, NewUpgradeNotification) == 0x000300, "Member 'UUpgradeSection::NewUpgradeNotification' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, UpgradesTextBlock) == 0x000308, "Member 'UUpgradeSection::UpgradesTextBlock' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, ModulesTextBlock) == 0x000310, "Member 'UUpgradeSection::ModulesTextBlock' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, Dot) == 0x000318, "Member 'UUpgradeSection::Dot' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, DotButton) == 0x000320, "Member 'UUpgradeSection::DotButton' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, SlotWidgetClass) == 0x000328, "Member 'UUpgradeSection::SlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, SettingsAsset) == 0x000330, "Member 'UUpgradeSection::SettingsAsset' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, Slots) == 0x000338, "Member 'UUpgradeSection::Slots' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, UpgradeL10n) == 0x000348, "Member 'UUpgradeSection::UpgradeL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, ModulesL10n) == 0x000360, "Member 'UUpgradeSection::ModulesL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, NewNotificationL10n) == 0x000378, "Member 'UUpgradeSection::NewNotificationL10n' has a wrong offset!");
static_assert(offsetof(UUpgradeSection, LastHighlightedSlot) == 0x0003C0, "Member 'UUpgradeSection::LastHighlightedSlot' has a wrong offset!");

// Class Stalker2.UpgradeSlot
// 0x0118 (0x0390 - 0x0278)
class UUpgradeSlot final : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x30];                                     // 0x0278(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 UpgradeImage;                                      // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 TopConnectionLine;                                 // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 MiddleConnectionLine;                              // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 DownConnectionLine;                                // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Locked;                                            // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Blueprint;                                         // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Highlighted;                                       // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Mod;                                               // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Border;                                            // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Discount;                                          // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                UpgradeButton;                                     // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUpgradesSettings*                      SettingsAsset;                                     // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x18];                                     // 0x0308(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUpgradeSlotData                       Data;                                              // 0x0320(0x0068)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Highlight();
	void OnUpgradeButtonClick();
	void Unhighlight();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpgradeSlot">();
	}
	static class UUpgradeSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpgradeSlot>();
	}
};
static_assert(alignof(UUpgradeSlot) == 0x000008, "Wrong alignment on UUpgradeSlot");
static_assert(sizeof(UUpgradeSlot) == 0x000390, "Wrong size on UUpgradeSlot");
static_assert(offsetof(UUpgradeSlot, UpgradeImage) == 0x0002A8, "Member 'UUpgradeSlot::UpgradeImage' has a wrong offset!");
static_assert(offsetof(UUpgradeSlot, TopConnectionLine) == 0x0002B0, "Member 'UUpgradeSlot::TopConnectionLine' has a wrong offset!");
static_assert(offsetof(UUpgradeSlot, MiddleConnectionLine) == 0x0002B8, "Member 'UUpgradeSlot::MiddleConnectionLine' has a wrong offset!");
static_assert(offsetof(UUpgradeSlot, DownConnectionLine) == 0x0002C0, "Member 'UUpgradeSlot::DownConnectionLine' has a wrong offset!");
static_assert(offsetof(UUpgradeSlot, Locked) == 0x0002C8, "Member 'UUpgradeSlot::Locked' has a wrong offset!");
static_assert(offsetof(UUpgradeSlot, Blueprint) == 0x0002D0, "Member 'UUpgradeSlot::Blueprint' has a wrong offset!");
static_assert(offsetof(UUpgradeSlot, Highlighted) == 0x0002D8, "Member 'UUpgradeSlot::Highlighted' has a wrong offset!");
static_assert(offsetof(UUpgradeSlot, Mod) == 0x0002E0, "Member 'UUpgradeSlot::Mod' has a wrong offset!");
static_assert(offsetof(UUpgradeSlot, Border) == 0x0002E8, "Member 'UUpgradeSlot::Border' has a wrong offset!");
static_assert(offsetof(UUpgradeSlot, Discount) == 0x0002F0, "Member 'UUpgradeSlot::Discount' has a wrong offset!");
static_assert(offsetof(UUpgradeSlot, UpgradeButton) == 0x0002F8, "Member 'UUpgradeSlot::UpgradeButton' has a wrong offset!");
static_assert(offsetof(UUpgradeSlot, SettingsAsset) == 0x000300, "Member 'UUpgradeSlot::SettingsAsset' has a wrong offset!");
static_assert(offsetof(UUpgradeSlot, Data) == 0x000320, "Member 'UUpgradeSlot::Data' has a wrong offset!");

// Class Stalker2.UpgradesMouseIPU
// 0x0000 (0x0040 - 0x0040)
class UUpgradesMouseIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpgradesMouseIPU">();
	}
	static class UUpgradesMouseIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpgradesMouseIPU>();
	}
};
static_assert(alignof(UUpgradesMouseIPU) == 0x000008, "Wrong alignment on UUpgradesMouseIPU");
static_assert(sizeof(UUpgradesMouseIPU) == 0x000040, "Wrong size on UUpgradesMouseIPU");

// Class Stalker2.UpgradesSettings
// 0x00D8 (0x0108 - 0x0030)
class UUpgradesSettings final : public UDataAsset
{
public:
	struct FSlateColor                            Purchased;                                         // 0x0030(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            bLocked;                                           // 0x0044(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            Available;                                         // 0x0058(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            PurchasedModuleOn;                                 // 0x006C(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            PurchasedModuleOff;                                // 0x0080(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            Unavailable;                                       // 0x0094(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            LastUpdated;                                       // 0x00A8(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            ClosedNotEmptySection;                             // 0x00BC(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            EmptySection;                                      // 0x00D0(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            OpenedSection;                                     // 0x00E4(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         HorizontalMaxNumber;                               // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VerticalMaxNumber;                                 // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectionAnimationDuration;                          // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpgradesSettings">();
	}
	static class UUpgradesSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpgradesSettings>();
	}
};
static_assert(alignof(UUpgradesSettings) == 0x000008, "Wrong alignment on UUpgradesSettings");
static_assert(sizeof(UUpgradesSettings) == 0x000108, "Wrong size on UUpgradesSettings");
static_assert(offsetof(UUpgradesSettings, Purchased) == 0x000030, "Member 'UUpgradesSettings::Purchased' has a wrong offset!");
static_assert(offsetof(UUpgradesSettings, bLocked) == 0x000044, "Member 'UUpgradesSettings::bLocked' has a wrong offset!");
static_assert(offsetof(UUpgradesSettings, Available) == 0x000058, "Member 'UUpgradesSettings::Available' has a wrong offset!");
static_assert(offsetof(UUpgradesSettings, PurchasedModuleOn) == 0x00006C, "Member 'UUpgradesSettings::PurchasedModuleOn' has a wrong offset!");
static_assert(offsetof(UUpgradesSettings, PurchasedModuleOff) == 0x000080, "Member 'UUpgradesSettings::PurchasedModuleOff' has a wrong offset!");
static_assert(offsetof(UUpgradesSettings, Unavailable) == 0x000094, "Member 'UUpgradesSettings::Unavailable' has a wrong offset!");
static_assert(offsetof(UUpgradesSettings, LastUpdated) == 0x0000A8, "Member 'UUpgradesSettings::LastUpdated' has a wrong offset!");
static_assert(offsetof(UUpgradesSettings, ClosedNotEmptySection) == 0x0000BC, "Member 'UUpgradesSettings::ClosedNotEmptySection' has a wrong offset!");
static_assert(offsetof(UUpgradesSettings, EmptySection) == 0x0000D0, "Member 'UUpgradesSettings::EmptySection' has a wrong offset!");
static_assert(offsetof(UUpgradesSettings, OpenedSection) == 0x0000E4, "Member 'UUpgradesSettings::OpenedSection' has a wrong offset!");
static_assert(offsetof(UUpgradesSettings, HorizontalMaxNumber) == 0x0000F8, "Member 'UUpgradesSettings::HorizontalMaxNumber' has a wrong offset!");
static_assert(offsetof(UUpgradesSettings, VerticalMaxNumber) == 0x0000FC, "Member 'UUpgradesSettings::VerticalMaxNumber' has a wrong offset!");
static_assert(offsetof(UUpgradesSettings, SectionAnimationDuration) == 0x000100, "Member 'UUpgradesSettings::SectionAnimationDuration' has a wrong offset!");

// Class Stalker2.UpgradesWidget
// 0x0000 (0x13C8 - 0x13C8)
class UUpgradesWidget final : public UInventoryNew
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpgradesWidget">();
	}
	static class UUpgradesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpgradesWidget>();
	}
};
static_assert(alignof(UUpgradesWidget) == 0x000008, "Wrong alignment on UUpgradesWidget");
static_assert(sizeof(UUpgradesWidget) == 0x0013C8, "Wrong size on UUpgradesWidget");

// Class Stalker2.UpscalingElementOnOff
// 0x0030 (0x1DF0 - 0x1DC0)
class UUpscalingElementOnOff final : public USettingElementOnOff
{
public:
	uint8                                         Pad_1DC0[0x20];                                    // 0x1DC0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	EPerformanceBoostUpscalingMethod              UpscalingMethodValue;                              // 0x1DE0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DE1[0xF];                                     // 0x1DE1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpscalingElementOnOff">();
	}
	static class UUpscalingElementOnOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpscalingElementOnOff>();
	}
};
static_assert(alignof(UUpscalingElementOnOff) == 0x000010, "Wrong alignment on UUpscalingElementOnOff");
static_assert(sizeof(UUpscalingElementOnOff) == 0x001DF0, "Wrong size on UUpscalingElementOnOff");
static_assert(offsetof(UUpscalingElementOnOff, UpscalingMethodValue) == 0x001DE0, "Member 'UUpscalingElementOnOff::UpscalingMethodValue' has a wrong offset!");

// Class Stalker2.UpscalingElementPercent
// 0x0030 (0x1E00 - 0x1DD0)
class UUpscalingElementPercent final : public USettingsElementPercent
{
public:
	uint8                                         Pad_1DD0[0x28];                                    // 0x1DD0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	EPerformanceBoostUpscalingMethod              UpscalingMethodValue;                              // 0x1DF8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DF9[0x7];                                     // 0x1DF9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpscalingElementPercent">();
	}
	static class UUpscalingElementPercent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpscalingElementPercent>();
	}
};
static_assert(alignof(UUpscalingElementPercent) == 0x000010, "Wrong alignment on UUpscalingElementPercent");
static_assert(sizeof(UUpscalingElementPercent) == 0x001E00, "Wrong size on UUpscalingElementPercent");
static_assert(offsetof(UUpscalingElementPercent, UpscalingMethodValue) == 0x001DF8, "Member 'UUpscalingElementPercent::UpscalingMethodValue' has a wrong offset!");

// Class Stalker2.UpscalingElementSwitcher
// 0x0030 (0x1EB0 - 0x1E80)
class UUpscalingElementSwitcher final : public USettingElementSwitcher
{
public:
	uint8                                         Pad_1E80[0x28];                                    // 0x1E80(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	EPerformanceBoostUpscalingMethod              UpscalingMethodValue;                              // 0x1EA8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EA9[0x7];                                     // 0x1EA9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpscalingElementSwitcher">();
	}
	static class UUpscalingElementSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpscalingElementSwitcher>();
	}
};
static_assert(alignof(UUpscalingElementSwitcher) == 0x000010, "Wrong alignment on UUpscalingElementSwitcher");
static_assert(sizeof(UUpscalingElementSwitcher) == 0x001EB0, "Wrong size on UUpscalingElementSwitcher");
static_assert(offsetof(UUpscalingElementSwitcher, UpscalingMethodValue) == 0x001EA8, "Member 'UUpscalingElementSwitcher::UpscalingMethodValue' has a wrong offset!");

// Class Stalker2.UpscalingSettingElementInterface
// 0x0000 (0x0000 - 0x0000)
class IUpscalingSettingElementInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpscalingSettingElementInterface">();
	}
	static class IUpscalingSettingElementInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUpscalingSettingElementInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUpscalingSettingElementInterface) == 0x000001, "Wrong alignment on IUpscalingSettingElementInterface");
static_assert(sizeof(IUpscalingSettingElementInterface) == 0x000001, "Wrong size on IUpscalingSettingElementInterface");

// Class Stalker2.UserMarkerCounter
// 0x0020 (0x0298 - 0x0278)
class UUserMarkerCounter final : public UWidgetBase
{
public:
	class UTextWidget*                            CounterText;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CounterFormat;                                     // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateMarkerCounterWidget(const int32 NewAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserMarkerCounter">();
	}
	static class UUserMarkerCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserMarkerCounter>();
	}
};
static_assert(alignof(UUserMarkerCounter) == 0x000008, "Wrong alignment on UUserMarkerCounter");
static_assert(sizeof(UUserMarkerCounter) == 0x000298, "Wrong size on UUserMarkerCounter");
static_assert(offsetof(UUserMarkerCounter, CounterText) == 0x000278, "Member 'UUserMarkerCounter::CounterText' has a wrong offset!");
static_assert(offsetof(UUserMarkerCounter, CounterFormat) == 0x000280, "Member 'UUserMarkerCounter::CounterFormat' has a wrong offset!");

// Class Stalker2.UserMarkerSelector
// 0x00A0 (0x0318 - 0x0278)
class UUserMarkerSelector final : public UChildViewBase
{
public:
	uint8                                         Pad_278[0x20];                                     // 0x0278(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               ButtonOverlay;                                     // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Background;                                        // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserMarkerCounter*                     MarkerCounter;                                     // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserMarkerSelectorButton*              TopButton;                                         // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserMarkerSelectorButton*              RightButton;                                       // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserMarkerSelectorButton*              LeftButton;                                        // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserMarkerSelectorButton*              BottomButton;                                      // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBox;                                           // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ShowAnimation;                                     // 0x02D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ToGamepadCursor;                                   // 0x02E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCursor;                                         // 0x02E8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowAnimationSpeedMultiplier;                      // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HideAnimationSpeedMultiplier;                      // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CursorSelectorTransitionSpeedMultiplier;           // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              size;                                              // 0x02F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserMarkerSelectorButton*              HoveredButton;                                     // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HoverButton(class UUserMarkerSelectorButton* InHoveredButton);
	void PressedButton(const EMarkerType MarkType, const struct FVector& Coordinates);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserMarkerSelector">();
	}
	static class UUserMarkerSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserMarkerSelector>();
	}
};
static_assert(alignof(UUserMarkerSelector) == 0x000008, "Wrong alignment on UUserMarkerSelector");
static_assert(sizeof(UUserMarkerSelector) == 0x000318, "Wrong size on UUserMarkerSelector");
static_assert(offsetof(UUserMarkerSelector, ButtonOverlay) == 0x000298, "Member 'UUserMarkerSelector::ButtonOverlay' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, Background) == 0x0002A0, "Member 'UUserMarkerSelector::Background' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, MarkerCounter) == 0x0002A8, "Member 'UUserMarkerSelector::MarkerCounter' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, TopButton) == 0x0002B0, "Member 'UUserMarkerSelector::TopButton' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, RightButton) == 0x0002B8, "Member 'UUserMarkerSelector::RightButton' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, LeftButton) == 0x0002C0, "Member 'UUserMarkerSelector::LeftButton' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, BottomButton) == 0x0002C8, "Member 'UUserMarkerSelector::BottomButton' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, SizeBox) == 0x0002D0, "Member 'UUserMarkerSelector::SizeBox' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, ShowAnimation) == 0x0002D8, "Member 'UUserMarkerSelector::ShowAnimation' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, ToGamepadCursor) == 0x0002E0, "Member 'UUserMarkerSelector::ToGamepadCursor' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, bIsCursor) == 0x0002E8, "Member 'UUserMarkerSelector::bIsCursor' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, ShowAnimationSpeedMultiplier) == 0x0002EC, "Member 'UUserMarkerSelector::ShowAnimationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, HideAnimationSpeedMultiplier) == 0x0002F0, "Member 'UUserMarkerSelector::HideAnimationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, CursorSelectorTransitionSpeedMultiplier) == 0x0002F4, "Member 'UUserMarkerSelector::CursorSelectorTransitionSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, size) == 0x0002F8, "Member 'UUserMarkerSelector::size' has a wrong offset!");
static_assert(offsetof(UUserMarkerSelector, HoveredButton) == 0x000308, "Member 'UUserMarkerSelector::HoveredButton' has a wrong offset!");

// Class Stalker2.UserWaterElement
// 0x0008 (0x0280 - 0x0278)
class UUserWaterElement : public UWidgetBase
{
public:
	class UOverlay*                               WaterMarks;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWaterElement">();
	}
	static class UUserWaterElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWaterElement>();
	}
};
static_assert(alignof(UUserWaterElement) == 0x000008, "Wrong alignment on UUserWaterElement");
static_assert(sizeof(UUserWaterElement) == 0x000280, "Wrong size on UUserWaterElement");
static_assert(offsetof(UUserWaterElement, WaterMarks) == 0x000278, "Member 'UUserWaterElement::WaterMarks' has a wrong offset!");

// Class Stalker2.UserWaterElementText
// 0x0018 (0x0290 - 0x0278)
class UUserWaterElementText : public UWidgetBase
{
public:
	class UTextBlock*                             WaterMarkText;                                     // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       WaterElementMovement;                              // 0x0280(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationSpeed;                                    // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWaterElementText">();
	}
	static class UUserWaterElementText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWaterElementText>();
	}
};
static_assert(alignof(UUserWaterElementText) == 0x000008, "Wrong alignment on UUserWaterElementText");
static_assert(sizeof(UUserWaterElementText) == 0x000290, "Wrong size on UUserWaterElementText");
static_assert(offsetof(UUserWaterElementText, WaterMarkText) == 0x000278, "Member 'UUserWaterElementText::WaterMarkText' has a wrong offset!");
static_assert(offsetof(UUserWaterElementText, WaterElementMovement) == 0x000280, "Member 'UUserWaterElementText::WaterElementMovement' has a wrong offset!");
static_assert(offsetof(UUserWaterElementText, AnimationSpeed) == 0x000288, "Member 'UUserWaterElementText::AnimationSpeed' has a wrong offset!");

// Class Stalker2.VerticalLadder
// 0x00E8 (0x03D0 - 0x02E8)
class AVerticalLadder final : public AInteractableObject
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          ClimbZone;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        ClimbStart;                                        // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        FoldedLadderRoot;                                  // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          FoldedLadderCollisionComponent;                    // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USingleClickComponent*                  SingleClickComponent;                              // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULadderComponent*                       LadderComponent;                                   // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImpulseComponent*                      ImpulseComponent;                                  // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CollisionExtend;                                   // 0x0328(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CollisionHeightUpperExtend;                        // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LadderAccessAngle;                                 // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LadderHeight;                                      // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoInteractTop;                                  // 0x0344(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoInteractBottom;                               // 0x0345(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimbingCollisionEnabled;                         // 0x0346(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMeshVisible;                                      // 0x0347(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELadderType                                   LadderType;                                        // 0x0348(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFoldedLadder;                                     // 0x0349(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34A[0x2];                                      // 0x034A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FoldedLadderHeight;                                // 0x034C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FoldedLadderZLocation;                             // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FoldedLadderHorizontalOffset;                      // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FoldedLadderPushImpulse;                           // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BottomSupportMeshOffset;                           // 0x0360(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TopSupportMeshOffset;                              // 0x0378(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x40];                                     // 0x0390(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClimbZoneBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);
	void OnClimbZoneEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex);
	void OnHiddenStateChanged();
	void OnLadderEnabled();
	void OnUnfoldingEnded();
	void OnUnfoldingStarted();
	void ProtectMeshLock(const ECollisionEnabled CollisionType);

	float GetClimbZoneHalfHeight() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VerticalLadder">();
	}
	static class AVerticalLadder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVerticalLadder>();
	}
};
static_assert(alignof(AVerticalLadder) == 0x000008, "Wrong alignment on AVerticalLadder");
static_assert(sizeof(AVerticalLadder) == 0x0003D0, "Wrong size on AVerticalLadder");
static_assert(offsetof(AVerticalLadder, ClimbZone) == 0x0002F0, "Member 'AVerticalLadder::ClimbZone' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, ClimbStart) == 0x0002F8, "Member 'AVerticalLadder::ClimbStart' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, FoldedLadderRoot) == 0x000300, "Member 'AVerticalLadder::FoldedLadderRoot' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, FoldedLadderCollisionComponent) == 0x000308, "Member 'AVerticalLadder::FoldedLadderCollisionComponent' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, SingleClickComponent) == 0x000310, "Member 'AVerticalLadder::SingleClickComponent' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, LadderComponent) == 0x000318, "Member 'AVerticalLadder::LadderComponent' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, ImpulseComponent) == 0x000320, "Member 'AVerticalLadder::ImpulseComponent' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, CollisionExtend) == 0x000328, "Member 'AVerticalLadder::CollisionExtend' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, CollisionHeightUpperExtend) == 0x000338, "Member 'AVerticalLadder::CollisionHeightUpperExtend' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, LadderAccessAngle) == 0x00033C, "Member 'AVerticalLadder::LadderAccessAngle' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, LadderHeight) == 0x000340, "Member 'AVerticalLadder::LadderHeight' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, bAutoInteractTop) == 0x000344, "Member 'AVerticalLadder::bAutoInteractTop' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, bAutoInteractBottom) == 0x000345, "Member 'AVerticalLadder::bAutoInteractBottom' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, bClimbingCollisionEnabled) == 0x000346, "Member 'AVerticalLadder::bClimbingCollisionEnabled' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, bMeshVisible) == 0x000347, "Member 'AVerticalLadder::bMeshVisible' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, LadderType) == 0x000348, "Member 'AVerticalLadder::LadderType' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, bFoldedLadder) == 0x000349, "Member 'AVerticalLadder::bFoldedLadder' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, FoldedLadderHeight) == 0x00034C, "Member 'AVerticalLadder::FoldedLadderHeight' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, FoldedLadderZLocation) == 0x000350, "Member 'AVerticalLadder::FoldedLadderZLocation' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, FoldedLadderHorizontalOffset) == 0x000354, "Member 'AVerticalLadder::FoldedLadderHorizontalOffset' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, FoldedLadderPushImpulse) == 0x000358, "Member 'AVerticalLadder::FoldedLadderPushImpulse' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, BottomSupportMeshOffset) == 0x000360, "Member 'AVerticalLadder::BottomSupportMeshOffset' has a wrong offset!");
static_assert(offsetof(AVerticalLadder, TopSupportMeshOffset) == 0x000378, "Member 'AVerticalLadder::TopSupportMeshOffset' has a wrong offset!");

// Class Stalker2.VideoLoadingScreenWidget
// 0x0038 (0x0328 - 0x02F0)
class UVideoLoadingScreenWidget : public UTimedLoadingScreenWidget
{
public:
	class UBinkMediaPlayer*                       BinkMediaPlayer;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x30];                                     // 0x02F8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndVideo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VideoLoadingScreenWidget">();
	}
	static class UVideoLoadingScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVideoLoadingScreenWidget>();
	}
};
static_assert(alignof(UVideoLoadingScreenWidget) == 0x000008, "Wrong alignment on UVideoLoadingScreenWidget");
static_assert(sizeof(UVideoLoadingScreenWidget) == 0x000328, "Wrong size on UVideoLoadingScreenWidget");
static_assert(offsetof(UVideoLoadingScreenWidget, BinkMediaPlayer) == 0x0002F0, "Member 'UVideoLoadingScreenWidget::BinkMediaPlayer' has a wrong offset!");

// Class Stalker2.VoiceoverSpeechComponent
// 0x01C0 (0x0240 - 0x0080)
class UVoiceoverSpeechComponent final : public USpeechComponent
{
public:
	uint8                                         Pad_80[0x50];                                      // 0x0080(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           AkVoiceoverSpeakerComponent;                       // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x168];                                     // 0x00D8(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAKEventFinished(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoiceoverSpeechComponent">();
	}
	static class UVoiceoverSpeechComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoiceoverSpeechComponent>();
	}
};
static_assert(alignof(UVoiceoverSpeechComponent) == 0x000008, "Wrong alignment on UVoiceoverSpeechComponent");
static_assert(sizeof(UVoiceoverSpeechComponent) == 0x000240, "Wrong size on UVoiceoverSpeechComponent");
static_assert(offsetof(UVoiceoverSpeechComponent, AkVoiceoverSpeakerComponent) == 0x0000D0, "Member 'UVoiceoverSpeechComponent::AkVoiceoverSpeakerComponent' has a wrong offset!");

// Class Stalker2.VortexAnomaly
// 0x0280 (0x0528 - 0x02A8)
class AVortexAnomaly final : public AUIDActor_VortexArchAnomaly
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           AudioComponent;                                    // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                VortexDistanceRTPC;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinPlayerDistanceToUpdateSound;                    // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVortexSplineDataPoint>         VortexMovementData;                                // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   RootMeshComponent;                                 // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   VortexCollisionComponent;                          // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   VortexSafeZoneComponent;                           // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexHalfHeight;                                  // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexCollisionRadius;                             // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexSafeZoneRadius;                              // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEffectPrototypeSID>            ObjectCollisionEffects;                            // 0x0308(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FFloatInterval                         AllowedThrowAngleInterval;                         // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowInvulnerabilityDuration;                      // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexOuterImpulse;                                // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexOuterLiftHeight;                             // 0x0328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexOuterLiftHorizontalSpeed;                    // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexOuterLiftVerticalSpeed;                      // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexOuterLiftMaxDuration;                        // 0x0334(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexInnerImpulse;                                // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexInnerLiftHeight;                             // 0x033C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexInnerLiftHorizontalSpeed;                    // 0x0340(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexInnerLiftVerticalSpeed;                      // 0x0344(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexInnerLiftMaxDuration;                        // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexSafeZoneLeaveTime;                           // 0x034C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FEffectPrototypeSID>            SafeZoneLeaveEffects;                              // 0x0350(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FPrototypeSID                          ArtifactSID;                                       // 0x0360(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArtifactHeight;                                    // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnArtifactOnEmissionOnly;                      // 0x03A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A5[0x3];                                      // 0x03A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DudeSpawnDistance;                                 // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DudeSpawnHeight;                                   // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DudeTimeToReachPlayer;                             // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DudeTargetDistance;                                // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexToPlayerDistForDudeSpawn;                    // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VortexToPlayerDistCheckFrequency;                  // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrototypeSID                          SpawnedObjSID;                                     // 0x03C0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrototypeSID                          SpawnedCorpseSID;                                  // 0x0400(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          DudeAudioEvent;                                    // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  WeatherSelectionVolumeGuid;                        // 0x0448(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           IndoorMPC;                                         // 0x0458(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  Guid;                                              // 0x0460(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0xB8];                                     // 0x0470(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVortexBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);
	void OnVortexEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex);
	void OnVortexSafeZoneBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex, const bool bFromSweep, const struct FHitResult& SweepResult);
	void OnVortexSafeZoneEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VortexAnomaly">();
	}
	static class AVortexAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVortexAnomaly>();
	}
};
static_assert(alignof(AVortexAnomaly) == 0x000008, "Wrong alignment on AVortexAnomaly");
static_assert(sizeof(AVortexAnomaly) == 0x000528, "Wrong size on AVortexAnomaly");
static_assert(offsetof(AVortexAnomaly, AudioComponent) == 0x0002B0, "Member 'AVortexAnomaly::AudioComponent' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexDistanceRTPC) == 0x0002B8, "Member 'AVortexAnomaly::VortexDistanceRTPC' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, MinPlayerDistanceToUpdateSound) == 0x0002C0, "Member 'AVortexAnomaly::MinPlayerDistanceToUpdateSound' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, SplineComponent) == 0x0002C8, "Member 'AVortexAnomaly::SplineComponent' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexMovementData) == 0x0002D0, "Member 'AVortexAnomaly::VortexMovementData' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, RootMeshComponent) == 0x0002E0, "Member 'AVortexAnomaly::RootMeshComponent' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexCollisionComponent) == 0x0002E8, "Member 'AVortexAnomaly::VortexCollisionComponent' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexSafeZoneComponent) == 0x0002F0, "Member 'AVortexAnomaly::VortexSafeZoneComponent' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexHalfHeight) == 0x0002F8, "Member 'AVortexAnomaly::VortexHalfHeight' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexCollisionRadius) == 0x0002FC, "Member 'AVortexAnomaly::VortexCollisionRadius' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexSafeZoneRadius) == 0x000300, "Member 'AVortexAnomaly::VortexSafeZoneRadius' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, ObjectCollisionEffects) == 0x000308, "Member 'AVortexAnomaly::ObjectCollisionEffects' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, AllowedThrowAngleInterval) == 0x000318, "Member 'AVortexAnomaly::AllowedThrowAngleInterval' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, ThrowInvulnerabilityDuration) == 0x000320, "Member 'AVortexAnomaly::ThrowInvulnerabilityDuration' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexOuterImpulse) == 0x000324, "Member 'AVortexAnomaly::VortexOuterImpulse' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexOuterLiftHeight) == 0x000328, "Member 'AVortexAnomaly::VortexOuterLiftHeight' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexOuterLiftHorizontalSpeed) == 0x00032C, "Member 'AVortexAnomaly::VortexOuterLiftHorizontalSpeed' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexOuterLiftVerticalSpeed) == 0x000330, "Member 'AVortexAnomaly::VortexOuterLiftVerticalSpeed' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexOuterLiftMaxDuration) == 0x000334, "Member 'AVortexAnomaly::VortexOuterLiftMaxDuration' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexInnerImpulse) == 0x000338, "Member 'AVortexAnomaly::VortexInnerImpulse' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexInnerLiftHeight) == 0x00033C, "Member 'AVortexAnomaly::VortexInnerLiftHeight' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexInnerLiftHorizontalSpeed) == 0x000340, "Member 'AVortexAnomaly::VortexInnerLiftHorizontalSpeed' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexInnerLiftVerticalSpeed) == 0x000344, "Member 'AVortexAnomaly::VortexInnerLiftVerticalSpeed' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexInnerLiftMaxDuration) == 0x000348, "Member 'AVortexAnomaly::VortexInnerLiftMaxDuration' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexSafeZoneLeaveTime) == 0x00034C, "Member 'AVortexAnomaly::VortexSafeZoneLeaveTime' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, SafeZoneLeaveEffects) == 0x000350, "Member 'AVortexAnomaly::SafeZoneLeaveEffects' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, ArtifactSID) == 0x000360, "Member 'AVortexAnomaly::ArtifactSID' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, ArtifactHeight) == 0x0003A0, "Member 'AVortexAnomaly::ArtifactHeight' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, bSpawnArtifactOnEmissionOnly) == 0x0003A4, "Member 'AVortexAnomaly::bSpawnArtifactOnEmissionOnly' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, DudeSpawnDistance) == 0x0003A8, "Member 'AVortexAnomaly::DudeSpawnDistance' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, DudeSpawnHeight) == 0x0003AC, "Member 'AVortexAnomaly::DudeSpawnHeight' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, DudeTimeToReachPlayer) == 0x0003B0, "Member 'AVortexAnomaly::DudeTimeToReachPlayer' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, DudeTargetDistance) == 0x0003B4, "Member 'AVortexAnomaly::DudeTargetDistance' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexToPlayerDistForDudeSpawn) == 0x0003B8, "Member 'AVortexAnomaly::VortexToPlayerDistForDudeSpawn' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, VortexToPlayerDistCheckFrequency) == 0x0003BC, "Member 'AVortexAnomaly::VortexToPlayerDistCheckFrequency' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, SpawnedObjSID) == 0x0003C0, "Member 'AVortexAnomaly::SpawnedObjSID' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, SpawnedCorpseSID) == 0x000400, "Member 'AVortexAnomaly::SpawnedCorpseSID' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, DudeAudioEvent) == 0x000440, "Member 'AVortexAnomaly::DudeAudioEvent' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, WeatherSelectionVolumeGuid) == 0x000448, "Member 'AVortexAnomaly::WeatherSelectionVolumeGuid' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, IndoorMPC) == 0x000458, "Member 'AVortexAnomaly::IndoorMPC' has a wrong offset!");
static_assert(offsetof(AVortexAnomaly, Guid) == 0x000460, "Member 'AVortexAnomaly::Guid' has a wrong offset!");

// Class Stalker2.VortexMPCVolume
// 0x0000 (0x02D8 - 0x02D8)
class AVortexMPCVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VortexMPCVolume">();
	}
	static class AVortexMPCVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVortexMPCVolume>();
	}
};
static_assert(alignof(AVortexMPCVolume) == 0x000008, "Wrong alignment on AVortexMPCVolume");
static_assert(sizeof(AVortexMPCVolume) == 0x0002D8, "Wrong size on AVortexMPCVolume");

// Class Stalker2.WalkIPU
// 0x0000 (0x0058 - 0x0058)
class UWalkIPU final : public UBehaviorBasedIPU
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WalkIPU">();
	}
	static class UWalkIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWalkIPU>();
	}
};
static_assert(alignof(UWalkIPU) == 0x000008, "Wrong alignment on UWalkIPU");
static_assert(sizeof(UWalkIPU) == 0x000058, "Wrong size on UWalkIPU");

// Class Stalker2.WanderingLightInstanceSpline
// 0x0000 (0x0680 - 0x0680)
class UWanderingLightInstanceSpline final : public USplineComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WanderingLightInstanceSpline">();
	}
	static class UWanderingLightInstanceSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWanderingLightInstanceSpline>();
	}
};
static_assert(alignof(UWanderingLightInstanceSpline) == 0x000010, "Wrong alignment on UWanderingLightInstanceSpline");
static_assert(sizeof(UWanderingLightInstanceSpline) == 0x000680, "Wrong size on UWanderingLightInstanceSpline");

// Class Stalker2.WanderingLightInstance
// 0x0000 (0x0298 - 0x0298)
class AWanderingLightInstance final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WanderingLightInstance">();
	}
	static class AWanderingLightInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWanderingLightInstance>();
	}
};
static_assert(alignof(AWanderingLightInstance) == 0x000008, "Wrong alignment on AWanderingLightInstance");
static_assert(sizeof(AWanderingLightInstance) == 0x000298, "Wrong size on AWanderingLightInstance");

// Class Stalker2.WLCylinderShapeComponent
// 0x0000 (0x05B0 - 0x05B0)
class UWLCylinderShapeComponent final : public UDebugDrawComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WLCylinderShapeComponent">();
	}
	static class UWLCylinderShapeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWLCylinderShapeComponent>();
	}
};
static_assert(alignof(UWLCylinderShapeComponent) == 0x000010, "Wrong alignment on UWLCylinderShapeComponent");
static_assert(sizeof(UWLCylinderShapeComponent) == 0x0005B0, "Wrong size on UWLCylinderShapeComponent");

// Class Stalker2.WanderingLightsArchiAnomaly
// 0x0D38 (0x0FD0 - 0x0298)
class AWanderingLightsArchiAnomaly final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ArtifactModelSID;                                  // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerMaxVisibilityDistance;                       // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayerViewFOVOverride;                            // 0x02B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerViewFOVDeg;                                  // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRuntimeFloatCurve>             PlayerFlashlightIntensityScaleCurves;              // 0x02C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         AnomalyStartTime;                                  // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnomalyEndTime;                                    // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InstanceVisibilityRadius;                          // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InstanceVisibilityChangeDelay;                     // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InstanceChemicalDamageRadius;                      // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InstanceChemicalDamagePerSecond;                   // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bScaleChemicalDamageFromPenetration;               // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InstanceOpacityChangeSpeed;                        // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRandomizeInstanceSpawnTime;                       // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1[0x3];                                      // 0x02F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomizedSpawnTimeOffsetMax;                      // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     InstanceVerticalMovementCurve;                     // 0x02F8(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bSkipMovementDuringWakeUp;                         // 0x0380(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkipMovementDuringShutDown;                       // 0x0381(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_382[0x2];                                      // 0x0382(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InstanceSpawnTime;                                 // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InstanceBlendTime;                                 // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AutoUpdateInstanceData;                            // 0x038C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          StretchBoundsWithInstanceData;                     // 0x038D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowVFXInEditMode;                                 // 0x038E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38F[0x1];                                      // 0x038F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AnomalyBounds;                                     // 0x0390(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BoundsMargin;                                      // 0x03A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraSystem>          IdleEffect;                                        // 0x03C0(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraSystem>          InteractEffect;                                    // 0x03F0(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FWLParticlesPropertyState>      IdleStateVFXParameters;                            // 0x0420(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FWLParticlesPropertyState>      TargetedStateVFXParameters;                        // 0x0430(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         TargetedStateVFXParametersDelay;                   // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialScalarDrivingProperties> MaterialCollectionsToDrive;                      // 0x0448(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         PostProcessBlendRadius;                            // 0x0458(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostProcessPriority;                               // 0x045C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0460(0x0720)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<EWanderingLightsSimulationState, class UAkAudioEvent*> StateSFXEvents;                      // 0x0B80(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EWanderingLightsSimulationState, class UAkSwitchValue*> StateSFXSwitches;                   // 0x0BD0(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FWanderingLightInstanceData>    AnomalyInstances;                                  // 0x0C20(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FPrototypeSID                          PlayerPSYEffectInsideAnomalyBounds;                // 0x0C30(0x0040)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BoxComponent;                                      // 0x0C70(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C78[0x290];                                    // 0x0C78(0x0290)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWLCylinderShapeParams                 CylinderShapeParams;                               // 0x0F08(0x0028)(NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        ArtifactSpawnLocations;                            // 0x0F30(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F40[0x90];                                     // 0x0F40(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateVFX(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WanderingLightsArchiAnomaly">();
	}
	static class AWanderingLightsArchiAnomaly* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWanderingLightsArchiAnomaly>();
	}
};
static_assert(alignof(AWanderingLightsArchiAnomaly) == 0x000010, "Wrong alignment on AWanderingLightsArchiAnomaly");
static_assert(sizeof(AWanderingLightsArchiAnomaly) == 0x000FD0, "Wrong size on AWanderingLightsArchiAnomaly");
static_assert(offsetof(AWanderingLightsArchiAnomaly, ArtifactModelSID) == 0x0002A0, "Member 'AWanderingLightsArchiAnomaly::ArtifactModelSID' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, PlayerMaxVisibilityDistance) == 0x0002B0, "Member 'AWanderingLightsArchiAnomaly::PlayerMaxVisibilityDistance' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, bPlayerViewFOVOverride) == 0x0002B4, "Member 'AWanderingLightsArchiAnomaly::bPlayerViewFOVOverride' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, PlayerViewFOVDeg) == 0x0002B8, "Member 'AWanderingLightsArchiAnomaly::PlayerViewFOVDeg' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, PlayerFlashlightIntensityScaleCurves) == 0x0002C0, "Member 'AWanderingLightsArchiAnomaly::PlayerFlashlightIntensityScaleCurves' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, AnomalyStartTime) == 0x0002D0, "Member 'AWanderingLightsArchiAnomaly::AnomalyStartTime' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, AnomalyEndTime) == 0x0002D4, "Member 'AWanderingLightsArchiAnomaly::AnomalyEndTime' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, InstanceVisibilityRadius) == 0x0002D8, "Member 'AWanderingLightsArchiAnomaly::InstanceVisibilityRadius' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, InstanceVisibilityChangeDelay) == 0x0002DC, "Member 'AWanderingLightsArchiAnomaly::InstanceVisibilityChangeDelay' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, InstanceChemicalDamageRadius) == 0x0002E0, "Member 'AWanderingLightsArchiAnomaly::InstanceChemicalDamageRadius' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, InstanceChemicalDamagePerSecond) == 0x0002E4, "Member 'AWanderingLightsArchiAnomaly::InstanceChemicalDamagePerSecond' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, bScaleChemicalDamageFromPenetration) == 0x0002E8, "Member 'AWanderingLightsArchiAnomaly::bScaleChemicalDamageFromPenetration' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, InstanceOpacityChangeSpeed) == 0x0002EC, "Member 'AWanderingLightsArchiAnomaly::InstanceOpacityChangeSpeed' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, bRandomizeInstanceSpawnTime) == 0x0002F0, "Member 'AWanderingLightsArchiAnomaly::bRandomizeInstanceSpawnTime' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, RandomizedSpawnTimeOffsetMax) == 0x0002F4, "Member 'AWanderingLightsArchiAnomaly::RandomizedSpawnTimeOffsetMax' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, InstanceVerticalMovementCurve) == 0x0002F8, "Member 'AWanderingLightsArchiAnomaly::InstanceVerticalMovementCurve' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, bSkipMovementDuringWakeUp) == 0x000380, "Member 'AWanderingLightsArchiAnomaly::bSkipMovementDuringWakeUp' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, bSkipMovementDuringShutDown) == 0x000381, "Member 'AWanderingLightsArchiAnomaly::bSkipMovementDuringShutDown' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, InstanceSpawnTime) == 0x000384, "Member 'AWanderingLightsArchiAnomaly::InstanceSpawnTime' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, InstanceBlendTime) == 0x000388, "Member 'AWanderingLightsArchiAnomaly::InstanceBlendTime' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, AutoUpdateInstanceData) == 0x00038C, "Member 'AWanderingLightsArchiAnomaly::AutoUpdateInstanceData' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, StretchBoundsWithInstanceData) == 0x00038D, "Member 'AWanderingLightsArchiAnomaly::StretchBoundsWithInstanceData' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, ShowVFXInEditMode) == 0x00038E, "Member 'AWanderingLightsArchiAnomaly::ShowVFXInEditMode' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, AnomalyBounds) == 0x000390, "Member 'AWanderingLightsArchiAnomaly::AnomalyBounds' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, BoundsMargin) == 0x0003A8, "Member 'AWanderingLightsArchiAnomaly::BoundsMargin' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, IdleEffect) == 0x0003C0, "Member 'AWanderingLightsArchiAnomaly::IdleEffect' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, InteractEffect) == 0x0003F0, "Member 'AWanderingLightsArchiAnomaly::InteractEffect' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, IdleStateVFXParameters) == 0x000420, "Member 'AWanderingLightsArchiAnomaly::IdleStateVFXParameters' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, TargetedStateVFXParameters) == 0x000430, "Member 'AWanderingLightsArchiAnomaly::TargetedStateVFXParameters' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, TargetedStateVFXParametersDelay) == 0x000440, "Member 'AWanderingLightsArchiAnomaly::TargetedStateVFXParametersDelay' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, MaterialCollectionsToDrive) == 0x000448, "Member 'AWanderingLightsArchiAnomaly::MaterialCollectionsToDrive' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, PostProcessBlendRadius) == 0x000458, "Member 'AWanderingLightsArchiAnomaly::PostProcessBlendRadius' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, PostProcessPriority) == 0x00045C, "Member 'AWanderingLightsArchiAnomaly::PostProcessPriority' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, PostProcessSettings) == 0x000460, "Member 'AWanderingLightsArchiAnomaly::PostProcessSettings' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, StateSFXEvents) == 0x000B80, "Member 'AWanderingLightsArchiAnomaly::StateSFXEvents' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, StateSFXSwitches) == 0x000BD0, "Member 'AWanderingLightsArchiAnomaly::StateSFXSwitches' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, AnomalyInstances) == 0x000C20, "Member 'AWanderingLightsArchiAnomaly::AnomalyInstances' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, PlayerPSYEffectInsideAnomalyBounds) == 0x000C30, "Member 'AWanderingLightsArchiAnomaly::PlayerPSYEffectInsideAnomalyBounds' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, BoxComponent) == 0x000C70, "Member 'AWanderingLightsArchiAnomaly::BoxComponent' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, CylinderShapeParams) == 0x000F08, "Member 'AWanderingLightsArchiAnomaly::CylinderShapeParams' has a wrong offset!");
static_assert(offsetof(AWanderingLightsArchiAnomaly, ArtifactSpawnLocations) == 0x000F30, "Member 'AWanderingLightsArchiAnomaly::ArtifactSpawnLocations' has a wrong offset!");

// Class Stalker2.WaterComponent
// 0x0030 (0x00D0 - 0x00A0)
class UWaterComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAffectedByRain;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0xF];                                       // 0x00A9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     RegularWaterMaterial;                              // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class AActor* OverlappedComponent, class AActor* OtherActor);
	void OnEndOverlap(class AActor* OverlappedComponent, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterComponent">();
	}
	static class UWaterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterComponent>();
	}
};
static_assert(alignof(UWaterComponent) == 0x000008, "Wrong alignment on UWaterComponent");
static_assert(sizeof(UWaterComponent) == 0x0000D0, "Wrong size on UWaterComponent");
static_assert(offsetof(UWaterComponent, bAffectedByRain) == 0x0000A8, "Member 'UWaterComponent::bAffectedByRain' has a wrong offset!");
static_assert(offsetof(UWaterComponent, RegularWaterMaterial) == 0x0000B8, "Member 'UWaterComponent::RegularWaterMaterial' has a wrong offset!");

// Class Stalker2.WaterElement
// 0x0008 (0x0280 - 0x0278)
class UWaterElement : public UWidgetBase
{
public:
	class UTextBlock*                             TextBlock;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterElement">();
	}
	static class UWaterElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterElement>();
	}
};
static_assert(alignof(UWaterElement) == 0x000008, "Wrong alignment on UWaterElement");
static_assert(sizeof(UWaterElement) == 0x000280, "Wrong size on UWaterElement");
static_assert(offsetof(UWaterElement, TextBlock) == 0x000278, "Member 'UWaterElement::TextBlock' has a wrong offset!");

// Class Stalker2.WaterManager
// 0x0058 (0x00D0 - 0x0078)
class UWaterManager final : public UBaseManager
{
public:
	uint8                                         Pad_78[0x58];                                      // 0x0078(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterManager">();
	}
	static class UWaterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterManager>();
	}
};
static_assert(alignof(UWaterManager) == 0x000008, "Wrong alignment on UWaterManager");
static_assert(sizeof(UWaterManager) == 0x0000D0, "Wrong size on UWaterManager");

// Class Stalker2.WaterTraceComponent
// 0x0028 (0x00C8 - 0x00A0)
class UWaterTraceComponent final : public UActorComponent
{
public:
	struct FVector                                PreviousLocation;                                  // 0x00A0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterTraceComponent">();
	}
	static class UWaterTraceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterTraceComponent>();
	}
};
static_assert(alignof(UWaterTraceComponent) == 0x000008, "Wrong alignment on UWaterTraceComponent");
static_assert(sizeof(UWaterTraceComponent) == 0x0000C8, "Wrong size on UWaterTraceComponent");
static_assert(offsetof(UWaterTraceComponent, PreviousLocation) == 0x0000A0, "Member 'UWaterTraceComponent::PreviousLocation' has a wrong offset!");

// Class Stalker2.WeaponDisplayInterface
// 0x0000 (0x0000 - 0x0000)
class IWeaponDisplayInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponDisplayInterface">();
	}
	static class IWeaponDisplayInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWeaponDisplayInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IWeaponDisplayInterface) == 0x000001, "Wrong alignment on IWeaponDisplayInterface");
static_assert(sizeof(IWeaponDisplayInterface) == 0x000001, "Wrong size on IWeaponDisplayInterface");

// Class Stalker2.WeatherParameterNamesDataAsset
// 0x01C8 (0x01F8 - 0x0030)
class UWeatherParameterNamesDataAsset final : public UDataAsset
{
public:
	class FName                                   AtmosphereBrightness;                              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EmissiveBrightness;                                // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ZenithColor;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HorizonColor;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloudMapBias;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloudMapDensity;                                   // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NoiseFlowMapAMultiplier;                           // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NoiseFlowMapABias;                                 // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NoiseFlowMapADetail;                               // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NoiseFlowMapABottomNoise;                          // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NoiseFlowMapBBias;                                 // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NoiseFlowMapBDetail;                               // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NoiseFlowMapBScale;                                // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BillowyStormyCloudsHeight;                         // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DensityVariationScale;                             // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DensityVariationPower;                             // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DensityVariationOutFirst;                          // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DensityVariationOutSecond;                         // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DensityVariationDarkMinDensity;                    // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloudBaseCapMaskRadius;                            // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloudBaseSpeedMultiplier;                          // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloudBaseECX;                                      // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloudBasePreExponentialDensity;                    // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloudBaseAlbedo;                                   // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloudBaseSecondAlbedo;                             // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EmissionParamPositionIntensity;                    // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EmissionParamColor;                                // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhaseBlend;                                        // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhaseG;                                            // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhaseGSecond;                                      // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MultiScatteringContribution;                       // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MultiScatteringOcclusion;                          // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MultiScatteringOcclusionPower;                     // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MultiScatteringEccentricity;                       // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoonOpacity;                                       // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoonLatitude;                                      // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoonLongitude;                                     // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SunShadowAmount;                                   // 0x0158(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkyAtmColorPower;                                  // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WindIntensity;                                     // 0x0168(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WindDirection;                                     // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FoliageWindDirection;                              // 0x0178(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FoliageWindIntensity;                              // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PreviousFoliageWindDirection;                      // 0x0188(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PreviousFoliageWindIntensity;                      // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RainActivate;                                      // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TimeOfDay;                                         // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Wetness;                                           // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WaterWindNormalMultiplier;                         // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RainWindDirection;                                 // 0x01B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RainWindStrength;                                  // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RainSpawnRate;                                     // 0x01C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LightningSpawnRate;                                // 0x01D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LightningColor;                                    // 0x01D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StormSpawnRate;                                    // 0x01E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloudShift;                                        // 0x01E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WaterShift;                                        // 0x01F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherParameterNamesDataAsset">();
	}
	static class UWeatherParameterNamesDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeatherParameterNamesDataAsset>();
	}
};
static_assert(alignof(UWeatherParameterNamesDataAsset) == 0x000008, "Wrong alignment on UWeatherParameterNamesDataAsset");
static_assert(sizeof(UWeatherParameterNamesDataAsset) == 0x0001F8, "Wrong size on UWeatherParameterNamesDataAsset");
static_assert(offsetof(UWeatherParameterNamesDataAsset, AtmosphereBrightness) == 0x000030, "Member 'UWeatherParameterNamesDataAsset::AtmosphereBrightness' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, EmissiveBrightness) == 0x000038, "Member 'UWeatherParameterNamesDataAsset::EmissiveBrightness' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, ZenithColor) == 0x000040, "Member 'UWeatherParameterNamesDataAsset::ZenithColor' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, HorizonColor) == 0x000048, "Member 'UWeatherParameterNamesDataAsset::HorizonColor' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, CloudMapBias) == 0x000050, "Member 'UWeatherParameterNamesDataAsset::CloudMapBias' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, CloudMapDensity) == 0x000058, "Member 'UWeatherParameterNamesDataAsset::CloudMapDensity' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, NoiseFlowMapAMultiplier) == 0x000060, "Member 'UWeatherParameterNamesDataAsset::NoiseFlowMapAMultiplier' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, NoiseFlowMapABias) == 0x000068, "Member 'UWeatherParameterNamesDataAsset::NoiseFlowMapABias' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, NoiseFlowMapADetail) == 0x000070, "Member 'UWeatherParameterNamesDataAsset::NoiseFlowMapADetail' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, NoiseFlowMapABottomNoise) == 0x000078, "Member 'UWeatherParameterNamesDataAsset::NoiseFlowMapABottomNoise' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, NoiseFlowMapBBias) == 0x000080, "Member 'UWeatherParameterNamesDataAsset::NoiseFlowMapBBias' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, NoiseFlowMapBDetail) == 0x000088, "Member 'UWeatherParameterNamesDataAsset::NoiseFlowMapBDetail' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, NoiseFlowMapBScale) == 0x000090, "Member 'UWeatherParameterNamesDataAsset::NoiseFlowMapBScale' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, BillowyStormyCloudsHeight) == 0x000098, "Member 'UWeatherParameterNamesDataAsset::BillowyStormyCloudsHeight' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, DensityVariationScale) == 0x0000A0, "Member 'UWeatherParameterNamesDataAsset::DensityVariationScale' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, DensityVariationPower) == 0x0000A8, "Member 'UWeatherParameterNamesDataAsset::DensityVariationPower' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, DensityVariationOutFirst) == 0x0000B0, "Member 'UWeatherParameterNamesDataAsset::DensityVariationOutFirst' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, DensityVariationOutSecond) == 0x0000B8, "Member 'UWeatherParameterNamesDataAsset::DensityVariationOutSecond' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, DensityVariationDarkMinDensity) == 0x0000C0, "Member 'UWeatherParameterNamesDataAsset::DensityVariationDarkMinDensity' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, CloudBaseCapMaskRadius) == 0x0000C8, "Member 'UWeatherParameterNamesDataAsset::CloudBaseCapMaskRadius' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, CloudBaseSpeedMultiplier) == 0x0000D0, "Member 'UWeatherParameterNamesDataAsset::CloudBaseSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, CloudBaseECX) == 0x0000D8, "Member 'UWeatherParameterNamesDataAsset::CloudBaseECX' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, CloudBasePreExponentialDensity) == 0x0000E0, "Member 'UWeatherParameterNamesDataAsset::CloudBasePreExponentialDensity' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, CloudBaseAlbedo) == 0x0000E8, "Member 'UWeatherParameterNamesDataAsset::CloudBaseAlbedo' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, CloudBaseSecondAlbedo) == 0x0000F0, "Member 'UWeatherParameterNamesDataAsset::CloudBaseSecondAlbedo' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, EmissionParamPositionIntensity) == 0x0000F8, "Member 'UWeatherParameterNamesDataAsset::EmissionParamPositionIntensity' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, EmissionParamColor) == 0x000100, "Member 'UWeatherParameterNamesDataAsset::EmissionParamColor' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, PhaseBlend) == 0x000108, "Member 'UWeatherParameterNamesDataAsset::PhaseBlend' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, PhaseG) == 0x000110, "Member 'UWeatherParameterNamesDataAsset::PhaseG' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, PhaseGSecond) == 0x000118, "Member 'UWeatherParameterNamesDataAsset::PhaseGSecond' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, MultiScatteringContribution) == 0x000120, "Member 'UWeatherParameterNamesDataAsset::MultiScatteringContribution' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, MultiScatteringOcclusion) == 0x000128, "Member 'UWeatherParameterNamesDataAsset::MultiScatteringOcclusion' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, MultiScatteringOcclusionPower) == 0x000130, "Member 'UWeatherParameterNamesDataAsset::MultiScatteringOcclusionPower' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, MultiScatteringEccentricity) == 0x000138, "Member 'UWeatherParameterNamesDataAsset::MultiScatteringEccentricity' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, MoonOpacity) == 0x000140, "Member 'UWeatherParameterNamesDataAsset::MoonOpacity' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, MoonLatitude) == 0x000148, "Member 'UWeatherParameterNamesDataAsset::MoonLatitude' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, MoonLongitude) == 0x000150, "Member 'UWeatherParameterNamesDataAsset::MoonLongitude' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, SunShadowAmount) == 0x000158, "Member 'UWeatherParameterNamesDataAsset::SunShadowAmount' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, SkyAtmColorPower) == 0x000160, "Member 'UWeatherParameterNamesDataAsset::SkyAtmColorPower' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, WindIntensity) == 0x000168, "Member 'UWeatherParameterNamesDataAsset::WindIntensity' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, WindDirection) == 0x000170, "Member 'UWeatherParameterNamesDataAsset::WindDirection' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, FoliageWindDirection) == 0x000178, "Member 'UWeatherParameterNamesDataAsset::FoliageWindDirection' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, FoliageWindIntensity) == 0x000180, "Member 'UWeatherParameterNamesDataAsset::FoliageWindIntensity' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, PreviousFoliageWindDirection) == 0x000188, "Member 'UWeatherParameterNamesDataAsset::PreviousFoliageWindDirection' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, PreviousFoliageWindIntensity) == 0x000190, "Member 'UWeatherParameterNamesDataAsset::PreviousFoliageWindIntensity' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, RainActivate) == 0x000198, "Member 'UWeatherParameterNamesDataAsset::RainActivate' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, TimeOfDay) == 0x0001A0, "Member 'UWeatherParameterNamesDataAsset::TimeOfDay' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, Wetness) == 0x0001A8, "Member 'UWeatherParameterNamesDataAsset::Wetness' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, WaterWindNormalMultiplier) == 0x0001B0, "Member 'UWeatherParameterNamesDataAsset::WaterWindNormalMultiplier' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, RainWindDirection) == 0x0001B8, "Member 'UWeatherParameterNamesDataAsset::RainWindDirection' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, RainWindStrength) == 0x0001C0, "Member 'UWeatherParameterNamesDataAsset::RainWindStrength' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, RainSpawnRate) == 0x0001C8, "Member 'UWeatherParameterNamesDataAsset::RainSpawnRate' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, LightningSpawnRate) == 0x0001D0, "Member 'UWeatherParameterNamesDataAsset::LightningSpawnRate' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, LightningColor) == 0x0001D8, "Member 'UWeatherParameterNamesDataAsset::LightningColor' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, StormSpawnRate) == 0x0001E0, "Member 'UWeatherParameterNamesDataAsset::StormSpawnRate' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, CloudShift) == 0x0001E8, "Member 'UWeatherParameterNamesDataAsset::CloudShift' has a wrong offset!");
static_assert(offsetof(UWeatherParameterNamesDataAsset, WaterShift) == 0x0001F0, "Member 'UWeatherParameterNamesDataAsset::WaterShift' has a wrong offset!");

// Class Stalker2.WeatherPresetDataAsset
// 0x2390 (0x23C0 - 0x0030)
class UWeatherPresetDataAsset final : public UDataAsset
{
public:
	struct FWeatherState                          WeatherState;                                      // 0x0030(0x2390)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherPresetDataAsset">();
	}
	static class UWeatherPresetDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeatherPresetDataAsset>();
	}
};
static_assert(alignof(UWeatherPresetDataAsset) == 0x000008, "Wrong alignment on UWeatherPresetDataAsset");
static_assert(sizeof(UWeatherPresetDataAsset) == 0x0023C0, "Wrong size on UWeatherPresetDataAsset");
static_assert(offsetof(UWeatherPresetDataAsset, WeatherState) == 0x000030, "Member 'UWeatherPresetDataAsset::WeatherState' has a wrong offset!");

// Class Stalker2.WeatherSelectionPostProcessData
// 0x0730 (0x0760 - 0x0030)
class UWeatherSelectionPostProcessData final : public UDataAsset
{
public:
	float                                         Priority;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendRadius;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   Settings;                                          // 0x0040(0x0720)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherSelectionPostProcessData">();
	}
	static class UWeatherSelectionPostProcessData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeatherSelectionPostProcessData>();
	}
};
static_assert(alignof(UWeatherSelectionPostProcessData) == 0x000010, "Wrong alignment on UWeatherSelectionPostProcessData");
static_assert(sizeof(UWeatherSelectionPostProcessData) == 0x000760, "Wrong size on UWeatherSelectionPostProcessData");
static_assert(offsetof(UWeatherSelectionPostProcessData, Priority) == 0x000030, "Member 'UWeatherSelectionPostProcessData::Priority' has a wrong offset!");
static_assert(offsetof(UWeatherSelectionPostProcessData, BlendRadius) == 0x000034, "Member 'UWeatherSelectionPostProcessData::BlendRadius' has a wrong offset!");
static_assert(offsetof(UWeatherSelectionPostProcessData, BlendWeight) == 0x000038, "Member 'UWeatherSelectionPostProcessData::BlendWeight' has a wrong offset!");
static_assert(offsetof(UWeatherSelectionPostProcessData, Settings) == 0x000040, "Member 'UWeatherSelectionPostProcessData::Settings' has a wrong offset!");

// Class Stalker2.WeightBar
// 0x0110 (0x0388 - 0x0278)
class UWeightBar final : public UWidgetBase
{
public:
	class UImage*                                 BackgroundImage;                                   // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HighlightImage;                                    // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DifferenceImage;                                   // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TrianglePointer;                                   // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               BarOverlay;                                        // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            CurrentWeightText;                                 // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            MaxWeightText;                                     // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentWeightTextPosition;                         // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrianglePosition;                                  // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           BackgroundSegmentColor1;                           // 0x02C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           OneItemDifferenceColor;                            // 0x02D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BackgroundSegmentColor2;                           // 0x02E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BackgroundSegmentColor3;                           // 0x02F0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           OverweightTextColor;                               // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NonOverweightTextColor;                            // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HighlightSegmentEnd;                               // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HighlightOpacity;                                  // 0x0324(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           HighlightColor;                                    // 0x0328(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DifferenceStart;                                   // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DifferenceEnd;                                     // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0xC];                                      // 0x0340(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DifferencePositiveColor;                           // 0x034C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DifferenceNegativeColor;                           // 0x035C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36C[0x1C];                                     // 0x036C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightBar">();
	}
	static class UWeightBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeightBar>();
	}
};
static_assert(alignof(UWeightBar) == 0x000008, "Wrong alignment on UWeightBar");
static_assert(sizeof(UWeightBar) == 0x000388, "Wrong size on UWeightBar");
static_assert(offsetof(UWeightBar, BackgroundImage) == 0x000278, "Member 'UWeightBar::BackgroundImage' has a wrong offset!");
static_assert(offsetof(UWeightBar, HighlightImage) == 0x000280, "Member 'UWeightBar::HighlightImage' has a wrong offset!");
static_assert(offsetof(UWeightBar, DifferenceImage) == 0x000288, "Member 'UWeightBar::DifferenceImage' has a wrong offset!");
static_assert(offsetof(UWeightBar, TrianglePointer) == 0x000290, "Member 'UWeightBar::TrianglePointer' has a wrong offset!");
static_assert(offsetof(UWeightBar, BarOverlay) == 0x000298, "Member 'UWeightBar::BarOverlay' has a wrong offset!");
static_assert(offsetof(UWeightBar, CurrentWeightText) == 0x0002A0, "Member 'UWeightBar::CurrentWeightText' has a wrong offset!");
static_assert(offsetof(UWeightBar, MaxWeightText) == 0x0002A8, "Member 'UWeightBar::MaxWeightText' has a wrong offset!");
static_assert(offsetof(UWeightBar, CurrentWeightTextPosition) == 0x0002B0, "Member 'UWeightBar::CurrentWeightTextPosition' has a wrong offset!");
static_assert(offsetof(UWeightBar, TrianglePosition) == 0x0002B4, "Member 'UWeightBar::TrianglePosition' has a wrong offset!");
static_assert(offsetof(UWeightBar, BackgroundSegmentColor1) == 0x0002C0, "Member 'UWeightBar::BackgroundSegmentColor1' has a wrong offset!");
static_assert(offsetof(UWeightBar, OneItemDifferenceColor) == 0x0002D0, "Member 'UWeightBar::OneItemDifferenceColor' has a wrong offset!");
static_assert(offsetof(UWeightBar, BackgroundSegmentColor2) == 0x0002E0, "Member 'UWeightBar::BackgroundSegmentColor2' has a wrong offset!");
static_assert(offsetof(UWeightBar, BackgroundSegmentColor3) == 0x0002F0, "Member 'UWeightBar::BackgroundSegmentColor3' has a wrong offset!");
static_assert(offsetof(UWeightBar, OverweightTextColor) == 0x000300, "Member 'UWeightBar::OverweightTextColor' has a wrong offset!");
static_assert(offsetof(UWeightBar, NonOverweightTextColor) == 0x000310, "Member 'UWeightBar::NonOverweightTextColor' has a wrong offset!");
static_assert(offsetof(UWeightBar, HighlightSegmentEnd) == 0x000320, "Member 'UWeightBar::HighlightSegmentEnd' has a wrong offset!");
static_assert(offsetof(UWeightBar, HighlightOpacity) == 0x000324, "Member 'UWeightBar::HighlightOpacity' has a wrong offset!");
static_assert(offsetof(UWeightBar, HighlightColor) == 0x000328, "Member 'UWeightBar::HighlightColor' has a wrong offset!");
static_assert(offsetof(UWeightBar, DifferenceStart) == 0x000338, "Member 'UWeightBar::DifferenceStart' has a wrong offset!");
static_assert(offsetof(UWeightBar, DifferenceEnd) == 0x00033C, "Member 'UWeightBar::DifferenceEnd' has a wrong offset!");
static_assert(offsetof(UWeightBar, DifferencePositiveColor) == 0x00034C, "Member 'UWeightBar::DifferencePositiveColor' has a wrong offset!");
static_assert(offsetof(UWeightBar, DifferenceNegativeColor) == 0x00035C, "Member 'UWeightBar::DifferenceNegativeColor' has a wrong offset!");

// Class Stalker2.WidgetPool
// 0x0028 (0x02A0 - 0x0278)
class UWidgetPool final : public UUserWidget
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                WidgetInPoolClass;                                 // 0x0288(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUserWidget* CreateWidgetByPool();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetPool">();
	}
	static class UWidgetPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetPool>();
	}
};
static_assert(alignof(UWidgetPool) == 0x000008, "Wrong alignment on UWidgetPool");
static_assert(sizeof(UWidgetPool) == 0x0002A0, "Wrong size on UWidgetPool");
static_assert(offsetof(UWidgetPool, WidgetInPoolClass) == 0x000288, "Member 'UWidgetPool::WidgetInPoolClass' has a wrong offset!");

// Class Stalker2.WildlifeBehaviourComponent
// 0x0008 (0x00A8 - 0x00A0)
class UWildlifeBehaviourComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WildlifeBehaviourComponent">();
	}
	static class UWildlifeBehaviourComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWildlifeBehaviourComponent>();
	}
};
static_assert(alignof(UWildlifeBehaviourComponent) == 0x000008, "Wrong alignment on UWildlifeBehaviourComponent");
static_assert(sizeof(UWildlifeBehaviourComponent) == 0x0000A8, "Wrong size on UWildlifeBehaviourComponent");

// Class Stalker2.WildlifeBehaviourInterface
// 0x0000 (0x0000 - 0x0000)
class IWildlifeBehaviourInterface final
{
public:
	void OnEmissionWeatherStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WildlifeBehaviourInterface">();
	}
	static class IWildlifeBehaviourInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWildlifeBehaviourInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IWildlifeBehaviourInterface) == 0x000001, "Wrong alignment on IWildlifeBehaviourInterface");
static_assert(sizeof(IWildlifeBehaviourInterface) == 0x000001, "Wrong size on IWildlifeBehaviourInterface");

// Class Stalker2.WindowDamageComponent
// 0x0028 (0x00C8 - 0x00A0)
class UWindowDamageComponent final : public UActorComponent
{
public:
	float                                         CheckRate;                                         // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PreviousLocation;                                  // 0x00A8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           CheckTimerHandle;                                  // 0x00C0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WindowDamageComponent">();
	}
	static class UWindowDamageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWindowDamageComponent>();
	}
};
static_assert(alignof(UWindowDamageComponent) == 0x000008, "Wrong alignment on UWindowDamageComponent");
static_assert(sizeof(UWindowDamageComponent) == 0x0000C8, "Wrong size on UWindowDamageComponent");
static_assert(offsetof(UWindowDamageComponent, CheckRate) == 0x0000A0, "Member 'UWindowDamageComponent::CheckRate' has a wrong offset!");
static_assert(offsetof(UWindowDamageComponent, PreviousLocation) == 0x0000A8, "Member 'UWindowDamageComponent::PreviousLocation' has a wrong offset!");
static_assert(offsetof(UWindowDamageComponent, CheckTimerHandle) == 0x0000C0, "Member 'UWindowDamageComponent::CheckTimerHandle' has a wrong offset!");

// Class Stalker2.WorldCompositionAnalyzer
// 0x0018 (0x00C0 - 0x00A8)
class UWorldCompositionAnalyzer final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldCompositionAnalyzer">();
	}
	static class UWorldCompositionAnalyzer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldCompositionAnalyzer>();
	}
};
static_assert(alignof(UWorldCompositionAnalyzer) == 0x000008, "Wrong alignment on UWorldCompositionAnalyzer");
static_assert(sizeof(UWorldCompositionAnalyzer) == 0x0000C0, "Wrong size on UWorldCompositionAnalyzer");

// Class Stalker2.WorldMap
// 0x00B0 (0x0328 - 0x0278)
class UWorldMap final : public UWidgetBase
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USizeBox*                               WorldMapSizeBox;                                   // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           MarkerStorage;                                     // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           ZoneStorage;                                       // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               MapContainer;                                      // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                PlayerPosition;                                    // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddWorldAngle;                                     // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LandmarkOffset;                                    // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsHovered, class UWorldMapMarker* InHoverMarkerWidget)> OnMapMarkerMarker; // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UWorldMapMarker* InHoverMarkerWidget)> OnMapMarkerClick; // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UWorldMapMarker*>                Markers;                                           // 0x02E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UWorldMapMarker*>                Landmarks;                                         // 0x02F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FUID                                   FollowMarker;                                      // 0x0308(0x0004)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorldMapMarker*                        CurrHoverMarker;                                   // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkerClick(const class UWorldMapMarker* HoverMarkerWidget);
	void MarkerHover(bool bInHovered, class UWorldMapMarker* InHoverMarkerWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMap">();
	}
	static class UWorldMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMap>();
	}
};
static_assert(alignof(UWorldMap) == 0x000008, "Wrong alignment on UWorldMap");
static_assert(sizeof(UWorldMap) == 0x000328, "Wrong size on UWorldMap");
static_assert(offsetof(UWorldMap, WorldMapSizeBox) == 0x000288, "Member 'UWorldMap::WorldMapSizeBox' has a wrong offset!");
static_assert(offsetof(UWorldMap, MarkerStorage) == 0x000290, "Member 'UWorldMap::MarkerStorage' has a wrong offset!");
static_assert(offsetof(UWorldMap, ZoneStorage) == 0x000298, "Member 'UWorldMap::ZoneStorage' has a wrong offset!");
static_assert(offsetof(UWorldMap, MapContainer) == 0x0002A0, "Member 'UWorldMap::MapContainer' has a wrong offset!");
static_assert(offsetof(UWorldMap, PlayerPosition) == 0x0002A8, "Member 'UWorldMap::PlayerPosition' has a wrong offset!");
static_assert(offsetof(UWorldMap, AddWorldAngle) == 0x0002B0, "Member 'UWorldMap::AddWorldAngle' has a wrong offset!");
static_assert(offsetof(UWorldMap, LandmarkOffset) == 0x0002B8, "Member 'UWorldMap::LandmarkOffset' has a wrong offset!");
static_assert(offsetof(UWorldMap, OnMapMarkerMarker) == 0x0002C8, "Member 'UWorldMap::OnMapMarkerMarker' has a wrong offset!");
static_assert(offsetof(UWorldMap, OnMapMarkerClick) == 0x0002D8, "Member 'UWorldMap::OnMapMarkerClick' has a wrong offset!");
static_assert(offsetof(UWorldMap, Markers) == 0x0002E8, "Member 'UWorldMap::Markers' has a wrong offset!");
static_assert(offsetof(UWorldMap, Landmarks) == 0x0002F8, "Member 'UWorldMap::Landmarks' has a wrong offset!");
static_assert(offsetof(UWorldMap, FollowMarker) == 0x000308, "Member 'UWorldMap::FollowMarker' has a wrong offset!");
static_assert(offsetof(UWorldMap, CurrHoverMarker) == 0x000310, "Member 'UWorldMap::CurrHoverMarker' has a wrong offset!");

// Class Stalker2.WorldMapMarker
// 0x00B8 (0x0330 - 0x0278)
class UWorldMapMarker : public UWidgetBase
{
public:
	TMulticastInlineDelegate<void(bool bIsHovered, class UWorldMapMarker* OutHoverMarkerWidget)> OnHoverMarker; // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UWorldMapMarker* HoverMarkerWidget)> OnClickMarker;    // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsScale;                                          // 0x0298(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWorldMapMarkerZone>        ZoneWidgetClass;                                   // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MarkerIcon;                                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               MarkerSizeBox;                                     // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ClickZone;                                         // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerAlignment;                                   // 0x02C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarkerSize;                                        // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableHoverScale;                                 // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoverScaleValue;                                   // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableMarkerClick;                                // 0x02DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DD[0x3B];                                     // 0x02DD(0x003B)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanelSlot*                       ParentCanvasSlot;                                  // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorldMapMarkerZone*                    ZoneWidget;                                        // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           ZoneCanvas;                                        // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void MarkerClick();
	void OnMouseHover();
	void OnMouseUnhover();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapMarker">();
	}
	static class UWorldMapMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMapMarker>();
	}
};
static_assert(alignof(UWorldMapMarker) == 0x000008, "Wrong alignment on UWorldMapMarker");
static_assert(sizeof(UWorldMapMarker) == 0x000330, "Wrong size on UWorldMapMarker");
static_assert(offsetof(UWorldMapMarker, OnHoverMarker) == 0x000278, "Member 'UWorldMapMarker::OnHoverMarker' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, OnClickMarker) == 0x000288, "Member 'UWorldMapMarker::OnClickMarker' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, bIsScale) == 0x000298, "Member 'UWorldMapMarker::bIsScale' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, ZoneWidgetClass) == 0x0002A0, "Member 'UWorldMapMarker::ZoneWidgetClass' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, MarkerIcon) == 0x0002A8, "Member 'UWorldMapMarker::MarkerIcon' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, MarkerSizeBox) == 0x0002B0, "Member 'UWorldMapMarker::MarkerSizeBox' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, ClickZone) == 0x0002B8, "Member 'UWorldMapMarker::ClickZone' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, MarkerAlignment) == 0x0002C0, "Member 'UWorldMapMarker::MarkerAlignment' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, MarkerSize) == 0x0002D0, "Member 'UWorldMapMarker::MarkerSize' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, bEnableHoverScale) == 0x0002D4, "Member 'UWorldMapMarker::bEnableHoverScale' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, HoverScaleValue) == 0x0002D8, "Member 'UWorldMapMarker::HoverScaleValue' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, bEnableMarkerClick) == 0x0002DC, "Member 'UWorldMapMarker::bEnableMarkerClick' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, ParentCanvasSlot) == 0x000318, "Member 'UWorldMapMarker::ParentCanvasSlot' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, ZoneWidget) == 0x000320, "Member 'UWorldMapMarker::ZoneWidget' has a wrong offset!");
static_assert(offsetof(UWorldMapMarker, ZoneCanvas) == 0x000328, "Member 'UWorldMapMarker::ZoneCanvas' has a wrong offset!");

// Class Stalker2.WorldMapHubMarker
// 0x0010 (0x0340 - 0x0330)
class UWorldMapHubMarker final : public UWorldMapMarker
{
public:
	class UImage*                                 MiniMarkerMain;                                    // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 MiniMarkerSide;                                    // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapHubMarker">();
	}
	static class UWorldMapHubMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMapHubMarker>();
	}
};
static_assert(alignof(UWorldMapHubMarker) == 0x000008, "Wrong alignment on UWorldMapHubMarker");
static_assert(sizeof(UWorldMapHubMarker) == 0x000340, "Wrong size on UWorldMapHubMarker");
static_assert(offsetof(UWorldMapHubMarker, MiniMarkerMain) == 0x000330, "Member 'UWorldMapHubMarker::MiniMarkerMain' has a wrong offset!");
static_assert(offsetof(UWorldMapHubMarker, MiniMarkerSide) == 0x000338, "Member 'UWorldMapHubMarker::MiniMarkerSide' has a wrong offset!");

// Class Stalker2.WorldMapIPU
// 0x0000 (0x0040 - 0x0040)
class UWorldMapIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapIPU">();
	}
	static class UWorldMapIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMapIPU>();
	}
};
static_assert(alignof(UWorldMapIPU) == 0x000008, "Wrong alignment on UWorldMapIPU");
static_assert(sizeof(UWorldMapIPU) == 0x000040, "Wrong size on UWorldMapIPU");

// Class Stalker2.WorldMapManager
// 0x0168 (0x0210 - 0x00A8)
class UWorldMapManager final : public UBaseTickableManager
{
public:
	uint8                                         Pad_A8[0x58];                                      // 0x00A8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWorldMapMarker>            WorldMapMarkerClass;                               // 0x0100(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UWorldMapMarker>            WorldMapRegionMarkerClass;                         // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UWorldMapMarker>            WorldMapLocationMarkerClass;                       // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UWorldMapMarker>            WorldMapHubMarkerClass;                            // 0x0118(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMarkerCompassWidget>       MarkerCompassWidgetClass;                          // 0x0120(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MarkerIconsDataTable;                              // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarkerSettings*                        MarkerSettingsAsset;                               // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x50];                                     // 0x0138(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class AWorldMapScene*                         WorldMapScene;                                     // 0x0188(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x20];                                     // 0x0190(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USRLEAsset*                             RegionTexture;                                     // 0x01B0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETrackGroup, struct FUID>                TrackedMarkers;                                    // 0x01C0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapManager">();
	}
	static class UWorldMapManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMapManager>();
	}
};
static_assert(alignof(UWorldMapManager) == 0x000008, "Wrong alignment on UWorldMapManager");
static_assert(sizeof(UWorldMapManager) == 0x000210, "Wrong size on UWorldMapManager");
static_assert(offsetof(UWorldMapManager, WorldMapMarkerClass) == 0x000100, "Member 'UWorldMapManager::WorldMapMarkerClass' has a wrong offset!");
static_assert(offsetof(UWorldMapManager, WorldMapRegionMarkerClass) == 0x000108, "Member 'UWorldMapManager::WorldMapRegionMarkerClass' has a wrong offset!");
static_assert(offsetof(UWorldMapManager, WorldMapLocationMarkerClass) == 0x000110, "Member 'UWorldMapManager::WorldMapLocationMarkerClass' has a wrong offset!");
static_assert(offsetof(UWorldMapManager, WorldMapHubMarkerClass) == 0x000118, "Member 'UWorldMapManager::WorldMapHubMarkerClass' has a wrong offset!");
static_assert(offsetof(UWorldMapManager, MarkerCompassWidgetClass) == 0x000120, "Member 'UWorldMapManager::MarkerCompassWidgetClass' has a wrong offset!");
static_assert(offsetof(UWorldMapManager, MarkerIconsDataTable) == 0x000128, "Member 'UWorldMapManager::MarkerIconsDataTable' has a wrong offset!");
static_assert(offsetof(UWorldMapManager, MarkerSettingsAsset) == 0x000130, "Member 'UWorldMapManager::MarkerSettingsAsset' has a wrong offset!");
static_assert(offsetof(UWorldMapManager, WorldMapScene) == 0x000188, "Member 'UWorldMapManager::WorldMapScene' has a wrong offset!");
static_assert(offsetof(UWorldMapManager, RegionTexture) == 0x0001B0, "Member 'UWorldMapManager::RegionTexture' has a wrong offset!");
static_assert(offsetof(UWorldMapManager, TrackedMarkers) == 0x0001C0, "Member 'UWorldMapManager::TrackedMarkers' has a wrong offset!");

// Class Stalker2.WorldMapMarkerSelector
// 0x0000 (0x0278 - 0x0278)
class UWorldMapMarkerSelector final : public UWidgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapMarkerSelector">();
	}
	static class UWorldMapMarkerSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMapMarkerSelector>();
	}
};
static_assert(alignof(UWorldMapMarkerSelector) == 0x000008, "Wrong alignment on UWorldMapMarkerSelector");
static_assert(sizeof(UWorldMapMarkerSelector) == 0x000278, "Wrong size on UWorldMapMarkerSelector");

// Class Stalker2.WorldMapPage
// 0x01B8 (0x0450 - 0x0298)
class UWorldMapPage final : public UPDAPage
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorldMapTooltip*                       WorldMapTooltip;                                   // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapLegend*                             MapLegend;                                         // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ZoomContainerBox;                                  // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorldMapZoomContainer*                 ZoomContainer;                                     // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UZoomIndicator*                         ZoomIndicator;                                     // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               HintZone;                                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   ShowMarkerSelectorHintGamepad;                     // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   MoveToPlayerPositionHint;                          // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   ShowMarkerSelectorHint;                            // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   HideMarkerSelectorHint;                            // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   SetFollowLandmarkHint;                             // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   SelectMarkerHint;                                  // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   DeleteSelectedLandmarkHint;                        // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   ButtonToggleTracking;                              // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   ChooseMarkerHint;                                  // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   ChangeZoomLevelHint;                               // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   GamepadNavigationHint;                             // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   ShowLegendHint;                                    // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   ShowGotoJournalTaskHint;                           // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHintInputController*                   ButtonHintExit;                                    // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              DefaultPosition;                                   // 0x0348(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DefaultZoomLVL;                                    // 0x0358(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldOpenDefaultZoomLVL;                         // 0x035C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnablePlayerLandmarks;                            // 0x035D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35E[0x2];                                      // 0x035E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HintZoomSID;                                       // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 HintScrollLegendSID;                               // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HintDisable;                                       // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HintTrack;                                         // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EMarkerType, struct FSlateColor>         MarkerHoverColors;                                 // 0x0390(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EMarkerType, struct FSlateColor>         MarkerUnhoverColors;                               // 0x03E0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x20];                                     // 0x0430(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkerClick(const class UWorldMapMarker* HoverMarkerWidget);
	void MarkerHover(const bool bHovered, class UWorldMapMarker* HoverMarkerWidget);
	void OnLegendHover();
	void OnLegendUnhover();
	void OnMarkerSelectorHide();
	void OnMarkerSelectorShow();
	void OnPressExit();
	void UIPDAChangeVisibilityPlayerMarkers();
	void UIPDACreatePlayerMarker(const EMarkerType LandmarkType, const struct FVector& CreateMarkedLocation);
	void UIPDACreateTrackedPlayerMarker();
	void UIPDADeletePlayerMarker();
	void UIPDAMapZoomIn();
	void UIPDAMapZoomOut();
	void UIPDAMoveToPlayerPosition();
	void UIPDANavigationDown();
	void UIPDANavigationDownReleased();
	void UIPDANavigationLeft();
	void UIPDANavigationLeftReleased();
	void UIPDANavigationRight();
	void UIPDANavigationRightReleased();
	void UIPDANavigationUp();
	void UIPDANavigationUpReleased();
	void UIPDAOpenPlayerMarkerSelector();
	void UIPDAOpenQuestInJournal();
	void UIPDAToggleLegend();
	void UIPDAToggleMarkTracking();
	void UpdatePlatformInputMode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapPage">();
	}
	static class UWorldMapPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMapPage>();
	}
};
static_assert(alignof(UWorldMapPage) == 0x000008, "Wrong alignment on UWorldMapPage");
static_assert(sizeof(UWorldMapPage) == 0x000450, "Wrong size on UWorldMapPage");
static_assert(offsetof(UWorldMapPage, WorldMapTooltip) == 0x0002A8, "Member 'UWorldMapPage::WorldMapTooltip' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, MapLegend) == 0x0002B0, "Member 'UWorldMapPage::MapLegend' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, ZoomContainerBox) == 0x0002B8, "Member 'UWorldMapPage::ZoomContainerBox' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, ZoomContainer) == 0x0002C0, "Member 'UWorldMapPage::ZoomContainer' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, ZoomIndicator) == 0x0002C8, "Member 'UWorldMapPage::ZoomIndicator' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, HintZone) == 0x0002D0, "Member 'UWorldMapPage::HintZone' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, ShowMarkerSelectorHintGamepad) == 0x0002D8, "Member 'UWorldMapPage::ShowMarkerSelectorHintGamepad' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, MoveToPlayerPositionHint) == 0x0002E0, "Member 'UWorldMapPage::MoveToPlayerPositionHint' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, ShowMarkerSelectorHint) == 0x0002E8, "Member 'UWorldMapPage::ShowMarkerSelectorHint' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, HideMarkerSelectorHint) == 0x0002F0, "Member 'UWorldMapPage::HideMarkerSelectorHint' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, SetFollowLandmarkHint) == 0x0002F8, "Member 'UWorldMapPage::SetFollowLandmarkHint' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, SelectMarkerHint) == 0x000300, "Member 'UWorldMapPage::SelectMarkerHint' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, DeleteSelectedLandmarkHint) == 0x000308, "Member 'UWorldMapPage::DeleteSelectedLandmarkHint' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, ButtonToggleTracking) == 0x000310, "Member 'UWorldMapPage::ButtonToggleTracking' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, ChooseMarkerHint) == 0x000318, "Member 'UWorldMapPage::ChooseMarkerHint' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, ChangeZoomLevelHint) == 0x000320, "Member 'UWorldMapPage::ChangeZoomLevelHint' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, GamepadNavigationHint) == 0x000328, "Member 'UWorldMapPage::GamepadNavigationHint' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, ShowLegendHint) == 0x000330, "Member 'UWorldMapPage::ShowLegendHint' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, ShowGotoJournalTaskHint) == 0x000338, "Member 'UWorldMapPage::ShowGotoJournalTaskHint' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, ButtonHintExit) == 0x000340, "Member 'UWorldMapPage::ButtonHintExit' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, DefaultPosition) == 0x000348, "Member 'UWorldMapPage::DefaultPosition' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, DefaultZoomLVL) == 0x000358, "Member 'UWorldMapPage::DefaultZoomLVL' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, bShouldOpenDefaultZoomLVL) == 0x00035C, "Member 'UWorldMapPage::bShouldOpenDefaultZoomLVL' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, bEnablePlayerLandmarks) == 0x00035D, "Member 'UWorldMapPage::bEnablePlayerLandmarks' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, HintZoomSID) == 0x000360, "Member 'UWorldMapPage::HintZoomSID' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, HintScrollLegendSID) == 0x000370, "Member 'UWorldMapPage::HintScrollLegendSID' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, HintDisable) == 0x000380, "Member 'UWorldMapPage::HintDisable' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, HintTrack) == 0x000388, "Member 'UWorldMapPage::HintTrack' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, MarkerHoverColors) == 0x000390, "Member 'UWorldMapPage::MarkerHoverColors' has a wrong offset!");
static_assert(offsetof(UWorldMapPage, MarkerUnhoverColors) == 0x0003E0, "Member 'UWorldMapPage::MarkerUnhoverColors' has a wrong offset!");

// Class Stalker2.WorldMapRegionMarker
// 0x0008 (0x0338 - 0x0330)
class UWorldMapRegionMarker final : public UWorldMapMarker
{
public:
	class UTextWidget*                            RegionName;                                        // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapRegionMarker">();
	}
	static class UWorldMapRegionMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMapRegionMarker>();
	}
};
static_assert(alignof(UWorldMapRegionMarker) == 0x000008, "Wrong alignment on UWorldMapRegionMarker");
static_assert(sizeof(UWorldMapRegionMarker) == 0x000338, "Wrong size on UWorldMapRegionMarker");
static_assert(offsetof(UWorldMapRegionMarker, RegionName) == 0x000330, "Member 'UWorldMapRegionMarker::RegionName' has a wrong offset!");

// Class Stalker2.WorldMapScene
// 0x0000 (0x0298 - 0x0298)
class AWorldMapScene final : public AActor
{
public:
	void SetCaptureEveryFrame(bool bIsEnabled);
	void SetMouseUV(const struct FVector& InUV);
	void SetNotSelectedAreaBrightness(float InBrightness);
	void SetOffset(const struct FVector2D& InOffset);
	void SetScale(float InScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapScene">();
	}
	static class AWorldMapScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldMapScene>();
	}
};
static_assert(alignof(AWorldMapScene) == 0x000008, "Wrong alignment on AWorldMapScene");
static_assert(sizeof(AWorldMapScene) == 0x000298, "Wrong size on AWorldMapScene");

// Class Stalker2.WorldMapScrollIPU
// 0x0000 (0x0040 - 0x0040)
class UWorldMapScrollIPU final : public UInputProcessingUnit
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapScrollIPU">();
	}
	static class UWorldMapScrollIPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMapScrollIPU>();
	}
};
static_assert(alignof(UWorldMapScrollIPU) == 0x000008, "Wrong alignment on UWorldMapScrollIPU");
static_assert(sizeof(UWorldMapScrollIPU) == 0x000040, "Wrong size on UWorldMapScrollIPU");

// Class Stalker2.WorldMapTooltip
// 0x00E8 (0x0360 - 0x0278)
class alignas(0x10) UWorldMapTooltip final : public UWidgetBase
{
public:
	class UWorldMapTooltipHeader*                 HeaderBackground;                                  // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            BodyPlainText;                                     // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        TooltipBodySwitcher;                               // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        TooltipFooterSwitcher;                             // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      ChildMarkerBox;                                    // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FactionImage;                                      // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            SubtitleText;                                      // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            TitleText;                                         // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MarkerImage;                                       // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTaskMenuWidget*                        QuestStage;                                        // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerStorageData*                     PlayerStorageData;                                 // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTooltipRecord*                         AnomalyDetails;                                    // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           BodyMainBox;                                       // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           FooterMainBox;                                     // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EMarkerType, class FName>                DisplayTooltipTitle;                               // 0x02E8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   MainQuestColorStyle;                               // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SecondaryColorQuestStyle;                          // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x18];                                     // 0x0348(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVisibilityChangedCallback(ESlateVisibility SlateVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapTooltip">();
	}
	static class UWorldMapTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMapTooltip>();
	}
};
static_assert(alignof(UWorldMapTooltip) == 0x000010, "Wrong alignment on UWorldMapTooltip");
static_assert(sizeof(UWorldMapTooltip) == 0x000360, "Wrong size on UWorldMapTooltip");
static_assert(offsetof(UWorldMapTooltip, HeaderBackground) == 0x000278, "Member 'UWorldMapTooltip::HeaderBackground' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, BodyPlainText) == 0x000280, "Member 'UWorldMapTooltip::BodyPlainText' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, TooltipBodySwitcher) == 0x000288, "Member 'UWorldMapTooltip::TooltipBodySwitcher' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, TooltipFooterSwitcher) == 0x000290, "Member 'UWorldMapTooltip::TooltipFooterSwitcher' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, ChildMarkerBox) == 0x000298, "Member 'UWorldMapTooltip::ChildMarkerBox' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, FactionImage) == 0x0002A0, "Member 'UWorldMapTooltip::FactionImage' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, SubtitleText) == 0x0002A8, "Member 'UWorldMapTooltip::SubtitleText' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, TitleText) == 0x0002B0, "Member 'UWorldMapTooltip::TitleText' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, MarkerImage) == 0x0002B8, "Member 'UWorldMapTooltip::MarkerImage' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, QuestStage) == 0x0002C0, "Member 'UWorldMapTooltip::QuestStage' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, PlayerStorageData) == 0x0002C8, "Member 'UWorldMapTooltip::PlayerStorageData' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, AnomalyDetails) == 0x0002D0, "Member 'UWorldMapTooltip::AnomalyDetails' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, BodyMainBox) == 0x0002D8, "Member 'UWorldMapTooltip::BodyMainBox' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, FooterMainBox) == 0x0002E0, "Member 'UWorldMapTooltip::FooterMainBox' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, DisplayTooltipTitle) == 0x0002E8, "Member 'UWorldMapTooltip::DisplayTooltipTitle' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, MainQuestColorStyle) == 0x000338, "Member 'UWorldMapTooltip::MainQuestColorStyle' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltip, SecondaryColorQuestStyle) == 0x000340, "Member 'UWorldMapTooltip::SecondaryColorQuestStyle' has a wrong offset!");

// Class Stalker2.WorldMapTooltipHeader
// 0x0050 (0x02C8 - 0x0278)
class UWorldMapTooltipHeader final : public UWidgetBase
{
public:
	class UImage*                                 TopBackgroundImage;                                // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MiddleBackgroundImage;                             // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BottomBackgroundImage;                             // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TopBackgroundImageColor;                           // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MiddleBackgroundImageColor;                        // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BottomBackgroundImageColor;                        // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TopBackgroundImageBlack;                           // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MiddleBackgroundImageBlack;                        // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BottomBackgroundImageBlack;                        // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DotsImage;                                         // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapTooltipHeader">();
	}
	static class UWorldMapTooltipHeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMapTooltipHeader>();
	}
};
static_assert(alignof(UWorldMapTooltipHeader) == 0x000008, "Wrong alignment on UWorldMapTooltipHeader");
static_assert(sizeof(UWorldMapTooltipHeader) == 0x0002C8, "Wrong size on UWorldMapTooltipHeader");
static_assert(offsetof(UWorldMapTooltipHeader, TopBackgroundImage) == 0x000278, "Member 'UWorldMapTooltipHeader::TopBackgroundImage' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltipHeader, MiddleBackgroundImage) == 0x000280, "Member 'UWorldMapTooltipHeader::MiddleBackgroundImage' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltipHeader, BottomBackgroundImage) == 0x000288, "Member 'UWorldMapTooltipHeader::BottomBackgroundImage' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltipHeader, TopBackgroundImageColor) == 0x000290, "Member 'UWorldMapTooltipHeader::TopBackgroundImageColor' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltipHeader, MiddleBackgroundImageColor) == 0x000298, "Member 'UWorldMapTooltipHeader::MiddleBackgroundImageColor' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltipHeader, BottomBackgroundImageColor) == 0x0002A0, "Member 'UWorldMapTooltipHeader::BottomBackgroundImageColor' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltipHeader, TopBackgroundImageBlack) == 0x0002A8, "Member 'UWorldMapTooltipHeader::TopBackgroundImageBlack' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltipHeader, MiddleBackgroundImageBlack) == 0x0002B0, "Member 'UWorldMapTooltipHeader::MiddleBackgroundImageBlack' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltipHeader, BottomBackgroundImageBlack) == 0x0002B8, "Member 'UWorldMapTooltipHeader::BottomBackgroundImageBlack' has a wrong offset!");
static_assert(offsetof(UWorldMapTooltipHeader, DotsImage) == 0x0002C0, "Member 'UWorldMapTooltipHeader::DotsImage' has a wrong offset!");

// Class Stalker2.WorldMapZoomContainer
// 0x00D8 (0x0350 - 0x0278)
class UWorldMapZoomContainer final : public UWidgetBase
{
public:
	class UImage*                                 MapTexture;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorldMap*                              WorldMap;                                          // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserMarkerSelector*                    GamepadCursor;                                     // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0xC0];                                     // 0x0290(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CenterOnCachedLocation();
	void MoveToPlayerLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapZoomContainer">();
	}
	static class UWorldMapZoomContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMapZoomContainer>();
	}
};
static_assert(alignof(UWorldMapZoomContainer) == 0x000008, "Wrong alignment on UWorldMapZoomContainer");
static_assert(sizeof(UWorldMapZoomContainer) == 0x000350, "Wrong size on UWorldMapZoomContainer");
static_assert(offsetof(UWorldMapZoomContainer, MapTexture) == 0x000278, "Member 'UWorldMapZoomContainer::MapTexture' has a wrong offset!");
static_assert(offsetof(UWorldMapZoomContainer, WorldMap) == 0x000280, "Member 'UWorldMapZoomContainer::WorldMap' has a wrong offset!");
static_assert(offsetof(UWorldMapZoomContainer, GamepadCursor) == 0x000288, "Member 'UWorldMapZoomContainer::GamepadCursor' has a wrong offset!");

// Class Stalker2.WoundedHoldComponent
// 0x0008 (0x0238 - 0x0230)
class UWoundedHoldComponent final : public UHoldComponent
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WoundedHoldComponent">();
	}
	static class UWoundedHoldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWoundedHoldComponent>();
	}
};
static_assert(alignof(UWoundedHoldComponent) == 0x000008, "Wrong alignment on UWoundedHoldComponent");
static_assert(sizeof(UWoundedHoldComponent) == 0x000238, "Wrong size on UWoundedHoldComponent");

// Class Stalker2.XboxSaveLoadIO
// 0x0000 (0x0028 - 0x0028)
class UXboxSaveLoadIO final : public USaveLoadIO
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XboxSaveLoadIO">();
	}
	static class UXboxSaveLoadIO* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXboxSaveLoadIO>();
	}
};
static_assert(alignof(UXboxSaveLoadIO) == 0x000008, "Wrong alignment on UXboxSaveLoadIO");
static_assert(sizeof(UXboxSaveLoadIO) == 0x000028, "Wrong size on UXboxSaveLoadIO");

// Class Stalker2.ZoomIndicator
// 0x0030 (0x02A8 - 0x0278)
class UZoomIndicator final : public UWidgetBase
{
public:
	class UHorizontalBox*                         ZoomPointer;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            TextCounter;                                       // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextPrefix;                                        // 0x0288(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 PointerZoomLevelOffset;                            // 0x0298(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZoomIndicator">();
	}
	static class UZoomIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZoomIndicator>();
	}
};
static_assert(alignof(UZoomIndicator) == 0x000008, "Wrong alignment on UZoomIndicator");
static_assert(sizeof(UZoomIndicator) == 0x0002A8, "Wrong size on UZoomIndicator");
static_assert(offsetof(UZoomIndicator, ZoomPointer) == 0x000278, "Member 'UZoomIndicator::ZoomPointer' has a wrong offset!");
static_assert(offsetof(UZoomIndicator, TextCounter) == 0x000280, "Member 'UZoomIndicator::TextCounter' has a wrong offset!");
static_assert(offsetof(UZoomIndicator, TextPrefix) == 0x000288, "Member 'UZoomIndicator::TextPrefix' has a wrong offset!");
static_assert(offsetof(UZoomIndicator, PointerZoomLevelOffset) == 0x000298, "Member 'UZoomIndicator::PointerZoomLevelOffset' has a wrong offset!");

}

